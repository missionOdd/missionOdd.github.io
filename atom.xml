<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🎉 Missionary&#39;s Blog 😆</title>
  
  <subtitle>Missionary 中国 👋</subtitle>
  <link href="https://github.com/missionOdd/atom.xml" rel="self"/>
  
  <link href="https://github.com/missionOdd/"/>
  <updated>2022-02-08T01:49:22.780Z</updated>
  <id>https://github.com/missionOdd/</id>
  
  <author>
    <name>Missionary</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm | 虚拟机全面扫盲+深入理解的原创笔记</title>
    <link href="https://github.com/missionOdd/2022/02/01/jvm-notes/"/>
    <id>https://github.com/missionOdd/2022/02/01/jvm-notes/</id>
    <published>2022-02-01T05:50:37.000Z</published>
    <updated>2022-02-08T01:49:22.780Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引言：</strong><br>来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。<br>优点：笔记知识点关联性好，挖得深，延伸多。<br>缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般</p><h1 id="1-class文件"><a href="#1-class文件" class="headerlink" title="1. class文件"></a>1. class文件</h1><figure class="image-box">                <img src="image-20220208022707509.png" alt="class文件" title class>                <p>class文件</p>            </figure><p><a href="https://blog.csdn.net/lioncatch/article/details/105919391" target="_blank" rel="noopener">https://blog.csdn.net/lioncatch/article/details/105919391</a></p><p><a href="https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc</a></p><p>8字节 2进制  Java文件编译之后</p><ul><li><h3 id="4字节魔数：标志文件类型；视频，照片也有魔数"><a href="#4字节魔数：标志文件类型；视频，照片也有魔数" class="headerlink" title="4字节魔数：标志文件类型；视频，照片也有魔数"></a>4字节魔数：标志文件类型；视频，照片也有魔数</h3></li><li><h3 id="次版本号和主版本号：标志JDK版本；兼容低版本问题"><a href="#次版本号和主版本号：标志JDK版本；兼容低版本问题" class="headerlink" title="次版本号和主版本号：标志JDK版本；兼容低版本问题"></a>次版本号和主版本号：标志JDK版本；兼容低版本问题</h3></li><li><h3 id="常量池计数器：记录后面常量池的常量（数据项）个数；※"><a href="#常量池计数器：记录后面常量池的常量（数据项）个数；※" class="headerlink" title="常量池计数器：记录后面常量池的常量（数据项）个数；※"></a>常量池计数器：记录后面常量池的常量（数据项）个数；※</h3></li><li><h3 id="常量池：字面量-符号引用"><a href="#常量池：字面量-符号引用" class="headerlink" title="常量池：字面量+符号引用"></a>常量池：字面量+符号引用</h3><p> 1.字面量：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值。<br> 2.符号引用<br>   package名字，权限命名，字段名称，方法名称，字段描述符，方法描述符，方法句柄，方法类型，动态调用点和动态常量（不了解）<br>   <strong>一句话：这部分就是常量池，装载了全部类的字段，方法，类名称的信息；</strong></p><figure class="image-box">                <img src="image_20220118183346.png?v=1&type=image&token=V1:3n03VpBe2yMBZgKD5g9o0h5d90CeNevbyQO6LX2UnvQ" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image-20220208023504211.png" alt="符号引用" title class>                <p>符号引用</p>            </figure><p><strong>每个常量项的第一个字节 对应上图中的tag标志 找到对应的结构</strong></p><figure class="image-box">                <img src="image_20220118170506.png?v=1&type=image&token=V1:6K2y024TT-YRQvmLRY5b09neyTtm2iaN319VPeQprHY" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184004.png?v=1&type=image&token=V1:rLsRMkCAd22AUMMS2KXLkI8chGO6nlPHBPOsm1vbbXM" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184033.png?v=1&type=image&token=V1:3CCva6EeaLck4wLZttiedHSfKB0KY8VF3QdPIXjTUjE" alt title class>                <p></p>            </figure></li></ul><ol start="2"><li>面试题</li></ol><ul><li><p>Q  哪些字面量会进入常量池中？</p><ol><li>【final修饰】的8种基本类型的值会进入常量池。</li><li>【非final类型】（包括static的）的8种基本类型的值，只有【double、float、long】的值会进入常量池。</li><li><p>常量池中包含的字符串类型字面量（【双引号引起来的字符串值】）。</p></li><li><p>final类型的8种基本类型的值会进常量池。</p></li><li><p>final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进常量池。</p></li><li><p>常量池中包含的字符串类型字量（双引号引起来的字符串值）。</p></li></ol></li><li><p>java 字段名和方法名，有无长度限制？<br>A: 有，CONSTANT_Utf8_info 存储字符串字面量， 最大长度是65535，大小限制在小于64kb</p><figure class="image-box">                <img src="image_20220119024159.png?v=1&type=image&token=V1:W7pDbZc-acY3wco7miFQ9qcUzZDjMeym7ot3fpzX19A" alt title class>                <p></p>            </figure></li><li><p>Q 字符串有长度限制吗？是多少？<br>  答：</p><ol><li>运行期限制<br>首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,<br>由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</li><li>编译时期限制<br>通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错。<br>原来是为了弥补早期设计时的一个bug，“长度刚好65535个字节，且以1个字节长度的指令结束，这条指令不能被异常处理器处理”，因此就将数组的最大长度限制到了65534了。跟程序计数器有关</li></ol></li></ul><p>运行时拼接或者赋值的话范围是在整形的最大范围。<br><a href="https://blog.csdn.net/rd_w_csdn/article/details/110387250" target="_blank" rel="noopener">https://blog.csdn.net/rd_w_csdn/article/details/110387250</a></p><p><del>错误回答：</del><br><del>CONSTANT_Utf8_info 中有 u2 length; 表明了该类型存储数据的长度。 u2 是无符号的 16 位整数，因此理论上允许的的最大长度是 2^16=65536。而 java class 文件是使用一种变体 UTF-8 格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534 个字节。</del></p><p><code>Modified UTF-8</code>  UTF-8 缩略编码是改进版的<code>UTF-8</code>编码，它和标准的UTF-8编码有下面三点区别：</p><ol><li><code>null</code>空字符的编码从一个字节的<code>&#39;\u0000&#39;</code>改变为2个字节的形式，即11000000 10000000，因此在字符串的编码中不会出现嵌入的null字符；</li><li>只使用1~3个字节的格式；（即范围由\u0000-\uffff）</li><li>辅助字符以代理对的形式表示。 <strong>补充字符通常指大于u+ffff而小于等于u+10ffff范围内的字符</strong></li></ol><ul><li>Q常量池计数器从0还是1开始？<br>A: 从1开始，0索引留给无法指向的东西，即没有父类，没有类名的，比如匿名内部类，Object类</li></ul><figure class="image-box">                <img src="image_20220116204409.png" alt title class>                <p></p>            </figure><ul><li><h3 id="2字节的访问标志："><a href="#2字节的访问标志：" class="headerlink" title="2字节的访问标志："></a>2字节的访问标志：</h3><p>  表明这个class有什么修饰符 只有两个字节</p><figure class="image-box">                <img src="image-20220208024117844.png" alt title class>                <p></p>            </figure></li></ul><p>举例: 原来是00 20(看下表中ACC_SUPER描述，最低限度必须有此标志)<br>如果：类是public类型-的，则第一个ACC_PUBLIC为true 则加上00 01 ，结果为00 21<br>如果：类还是 final类型-的，则第二个为true，再加上00 10 ，结果为00 31</p><p>00 21 = 00 20 + 00 01 ( 加了public)<br>表示为public 的类<br>设置的数值刚好不会出现相加和其他状态相等的情况，很巧妙<br><strong>一句话 访问标识就是只用两个字节表示了这个类的修饰符有哪些</strong></p><ul><li><h3 id="类、父类-This-class-Super-class"><a href="#类、父类-This-class-Super-class" class="headerlink" title="类、父类(This class,Super class)"></a>类、父类(This class,Super class)</h3><p>如 00 02 和 00 003两个标识符也都是一个两字节的引用，我们class文件中，分别引向常量池中00 02的第二个常量项和00 03 第三个常量项<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到类名</p><figure class="image-box">                <img src="20200506112335237.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></li><li><h3 id="接口索引计数器"><a href="#接口索引计数器" class="headerlink" title="接口索引计数器"></a>接口索引计数器</h3><p>类文件实现了接口的数量，没有就是00 00 ，有一个就是 00 01</p></li><li><h3 id="接口索引项"><a href="#接口索引项" class="headerlink" title="接口索引项"></a>接口索引项</h3><p>指向常量池索引<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到接口名</p></li></ul><ul><li><h3 id="字段表：字段个数，字段1，字段2。。。。"><a href="#字段表：字段个数，字段1，字段2。。。。" class="headerlink" title="字段表：字段个数，字段1，字段2。。。。"></a>字段表：字段个数，字段1，字段2。。。。</h3><p>和上面差不多<br>`<br>※  注意：ConstantValue属性：</p><p>  final static String = “hello”<br>必须是String 类型，其值直接存储在字段表里面附带属性项指向的属性表里面的Constant属性里面，这样就可以类未加载直接用，效率提升<br>`</p></li></ul><blockquote><p>ConstantValue属性<br>属性表中的一个属性<br>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；tatic类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p><p>在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p><p>为什么ConstantValue的属性值只限于基本类型和string？</p><p>因为从常量池中只能引用到基本类型和String类型的字面量</p><p>final、static、static final修饰的字段赋值的区别</p><p>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</p><p>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</p><p>static<br>final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。</p><p>可以理解为在编译期即把结果放入了常量池中。</p></blockquote><figure class="image-box">                <img src="image_20220118180056.png?v=1&type=image&token=V1:CPihlXhsDyMBxTiSaP4vHqG9vSKcCYlTGlI4SJLB2Os" alt title class>                <p></p>            </figure><p><strong>分析第一个 access_flags</strong><br>—-其实跟之前我们讲访问标识的时候一样，不一样的是这次的访问标志修饰符是修饰字段的<br>所以在标志名称上有些不同<br><img src="image-20220208024515966.png" alt="在这里插入图片描述"></p><p>这里加一张图用另一种方式表示我们的修饰符<br><figure class="image-box">                <img src="image-20220208024418503.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></p><p><strong>分析第四个 attributes_count</strong><br>表示这个字段所拥有的attribute类型的个数，如果是00 01 就表示一个<br><strong>分析第五个 attributes[attributes_count]</strong><br>就是一个长度为 attributes_count，类型是：属性类型的数组<br>这个类型我们暂时不分析，到后面讲到 属性 时一起讲</p><p><strong>一句话总结<br>就是一个装有我们定义的所有属性的数组，长度为字段个数，里面的每一个表信息都表示一个字段</strong></p><ul><li><h3 id="方法表：-方法个数，方法1，方法2。。。。"><a href="#方法表：-方法个数，方法1，方法2。。。。" class="headerlink" title="方法表： 方法个数，方法1，方法2。。。。"></a>方法表： 方法个数，方法1，方法2。。。。</h3><figure class="image-box">                <img src="image_20220118182212.png?v=1&type=image&token=V1:I_meGZXidnP-pQ7GadHjyGZ5OJv_1gQzErPxNEyHeg0" alt title class>                <p></p>            </figure>access_flags的修饰类型<figure class="image-box">                <img src="image-20220208024616971-16442595798677.png" alt title class>                <p></p>            </figure></li></ul><p>※※  方法的代码存储在： 方法表里面附带属性项指向的属性表的CODE属性里面。<br><a href="https://blog.csdn.net/weixin_29732737/article/details/113051809" target="_blank" rel="noopener">https://blog.csdn.net/weixin_29732737/article/details/113051809</a><br> <strong>max_stack</strong><br>操作数栈的最大深度，说明方法在编译把方法的栈深度已经定好了。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。<br><strong>max_locals</strong><br>局部变量表所需要的空间，长度不能变<br>单位是Slot，int、byte和returnAddress不超过32位的数据类型采用1个Slot来存储；<br>double和long等64位的数据类型采用两个Slot存储<br><strong>其他（包括异常信息）</strong><br>code_length存储了方法体中的字节码指令的长度<br>code就存储了具体的字节码指令<br>exception_table_length<br>显示异常(受检查的异常)中的个数(try-cacatch中的异常)<br>exception_info<br>这是受检查异常的具体信息</p><ul><li><h3 id="属性表：-属性个数，属性1，属性2。。。。"><a href="#属性表：-属性个数，属性1，属性2。。。。" class="headerlink" title="属性表： 属性个数，属性1，属性2。。。。"></a>属性表： 属性个数，属性1，属性2。。。。</h3>上面所说的<strong>字段</strong>和<strong>方法</strong>的最后都有一项：<strong>属性项数组</strong>，里面装的就是这个类型了,比如ConstantValue和Code<br>其实class文件还有一个属性表，就是上面那张图没有覆盖掉的最后一部分<br>在Class文件、字段表、方法表都可以携带自己的属性表集合<br>属性表中不要求各个属性表具有严格的顺序，只要不与已有属性重名即可</li></ul><h1 id="2-JVM-类加载的整体流程"><a href="#2-JVM-类加载的整体流程" class="headerlink" title="2. JVM 类加载的整体流程"></a>2. JVM 类加载的整体流程</h1><p> 普通回答（过于绝对）：<br> 加载，连接，初始化<br> 连接又分为验证，准备，解析</p><p>※ 从细节回答：<br>真正是分为7到8步</p><ol><li>加载<br> 静态加载，java编译为class文件二进制字节流，获得的是class文件二进制字节流</li><li>验证<br> 进入连接阶段的验证：<br>第一步，文件格式验证： 魔数和主次版本号</li><li>加载<br> 验证成功后，把class文件二进制字节流 加载到 方法区<br>  作用： 结构调整，把静态存储文件转换为运行时数据结构<br> （思考： class常量池和方法区的运行时常量池的区别和联系）</li><li>加载<br> 堆内存生成当前类class对象 作为方法区中这个类的各种访问入口，比如：Object类，java.lang.Object 一定先加载，放入堆，提供给其他类访问</li><li>验证<br> 跳到连接阶段的验证：<br>第二步，元数据验证，字节码描述的信息进行语义分析</li><li>验证<br> 跳到连接阶段的验证：<br>第三步，字节码验证，通过数据流和控制流分析<br> <a href="https://blog.csdn.net/weixin_38608626/article/details/88173916" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38608626/article/details/88173916</a></li><li>准备<br> 0值的初始转化，含了给这个类的静态变量static和其他数据分配内存空间（<strong>仅仅是分配内存空间，具体初始化在最后一步</strong>）。<br> static int a=123;  这一阶段a会变成0</li><li>初始化<br> （解析： 第四步，符号验证，常量池内符号引用转直接引用，确定解析一定初始化之前，不确定在何时）【直接引用与虚拟机有关，不同的虚拟机翻译出来一般不会相同】<br> JVM用赋值或者缺省值将静态变量进行初始化，并执行静态初始化程序（static块中的代码），初始化发生在执行main方法之前，但在指定的类初始化之前他的父类必须先初始化，若其父类仍然存在父类，那也需递归的初始化。</li></ol><p>真正执行java代码，会调用<code>&lt;clinit&gt;()</code>方法 ：<br><code>在编译生成class文件时,会自动产生两个方法,一个是类的初始化方法&lt;clinit&gt;, 另一个是实例的初始化方法&lt;init&gt;。</code><br>只有被static修饰并且赋值的静态属性才会产生<code>&lt;clinit&gt;()</code>方法，不管是直接赋值还是在静态块中赋值，最后都会被合并成一个<code>&lt;clinit&gt;()</code>方法，并按照代码中的顺序依次赋值。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口。</li><li>在初始化一个接口时，并不会先初始化它的父接口。</li></ul><h3 id="（面试题）-什么情况下立即对类初始化？"><a href="#（面试题）-什么情况下立即对类初始化？" class="headerlink" title="（面试题） 什么情况下立即对类初始化？"></a>（面试题） 什么情况下立即对类初始化？</h3><p>1 遇到四条字节码指令会立即初始化：</p><ul><li>创建普通对象的指令：new</li><li>访问类字段（static 字段，或者称为类变量）的指令：getstatic, putstatic</li><li>invokestatic 指令：用于调用类方法(static方法)。<br>（new引用类会立即初始化， new数组不会初始化： 原因：创建数组得到指令：newarray , anewarray , multianewarray，不是new指令）</li></ul><p>2 反射直接初始化<br>3 父类未初始化先初始化<br>4 有main函数<br>5 java.lang.invoke.MethodHandle 实例最后解析结构结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，必须触发其初始化。<br>6 jdk1.8 接口default 方法</p><p>引申知识：</p><ul><li><p>加载：<br>  双亲委派模型：<br>  1启动类加载器（lib目录，根加载器），<br>  2拓展类加载器（lib-&gt;ext目录），<br>  3系统类加载器<br>(又叫应用程序加载器，加载用户类路径（classpath）上的指定类库，可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器)<br> 4当然，可以通过继承Classloader实现自定义加载器<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><ul><li><p>（面试） 双亲委派好处？<br>1.顺序加载。父类优先加载，<strong>避免重复加载</strong><br>2.安全性和唯一性。<strong>避免核心类篡改</strong></p><p>  利用 沙箱安全机制。 比如：加载器发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来（或自己写）的java.lang.Integer<br>  <code>tips： instance of 是根据类名称+类加载器 定位</code></p></li><li>JVM加载数组？<br>数组这个类加载，不是类加载器加载，其内存区域是运行中内存动态构造的。<br>类型的类在new时，才由加载器加载。<br>如何标记出唯一数组？</li></ul><ol><li>当引用类被加载器加载时，数组标志在加载器的<code>命名空间</code>上。</li><li>基础类型数组类型直接标记在<code>启动类加载器</code>的<code>命名空间</code>上。</li></ol></li></ul><p><strong>命名空间</strong><br>    <a href="https://blog.csdn.net/chuifuhuo6864/article/details/100887587" target="_blank" rel="noopener">https://blog.csdn.net/chuifuhuo6864/article/details/100887587</a></p><blockquote><p>由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间。命名空间由一系列唯一的名称组成，每一个被装载的类有一个名字。JAVA虚拟机为每一个类装载器维护一个名字空间。例如，一旦JAVA虚拟机将一个名为Volcano的类装入一个特定的命名空间，它就不能再装载名为Valcano的其他类到相同的命名空间了。可以把多个Valcano类装入一个JAVA虚拟机中，因为可以通过创建多个类装载器从而在一个JAVA应用程序中创建多个命名空间。<br><strong>初始类装载器/</strong> <strong>定义类装载器</strong></p><p>命名空间有助于安全的实现，因为你可以有效地在装入了不同命名空间的类之间设置一个防护罩。在JAVA虚拟机中，在同一个命名空间内的类可以直接进行交互，而不同的命名空间中的类甚至不能觉察彼此的存在，除非显示地提供了允许它们进行交互的机制，如获取Class对象的引用后使用反射来访问。</p><p>如果要求某个类装载器去装载一个类型，但是却返回了其他类装载器装载的类型，这种装载器被称为是那个类型的<strong>初始类装载器</strong><br>；而实际装载那个类型的类装载器被称为该类型的<strong>定义类装载器</strong><br>。任何被要求装载类型，并且能够返回Class实例的引用代表这个类型的类装载器，都是这个类型的初始类装载器。</p></blockquote><h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h1><p>1.常量池常量池,也叫Class常量池(常量池==Class常量池)。Java文件被编译成Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区各种字面量(Literal)和符号引用。在Class文件结构中，最头的4个字节用于存储魔数(MagicNumber)，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念。如下</p><p>2.运行时常量池</p><p>2.1运行时常量池的简介运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中2.2方法区的Class文件信息，Class常量池和运行时常量池的三者关系字符串常量池</p><p>3.1字符串常量池的简介字符串常量池又称为：字符串池，全局字符串池,英文也叫StringPo。在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3. 运行时数据区"></a>3. 运行时数据区</h1><ol><li>线程共享<br> 方法区，堆</li><li>线程私有<br> 虚拟机栈，本地方法栈，程序计数器</li></ol><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol><li>小内存，几乎无OOM，控制代码执行位置，比如循环，线程block恢复，wait恢复</li></ol><h2 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h2><ol><li>存储类信息 （第四步加载过程）</li><li>常量，静态变量</li><li>即时编译后的代码缓存数据 【Class方法表中Code属性，保存执行指令字节，将其缓存在方法区】</li></ol><p>元空间：能不限制使用系统内存资源</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ol><li>存放编译期生成的字面量+符号引用</li><li>具备动态性<br>不要求常量一定只有编译期才能产生<br><strong>String.intern()</strong> 是一个Native方法。调用intern()方法后，JVM 就会在当前类的运行时常量池中查找是否存在与str等值的String，若存在则直接返回运行时常量池中相应Strnig的引用；若不存在，则会在运行时常量池中创建一个等值的String，然后返回这个String在运行时常量池中的引用。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol><li>对象头（Header）: （Mark Word+ class指针+ 数组长度）<br>hashcode，GC分代年龄，锁标志状态，当前锁，偏向锁ID，偏向时间戳</li><li>实例数据（ Instance）</li><li>对齐填充（Padding）： 不满8字节的倍数就对齐填充<br><strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。 如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></li></ol><p><strong>（面试题） 64位JVM 中 new Object()  在Java中占多少内存？</strong><br>16字节。<br>Mark Word （8字节）+ class指针（指针压缩4字节，否则8字节）+实例数据（0字节）+对齐填充（4字节或0字节）</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>java栈是针对每一个线程的，每一个线程都会有自己的栈，维护在其内部的引用就是本地变量表。</p><p>通过线程想起栈，提问，对象是如何被线程访问定位的呀？问的非常底层。<br><a href="https://blog.csdn.net/y471519146/article/details/104638340" target="_blank" rel="noopener">https://blog.csdn.net/y471519146/article/details/104638340</a></p><ol><li>使用句柄。句柄是一个对象的唯一标示。中间有一个句柄池，存在于java堆的内存区域，线程指向句柄池，句柄池reference链接到对象地址</li><li>使用直接指针。线程对象指向另一对象。<br>优劣：直接指针访问快，但gc清理将对象位置移动，每个线程的指针就要改变，消耗大。<br>句柄优势：稳定，句柄池位置不变，当gc清理将对象位置移动，只需改变句柄池1个链接。</li></ol><h3 id="栈帧※"><a href="#栈帧※" class="headerlink" title="栈帧※"></a>栈帧※</h3><ol><li>1个方法创建1个栈帧：存储方法的局部变量表，操作数栈，动态链接，返回地址等。【class方法表中附带属性表中code属性有局部变量所需要的空间】</li><li>开始调用到完成过程就是一个栈帧的入栈出栈<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5>存储方法里的局部变量（包括方法参数），编译完成存储【class方法表中附带属性表中code属性】<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5>方法调用的最大深度【code属性的max_stack】，比如递归，调用数超出，则StackOverflowError。<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5>方法调用过程中，链接其他方法或其他类<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5>谁调用返回给谁。分两点</li><li>正常退出。</li><li>异常退出。抛错给调用方。</li></ol><p>####</p><h2 id="堆-展开知识-（第二期）"><a href="#堆-展开知识-（第二期）" class="headerlink" title="堆 展开知识 （第二期）"></a>堆 展开知识 （第二期）</h2><p>Q:新生代  eden s0 s1 是根据什么思想 8:1:1分区 ？ 回收器都是这样吗？<br>基于标记复制算法思想； 而基于标记清理算法就不是。</p><p>第一次minorgc： eden 空，s0 年龄1<br>第二次minorgc：eden空，s0空，s1 年龄有1和2<br>此时 s0 和 s1 角色互换<br>第三次minorgc：eden 1岁，s0空，s1 年龄有2和3<br>                             eden 空，s0空年龄有1,、2和3 ，s1空<br>此时 s0 和 s1 角色互换…</p><p>为什么需要s0和s1？<br> 需要空闲的缓冲内存，存储清理后的存活对象，避免s0区空间碎片化。</p><p>老年代</p><ol><li>年龄15岁以上</li><li>超大对象，超过阈值设置 max tenuring thread hold</li><li><p>相同年龄所有对象大小总和大于一个幸存者空间的一半，取年龄大于等于的对象，<br>所以年轻代空间利用，只有 90%</p><p>（一旦老年代要满就引发fullgc）</p></li></ol><p>※ 空间分配担保策略<br> minorGC发生之前，第一步先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立确保安全，如果条件不成立，比如空间剩余500M；<br> 就会第二步检查虚拟机HandlePromotionFailure参数是否true，是否允许担保失败；<br> 如果允许担保失败，jvm再次第三步检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小；</p><ul><li>如果大于，比如平均之前300M，冒险尝试一次minorGC，  存在风险：minorGC后存活对象还是大于500M，超出最大可用连续空间，说明老年代要满了就引发fullGC。<ul><li>如果小于 或 HandlePromotionFailure参数false，就直接fullGC。</li></ul></li></ul><p>（面试）如何判断对象是否存活？ gc过程是什么？<br>可达性分析算法，通过一系列称为“GC Roots”根节点，开始引用链的搜索，如果对象搜索不到，证明对象不可达，标记白色，最终被垃圾回收。<br>引申：引用计数器算法，每个对象有引用计数器，Redis使用<br>5个问题：</p><h3 id="1-gcroots-是什么？"><a href="#1-gcroots-是什么？" class="headerlink" title="1.gcroots 是什么？"></a>1.gcroots 是什么？</h3><p>是可达性分析的起点，是两个栈的栈帧的本地变量表中引用的对象，方法区中静态属性引用的对象，方法区中常量引用对象（两个栈两个方法区），其实还有，jvm内部也有引用，锁的获取和释放。</p><h3 id="2-引用链是什么？"><a href="#2-引用链是什么？" class="headerlink" title="2.引用链是什么？"></a>2.引用链是什么？</h3><p>强：常见，永远不被垃圾回收<br>软：非必须，内存溢出OOM之前，列入回收范围进行第二次回收，还溢出就抛错<br>弱：生存到下一次垃圾收集之前<br>虚：幽（或幻）灵引用，主要用于监测对象是否已经从内存中删除，堆外内存回收。</p><p>软引用尝试保留其引用对象，弱引用不会试图保留其引用对象，虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除。</p><blockquote><ul><li><p>虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中</p></li><li><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</p></li></ul></blockquote><h3 id="3-对象不可达意味着什么？一定被回收吗？"><a href="#3-对象不可达意味着什么？一定被回收吗？" class="headerlink" title="3.对象不可达意味着什么？一定被回收吗？"></a>3.对象不可达意味着什么？一定被回收吗？</h3><p>意味对象即将被垃圾回收，当然，不会立即回收。<br>※ 对象会放入f-q 的队列，会启动一条低优先级别的线程，读取对象，一个个调用对象的finalize方法，如果方法被覆盖并且被调用过，jvm会对该对象置为非必要垃圾回收，它逃过垃圾回收</p><h3 id="4-三色标记法是什么？"><a href="#4-三色标记法是什么？" class="headerlink" title="4.三色标记法是什么？"></a>4.三色标记法是什么？</h3><p>白： 对象不可达<br>黑： 已被访问，所有关联对象也扫描过<br>灰：未被扫描 （重新标记有关）</p><ul><li><figure class="image-box">                <img src="7779607-eecbd09f81b721f8.gif" alt="img" title class>                <p>img</p>            </figure></li></ul><p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p><ol><li><p>初始时，所有对象都在【白色集合】中；</p></li><li><p>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</p></li><li><p>从灰色集合中获取对象：<br>3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中；<br>3.2. 将本对象挪到【黑色集合】里面。</p></li><li><p>重复步骤3，直至【灰色集合】为空时结束。</p></li><li><p>结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收。</p><blockquote><p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p></blockquote></li></ol><p>当 Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。</p><p>而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p><p><strong>多标-浮动垃圾</strong></p><p>假设已经遍历到 E（变为灰色了），此时应用执行了 objD.fieldE = null (D &gt; E 的引用断开)：<br><figure class="image-box">                <img src="1153954-20201220213532679-409632912.png" alt="img" title class>                <p>img</p>            </figure></p><p>此刻之后，对象 E/F/G 是“应该”被回收的。然而因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮 GC 不会回收这部分内存。</p><p>这部分本应该回收 但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p><p>另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p><p><strong>漏标-读写屏障</strong></p><p>假设 GC 线程已经遍历到 E（变为灰色了），此时应用线程先执行了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG;</span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 灰色E 断开引用 白色G</span></span><br><span class="line">objD.fieldG = G;  <span class="comment">// 黑色D 引用 白色G</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="1153954-20201220214557708-22631031.png" alt="img" title class>                <p>img</p>            </figure><p>此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。</p><p>最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。</p><p>不难分析，漏标只有同时满足以下两个条件时才会发生：</p><ol><li>灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。</li><li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li></ol><p>从代码的角度看：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG; <span class="comment">// 1.读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 3.写</span></span><br></pre></td></tr></table></figure><ol><li>读取对象 E 的成员变量 fieldG 的引用值，即对象 G；</li><li>对象 E 往其成员变量 fieldG，写入 null值。</li><li>对象 D 往其成员变量 fieldG，写入对象 G ；</li></ol><p>我们只要在上面这三步中的任意一步中做一些“手脚”，将对象 G 记录起来，然后作为灰色对象再进行遍历即可。比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。</p><blockquote><p>重新标记是需要 STW 的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记 STW 的时间，这个是优化问题了。</p></blockquote><p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。<br>它们的拦截的目的很简单：就是在读写前后，将对象 G 给记录下来。</p><p><strong>写屏障(仅拓展)</strong></p><ul><li><p>CMS：写屏障 + 增量更新</p><blockquote><p>当有新引用插入进来时，记录下新的引用对象。</p><p>思路：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。</p></blockquote></li></ul><ul><li><p>G1：写屏障 + SATB</p><blockquote><p>当原来成员变量的引用发生变化之前，记录下原来的引用对象。</p><p>思路：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的 GC Roots 确定后，当时的对象图就已经确定了</p><p>比如 当时 D 是引用着 G 的，那后续的标记也应该是按照这个时刻的对象图走（D 引用着 G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p></blockquote></li><li><p>ZGC：读屏障</p><blockquote><p>当读取成员变量时，一律记录下来</p></blockquote></li></ul><h3 id="5-有没有跨代引用的问题？※"><a href="#5-有没有跨代引用的问题？※" class="headerlink" title="5.有没有跨代引用的问题？※"></a>5.有没有跨代引用的问题？※</h3><p>minorGC时候，如果当前年轻对象被老年代的对象引用，那么就需要遍历老年代对象里面的引用，如果有引用就不删除年轻代对象。 遍历过多，这消耗过大。</p><p>空间换时间，引入<strong>记忆集</strong>（<strong>RememberSet数据结构</strong>），<br><strong>（卡表CardTable是具体实现类似数组的一种实现）</strong></p><p>用于记录从非收集区域指向收集区域的一个指针集合的抽象数据结构。</p><p>它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题。<br><a href="https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc</a></p><blockquote><p>记忆集根据记录的精度分三类：<br>字长精度：记录的是老年代指向新生代地址。<br>对象精度：记录的是老年代引用的新生代对象。<br>卡精度：记录的是新生代一段地址是否存在被老年代引用的记录。</p></blockquote><p>把地址的值右移9位相当于除于512就是卡表索引，每字节512为一组对应卡表同一个元素，一组就是一个卡页，<br>如果这个卡页中只要有一个对象被其他区域对象所引用，对应卡表元素的值就变成1，也就是所谓的元素变脏。</p><p>在垃圾回收时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页对应的内存包含跨代指针，把他们加入GC Roots中一并扫描。</p><h3 id="垃圾回收的3种算法"><a href="#垃圾回收的3种算法" class="headerlink" title="垃圾回收的3种算法"></a>垃圾回收的3种算法</h3><ul><li><p>标记-清除算法<br>标记后统一回收<br>空间问题: 他只有一块内存空间，会产生空间碎片，导致没有太多的可用的比较大的连续空间，导致对象创建找不到容纳空间，直接进入老年代。<br>优点：快，找到并马上删除</p></li><li><p>标记-复制算法<br>起初思想是将内存分半，内存1:1，一部分存储新对象，一部分负责我们的存活对象。实现的时候，eden，s0，s1，幸存者区1个缓冲<br>缺点：至少10%空间浪费，相对慢<br>优点：针对创建对象，有很大的可用连续空间，GC后，eden区域清空，都是连续空空间，没有空间碎片</p></li></ul><ul><li>标记-整理算法<br>优化了标记复制算法和标志清除算法的改进，</li></ul><ol><li>标记并清除</li><li>存活对象整理到1边<br>删除快，没有空间碎片</li></ol><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="image-box">                <img src="image_20220129152044.png?v=1&type=image&token=V1:muO6XhBva0We3ErRpB0T7PPyoRqWWSq-G6D2IwZ9ymA" alt title class>                <p></p>            </figure><ol><li>新生代：serial 单线程<br>单核服务器最快最理想，有stw暂停和安全点线程挂起的问题。<br>Q：会不会有CPU时间切片轮询？为什么单核快呢？<br>其他线程必须挂起Stop the world，cpu时间片都要落到垃圾收集的线程里面，其他线程不会有cpu时间片轮询，即便有，cpu时间片也是0。其他线程处于内核态，只有垃圾收集器处于用户态。</li></ol><p>为什么Stop the world呢？</p><ol start="2"><li><p>新生代：并发的parNew 。 serial 的多线程版本<br>标记复制算法</p></li><li><p>新生代：parallel Scavenge。<br>能多线程，又能关注和控制吞吐量。<br>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)<br>不与CMS合作</p></li></ol><p>两个控制参数：<br>    最大垃圾收集停顿时间<br>    直接设置吞吐量大小<br>如何控制吞吐量？<br>    首先，运行用户代码不会变。<br>    那么，通过多运行几回垃圾收集，来提高一次虚拟机运行的吞吐量。<br>    比如： 注意吞吐量参数是（0,100）</p><ol start="4"><li><p>老年代：Serial Old 收集器<br>单线程，标记整理算法</p></li><li><p>老年代：Pallel Old 收集器<br>标记整理算法，jdk1.6才开始，吞吐量优先。</p></li><li><p>老年代：CMS 收集器<br>Concurent Mark Sweep 多线程标记清除，以最短回收停顿时间为目标的收集器。<br>记忆：<br>三个mark一清除，初重stw</p></li></ol><p>CMS步骤过程：<br>初始标记 stw，标记gcroots 直接关联对象<br>并发标记  不停顿，扫描old区对象。</p><blockquote><p>刚才产生的集合中标记出存活对象；<br>应用程序也在运行；<br>并不能保证可以标记出所有的存活对象；</p></blockquote><p>重新标记 stw，修正<br>并发清除</p><p>stop the world 其他线程被挂起，处于内核态。</p><p>※※<br>CMS 缺点：<br>首先承认，G1 出来之前，jdk9之前, CMS是靠谱的。</p><ol><li>对资源处理非常敏感。<br>在并发标记时，占用CPU线程数，影响项目中运行所用线程数。因为占用资源，可能导致资源不足。默认启动(核数n+3)/4线程，这样，核数多防止占用。</li><li><p>无法处理浮动垃圾。<br>并发清除，程序运行依然运行，有新垃圾出现，本次收集无法处理，留到下一次GC才清理，这就是“浮动垃圾”。如果对象被疯狂访问，大量对象堆积，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p></li><li><p>“标记清除算法”虽然快，会产生大量空间碎片。</p></li></ol><h3 id="stop-the-word-※※"><a href="#stop-the-word-※※" class="headerlink" title="stop the word ※※"></a>stop the word ※※</h3><p>引入概念：根节点枚举。<br>在开始标记收集的时候，不管单线程还是并发，不管是对象还是线程，一定在一致性的快照里，才能进行。<br>如果不知道当前的状态的话，没办法进行后续的标记。<br>一致性快照的分析工作就是根节点枚举期间：所有线程停顿。</p><p>OopMap 特定的位置记录下栈和寄存器中的哪些位置是引用</p><blockquote><p> OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。<br> 一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。<br> 我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。<br> <strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong><br> 通过上面的解释，我们可以很清楚的看到使用 OopMap 可以避免全栈扫描，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC 。</p></blockquote><h3 id="安全点Safepoint"><a href="#安全点Safepoint" class="headerlink" title="安全点Safepoint"></a>安全点Safepoint</h3><p>垃圾收集过程，用户线程到达特定位置，这位置不会产生新对象，也不会影响项目的执行，只能让垃圾收集非常安全的进行下去。<br>位置：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置</p><p>OopMap线程找对象<br>回顾句柄池，直接指针。</p><p>如何线程如何找Class文件？<br>找常量池里的Constant_class_info指向Constant_utf8_info,找到权限命名，再去方法区。（类加载过程中，对象加载到方法区，再在堆生成class对象，作为访问类的入口）在堆中定位到Class。</p><p>想继续找方法？<br>方法表-&gt;属性表-&gt;code-&gt;max stack，max local，方法入口-&gt; 代码</p><h3 id="G1垃圾收集器※※"><a href="#G1垃圾收集器※※" class="headerlink" title="G1垃圾收集器※※"></a>G1垃圾收集器※※</h3><figure class="image-box">                <img src="image-20220208015310593.png" alt title class>                <p></p>            </figure><ol><li>分代理论垃圾收集，只不过是增加一个拓展。</li><li>把内存区域分成多个大小相等的内存区域块Region。</li><li>jdk9发布，把吞吐量组合取代了，成为服务端默认。如果换成CMS，那么JDK参数配置开启CMS，不过提示Warnings：CMS以后会被废弃。</li><li>内存分块会按照“意愿”进行局部收集。</li><li><p>Region堆内存布局的原理：<br>不再坚持固定大小的分代理论，把内存区域分成多个大小相等的内存区域块Region，每个Region会根据需要扮演新生代eden，survival），老年代的角色。<br>如果有大对象？<br>G1会分出一部分区域作为特殊区域专门存储大对象，如果通过G1检测，只要大小超过<strong>超过1.5个region</strong>，就可以判断大对象，就放到H。Region可以通过JVM参数设置，1-32GB之间。如果超过16GB，肯定放在大对象区域。<br>大对象区域称为：humongous，全称：attempt_allocation_humongous。<br>对于超大对象，比如32GB，会分配两个连续的Region空间。</p></li><li><p><strong>标榜：可预测停顿时间的模型。</strong><br> 关注每个模块里回收价值的大小，通过设置一个很低的最大允许GC时间ms，，-XX：MaxGCPauseMillis =200，根据200ms去找它能够进行收集的Region，比如：收10个Region需要花300ms，由于超过200ms，按比例降低先收集6-7Region达到而200ms要求。</p><ul><li>由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制</li></ul></li></ol><ul><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,<strong>每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</li></ul><p>Q：如何解决跨代Region引用问题？<br>A：使用记忆集，结构相对复杂，是个双向卡表。</p><p>步骤：<br>1.初始标记：stw<br>    GCRoots根节点枚举，在安全点进行<br>2.并发标记<br>3.最终标记：stw<br>4.筛选回收<br>    <strong>根据MaxGCPauseMillis最大允许GC时间，优先回收价值最大的Region， 保证可预测停顿时间。</strong></p><h3 id="JVM调优经验-※※"><a href="#JVM调优经验-※※" class="headerlink" title="JVM调优经验 ※※"></a>JVM调优经验 ※※</h3><p>根据用户访问量，在不同时刻导致JVM回收<br>在上线前，做压测，监督内存空间的使用，以及发生GC回收的频率和停顿时间。</p><ol><li><p>大访问的压力，一边回收一边对象持续创建，minorGC会比较频繁，那么，一：<strong>调大年轻代的大小</strong>。二：如果发生时间不长，很快回收，且回收率高，不会导致老年代短时间内有对象填充，那么就，<strong>进行持续压测</strong>，观察老年代的上限。</p></li><li><p>大对象创建的频繁且常访问，导致FullGC比较频繁，（对于G1会分配到humongous区）。一：压测观察大对象的大小，过大可以把对象拆分，维持在JVM参数下；二：适当调大判断为大对象的参数，防止它直接进入老年代；三：发生OOM异常，如何排查呢？压测过程，一定先dump出来堆内存的heap文件，导入visual VM工具，主要查看堆栈信息。找内存占用高的对象，Reference指向堆栈信息，最终定位代码。springboot的Context上下文是单例，很难发生大对象频繁创建。四:  线程无法到达安全点，请求第三方等待中，比如60s超时时间，其他线程的已经在安全点STW，这里细说：用户态和内核态。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;引言：&lt;/strong&gt;&lt;br&gt;来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。&lt;br&gt;优点：笔记知识点关联性好，挖得深，延伸多。&lt;br&gt;缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="jvm" scheme="https://github.com/missionOdd/categories/jvm/"/>
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/jvm/技术/"/>
    
    
    <category term="jvm" scheme="https://github.com/missionOdd/tags/jvm/"/>
    
    <category term="java" scheme="https://github.com/missionOdd/tags/java/"/>
    
    <category term="技术" scheme="https://github.com/missionOdd/tags/技术/"/>
    
    <category term="原理" scheme="https://github.com/missionOdd/tags/原理/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包是什么？ 如何解决？</title>
    <link href="https://github.com/missionOdd/2022/01/12/zhan-bao/"/>
    <id>https://github.com/missionOdd/2022/01/12/zhan-bao/</id>
    <published>2022-01-12T14:15:08.000Z</published>
    <updated>2022-01-12T14:58:42.132Z</updated>
    
    <content type="html"><![CDATA[<p>事情从一个健身教练说起吧。</p><p>李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件<strong>琛琛</strong>上发布广告。</p><p>键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！</p><p>还记得<strong>四层网络协议</strong>长什么样子吗？</p><figure class="image-box">                <img src="v2-3ce2ef6cc4a7f288941ade57c9799450_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>四层网络模型每层各司其职，消息在进入每一层时都会多加一个<strong>报头</strong>，每多一个报头可以理解为<strong>数据报多戴一顶帽子</strong>。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，<strong><code>mac头部</code>记录的是硬件的唯一地址，<code>IP头</code>记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程</strong>。</p><p>在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。</p><figure class="image-box">                <img src="v2-a74a8e2932a412ffdbcb98f884fc086f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="为什么要将数据切片"><a href="#为什么要将数据切片" class="headerlink" title="为什么要将数据切片"></a><strong>为什么要将数据切片</strong></h3><p>软件<strong>琛琛</strong>是属于<strong>应用层</strong>上的。</p><p>而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是<strong>传输层上的 TCP 协议</strong>。消息在进入<strong>传输层（TCP）</strong>时会被切片为一个个数据包。这个数据包的长度是<code>MSS</code>。</p><p>可以把网络比喻为一个水管，是有一定的<strong>粗细</strong>的，这个粗细由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>，一般认为是的<code>MTU</code>（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。</p><figure class="image-box">                <img src="v2-5db7c25baee72ee2b77ca3bcbee97312_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="MTU-和-MSS-有什么区别"><a href="#MTU-和-MSS-有什么区别" class="headerlink" title="MTU 和 MSS 有什么区别"></a><strong>MTU 和 MSS 有什么区别</strong></h3><figure class="image-box">                <img src="v2-ce18e60cfc7a9bbe120b85ac4a7077ec_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</li><li><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</li></ul><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a><strong>什么是粘包</strong></h3><p>那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。</p><figure class="image-box">                <img src="v2-1daa1040cda53b3015f7001a2a72897f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的<strong>字节流（stream）</strong>。</p><figure class="image-box">                <img src="v2-17ecf0e357371feddf343f93b658ec84_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>但由于聊天软件<strong>琛琛</strong>是新开发的，而且开发者叫<strong>小白</strong>，完了，是个<strong>臭名昭著的造 bug 工程师</strong>。经过他的代码，在处理<strong>字节流</strong>的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的<strong>粘包</strong>。</p><figure class="image-box">                <img src="v2-b57e49bce332079e2a62c656b2d422e5_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>一个号称<strong>健康终结者</strong>的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a><strong>为什么会出现粘包</strong></h3><p>那就要从 TCP 是啥说起。</p><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-e2a59fa4a549dadabd73e202ad0fe6e8_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>其中跟<strong>粘包</strong>关系最大的就是<strong>基于字节流</strong>这个特点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间<strong>没有任何边界</strong>。</p><figure class="image-box">                <img src="v2-7b36d6b7eae993081244621846b11704_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p><h3 id="为什么要组装发送的数据"><a href="#为什么要组装发送的数据" class="headerlink" title="为什么要组装发送的数据"></a><strong>为什么要组装发送的数据</strong></h3><p>上面提到 TCP <strong>切割</strong>数据包是为了能顺利通过网络这根水管。相反，还有一个<strong>组装</strong>的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较<strong>浪费</strong>网络 io 。</p><figure class="image-box">                <img src="image-20220112222810497.png" alt="image-20220112222810497" title class>                <p>image-20220112222810497</p>            </figure><p>比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。</p><p>优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先<strong>等待</strong>，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。</p><p>上面说的其实就是<code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><figure class="image-box">                <img src="v2-495ef2712c3b542cf277a5121cfe3ab4_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>由于启动了<strong>Nagle算法</strong>， msg1 小于 mss ，此时等待<code>200ms</code>内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为<code>MSS</code>。此时发送出去。</li><li>剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。</li><li>剩余的 msg3(2) 长度不足<code>mss</code>，同时在<code>200ms</code>内没有等到下一个包，等待超时，直接发送。</li><li>此时三个包虽然在图里<strong>颜色不同</strong>，但是实际场景中，他们都是<strong>一整个 01 串</strong>，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就<strong>像是两个包粘在一起</strong>，就会导致<strong>粘包问题</strong>。</li></ul><h3 id="关掉-Nagle-算法就不会粘包了吗？"><a href="#关掉-Nagle-算法就不会粘包了吗？" class="headerlink" title="关掉 Nagle 算法就不会粘包了吗？"></a><strong>关掉 Nagle 算法就不会粘包了吗？</strong></h3><p><strong>Nagle</strong> 算法其实是个<strong>有些年代</strong>的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。</p><p>但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。</p><p>所以现在<strong>一般也会把它关掉</strong>。</p><p>看起来，Nagle 算法的优化作用貌似不大，还会导致<strong>粘包”问题”</strong>。那么是不是关掉这个算法就可以解决掉这个<strong>粘包”问题”</strong>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP_NODELAY = 1</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-53dd931a4d8ea89ea1fbc0bbcfa50072_r.jpg" alt="preview" title class>                <p>preview</p>            </figure><ul><li>接受端应用层在收到 <strong>msg1</strong> 时立马就取走了，那此时 <strong>msg1</strong> 没粘包问题</li><li><strong>msg2 </strong>到了后，应用层在忙，没来得及取走，就呆在 <strong>TCP Recv Buffer</strong> 中了</li><li><strong>msg3 </strong>此时也到了，跟 <strong>msg2</strong> 和 <strong>msg3</strong> 一起放在了 <strong>TCP Recv Buffer</strong> 中</li><li>这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中<strong>都是 01 串</strong>，此时一起取走，发现还是粘包。</li></ul><p>因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。</p><h3 id="怎么处理粘包"><a href="#怎么处理粘包" class="headerlink" title="怎么处理粘包"></a><strong>怎么处理粘包</strong></h3><p>粘包出现的根本原因是不确定<strong>消息的边界</strong>。接收端在面对<strong>“无边无际”的二进制流</strong>的时候，根本不知道收了多少 01 才算<strong>一个消息</strong>。一不小心拿多了就说是<strong>粘包</strong>。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong>，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。</p><p>常见的方法有</p><ul><li>加入特殊标志</li></ul><figure class="image-box">                <img src="image-20220112222646626.png" alt="image-20220112222646626" title class>                <p>image-20220112222646626</p>            </figure><p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p><ul><li>加入消息长度信息</li></ul><figure class="image-box">                <img src="v2-67108ed6fe1b9f89f4c831882ff9ff1c_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。</p><p>可能这时候会有朋友会问，采用<code>0xfffffe</code>标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？</p><p>是的，<strong>怕</strong>，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（<code>校验和</code>或者对整段完整数据进行 <code>CRC</code> 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。</p><figure class="image-box">                <img src="v2-a12fe05290289991e6d3fc4ed2137664_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="UDP-会粘包吗"><a href="#UDP-会粘包吗" class="headerlink" title="UDP 会粘包吗"></a><strong>UDP 会粘包吗</strong></h3><p>跟 <code>TCP</code> 同为传输层的另一个协议，<strong>UDP，User Datagram Protocol</strong>。用户数据包协议，是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-cb14cd4ee7817c81e0140fb0466e26ce_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p>我们先看下<strong>IP报头</strong></p><figure class="image-box">                <img src="v2-8d684c81269540bc81237b343755f7fc_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 <strong>UDP 的报头</strong>。</p><figure class="image-box">                <img src="v2-a62f8fa5871ce69211fa809032e633b6_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>在报头中有<code>16bit</code>用于指示 <strong>UDP 数据报文的长度</strong>，假设这个长度是 n ，以此作为<strong>数据边界</strong>。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个<strong>完整的</strong>数据报，从而避免粘包和拆包的问题。</p><p>当然，就算没有这个位（<strong>16位 UDP 长度</strong>），因为 IP 的头部已经包含了数据的<strong>总长度</strong>信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个<strong>总长度</strong>其实就包含了 UDP 的头部和 UDP 的数据。</p><p>因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了<code>数据和选项</code>以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。</p><figure class="image-box">                <img src="v2-0640a5a91302b68c71aafde8aeae2722_720w.jpg" alt="img" title class>                <p>img</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-4fdde9161d9f6be4fe2a372c1ff6d49b_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>TCP首部里是没有长度这个信息的，跟UDP类似，同样可以通过下面的公式获得当前包的TCP数据长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220112223526763.png" alt="img" title class>                <p>img</p>            </figure><p>跟 UDP 不同在于，TCP 发送端在发的时候就<strong>不保证发的是一个完整的数据报</strong>，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。</p><h3 id="为什么长度字段冗余还要加到-UDP-首部中"><a href="#为什么长度字段冗余还要加到-UDP-首部中" class="headerlink" title="为什么长度字段冗余还要加到 UDP 首部中"></a><strong>为什么长度字段冗余还要加到 UDP 首部中</strong></h3><p>关于这一点，查了很多资料，<code>《 TCP-IP 详解（卷2）》</code>里说可能是因为要用于计算校验和。也有的说是因为UDP底层使用的可以不是IP协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是IP层协议，而是其他网络层协议，就不能继续这么计算了。</p><p>但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，<strong>如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢</strong>？</p><p>因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。</p><figure class="image-box">                <img src="image-20220112223547322.png" alt="image-20220112223547322" title class>                <p>image-20220112223547322</p>            </figure><p>面试的时候咱就把这些全说出去，<strong>显得</strong>咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，<strong>加分加分</strong>。</p><p>如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！</p><h3 id="IP-层有粘包问题吗"><a href="#IP-层有粘包问题吗" class="headerlink" title="IP 层有粘包问题吗"></a><strong>IP 层有粘包问题吗</strong></h3><p>IP 层会对大包进行切片，是不是也有粘包问题？</p><p>先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。</p><p>先看看 IP 层的切片分包是怎么回事。</p><figure class="image-box">                <img src="v2-1f597892a79da54e5830c2e64c2fcb4a_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>如果消息过长，<code>IP层</code>会按 <strong>MTU 长度</strong>把消息分成 <strong>N 个切片</strong>，每个切片带有自身在<strong>包里的位置（offset）</strong>和<strong>同样的IP头信息</strong>。</li><li>各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后<strong>在最后的终点汇合后再组装</strong>。</li><li>在接收端收到第一个切片包时会申请一块新内存，创建IP包的数据结构，等待其他切片分包数据到位。</li><li>等消息全部到位后就把整个消息包给到上层（传输层）进行处理。</li></ul><p>可以看出整个过程，<code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。</p><p><code>IP 层</code>表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。</p><p>听起来就像 “<strong>我不管产品的需求傻不傻X，我实现了就行，我不问，也懒得争了</strong>”，这思路值得每一位优秀的划水程序员学习，<strong>respect</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。</p><ul><li>TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。</li><li>TCP 粘包跟Nagle算法有关系，但关闭 Nagle 算法并不解决粘包问题。</li><li>UDP 是基于数据报的传输协议，不会有粘包问题。</li><li>IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。</li><li><code>TCP</code> 发送端可以发 <code>10 次</code>字节流数据，接收端可以分 <code>100 次</code>去取；<code>UDP</code> 发送端发了 <code>10 次</code>数据报，那接收端就要在 <code>10 次</code>收完。</li></ul><p>数据包也只是按着 TCP 的方式进行组装和拆分，<strong>如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已</strong>。</p>]]></content>
    
    
    <summary type="html">转载自：https://zhuanlan.zhihu.com/p/359177898</summary>
    
    
    
    <category term="计算机网络" scheme="https://github.com/missionOdd/categories/计算机网络/"/>
    
    
    <category term="TCP/IP" scheme="https://github.com/missionOdd/tags/TCP-IP/"/>
    
    <category term="粘包" scheme="https://github.com/missionOdd/tags/粘包/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 |  双串题 | 不同的子序列</title>
    <link href="https://github.com/missionOdd/2022/01/05/distinct-subsequences/"/>
    <id>https://github.com/missionOdd/2022/01/05/distinct-subsequences/</id>
    <published>2022-01-05T07:50:37.000Z</published>
    <updated>2022-02-08T01:49:22.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="115"><li>不同的子序列<br>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</li></ol><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p></blockquote><blockquote><p>示例 1：<br>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>rabbbit<br>rabbbit<br>rabbbit</p></blockquote><blockquote><p>示例 2：<br>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>babgbag<br>babgbag<br>babgbag<br>babgbag<br>babgbag</p></blockquote><blockquote><p>提示：<br>0 &lt;= s.length, t.length &lt;= 1000<br>s 和 t 由英文字母组成</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>s, t引入头部””空字符；定义m、n分别是s、t长度，定义二维数组dp[m+1][n+1]，值表示s[0：i]可以组成t[0：j]的子序列最大数量；<br><code>（i，j泛指符合题目不超边界的相关变量，[0：i]表示枚举从0到i）</code></li><li>初始化</li></ol><ul><li>s[0：i]全部删除取得子序列“”，成功组成t[0]即“” ，所以dp[0：m][0] = 1</li><li>s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</li></ul><ol start="3"><li>递推过程</li></ol><ul><li>结尾字符相等，取两种情况的结合<br>第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等<br>第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</li><li>结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]<br><code>tips：由于引入“”的关系，s的当前字符指针是i-1，t的当前字符指针是j-1，与dp的i-1，j-1区别开</code></li></ul><ol start="4"><li>剪枝优化，限制t[0：j]长度不可能大于s[0：i]</li><li>返回结果</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s[0：i]全部删除取得子序列“”，成功组成t[0]“” ，所以dp[0：m][0] = 1</span></span><br><span class="line">        <span class="comment">//s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Math.min(i,n);j++)&#123; <span class="comment">// 剪枝操作，t[0：j]长度不可能大于s[0：i]</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">// 结尾字符相等，取两种情况的结合</span></span><br><span class="line">                    <span class="comment">//第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等</span></span><br><span class="line">                    <span class="comment">//第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distinct-subsequences/&quot; targ</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="动态规划" scheme="https://github.com/missionOdd/tags/动态规划/"/>
    
  </entry>
  
  <entry>
    <title>贪心| 大根堆 | 最长快乐字符串 | 取合法的剩余最多的字符进行拼接</title>
    <link href="https://github.com/missionOdd/2022/01/03/longest-happy-string/"/>
    <id>https://github.com/missionOdd/2022/01/03/longest-happy-string/</id>
    <published>2022-01-03T07:50:37.000Z</published>
    <updated>2022-02-07T19:11:39.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>贪心思路</strong>：<br>在同一字符相邻小于3的情况下，取剩余最多的字符进行拼接，否则不用第3个字符，取剩余数第二多的字符拼接。<br><strong>步骤</strong>：</p><ol><li>定义大根堆，目的是进行字符剩余数量的排序</li><li>定义结果字符串</li><li>遍历堆的取出操作，直至堆空</li><li>判断取出字段是否可能组成同一字符相邻出现3个的情况，如果是，则不用第3个字符，取剩余数第二多的字符拼接<br>（注意发生堆空的情况：不存在剩余数第二多的字符）</li><li>如果字符数量大于0，拼接字符</li><li>使用掉1个字符后，如果数量大于0，即仍有剩余就重新放入堆</li><li>返回String结果<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><a href="https://leetcode-cn.com/problems/longest-happy-string/" target="_blank" rel="noopener">the leetcode link</a><blockquote><ol start="1405"><li>最长快乐字符串<br>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</li></ol><p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p></blockquote></li></ol><blockquote><p>示例 1：<br>输入：a = 1, b = 1, c = 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。</p></blockquote><blockquote><p>示例 2：<br>输入：a = 2, b = 2, c = 1<br>输出：”aabbc”</p></blockquote><blockquote><p>示例 3：<br>输入：a = 7, b = 1, c = 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p></blockquote><blockquote><p>提示：<br>0 &lt;= a, b, c &lt;= 100<br>a + b + c &gt; 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      贪心：在同一字符相邻小于3的情况下，取剩余最多的字符进行拼接，否则不用第3个字符，取剩余数第二多的字符拼接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 定义大根堆，目的是进行字符剩余数量的排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; mostCountQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y)-&gt;y[<span class="number">1</span>]-x[<span class="number">1</span>]);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'a'</span>, a&#125;);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'b'</span>, b&#125;);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'c'</span>, c&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义结果字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 遍历堆的取出操作，直至堆空</span></span><br><span class="line">        <span class="keyword">while</span> (!mostCountQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = mostCountQueue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 判断取出字段是否可能组成同一字符相邻出现3个的情况，如果是，则不用第3个字符，取剩余数第二多的字符拼接</span></span><br><span class="line">            <span class="keyword">int</span> n =sb.length();</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> &amp;&amp; sb.charAt(n - <span class="number">1</span>)== cur[<span class="number">0</span>] &amp;&amp; sb.charAt(n - <span class="number">2</span>)== cur[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mostCountQueue.isEmpty()) <span class="keyword">break</span>; <span class="comment">//注意堆空的情况：不存在剩余数第二多的字符</span></span><br><span class="line">                <span class="keyword">int</span>[] temp = cur; <span class="comment">// temp暂存旧cur</span></span><br><span class="line">                cur = mostCountQueue.poll(); <span class="comment">// 取剩余数第二多的字符作为新cur</span></span><br><span class="line">                mostCountQueue.add(temp); <span class="comment">// temp重新放入堆</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 如果数量大于0，拼接字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>)cur[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 使用掉1个字符后，如果数量大于0，即仍有剩余就重新放入堆</span></span><br><span class="line">                <span class="keyword">if</span> (--cur[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    mostCountQueue.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;贪心思路&lt;/strong&gt;：&lt;br&gt;在同一字符相邻小于3的情况下，取剩余最多的字符进行拼接，否则不用第3个字</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="队列" scheme="https://github.com/missionOdd/tags/队列/"/>
    
    <category term="贪心" scheme="https://github.com/missionOdd/tags/贪心/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题 | 看懂鸡蛋掉落的本质 + 滚动数组优化</title>
    <link href="https://github.com/missionOdd/2022/01/03/super-egg-drop/"/>
    <id>https://github.com/missionOdd/2022/01/03/super-egg-drop/</id>
    <published>2022-01-03T07:50:37.000Z</published>
    <updated>2022-02-07T18:59:26.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="887"><li>鸡蛋掉落<br>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</li></ol><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p></blockquote><blockquote><p>示例 1：<br>输入：k = 1, n = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。</p></blockquote><blockquote><p>示例 2：<br>输入：k = 2, n = 6<br>输出：3</p></blockquote><blockquote><p>示例 3：<br>输入：k = 3, n = 14<br>输出：4</p></blockquote><p>提示：<br>1 &lt;= k &lt;= 100<br>1 &lt;= n &lt;= 104</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>本题解主要告诉你：这题目就是0-1背包问题的抽象</strong></p><ul><li>物品重量：1次操作数；(物品不超n个)</li><li>背包容量：鸡蛋数k个；</li><li>价值：确定楼层</li></ul><p>一般的背包问题：已知每个物品的重量及其价值、背包容量，求最大价值。<br>这题的背包问题：已知不超n个的物品（不超n次操作数），所有物品重量均为1（1次操作数）、背包容量（鸡蛋数k），求价值(确定楼层)为n时有多少物品。</p><p><code>看本题解，千万别纠结在第几楼层扔鸡蛋，因为它与01背包的思想无关</code></p><h4 id="1-确定dp数组以及下标的含义"><a href="#1-确定dp数组以及下标的含义" class="headerlink" title="1. 确定dp数组以及下标的含义"></a>1. 确定dp数组以及下标的含义</h4><p> dp[i][j] 表示： 容量（鸡蛋数）为i的背包，放入物品重量（操作数）为j时，价值(确定楼层)是多少。<br> 初始化：dp[0][0]=0，鸡蛋0，操作数0，确定楼层0</p><h4 id="2-确定递推公式"><a href="#2-确定递推公式" class="headerlink" title="2. 确定递推公式"></a>2. 确定递推公式</h4><p>当第i个鸡蛋、第count次扔出操作时，蛋要么碎，要么不碎，所能确定的楼层都+1</p><ul><li>dp[i][count]：表示你还剩 i 个蛋，且已操作 count 次，所能确定的楼层。</li><li>dp[i][count-1]：当蛋没碎，情况为少1次操作数，所能确定的楼层</li><li>dp[i-1][count-1]：当蛋碎了，情况为少1个蛋，少1次操作数，所能确定的楼层<br>当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1<br><code>dp[i][count] = dp[i-1][count-1]+dp[i][count-1]+1;</code></li></ul><h3 id="二维背包代码"><a href="#二维背包代码" class="headerlink" title="二维背包代码"></a>二维背包代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        01背包问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//背包：鸡蛋数（k个）； 物品：操作数（n个）；价值：确定楼层</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有人问了，为什么不是鸡蛋作为物品，最小操作数作为背包？</span></span><br><span class="line">        <span class="comment">// 背包问题往往物品与价值有正相关关系。</span></span><br><span class="line">        <span class="comment">// 鸡蛋有k个，但实际不一定全都用上，限制一定的最小操作数，鸡蛋增加，确定楼层（价值）不一定增加</span></span><br><span class="line">        <span class="comment">// 而取一定的鸡蛋，最小操作数每增加1，确定楼层(价值)就会一定增加</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(;dp[k][count]&lt;n;)&#123; <span class="comment">// 遍历物品，这里直到价值为n就结束</span></span><br><span class="line">             count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;=<span class="number">1</span>; i--) &#123; <span class="comment">// 遍历背包，二维数组可以正序或倒叙</span></span><br><span class="line">                <span class="comment">//当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1</span></span><br><span class="line">                dp[i][count] = dp[i-<span class="number">1</span>][count-<span class="number">1</span>]+dp[i][count-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维滚动数组代码"><a href="#一维滚动数组代码" class="headerlink" title="一维滚动数组代码"></a>一维滚动数组代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        01背包问题， 滚动数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 背包：鸡蛋数（k个）；物品：操作数（n个）；价值：确定楼层</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有人问了，为什么不是鸡蛋作为物品，操作数作为背包？</span></span><br><span class="line">        <span class="comment">// 背包问题往往物品与价值有正相关关系。</span></span><br><span class="line">        <span class="comment">// 鸡蛋有k个，但实际不一定全都用上，限制一定的操作数，鸡蛋增加，确定楼层（价值）不一定增加</span></span><br><span class="line">        <span class="comment">// 而取一定的鸡蛋，操作数每增加1，确定楼层 (价值)就会一定增加</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(;dp[k]&lt;n;)&#123; <span class="comment">// 遍历物品，这里直到价值为n就结束</span></span><br><span class="line">             count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;=<span class="number">1</span>; i--) &#123; <span class="comment">// 遍历背包，一维滚动数组一定倒叙</span></span><br><span class="line">                <span class="comment">//当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+dp[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 对于背包问题不了解的同学，推荐看看代码随想录的背包问题合集；<br>目前没看到其他人运用到背包的思路，此题解是本人学习过程中的野生想法，如有问题，欢迎指正</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-colors/&quot; target=&quot;_blank</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="01背包" scheme="https://github.com/missionOdd/tags/01背包/"/>
    
  </entry>
  
  <entry>
    <title>系统设计实战应用篇| 常见的业务场景</title>
    <link href="https://github.com/missionOdd/2022/01/03/java-design/"/>
    <id>https://github.com/missionOdd/2022/01/03/java-design/</id>
    <published>2022-01-03T05:50:37.000Z</published>
    <updated>2022-02-08T03:28:26.276Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#一es篇">一、ES篇</a><ul><li><a href="#1概述">1、概述</a><ul><li><a href="#特点">特点</a></li><li><a href="#功能">功能</a></li><li><a href="#场景">场景</a></li><li><a href="#竞品分析">竞品分析</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#2基本概念">2、基本概念</a><ul><li><a href="#ik分词器">IK分词器</a></li><li><a href="#索引类数据库">索引（类数据库）</a></li><li><a href="#映射类表设计">映射（类表设计）</a></li><li><a href="#文档数据">文档（数据）</a></li></ul></li><li><a href="#3高级特性">3、高级特性</a><ul><li><a href="#映射高级">映射高级</a><ul><li><a href="#地理坐标点数据类型"><strong>地理坐标点数据类型</strong></a></li><li><a href="#动态映射">动态映射</a></li></ul></li><li><a href="#dsl高级">DSL高级</a></li><li><a href="#聚合分析"><strong>聚合分析</strong></a></li><li><a href="#智能搜索"><strong>智能搜索</strong></a></li></ul></li><li><a href="#4实战">4、实战</a><ul><li><a href="#写优化">写优化</a></li><li><a href="#读优化">读优化</a></li><li><a href="#零停机索引重建方案">零停机索引重建方案</a></li><li><a href="#deeppaging性能解决方案">DeepPaging性能解决方案</a></li></ul></li></ul></li><li><a href="#二dockerk8s篇">二：Docker&amp;K8S篇</a><ul><li><a href="#why-docker">Why Docker</a></li><li><a href="#核心概念">核心概念</a></li><li><a href="#基本操作">基本操作</a></li><li><a href="#实战">实战</a></li></ul></li><li><a href="#三netty篇">三、Netty篇</a><ul><li><a href="#核心组件">核心组件</a><ul><li><a href="#1整体结构">1、整体结构</a></li><li><a href="#2逻辑架构">2、逻辑架构</a></li></ul></li><li><a href="#网络传输">网络传输</a><ul><li><a href="#1五种io模型的区别"><strong>1、五种IO模型的区别</strong></a></li><li><a href="#2reactor多线程模型">2、Reactor多线程模型</a></li><li><a href="#3拆包粘包问题">3、拆包粘包问题</a></li><li><a href="#4自定义协议">4、自定义协议</a></li><li><a href="#5writeandflush">5、WriteAndFlush</a></li></ul></li><li><a href="#内存管理">内存管理</a><ul><li><a href="#1堆外内存">1、堆外内存</a></li><li><a href="#2数据载体bytebuf">2、<strong>数据载体ByteBuf</strong></a></li><li><a href="#3内存分配jemalloc">3、<strong>内存分配jemalloc</strong></a></li><li><a href="#4jemalloc-架构">4、jemalloc 架构</a></li><li><a href="#5内存池设计待补充">5、内存池设计（待补充）</a></li><li><a href="#6recycle对象池待补充">6、Recycle对象池（待补充）</a></li><li><a href="#7零拷贝技术">7、零拷贝技术</a></li></ul></li><li><a href="#高性能数据结构">高性能数据结构</a><ul><li><a href="#1fastthreadlocal">1、FastThreadLocal</a></li><li><a href="#2hashedtimerwheel">2、<strong>HashedTimerWheel</strong></a></li><li><a href="#3mpscqueue">3、MpscQueue</a></li><li><a href="#4selectpollepoll的区别">4、select、poll、epoll的区别</a></li></ul></li></ul></li><li><a href="#四leetcode">四、LEETCODE</a><ul><li><a href="#python语法">【Python语法】</a></li><li><a href="#背包模板">【背包模板】</a></li><li><a href="#回溯模板">【回溯模板】</a></li><li><a href="#并查集模板">【并查集模板】</a></li><li><a href="#拓扑排序模板">【拓扑排序模板】</a></li><li><a href="#单调栈模板"><strong>【单调栈模板】</strong></a></li><li><a href="#二分模板">【二分模板】</a></li><li><a href="#动态规划模板">【动态规划模板】</a><ul><li><a href="#单串问题">「<strong>单串问题</strong>」</a></li><li><a href="#单串加状态问题">「<strong>单串加状态问题</strong>」</a></li><li><a href="#经典双串lcs问题">「<strong>经典双串LCS问题</strong>」</a></li><li><a href="#区间动态规划">「区间动态规划」</a></li><li><a href="#区间分治动态规划"><strong>「区间分治动态规划」</strong></a></li></ul></li><li><a href="#滑动窗口">【滑动窗口】</a></li><li><a href="#前缀和">【前缀和】</a></li><li><a href="#双指针">【双指针】</a></li><li><a href="#深度优先">【深度优先】</a></li><li><a href="#广度优先">【广度优先】</a></li><li><a href="#图论">【图论】</a></li></ul></li><li><a href="#五实战算法篇">五、实战算法篇</a><ul><li><a href="#1url黑名单布隆过滤器"><strong>1、</strong>URL黑名单（布隆过滤器）</a></li><li><a href="#2词频统计分文件">2、词频统计（分文件）</a></li><li><a href="#3未出现的数bit数组"><strong>3、未出现的数</strong>（bit数组）</a></li><li><a href="#4重复url分机器"><strong>4、重复URL</strong>（分机器）</a></li><li><a href="#5topk搜索小根堆"><strong>5、TOPK搜索（小根堆）</strong></a></li><li><a href="#6中位数单向二分查找"><strong>6、中位数（单向二分查找）</strong></a></li><li><a href="#7短域名系统缓存"><strong>7、短域名系统（缓存）</strong></a></li><li><a href="#8海量评论入库消息队列"><strong>8、海量评论入库（消息队列）</strong></a></li><li><a href="#9在线并发用户数redis"><strong>9、在线/并发用户数（Redis）</strong></a></li><li><a href="#10热门字符串前缀树">10、热门字符串（前缀树）</a></li><li><a href="#11红包算法">11、红包算法</a></li><li><a href="#11手写快排">11、手写快排</a></li><li><a href="#12手写归并">12、手写归并</a></li><li><a href="#13手写堆排">13、手写堆排</a></li><li><a href="#14手写单例">14、手写单例</a></li><li><a href="#15手写lrucache">15、手写LRUcache</a></li><li><a href="#16手写线程池"><strong>16、手写线程池</strong></a></li><li><a href="#17手写消费者生产者模式"><strong>17、手写消费者生产者模式</strong></a></li><li><a href="#18手写阻塞队列"><strong>18、手写阻塞队列</strong></a></li><li><a href="#19手写多线程交替打印abc"><strong>19、手写多线程交替打印ABC</strong></a></li><li><a href="#20交替打印foobar">20、交替打印FooBar</a></li></ul></li><li><a href="#六个人项目"><strong>六、个人项目</strong></a><ul><li><a href="#一一站到底"><strong>一、一站到底</strong></a><ul><li><a href="#1如何设计排行榜">1、如何设计排行榜</a><ul><li><a href="#性能优化过程">性能优化过程</a></li><li><a href="#方案优化过程">方案优化过程</a></li><li><a href="#方案1每日一个滚动榜当日汇聚费时间">方案1：每日一个滚动榜，当日汇聚（费时间）</a></li><li><a href="#方案2全局n个滚动榜同时写费空间">方案2：全局N个滚动榜同时写（费空间）</a></li><li><a href="#方案3实时更新常数次写操作">方案3：实时更新，常数次写操作</a></li></ul></li><li><a href="#2如何解决重复答题">2、<strong>如何解决重复答题</strong></a></li><li><a href="#3一个题目被多个人抢答"><strong>3、一个题目被多个人抢答</strong></a></li><li><a href="#4如何管理昵称重复"><strong>4、如何管理昵称重复</strong></a></li><li><a href="#5如何管理出题定时任务"><strong>5、如何管理出题定时任务</strong></a></li><li><a href="#6如何解决客户端断连"><strong>6：如何解决客户端断连</strong></a></li></ul></li><li><a href="#二秒杀项目">二、秒杀项目</a><ul><li><a href="#技术选型"><strong>技术选型</strong></a></li><li><a href="#方案设计">方案设计</a></li><li><a href="#1如何解决超卖"><strong>1、如何解决超卖？</strong></a></li><li><a href="#2如何解决重复下单"><strong>2、如何解决重复下单？</strong></a></li><li><a href="#3如何防刷"><strong>3、如何防刷？</strong></a></li><li><a href="#4热key问题如何解决"><strong>4、热key问题如何解决？</strong></a></li><li><a href="#5应对高并发的读请求"><strong>5、应对高并发的读请求</strong></a></li><li><a href="#6应对高并发的写请求"><strong>6、应对高并发的写请求</strong></a></li><li><a href="#7如何保证数据一致性"><strong>7、如何保证数据一致性</strong></a></li><li><a href="#8可靠性如何保障">8、可靠性如何保障**</a></li><li><a href="#9秒杀系统瓶颈-日志">9、秒杀系统瓶颈-日志</a></li></ul></li><li><a href="#三即时通信">三、即时通信</a><ul><li><a href="#1单聊消息可靠传输">1、<strong>单聊消息可靠传输</strong></a></li><li><a href="#2群聊消息如何保证不丢不重"><strong>2、群聊消息如何保证不丢不重</strong></a></li><li><a href="#3如何保证消息的时序性">3、<strong>如何保证消息的时序性</strong></a></li><li><a href="#4推拉结合"><strong>4：推拉结合</strong></a></li><li><a href="#5好友推荐">5、好友推荐</a></li></ul></li><li><a href="#四智慧社区">四、智慧社区</a><ul><li><a href="#物联网架构"><strong>物联网架构</strong></a><ul><li><a href="#dcm系统架构">DCM系统架构</a></li><li><a href="#三要素"><strong>三要素</strong></a></li><li><a href="#云--边--端协同">云 / 边 / 端协同</a></li><li><a href="#物联网平台接入">物联网平台接入</a></li><li><a href="#门锁接入">门锁接入</a></li><li><a href="#各种协议">各种协议</a></li></ul></li><li><a href="#iot流量洪峰">IOT流量洪峰</a></li><li><a href="#社区直播带货">社区直播带货</a><ul><li><a href="#产品的背景"><strong>产品的背景</strong></a></li><li><a href="#面临的挑战">面临的挑战</a></li><li><a href="#协议的比较">协议的比较</a></li><li><a href="#整体流程">整体流程</a></li><li><a href="#直播流程"><strong>直播流程</strong></a></li><li><a href="#播放流程">播放流程</a></li></ul></li><li><a href="#直播高可用方案"><strong>直播高可用方案</strong></a></li><li><a href="#性能优化方案"><strong>性能优化方案</strong></a></li><li><a href="#流量回放自动化测试">流量回放自动化测试</a></li></ul></li></ul></li><li><a href="#七架构设计"><strong>七、架构设计</strong></a><ul><li><a href="#1社区系统的架构">1、社区系统的架构</a></li><li><a href="#2商城系统-亿级商品如何存储">2、商城系统-亿级商品如何存储</a></li><li><a href="#3对账系统-分布式事务一致性">3、对账系统-分布式事务一致性</a></li><li><a href="#4用户系统-多线程数据割接">4、用户系统-多线程数据割接</a></li><li><a href="#5秒杀系统场景设计">5、秒杀系统场景设计</a></li><li><a href="#6统计系统-海量计数"><strong>6、统计系统-海量计数</strong></a></li><li><a href="#7系统设计---微软">7、系统设计 - 微软</a><ul><li><a href="#1需求收集"><strong>1、需求收集</strong></a></li><li><a href="#2顶层设计"><strong>2、顶层设计</strong></a></li><li><a href="#3系统核心指标"><strong>3、系统核心指标</strong></a></li><li><a href="#4数据存储">4、数据存储</a></li></ul></li><li><a href="#7如何设计一个微博">7、如何设计一个微博</a></li></ul></li><li><a href="#八领域模型落地">八、领域模型落地</a><ul><li><a href="#1拆分微服务">1、拆分微服务</a></li><li><a href="#2关联微服务">2、关联微服务</a></li><li><a href="#3微服务的落地"><strong>3、微服务的落地</strong></a></li><li><a href="#4领域模型的意义">4、领域模型的意义</a></li><li><a href="#5战略建模">5、战略建模</a></li><li><a href="#6相关名词"><strong>6、相关名词</strong></a></li></ul></li></ul><h1 id="一、ES篇"><a href="#一、ES篇" class="headerlink" title="一、ES篇"></a>一、ES篇</h1><blockquote><p>Elasticsearch可以实现<strong>秒级</strong>的搜索，cluster是一种分布式的部署，极<strong>易扩展(scale )</strong>这样很容易使它处理PB级的数据库容量。最重要的是Elasticsearch是它搜索的结果可以按照分数进行排序，它能提供我们最<strong>相关</strong>的搜索结果（<strong>relevance</strong>) 。</p></blockquote><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>安装方便</strong>：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</p></li><li><p><strong>JSON</strong>：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</p></li><li><p><strong>RESTful</strong>：基本所有操作 ( 索引、查询、甚至是配置 ) 都可以通过 HTTP 接口进行</p></li><li><p><strong>分布式</strong>：节点对外表现对等（每个节点都可以用来做入口） 加入节点自动负载均衡</p></li><li><p><strong>多租户</strong>：可根据不同的用途分索引，可以同时操作多个索引</p></li><li><p><strong>支持超大数据</strong>： 可以扩展到 PB 级的结构化和非结构化数据 海量数据的近实时处理</p></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>分布式的搜索引擎</strong></p><p>分布式：Elasticsearch自动将海量数据分散到多台服务器上去存储和检索</p></li><li><p><strong>全文检索</strong></p><p>提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能</p></li><li><p><strong>数据分析引擎（分组聚合）</strong></p><p>社区网站，最近一周用户登录、最近一个月各功能使用情况</p></li><li><p><strong>对海量数据进行近实时（秒级）的处理</strong></p><p>海量数据的处理：因为是分布式架构，可以采用大量的服务器去存储和检索数据</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p><strong>搜索类</strong>场景</p><p>比如说人员检索、设备检索、App内的搜索、订单搜索。</p></li><li><p><strong>日志分析</strong>类场景</p><p>经典的ELK组合（<strong>Elasticsearch</strong>/<strong>Logstash</strong>/<strong>Kibana</strong>），实现<strong>日志收集</strong>，<strong>日志存储</strong>，<strong>日志分析</strong></p></li><li><p><strong>数据预警平台</strong>及数据分析场景</p><p>例如社区团购提示，当优惠的价格低于某个值时，自动触发通知消息，通知用户购买。</p><p>分析竞争对手商品销量Top10，供运营分析等等。</p></li><li><p><strong>商业BI(Business Intelligence)</strong>系统</p><p>比如社区周边，需要分析某一地区用户消费金额及商品类别，输出相应的报表数据，并预测该地区的热卖商品，通过区域和人群特征划分进行定向推荐。Elasticsearch执行数据分析和挖掘，Kibana做数据可视化。</p></li></ul><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p><strong>Lucene</strong></p><p>Java编写的信息搜索工具包（Jar包），Lucene只是一个框架，熟练运用Lucene非常复杂。</p><p><strong>Solr</strong></p><p>基于<strong>Lucene</strong>的HTTP接口查询服务器，是一个封装了很多Lucene细节搜索引擎系统</p><p><strong>Elasticsearch</strong></p><p>基于<strong>Lucene</strong>分布式海量数据近实时搜索引擎。采用的策略是将每一个字段都编入索引，使其可以被搜索。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>1）Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能</p><p>2）Solr比Elasticsearch实现更加全面，而Elasticsearch本身更注重于核心功能， 高级功能多由第三方插件提供</p><p>3）Solr在传统的搜索应用中表现好于Elasticsearch，而Elasticsearch在实时搜索应用方面比Solr表现好</p><p>目前主流依然是<strong>Elasticsearch</strong>7.x 最新的是7.8</p><p>​    优化：<strong>默认集成JDK</strong>、升级Lucene8大幅提升<strong>TopK性能</strong>、引入熔断机制<strong>避免OOM</strong>发生</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p><p>IK分词器3.0的特性如下：</p><ol><li>采用了特有的“正向迭代<strong>最细粒度</strong>切分算法“，具有<strong>60万</strong>字/秒的高速处理能力。</li><li>采用了<strong>多子处理器</strong>分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。</li><li>支持<strong>个人词条的优化</strong>的词典存储，更小的内存占用。</li><li>针对Lucene<strong>全文检索优化</strong>的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索</li><li>排列组合，能极大的提高Lucene检索的命中率。</li></ol><ul><li><strong>扩展词典</strong>：ext_dict</li><li><strong>停用词典</strong>：stop_dict</li><li><strong>同义词典</strong>：same_dict</li></ul><h3 id="索引（类数据库）"><a href="#索引（类数据库）" class="headerlink" title="索引（类数据库）"></a>索引（类数据库）</h3><p>settings：设置索引库，定义索引库的分片数副本数等</p><h3 id="映射（类表设计）"><a href="#映射（类表设计）" class="headerlink" title="映射（类表设计）"></a>映射（类表设计）</h3><ul><li>字段的数据类型</li><li>分词器类型</li><li>是否要进行存储或者创造索引</li></ul><h3 id="文档（数据）"><a href="#文档（数据）" class="headerlink" title="文档（数据）"></a>文档（数据）</h3><ul><li>全量更新用Put</li><li>局部更新用Post</li></ul><h2 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h2><h3 id="映射高级"><a href="#映射高级" class="headerlink" title="映射高级"></a>映射高级</h3><h4 id="地理坐标点数据类型"><a href="#地理坐标点数据类型" class="headerlink" title="地理坐标点数据类型"></a><strong>地理坐标点数据类型</strong></h4><blockquote><p>地理坐标点是指地球表面可以用经纬度描述的一个点。 地理坐标点可以用来计算两个坐标间的距离，还可以判断一个坐标是否在一个区域中。地理坐标点需要显式声明对应字段类型为 geo_point</p></blockquote><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><blockquote><p>使用dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射</p></blockquote><h3 id="DSL高级"><a href="#DSL高级" class="headerlink" title="DSL高级"></a>DSL高级</h3><ul><li><strong>查询所有(match_all query)</strong></li><li><p><strong>全文搜索(full-text query)</strong></p><ul><li>匹配搜索(match query)</li><li>短语搜索(match phrase query)</li><li>默认查询(query string)</li><li>多字段匹配搜索(multi match query)</li></ul></li><li><p><strong>词条级搜索(term-level query)</strong></p><ul><li>精确搜索term</li><li>集合搜索idx</li><li>范围搜索range</li><li>前缀搜索prefix</li><li>通配符搜索wildcard</li><li>正则搜索regexp</li><li>模糊搜索fuzzy</li></ul></li><li><p>复合搜索</p></li><li>排序<strong>sort</strong>&amp;分页<strong>size</strong>&amp;高亮<strong>highLight</strong>&amp;批量<strong>bluk</strong></li></ul><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a><strong>聚合分析</strong></h3><blockquote><p>聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出某字段（或计算表达式的结果）的最大值、最小值，计算和、平均值等</p></blockquote><ul><li>对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为<strong>指标聚合</strong> <strong>metric</strong></li><li>对查询出的数据进行<strong>分桶</strong>group by，再在<strong>桶</strong>上进行指标<strong>桶聚合</strong> <strong>bucketing</strong></li></ul><h3 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a><strong>智能搜索</strong></h3><ul><li>Term Suggester</li><li>Phrase Suggester</li><li>Completion Suggester</li><li>Context Suggester</li></ul><p>如果<strong>Completion Suggester</strong>已经到了零匹配，可以猜测用户有输入错误，这时候可以尝试一下<strong>Phrase Suggester</strong>。如果还是未匹配则尝试<strong>Term Suggester</strong>。</p><p>精准程度上(<strong>Precision</strong>)看： <strong>Completion &gt; Phrase &gt; Term</strong>， 而召回率上(Recall)则反之。</p><p>从性能上看，Completion Suggester是最快的，如果能满足业务需求，只用Completion Suggester做前缀匹配是最理想的。 Phrase和Term由于是做倒排索引的搜索，相比较而言性能应该要低不少，应尽量控制Suggester用到的索引的数据量，最理想的状况是经过一定时间预热后，索引可以全量map到内存。</p><h2 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h2><h3 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h3><ul><li><p><strong>副本数量</strong>0</p><p>首次 初始化数据时，将副本设置为0，写入完毕再改回，避免了副本建立索引的过程</p></li><li><p><strong>自动生成id</strong></p><p>可以避免写前判断是否存在的过程</p></li><li><p><strong>合理使用分词器</strong></p><p>binary类型不适用，title和text使用不同的分词器加快速度</p></li><li><p><strong>禁用评分，延长索引刷新间隔</strong></p></li><li><p><strong>将多个索引操作放入到batch进行处理</strong></p></li></ul><h3 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h3><ul><li><p>使用<strong>Filter</strong>代替Query，减少打分缓解，使用<strong>bool</strong>组合query和filter查询</p></li><li><p>对数据进行<strong>分组</strong>，按照日，月，年不同维度分组，查询可集中在局部index中</p></li></ul><h3 id="零停机索引重建方案"><a href="#零停机索引重建方案" class="headerlink" title="零停机索引重建方案"></a>零停机索引重建方案</h3><ul><li><p><strong>外部数据导入</strong></p><ul><li>通过MQ的web控制台或cli命令行，发送指定的MQ消息</li><li>MQ消息被微服务模块的消费者消费，触发ES数据重新导入功能</li><li>微服务模块从数据库里查询数据的总数及分页信息，并发送至MQ</li><li>微服务从MQ中根据分页信息从数据库获取到数据后，根据索引结构的定义，将数据组装成ES支持的JSON格式，并通过bulk命令将数据发送给Elasticsearch集群进行索引的重建工作。</li></ul></li><li><p><strong>基于Scroll+bulk+索引别名的方案</strong></p><ul><li><p>新建索引book_new，将mapping信息，settings信息等按新的要求全部定义好</p></li><li><p>使用scroll api将数据批量查询出来，指定scroll查询持续时间</p></li><li><p>采用bulk api将scoll查出来的一批数据，批量写入新索引</p></li><li><p>查询一批导入一批，注意每次都使用上次结束时的scoll_id</p></li><li><p>切换别名book_alias到新的索引book_new上面，此时Java客户端仍然使用别名访问，也不需要修</p><p>改任何代码，不需要停机。验证别名查询的是否为新索引的数据</p></li></ul></li><li><p><strong>Reindex API方案</strong></p><ul><li>Elasticsearch v6.3.1已经支持Reindex API，它对scroll、bulk做了一层封装，能够 对文档重建索引而不需要任何插件或外部工具。</li></ul></li></ul><p><strong>参与度</strong> &amp; <strong>灵活性</strong>：自研 &gt; scroll+bulk &gt; reindex</p><p><strong>稳定性</strong> &amp; <strong>可靠性</strong>：自研 &lt; scroll+bulk &lt; reindex</p><h3 id="DeepPaging性能解决方案"><a href="#DeepPaging性能解决方案" class="headerlink" title="DeepPaging性能解决方案"></a>DeepPaging性能解决方案</h3><blockquote><p>比如超级管理员，要给某个省份用户发送公告或者广告，最容易想到的就是利用 from + size 来实现，但这是不现实的</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gne4vx9hu4j30x60gw0w5.jpg" alt="image-20210206212712493" style="zoom:60%;"></p><h1 id="二：Docker-amp-K8S篇"><a href="#二：Docker-amp-K8S篇" class="headerlink" title="二：Docker&amp;K8S篇"></a>二：Docker&amp;K8S篇</h1><blockquote><p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p></blockquote><p><strong>虚拟化技术_VMware 、VirtualBox、KVM</strong></p><p>虚拟化技术就是在操作系统上多加了一个虚拟化层（Hypervisor），可以将物理机的CPU、内存、硬盘、网络等资源进行虚拟化，再通过虚拟化出来的空间上安装操作系统，构建虚拟的应用程序执行环境。这就是我们通常说的虚拟机。</p><p>虚拟机的优点：</p><ul><li>提升IT效率、降低运维成本</li><li>更快地部署工作负责</li><li>提高服务器可用性</li></ul><p>虚拟机的缺点：</p><ul><li>占用资源较多、性能较差</li><li>扩展、迁移能力较差</li></ul><h3 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker"></a>Why Docker</h3><p><strong>场景</strong></p><ul><li>开发人员在本地编写代码，并使用Docker容器与其他同事共享劳动成果。</li><li>使用Docker将应用程序推送到测试环境中，并执行自动和手动测试。</li><li>开发人员可以在开发环境中对其进行修复，然后将其重新部署到测试环境中以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境就像将更新的镜像推送到生产环境一样简单。</li></ul><p><strong>需求</strong></p><blockquote><p>快速，一致地交付应用程序、镜像打包环境，避免了环境不一致的问题，简化开发的生命周期，适合于快速迭代敏捷开发的场景</p></blockquote><p><img src="https://i.loli.net/2021/02/20/7hx2RcvUPKgXpma.png" alt="image-20210220140837929" style="zoom: 50%;"></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Docker引擎-守护进程</strong></p><p>​    Docker使用C / S架构 ：用户通过<strong>Docker客户端</strong>与Docker守护进程（Docker引擎）通过Unix套接字或者RESTAPI进行通信，<strong>Docker引擎</strong>完成了构建，运行和分发Docker容器的繁重工作</p><p><strong>Docker镜像-Dockerfile</strong></p><p>​    Docker镜像类似于虚拟机镜像，是一个只读的模板，是创建Docker容器的基础</p><p>​    镜像是基于联合（Union）文件系统的一种层式的结构，由一系列指令一步一步构建出来。</p><p>​    比如：拷贝文件、执行命令</p><p><strong>Docker仓库-Hub</strong></p><p>Docker仓库可以分为<strong>公开仓库 （Public）</strong>和<strong>私有仓库（Private）</strong>两种形式。</p><p>最大的公开仓库是官方提供的<strong>Docker Hub</strong>，其中存放了数量庞大的镜像供用户下载。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7.30</span></span><br><span class="line"><span class="number">5.7</span>.<span class="number">30</span>: Pulling <span class="keyword">from</span> library/mysql ……</span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag mysql:5.7.30 mysql5</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">mysql5 latest <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker inspect mysql:5.7.30</span></span><br><span class="line">[&#123;显示docker 详细信息&#125;]</span><br><span class="line">[root@localhost ~]<span class="comment"># docker search mysql</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi mysql:5.7.30</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker push mysql[:TAG]</span></span><br></pre></td></tr></table></figure><p><strong>容器</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker create -it nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start 9cfcce23593a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看运行的容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line"><span class="comment">#查看所有容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line"><span class="comment">#新建并启动容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -it --rm --network host tomcat:8.5.56-jdk8-openjdk</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li><p>创建一个卷，待后边使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span> create test_volume</span><br></pre></td></tr></table></figure></li><li><p>分别启动2个容器挂在上卷,</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在<span class="number">2</span>个终端窗口启动<span class="number">2</span>个容器</span><br><span class="line">docker <span class="keyword">run</span> -it --rm -v test_volume:/test nginx:latest /bin/bash</span><br><span class="line">docker <span class="keyword">run</span> -it --rm -v test_volume:/test nginx:latest /bin/bash</span><br><span class="line">cd /test;</span><br><span class="line">touch a.txt</span><br><span class="line">ls /test <span class="comment"># 在两个容器中我们均可以看到我们创建的文件，shixian在多个容器之间实现数据共享</span></span><br></pre></td></tr></table></figure></li></ol><p>挂载在容器 /test 目录内创建。 Docker <strong>不支持容器内安装点的相对路径</strong>。 多个容器可以在同一时间段内使用相同的卷。如果两个容器需要访问共享数据，例如，如果一个容器写入而另一个容器读取数据。 卷名 在驱动程序test必须唯一。这意味着不能将<strong>相同的卷名</strong>与两个不同的驱动程序一起使用。 如果我们指定了当前test_volume程序上已在使用的卷名，则Docker会假定我们要重用现有卷，并且不会返回错误。如果开始无 test_volume 则会创建这个卷当然除了使用卷，也可以使用将宿主机的文件映射到容器的卷，命令类似，只不过不用提前创建卷，而且数据会映射到宿主机上注意如果宿主机上的目录可以不存在，会在启动容器的时候创建</p><h1 id="三、Netty篇"><a href="#三、Netty篇" class="headerlink" title="三、Netty篇"></a>三、Netty篇</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijej9w7j30p00doaim.jpg" alt="image-20210504171606057" style="zoom:50%;"></p><p>​</p><p>​    <strong>Core 核心层</strong><br>​    Core 核心层是 Netty 最精华的内容，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的 ByteBuf 等。</p><p>​    <strong>Protocol Support 协议支持层</strong><br>​    协议支持层基本上覆盖了主流协议的编解码实现，如 HTTP、Protobuf、WebSocket、二进制等主流协议，此外 Netty 还支持自定义应用层协议。Netty 丰富的协议支持降低了用户的开发成本，基于 Netty 我们可以快速开发 HTTP、WebSocket 等服务。</p><p>​    <strong>Transport Service 传输服务层</strong><br>​    传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道、虚拟机管道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。</p><h4 id="2、逻辑架构"><a href="#2、逻辑架构" class="headerlink" title="2、逻辑架构"></a>2、逻辑架构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iiju6h8j30ry0o6dj0.jpg" alt="image-20210504171514089" style="zoom:50%;"></p><p>​        </p><p>​    <strong>网络通信层</strong><br>​    网络通信层的职责是执行网络 I/O 的操作。它支持多种网络协议和 I/O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。</p><p>网络通信层的核心组件包含<strong>BootStrap、ServerBootStrap、Channel</strong>三个组件。</p><p>​    Bootstrap 是“引导”的意思，负责 Netty <strong>客户端程序</strong>的启动、初始化、服务器连接等过程，串联了 Netty 的其他核心组件。</p><p>​    ServerBootStrap 用于<strong>服务端启动</strong>绑定本地端口，会绑定Boss 和 Worker两个 EventLoopGroup。</p><p>​    Channel 的是“<strong>通道</strong>”，Netty Channel提供了基于NIO更高层次的抽象，如 register、bind、connect、read、write、flush 等。</p><p>​</p><p>​    <strong>事件调度层</strong><br>​    事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件（ I/O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。</p><p>事件调度层的核心组件包括 <strong>EventLoopGroup、EventLoop</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijuqesxj30ke0ekgpj.jpg" alt="image-20210504171631793" style="zoom:50%;"></p><p>​                        </p><p>​    <strong>EventLoop</strong> 负责处理 Channel 生命周期内的所有 I/O 事件，如 accept、connect、read、write 等 I/O 事件</p><p>​        ①一个 EventLoopGroup 往往包含<strong>一个或者多个</strong> EventLoop。</p><p>​        ②EventLoop 同一时间会与一个Channel绑定，每个 EventLoop 负责<strong>处理一种类型 Channel</strong>。</p><p>​        ③Channel 在生命周期内可以对和多个 EventLoop 进行<strong>多次绑定和解绑</strong>。        </p><p>​    <strong>EventLoopGroup</strong> 是Netty 的<strong>核心处理引擎</strong>，本质是一个线程池，主要负责接收 I/O 请求，并分配线程执行处理请求。通过创建不同的 EventLoopGroup 参数配置，就可以支持 Reactor 的三种线程模型：</p><p>​        <strong>单线程模型</strong>：EventLoopGroup 只包含一个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>主从多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 是主 Reactor，Worker 是从 Reactor，它们分别使用不同的 EventLoopGroup，主 Reactor 负责新的网络连接 Channel 创建，然后把 Channel 注册到从 Reactor。</p><p>​    <strong>服务编排层</strong><br>​    服务编排层的职责是负责组装各类服务，它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p><p>服务编排层的核心组件包括 <strong>ChannelPipeline、ChannelHandler、ChannelHandlerContext</strong>。</p><p>​    <strong>ChannelPipeline</strong> 是 Netty 的核心编排组件，负责组装各种 ChannelHandler，ChannelPipeline 内部通过双向链表将不同的 ChannelHandler 链接在一起。当 I/O 读写事件触发时，Pipeline 会依次调用 Handler 列表对 Channel 的数据进行拦截和处理。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6il759apj313s068abj.jpg" alt="image-20210504171749533" style="zoom:50%;"></p><p>​</p><p>​    客户端和服务端都有各自的 ChannelPipeline。客户端和服务端一次完整的请求：客户端出站（Encoder 请求数据）、服务端入站（Decoder接收数据并执行业务逻辑）、服务端出站（Encoder响应结果）。</p><p>​    <strong>ChannelHandler</strong> 完成数据的编解码以及处理工作。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ilvuhupj30ye08e0vd.jpg" alt="image-20210504171829071" style="zoom:50%;"></p><p>​    <strong>ChannelHandlerContext</strong> 用于保存Handler 上下文，通过 HandlerContext 我们可以知道 Pipeline 和 Handler 的关联关系。HandlerContext 可以实现 Handler 之间的交互，HandlerContext 包含了 Handler 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。同时，HandlerContext 实现了Handler通用的逻辑的模型抽象。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6imu2khlj31080gu0xc.jpg" alt="image-20210504171924019" style="zoom:50%;"></p><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><h4 id="1、五种IO模型的区别"><a href="#1、五种IO模型的区别" class="headerlink" title="1、五种IO模型的区别"></a><strong>1、五种IO模型的区别</strong></h4><p><strong>阻塞I/O：（BIO）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ingki0yj30kw0d6gmr.jpg" alt="image-20210504171959821" style="zoom:50%;"></p><p>​</p><p>​        应用进程向内核发起 I/O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I/O 请求称为BIO（Blocking IO，阻塞 I/O），所以 BIO 在实现异步操作时，只能使用多线程模型，一个请求对应一个线程。但是，<strong>线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。</strong></p><p><strong>同步非阻塞I/O（NIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6inzsk9xj30lg0cign1.jpg" alt="image-20210504172029418" style="zoom:50%;"></p><p>​        </p><p>​        应用进程向内核发起 I/O 请求后不再会同步等待结果，而是会立即返回，通过轮询的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I/O 时效率并不高，而且<strong>随着并发量的提升，非阻塞 I/O 会存在严重的性能浪费。</strong></p><p><strong>多路复用I/O（select和poll）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iogl9x0j30ja0cqdh7.jpg" alt="image-20210504172057237" style="zoom:50%;"></p><p>​        </p><p>​        多路复用实现了<strong>一个线程处理多个 I/O 句柄的操作</strong>。多路指的是多个数据通道，复用指的是使用一个或多个固定线程来处理每一个 Socket。select、poll、epoll 都是 I/O 多路复用的具体实现，线程一次 select 调用可以获取内核态中多个数据通道的数据状态。其中，select只负责等，recvfrom只负责拷贝，阻塞IO中可以对多个文件描述符进行阻塞监听，是一种非常高效的 I/O 模型。</p><p><strong>信号驱动I/O（SIGIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ioxthajj30ii0cemyk.jpg" alt="image-20210504172124965" style="zoom:50%;"></p><p>​        </p><p>​        信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p><p><strong>异步I/O（Posix.1的aio_系列函数）：</strong></p><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipcc12jj30lg0coabe.jpg" alt="image-20210504172148095" style="zoom:50%;"></p><p>​        当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。</p><h4 id="2、Reactor多线程模型"><a href="#2、Reactor多线程模型" class="headerlink" title="2、Reactor多线程模型"></a>2、Reactor多线程模型</h4><p>​        Netty 的 I/O 模型是基于<strong>非阻塞 I/O</strong> 实现的，底层依赖的是 NIO 框架的<strong>多路复用器 Selector</strong>。采用 <strong>epoll 模式</strong>后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个<strong>事件分发器</strong>（Event Dispather），它负责将读写事件分发给对应的读写<strong>事件处理器</strong>（Event Handler）。事件分发器有两种设计模式：<strong>Reactor 和 Proactor</strong>，Reactor 采用同步 I/O， Proactor 采用异步 I/O。</p><p>​</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipob6wjj30we0i4jz2.jpg" alt="image-20210504172207142" style="zoom:50%;"></p><p>​        Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I/O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 <strong>select 或 epoll</strong> 来实现。</p><h4 id="3、拆包粘包问题"><a href="#3、拆包粘包问题" class="headerlink" title="3、拆包粘包问题"></a>3、拆包粘包问题</h4><p><strong>拆包</strong>TCP 传输协议是面向流的，没有数据包界限。<br><strong>MTU（Maxitum Transmission Unit）</strong> 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iq4xdjtj30q407egnk.jpg" alt="image-20210504172233844" style="zoom:50%;"></p><p>如上图所示，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是<strong>拆包现象</strong>。</p><p><strong>Nagle 算法</strong><br>Nagle 算法可以理解为批量发送，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。Netty 中为了使数据<strong>传输延迟最小化</strong>，就默认<strong>禁用了 Nagle 算法</strong>。</p><p><strong>拆包/粘包的解决方案</strong></p><p>在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。需要确定边界：</p><p><strong>消息长度固定</strong><br><strong>特定分隔符</strong><br><strong>消息长度 + 消息内容</strong>(Netty)</p><h4 id="4、自定义协议"><a href="#4、自定义协议" class="headerlink" title="4、自定义协议"></a>4、自定义协议</h4><p>Netty 常用编码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageToByteEncoder <span class="comment">//对象编码成字节流；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageEncoder <span class="comment">//一种消息类型编码成另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>Netty 常用解码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteToMessageDecoder/ReplayingDecoder <span class="comment">//将字节流解码为消息对象；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageDecoder <span class="comment">//将一种消息类型解码为另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>编解码器可以分为<strong>一次解码器</strong>和<strong>二次解码器</strong>，一次解码器用于解决 <strong>TCP 拆包/粘包问题</strong>，按协议解析后得到的字节数据。如果你需要对解析后的<strong>字节数据做对象模型</strong>的转换，这时候便需要用到二次解码器，同理编码器的过程是反过来的。</p><p><strong>Netty自定义协议内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | </span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">|                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>如何判断 ByteBuf 是否存在完整的报文？最常用的做法就是通过读取消息长度 dataLength 进行判断。如果 ByteBuf 的可读数据长度小于 dataLength，说明 ByteBuf 还不够获取一个完整的报文。</p><h4 id="5、WriteAndFlush"><a href="#5、WriteAndFlush" class="headerlink" title="5、WriteAndFlush"></a>5、WriteAndFlush</h4><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iqnas8fj31400lkaj2.jpg" alt="image-20210504172303465" style="zoom:50%;"></p><p>​    ①writeAndFlush 属于出站操作，它是从 Pipeline 的 Tail 节点开始进行事件传播，一直向前传播到 Head 节点。不管在 write 还是 flush 过程，Head 节点都中扮演着重要的角色。</p><p>​    ②write 方法并没有将数据写入 Socket 缓冲区，只是将数据写入到 ChannelOutboundBuffer 缓存中，ChannelOutboundBuffer 缓存内部是由单向链表实现的。</p><p>​    ③flush 方法才最终将数据写入到 Socket 缓冲区。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1、堆外内存"><a href="#1、堆外内存" class="headerlink" title="1、堆外内存"></a>1、堆外内存</h4><p>​    在 Java 中对象都是在堆内分配的，通常我们说的<strong>JVM 内存</strong>也就指的<strong>堆内内存</strong>，<strong>堆内内存</strong>完全被<strong>JVM 虚拟机</strong>所管理，JVM 有自己的垃圾回收算法，对于使用者来说不必关心对象的内存如何回收。<strong>堆外内存</strong>与堆内内存相对应，对于整个机器内存而言，除<strong>堆内内存以外部分即为堆外内存</strong>。堆外内存不受 JVM 虚拟机管理，直接由操作系统管理。使用堆外内存有如下几个优点：</p><ol><li>堆内内存由 JVM GC 自动回收内存，降低了 Java 用户的使用心智，堆外内存由于不受 JVM 管理，所以在一定程度上可以降低 GC 对应用运行时带来的影响。</li><li>堆外内存需要手动释放，这一点跟 C/C++ 很像，稍有不慎就会造成应用程序内存泄漏，当出现内存泄漏问题时排查起来会相对困难。</li><li>当进行网络 I/O 操作、文件读写时，堆内内存都需要转换为堆外内存，然后再与底层设备进行交互，所以直接使用堆外内存可以减少一次内存拷贝。</li><li>堆外内存可以方便实现进程之间、JVM 多实例之间的数据共享。</li></ol><p>​    在堆内存放的 DirectByteBuffer 对象并不大，仅仅包含堆外内存的地址、大小等属性，同时还会创建对应的 Cleaner 对象，通过 ByteBuffer 分配的堆外内存不需要手动回收，它可以被 JVM 自动回收。当堆内的 DirectByteBuffer 对象被 GC 回收时，Cleaner 就会用于回收对应的堆外内存。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    从 DirectByteBuffer 的构造函数中可以看出，真正分配堆外内存的逻辑还是通过 unsafe.allocateMemory(size)，Unsafe 是一个非常不安全的类，它用于执行内存访问、分配、修改等<strong>敏感操作</strong>，可以越过 JVM 限制的枷锁。Unsafe 最初并不是为开发者设计的，使用它时虽然可以获取对底层资源的控制权，但也失去了安全性的保证，使用 Unsafe 一定要慎重（Java 中是不能直接使用 Unsafe 的，但是可以通过反射获取 Unsafe 实例）。Netty 中依赖了 Unsafe 工具类，是因为 Netty 需要与底层 Socket 进行交互，Unsafe 提升 Netty 的性能</p><p>​     因为DirectByteBuffer 对象的回收需要依赖 Old GC 或者 Full GC 才能触发清理，如果长时间没有 GC执行，那么堆外内存即使不再使用，也会一直在占用内存不释放，很容易将机器的物理内存耗尽。-XX:MaxDirectMemorySize 指定堆外内存的上限大小，超出时触发GC，仍无法释放抛出OOM异常。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    当初始化堆外内存时，内存中的对象引用情况如下图所示，first 是 Cleaner 类中的静态变量，Cleaner 对象在初始化时会加入 Cleaner 链表中。DirectByteBuffer 对象包含堆外内存的地址、大小以及 Cleaner 对象的引用，ReferenceQueue 用于保存需要回收的 Cleaner 对象。</p><p>​</p><h4 id="2、数据载体ByteBuf"><a href="#2、数据载体ByteBuf" class="headerlink" title="2、数据载体ByteBuf"></a>2、<strong>数据载体ByteBuf</strong></h4><p>JDK NIO 的 <strong>ByteBuffer</strong></p><ul><li>mark：为某个读取过的关键位置做标记，方便回退到该位置；</li><li>position：当前读取的位置；</li><li>limit：buffer 中有效的数据长度大小；</li><li>capacity：初始化时的空间容量。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6irlptv0j30z408wabn.jpg" alt="image-20210504172358702" style="zoom:50%;"></p><p>​    第一，ByteBuffer 分配的长度是固定的，无法动态扩缩容，每次在存放数据的时候对容量大小做校验，扩容需要将已有的数据迁移。</p><p>​    第二，ByteBuffer 只能通过 position 获取当前可操作的位置，因为读写共用的 position 指针，所以需要频繁调用 flip、rewind 方法切换读写状态。</p><p>Netty中的ByteBuf</p><ul><li><strong>废弃字节</strong>，表示已经丢弃的无效字节数据。</li><li><strong>可读字节</strong>，表示 ByteBuf 中可以被读取的字节内容，可以通过 writeIndex - readerIndex 计算得出。当读写位置重叠时时，表示 ByteBuf 已经不可读。</li><li><strong>可写字节</strong>，向 ByteBuf 中写入数据都会存储到可写字节区域。当 writeIndex 超过 capacity，表示 ByteBuf 容量不足，需要扩容。</li><li><strong>可扩容字节</strong>，表示 ByteBuf 最多还可以扩容多少字节，最多扩容到 maxCapacity 为止，超过 maxCapacity 再写入就会出错。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j1t85zuj31020ds42m.jpg" alt="image-20210504173347000" style="zoom:50%;"></p><p><strong>引用计数</strong></p><p>​    当byteBuf当引用计数为 0，该 ByteBuf 可以被放入到对象池中，避免每次使用 ByteBuf 都重复创建。</p><p>​    JVM 并不知道 Netty 的引用计数是如何实现的，当 ByteBuf 对象不可达时，一样会被 GC 回收掉，但是如果此时 ByteBuf 的引用计数不为 0，那么该对象就不会释放或者被放入对象池，从而发生了内存泄漏。Netty 会对分配的 ByteBuf 进行抽样分析，检测 ByteBuf 是否已经不可达且引用计数大于 0，判定内存泄漏的位置并输出到日志中，<strong>通过关注日志中 LEAK 关键字可以找到内存泄漏的具体对象</strong>。</p><h4 id="3、内存分配jemalloc"><a href="#3、内存分配jemalloc" class="headerlink" title="3、内存分配jemalloc"></a>3、<strong>内存分配jemalloc</strong></h4><p>​    为了减少分配时产生的内部碎片和外部碎片，常见的内存分配算法<strong>动态内存分配</strong>、<strong>伙伴算法</strong>和<strong>Slab 算法</strong></p><p><strong>动态内存分配（DMA）</strong></p><p>​    <strong>⾸次适应算法（first fit）</strong>，空闲分区链以地址递增的顺序将空闲分区以双向链表的形式连接在一起，从空闲分区链中找到第一个满足分配条件的空闲分区，然后从空闲分区中划分出一块可用内存给请求进程，剩余的空闲分区仍然保留在空闲分区链中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j26fh88j30ni0ea41c.jpg" alt="image-20210504173407923" style="zoom:50%;"></p><p>​    <strong>循环首次适应算法（next fit）</strong>不再是每次从链表的开始进行查找，而是从上次找到的空闲分区的以后开始查找。查找效率提升，会产生更多的碎片。</p><p>​    <strong>最佳适应算法（best fit）</strong>，空闲分区链以空闲分区大小递增的顺序将空闲分区以双向链表的形式连接在一起，每次从空闲分区链的开头进行查找。</p><p><strong>伙伴算法</strong>（外部碎片少，内部碎片多）</p><p>​    是一种非常经典的内存分配算法，它采用了<strong>分离适配的设计思想</strong>，将物理内存按照 2 的次幂进行划分，内存分配时也是按照 2 的次幂大小进行按需分配</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j2m0rr1j30ly0iugnk.jpg" alt="image-20210504173433749" style="zoom:50%;"></p><ol><li>首先需要找到存储 2^4 连续 Page 所对应的链表，即数组下标为 4；</li><li>查找 2^4 链表中是否有空闲的内存块，如果有则分配成功；</li><li>如果 2^4 链表不存在空闲的内存块，则继续沿数组向上查找，即定位到数组下标为 5 的链表，链表中每个节点存储 2^5 的连续 Page；</li><li>如果 2^5 链表中存在空闲的内存块，则取出该内存块并将它分割为 2 个 2^4 大小的内存块，其中一块分配给进程使用，剩余的一块链接到 2^4 链表中。</li></ol><p><strong>Slab 算法（解决伙伴算法内部碎片问题）</strong></p><p>​    Slab 算法在伙伴算法的基础上，对小内存的场景专门做了优化，采用了内存池的方案，解决内部碎片问题。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p>在 Slab 算法中维护着大小不同的 Slab 集合，将这块内存划分为大小相同的 slot，不会对内存块再进行合并，同时使用位图 bitmap 记录每个 slot 的使用情况。</p><p>​    kmem_cache 中包含三个 Slab 链表：<strong>完全分配使用 slab_full</strong>、<strong>部分分配使用 slab_partial</strong>和<strong>完全空闲 slabs_empty</strong>，这三个链表负责内存的分配和释放。Slab 算法是基于对象进行内存管理的，它把相同类型的对象分为一类。当分配内存时，从 Slab 链表中划分相应的内存单元；单个 Slab 可以在不同的链表之间移动，例如当一个 Slab 被分配完，就会从 slab_partial 移动到 slabs_full，当一个 Slab 中有对象被释放后，就会从 slab_full 再次回到 slab_partial，所有对象都被释放完的话，就会从 slab_partial 移动到 slab_empty。当<strong>释放内存时，Slab 算法并不会丢弃已经分配的对象，而是将它保存在缓存中，当下次再为对象分配内存时，直接会使用最近释放的内存块</strong>。</p><h4 id="4、jemalloc-架构"><a href="#4、jemalloc-架构" class="headerlink" title="4、jemalloc 架构"></a>4、jemalloc 架构</h4><ul><li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li><li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li><li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li><li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li><li>每个 tcache 对应一个 arena，tcache 中包含多种类型的 bin。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p><strong>内存管理Arena</strong> ，内存由一定数量的 arenas 负责管理。每个用户线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配。</p><p><strong>分级管理Bin</strong>，每个 bin 管理的内存大小是按分类依次递增。<strong>jemalloc 中小内存的分配是基于 Slab 算法</strong>完成的，会产生不同类别的内存块。</p><p><strong>Page集合chunk</strong>，chunk 以 Page 为单位管理内存。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</p><p><strong>实际分配单位run</strong>，run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</p><p><strong>run 细分region</strong>，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</p><p><strong>tcache 是每个线程私有的缓存</strong>，tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，避免锁竞争，分配失败才会通过 run 执行内存分配。</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u1jn9b3j31e80hqjt5.jpg" alt="image-20211205121406792" title class>                <p>image-20211205121406792</p>            </figure><p>Small 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p><p>Large 场景的内存分配与 Smalll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p><p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p><h4 id="5、内存池设计（待补充）"><a href="#5、内存池设计（待补充）" class="headerlink" title="5、内存池设计（待补充）"></a>5、内存池设计（待补充）</h4><h4 id="6、Recycle对象池（待补充）"><a href="#6、Recycle对象池（待补充）" class="headerlink" title="6、Recycle对象池（待补充）"></a>6、Recycle对象池（待补充）</h4><h4 id="7、零拷贝技术"><a href="#7、零拷贝技术" class="headerlink" title="7、零拷贝技术"></a>7、零拷贝技术</h4><ol><li>当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA 引擎从文件中读取数据，并存储到内核态缓冲区，这里是<strong>第一次数据拷贝</strong>。</li><li>请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。<strong>第二次数据拷贝</strong>的过程同时，会导致上下文从内核态再次切换到用户态。</li><li>用户进程调用 send() 方法期望将数据发送到网络中，用户态会再次切换到内核态，<strong>第三次数据拷贝</strong>请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区。</li><li>最终 send() 系统调用结束返回给用户进程，发生了第四次上下文切换。<strong>第四次拷贝会异步执行</strong>，从 Socket 缓冲区拷贝到协议引擎中。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jlghxe0j30t00fsjtw.jpg" alt="image-20210504175240348" style="zoom:50%;"></p><p>​    <strong>在 Linux 中</strong>系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术。</p><p>​    <strong>在 Java 中</strong>也使用了零拷贝技术，它就是 NIO FileChannel 类中的 transferTo() 方法，它可以将数据从 FileChannel 直接传输到另外一个 Channel。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jm8q3yej311c0h6q7v.jpg" alt="image-20210504175323875" style="zoom:50%;"></p><p><strong>Netty 中的零拷贝</strong>技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li>堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝。</li></ul><h3 id="高性能数据结构"><a href="#高性能数据结构" class="headerlink" title="高性能数据结构"></a>高性能数据结构</h3><h4 id="1、FastThreadLocal"><a href="#1、FastThreadLocal" class="headerlink" title="1、FastThreadLocal"></a>1、FastThreadLocal</h4><p>​    ThreadLocal 可以理解为线程本地变量。ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。</p><p>​    既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本，那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map，记录线程与实例之间的映射关系。当新增线程和销毁线程时都需要更新 Map 中的映射关系，因为会存在多线程并发修改，所以需要保证 Map 是线程安全的。但是在高并发的场景并发修改 Map 需要加锁，势必会降低性能。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmqtl1hj30q60dmtck.jpg" alt="image-20210504175349901" style="zoom:50%;"></p><p>​    JDK 为了避免加锁，采用了相反的设计思路。以 Thread 入手，在 Thread 中维护一个 Map，记录 ThreadLocal 与实例之间的映射关系，这样在同一个线程内，Map 就不需要加锁了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmyxnylj30ns06adgu.jpg" alt="image-20210504175406824" style="zoom:50%;"></p><p>​    ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据，通过魔数0x61c88647来使散列更加平衡。ThreadLocalMap 初始化一个长度为 16 的 Entry 数组。与 HashMap 不同的是，Entry 的 key 就是 ThreadLocal对象本身，value 就是用户具体需要存储的值。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jncecy1j30yy0eejtq.jpg" alt="image-20210504175428964" style="zoom:50%;"></p><p>​    Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。那么为什么 Entry 的 key 要设计成弱引用呢？如果 key 都是强引用，当线 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4umi0759j30hi0a03zd.jpg" alt="img" style="zoom: 67%;"></p><p>​    虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal不再使用(<strong>业务逻辑走完，但是由于线程复用导致线程并没有结束</strong>)被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？ThreadLocal 已经帮助我们做了一定的保护措施，在执行 ThreadLocal.set()/get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，应在 finally 代码块中进行清理，保持良好的编码意识。在Netty中，可以方便的使用FashThreadLocal来防止内存泄漏</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4ux5gohpj30hs0ajjs1.jpg" alt="img" style="zoom:67%;"></p><p><strong>FastThreadLocal</strong></p><p>​    FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal&lt;?&gt;&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。主要是针对set方法，增加了两个额外的行为。</p><ol><li>找到数组下标 index 位置，设置新的 value。</li><li>将 <strong>FastThreadLocal 对象保存到待清理的 Set 中</strong>。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jnu8l6aj315k060wfi.jpg" alt="image-20210504175457264" style="zoom:50%;"></p><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，<strong>任务执行完毕后一定会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉</strong></li></ul><h4 id="2、HashedTimerWheel"><a href="#2、HashedTimerWheel" class="headerlink" title="2、HashedTimerWheel"></a>2、<strong>HashedTimerWheel</strong></h4><p>​    生成月统计报表、每日得分结算、邮件定时推送</p><p>​    定时任务三种形式：</p><p>​        1、按固定周期定时执行</p><p>​        2、延迟一定时间后执行</p><p>​        3、指定某个时刻执行</p><p>​    定时任务的三个关键方法：</p><p>​        Schedule 新增任务至任务集合；</p><p>​        Cancel 取消某个任务；</p><p>​        Run 执行到期的任务</p><p>JDK自带的三种定时器：<strong>Timer</strong>、<strong>DelayedQueue</strong> 和 <strong>ScheduledThreadPoolExecutor</strong></p><pre><code>Timer小根堆队列，deadline 任务位于堆顶端，弹出的始终是最优先被执行的任务。Run 操作时间复杂度 O(1)，Schedule 和Cancel 操作的时间复杂度都是 O(logn)。</code></pre><p>不论有多少任务被加入数组，始终由 异步线程TimerThread 负责处理。TimerThread 会定时轮询 TaskQueue 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 TaskQueue 中删除。</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayedQueue 采用优先级队列 PriorityQueue延迟获取对象的阻塞队列。DelayQueue中的每个对象都必须实现Delayed 接口，并重写 compareTo 和 getDelay 方法。</span><br></pre></td></tr></table></figure><p>DelayQueue 提供了 put() 和 take() 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 DelayQueue 后，会根据 compareTo() 方法进行优先级排序。getDelay() 方法用于计算消息延迟的剩余时间，只有 getDelay &lt;=0 时，该对象才能从 DelayQueue 中取出。</p><p>DelayQueue 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 DelayQueue，通过一个异步线程 take() 取出对象然后继续进行重试。如果还是请求失败，继续放回 DelayQueue。可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。DelayQueue的时间复杂度和Timer基本一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了解决 Timer 的设计缺陷，JDK 提供了功能更加丰富的 ScheduledThreadPoolExecutor，多线程、相对时间、对异常</span><br></pre></td></tr></table></figure><p>​    Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</p><p>​    Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</p><p>​    TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</p><p><strong>时间轮原理分析</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jo7abpbj30wi0ciacs.jpg" alt="image-20210504175518335" style="zoom:50%;"></p><p>根据任务的到期时间进行取余和取模，然后根据取余结果将任务分布到不同的 slot 中，每个slot中根据round值决定是否操作，每次轮询到指定slot时，总时遍历最少round的对象进行执行，这样新增、执行两个操作的时间复杂度都近似O(1)。如果冲突较大可以增加数组长度，或者采用多级时间轮的方式处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory, //线程池，但是只创建了一个线程</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> tickDuration, //时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit, //表示 tickDuration 的时间单位，tickDuration * unit</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> ticksPerWheel,  //时间轮上一共有多少个 slot，默认 <span class="number">512</span> 个。</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;<span class="comment">//最大允许等待任务数</span></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel); <span class="comment">// 创建时间轮的环形数组结构</span></span><br><span class="line">    mask = wheel.length - <span class="number">1</span>; <span class="comment">// 用于快速取模的掩码</span></span><br><span class="line">    <span class="keyword">long</span> duration = unit.toNanos(tickDuration); <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker); <span class="comment">// 创建工作线程</span></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>; <span class="comment">// 是否开启内存泄漏检测</span></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts; <span class="comment">// 最大允许等待任务数，HashedWheelTimer 中任务超出该阈值时会抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jofq9r4j315i0fmq96.jpg" alt="image-20210504175531294" style="zoom:50%;"></p><p>​    <strong>时间轮空推进问题</strong></p><p>​    Netty 中的时间轮是通过固定的时间间隔 tickDuration 进行推动的，如果长时间没有到期任务，那么会存在时间轮空推进的现象，从而造成一定的性能损耗。此外，如果任务的到期时间跨度很大，例如 A 任务 1s 后执行，B 任务 6 小时之后执行，也会造成空推进的问题。</p><p><strong>Kafka解决方案</strong></p><p>​    <strong>为了解决空推进的问题</strong>，Kafka 借助 JDK 的 DelayQueue 来负责推进时间轮。DelayQueue 保存了时间轮中的每个 Bucket，并且根据 Bucket 的到期时间进行排序，最近的到期时间被放在 DelayQueue 的队头。Kafka 中会有一个线程来读取 DelayQueue 中的任务列表，<strong>如果时间没有到，那么 DelayQueue 会一直处于阻塞状态</strong>，从而解决空推进的问题。虽然DelayQueue 插入和删除的性能不是很好，但这其实就是一种权衡的策略，但是DelayQueue 只存放了 Bucket，Bucket 的数量并不多，相比空推进带来的影响是利大于弊的。</p><p>​    <strong>为了解决任务时间跨度很大的问题</strong>，Kafka 引入了层级时间轮，如下图所示。当任务的 deadline 超出当前所在层的时间轮表示范围时，就会尝试将任务添加到上一层时间轮中，跟钟表的时针、分针、秒针的转动规则是同一个道理。</p><h4 id="3、MpscQueue"><a href="#3、MpscQueue" class="headerlink" title="3、MpscQueue"></a>3、MpscQueue</h4><h4 id="4、select、poll、epoll的区别"><a href="#4、select、poll、epoll的区别" class="headerlink" title="4、select、poll、epoll的区别"></a>4、select、poll、epoll的区别</h4><p><strong>select</strong> （windows）<strong>poll </strong>(linux)本质上和select没有区别，查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</p><p><strong>epoll </strong>支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>Epoll空轮询漏洞</strong></p><p>在 JDK 中， Epoll 的实现是存在漏洞的，即使 Selector 轮询的事件列表为空，NIO 线程一样可以被唤醒，导致 CPU 100% 占用。实际上 Netty 并没有从根源上解决该问题，而是巧妙地规避了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/*事件轮询的持续时间大于等于 timeoutMillis*/</span>) &#123;</span><br><span class="line">    selectCnt = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*不正常的次数 selectCnt 达到阈值 512*/</span>) &#123;</span><br><span class="line">    <span class="comment">//重建Select并且SelectionKey重新注册到新Selector上</span></span><br><span class="line">  selector = selectRebuildSelector(selectCnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop 线程的可靠性至关重要，一旦 NioEventLoop 发生阻塞或者陷入空轮询，就会导致整个系统不可用。</p><h1 id="四、LEETCODE"><a href="#四、LEETCODE" class="headerlink" title="四、LEETCODE"></a>四、LEETCODE</h1><h3 id="【Python语法】"><a href="#【Python语法】" class="headerlink" title="【Python语法】"></a>【Python语法】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x * y,ns) <span class="comment"># 数组之乘积 (ns[0] * ns[1]) * ns[2]</span></span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x + y,ns) <span class="comment"># 数组之和</span></span><br><span class="line"><span class="comment"># 记忆化搜索</span></span><br><span class="line"><span class="meta">@functools.lru_cache(None)</span></span><br><span class="line">res = helper(<span class="number">0</span>,N,<span class="number">0</span>)</span><br><span class="line">helper.cache_clear()</span><br><span class="line">tuple(ns) 可以hash做参数</span><br><span class="line"><span class="comment"># 大根堆</span></span><br><span class="line">q = list(map(<span class="keyword">lambda</span> x:-x,ns))</span><br><span class="line">heapq.heapify(q)</span><br><span class="line">key = -heapq.heappop(q)</span><br><span class="line"><span class="comment"># 过滤函数</span></span><br><span class="line">filter(function, iterable)</span><br><span class="line">    filter(<span class="keyword">lambda</span> x: <span class="number">2</span> &lt; x &lt; <span class="number">10</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">18</span>))</span><br><span class="line">    filter(dfs, range(len(graph)))</span><br><span class="line"><span class="comment"># 除数</span></span><br><span class="line">div, mod = divmod(sum(ns), <span class="number">4</span>)</span><br><span class="line">random.randint(i,len(self.ns)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#第一个降序，第二个升序</span></span><br><span class="line">sorted(pss,key = <span class="keyword">lambda</span> x:[x[<span class="number">0</span>],-x[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变str 常见函数</span></span><br><span class="line">split(sep=<span class="literal">None</span>, maxsplit=<span class="number">-1</span>)  <span class="comment"># 以sep来分割字符串</span></span><br><span class="line">strip([chars])  <span class="comment"># 去除首末两端的字符, 默认是 \r,\n," "</span></span><br><span class="line">join(iterable)  <span class="comment"># 将iterable内的元素拼接成字符串,如','.join(['leet', 'code'])="leet,code"</span></span><br><span class="line">replace(old, new[, count])  <span class="comment"># 字符串替换, old to new</span></span><br><span class="line">count(sub[, start[, end]])  <span class="comment"># 统计子字符串sub的个数</span></span><br><span class="line">startswith(prefix[, start[, end]])  <span class="comment"># 以prefix开始的字符串</span></span><br><span class="line">endswith(suffix[, start[, end]])  <span class="comment"># 以suffix结束的字符串</span></span><br><span class="line">cs <span class="keyword">in</span> chrs: <span class="comment"># chrs 中包含 cs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deque 常见函数</span></span><br><span class="line">queue = deque([iterable[, maxlen]])</span><br><span class="line">queue.append(val)  <span class="comment"># 往右边添加一个元素</span></span><br><span class="line">queue.appendleft(val)  <span class="comment"># 往左边添加一个元素</span></span><br><span class="line">queue.clear()  <span class="comment"># 清空队列</span></span><br><span class="line">queue.count(val)  <span class="comment"># 返回指定元素的出现次数</span></span><br><span class="line">queue.insert(val[, start[, stop]])  <span class="comment"># 在指定位置插入元素</span></span><br><span class="line">queue.pop()  <span class="comment"># 获取最右边一个元素，并在队列中删除</span></span><br><span class="line">queue.popleft()  <span class="comment"># 获取最左边一个元素，并在队列中删除</span></span><br><span class="line">queue.reverse()  <span class="comment"># 队列反转</span></span><br><span class="line">queue.remove(val)  <span class="comment"># 删除指定元素</span></span><br><span class="line">queue.rotate(n=<span class="number">1</span>)  <span class="comment"># 把右边元素放到左边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 常见函数</span></span><br><span class="line">lst.sort(*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">lst.append(val)  <span class="comment"># 也可以 lst = lst + [val]</span></span><br><span class="line">lst.clear()  <span class="comment"># 清空列表</span></span><br><span class="line">lst.count(val)  <span class="comment"># val个数</span></span><br><span class="line">lst.pop(val=lst[<span class="number">-1</span>])  <span class="comment"># (默认)从末端移除一个值</span></span><br><span class="line">lst.remove(val)  <span class="comment"># 移除 val</span></span><br><span class="line">lst.reverse()  <span class="comment"># 反转</span></span><br><span class="line">lst.insert(i, val)  <span class="comment"># 在 i 处插入 val</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典dict 常见函数</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span> : value) <span class="comment"># 取到不存在的值时不会报错，用&#123;&#125;时、需要设置get的default值</span></span><br><span class="line">pop(key[, default])  <span class="comment"># 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))</span></span><br><span class="line">setdefault(key[, default])  <span class="comment"># 设置默认值</span></span><br><span class="line">update([other])  <span class="comment"># 批量添加</span></span><br><span class="line">get(key[, default])  <span class="comment"># 通过键获取值(若没有该键可设置默认值, 预防报错)</span></span><br><span class="line">clear()  <span class="comment"># 清空字典</span></span><br><span class="line">keys()  <span class="comment"># 将字典的键组成新的可迭代对象</span></span><br><span class="line">values()  <span class="comment"># 将字典中的值组成新的可迭代对象</span></span><br><span class="line">items()  <span class="comment"># 将字典的键值对凑成一个个元组, 组成新的可迭代对象</span></span><br><span class="line">dict1 = dict2 <span class="comment">#两个字典完全相等，滑窗时可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合set 常见函数</span></span><br><span class="line">s = set(<span class="keyword">lambda</span> : value)</span><br><span class="line">add(elem)  <span class="comment"># 向集合中添加数据</span></span><br><span class="line">update(*others)  <span class="comment"># 迭代着增加</span></span><br><span class="line">clear()  <span class="comment"># 清空集合</span></span><br><span class="line">discard(elem)  <span class="comment"># 删除集合中指定的值(不存在则不删除)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆heapq 常见函数</span></span><br><span class="line">heap = []  <span class="comment"># 建堆</span></span><br><span class="line">heapq.heappush(heap,item)  <span class="comment"># 往堆中插入新值</span></span><br><span class="line">heapq.heappop(heap)  <span class="comment"># 弹出最小的值</span></span><br><span class="line">heap[<span class="number">0</span>]  <span class="comment"># 查看堆中最小的值, 不弹出</span></span><br><span class="line">heapq.heapify(x)  <span class="comment"># 以线性时间将一个列表转为堆</span></span><br><span class="line">heapq.heappoppush(heap, item)  <span class="comment"># 弹出最小的值.并且将新的值插入其中.</span></span><br><span class="line">heapq.merge(*iterables, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  <span class="comment"># 将多个堆进行合并</span></span><br><span class="line">heapq.nlargest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</span></span><br><span class="line">heapq.nsmallest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最小的 n 个数, 与 nlargest 相反</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找函数</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=len(ns))  <span class="comment">#二分左边界</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=len(ns)) <span class="comment">#二分右边界</span></span><br><span class="line">bisect.insort_left(a, x, lo=<span class="number">0</span>, hi=len(a))  <span class="comment"># 二分插入到左侧</span></span><br><span class="line">bisect.insort_right(a, x, lo=<span class="number">0</span>, hi=len(a)) <span class="comment"># 二分插入到右侧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bit操作</span></span><br><span class="line">&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算</span><br><span class="line">| 符号，x | y ，会将两个十进制数在二进制下进行或运算</span><br><span class="line">^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算</span><br><span class="line">&lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 <span class="number">0</span> 填充</span><br><span class="line">&gt;&gt; 符号，x &gt;&gt; y 右移操作，最左边用 <span class="number">0</span> 填充</span><br><span class="line">~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数集合set位运算</span></span><br><span class="line"><span class="comment"># 整数集合做标志时，可以做参数加速运算</span></span><br><span class="line">vstd 访问 i ：vstd | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 离开 i ：vstd &amp; ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 不包含 i : <span class="keyword">not</span> vstd &amp; (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"></span><br><span class="line">并集 ：A | B</span><br><span class="line">交集 ：A &amp; B</span><br><span class="line">全集 ：(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">补集 ：((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ A</span><br><span class="line">子集 ：(A &amp; B) == B</span><br><span class="line">判断是否是 <span class="number">2</span> 的幂 ：A &amp; (A - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">最低位的 <span class="number">1</span> 变为 <span class="number">0</span> ：n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">最低位的 <span class="number">1</span>：A &amp; (-A)，最低位的 <span class="number">1</span> 一般记为 lowbit(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ^     ：匹配字符串开头</span></span><br><span class="line"><span class="comment"># [\+\-]：代表一个+字符或-字符</span></span><br><span class="line"><span class="comment"># ?     ：前面一个字符可有可无</span></span><br><span class="line"><span class="comment"># \d    ：一个数字</span></span><br><span class="line"><span class="comment"># +     ：前面一个字符的一个或多个</span></span><br><span class="line"><span class="comment"># \D    ：一个非数字字符</span></span><br><span class="line"><span class="comment"># *     ：前面一个字符的0个或多个</span></span><br><span class="line">matches = re.match(<span class="string">'[ ]*([+-]?\d+)'</span>, s)</span><br></pre></td></tr></table></figure><h3 id="【背包模板】"><a href="#【背包模板】" class="headerlink" title="【背包模板】"></a>【背包模板】</h3><p><strong>「力扣」上的 0-1 背包问题：</strong></p><ul><li><p>组合问题模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0-1背包，不可重复</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(T, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[i] = max(dp[i], dp[i - n] + ws[i])</span><br><span class="line"><span class="comment">#完全背包，可重复，无序，算重量</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, T+<span class="number">1</span>):</span><br><span class="line">        dp[i] = max(dp[i], dp[i - n] + ws[i])</span><br><span class="line"><span class="comment">#完全背包，可重复，有序，算次数     </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, T+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">dp[i] += dp[i-n]</span><br></pre></td></tr></table></figure><p><strong>✅377</strong> 组合总和 Ⅳ<br>✅<strong>494</strong> 目标和<br>✅<strong>518</strong> 零钱兑换 II</p></li><li><p>True、False问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] |= dp[i-num]</span><br></pre></td></tr></table></figure><p><strong>✅139</strong> 单词拆分<br><strong>✅416</strong> 分割等和子集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#特殊的可以使用bit数组</span></span><br></pre></td></tr></table></figure></li><li><p>最大最小问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i], dp[i-num]+<span class="number">1</span>)</span><br><span class="line">dp[i] = max(dp[i], dp[i-num]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>✅<strong>474</strong> 一和零<br>✅<strong>322</strong> 零钱兑换</p></li></ul><p>「力扣」第 <strong>879</strong> 题：盈利计划（困难）；<br>「力扣」第 <strong>1449</strong> 题：数位成本和为目标值的最大数字（困难）。</p><h3 id="【回溯模板】"><a href="#【回溯模板】" class="headerlink" title="【回溯模板】"></a>【回溯模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯算法，复杂度较高2^n或者N！，因为回溯算法就是暴力穷举，可用lru剪枝</span></span><br><span class="line"><span class="meta">@functools.lru_cache(None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        结果.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:    <span class="comment"># 核心代码段</span></span><br><span class="line">      <span class="keyword">if</span> vst[i]:   <span class="comment"># 辅助数组，减枝</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        做出选择</span><br><span class="line">        递归执行backtrack</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>「<strong>剪枝</strong>」第 <strong>46</strong> 题 全排列 第 <strong>47</strong> 题 全排列②</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 剪枝</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(temp_list, length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == n:</span><br><span class="line">      res.append(temp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">          visited[i] = <span class="number">1</span></span><br><span class="line">          backtrack(temp_list + [nums[i]], length + <span class="number">1</span>)</span><br><span class="line">          visited[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>「<strong>索引遍历</strong>」第 <strong>78</strong> 题 子集 | 第 <strong>47</strong> 题 子集② | 第 <strong>131</strong> 题 分割字符串</p><pre><code>第 **39 **题 组合 | 第 **40** 题 组合②  | 第 **216** 题 组合③</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(idx, n, temp_list)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> temp_list <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">    res.append(temp_list)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(idx, n):</span><br><span class="line">    helper1(i + <span class="number">1</span>, n, temp_list + [nums[i]])</span><br></pre></td></tr></table></figure><p>「 <strong>资源消耗</strong>」第 <strong>22</strong> 题 夸号生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(S, L, R)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R:</span><br><span class="line">    ans.append(<span class="string">''</span>.join(S))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> L :     backtrack(S + [<span class="string">'('</span>], L<span class="number">-1</span>, R)</span><br><span class="line">  <span class="keyword">if</span> R &gt; L : backtrack(S + [<span class="string">')'</span>], L, R<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>93</strong> 题 复原IP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">资源消耗</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, tmp, flag)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> i == n <span class="keyword">and</span> flag == <span class="number">0</span>:</span><br><span class="line">    res.append(tmp[:<span class="number">-1</span>])</span><br><span class="line">  <span class="keyword">elif</span> i&lt;n <span class="keyword">and</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">    backtrack(i + <span class="number">1</span>, tmp + s[i] + <span class="string">"."</span>, flag - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">elif</span> flag :</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, min(n,i + <span class="number">3</span>)):</span><br><span class="line">      <span class="keyword">if</span> <span class="number">0</span> &lt; int(s[i:j + <span class="number">1</span>]) &lt;= <span class="number">255</span>:</span><br><span class="line">        backtrack(j + <span class="number">1</span>, tmp + s[i:j + <span class="number">1</span>] + <span class="string">"."</span>, flag - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>17</strong> 题 电话号码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, remains)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> remains:</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remains)):</span><br><span class="line">    dfs(path + [remains[i]], remains[:i] + remains[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pth,idx)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> idx == len(ds):</span><br><span class="line">        res.append(pth)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> dic[ds[idx]]:</span><br><span class="line">        dfs(pth + c, idx + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>多重限制</strong>」第 <strong>37</strong> 题 解数独  | 第 <strong>51</strong> 题 N皇后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多重限制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(pos)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> pos == n:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  i, j = empty[pos]</span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> row[i] &amp; col[j] &amp; block[bidx(i, j)]:</span><br><span class="line">    row[i].remove(num)</span><br><span class="line">    col[j].remove(num)</span><br><span class="line">    block[bidx(i, j)].remove(num)</span><br><span class="line">    board[i][j] = str(num)</span><br><span class="line">    <span class="keyword">if</span> backtrack(pos + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    row[i].add(num)</span><br><span class="line">    col[j].add(num)</span><br><span class="line">    block[bidx(i, j)].add(num)</span><br></pre></td></tr></table></figure><p>「<strong>递归</strong>」第 <strong>10</strong> 题 正则匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">  f = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">  <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">    <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> f <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> f <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="【并查集模板】"><a href="#【并查集模板】" class="headerlink" title="【并查集模板】"></a>【并查集模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟节点用以连接某一特征的全部节点，类似于链表的preHead</span></span><br><span class="line">dummy</span><br><span class="line">parent = &#123;&#125;</span><br><span class="line">size = collections.defaultdict(<span class="keyword">lambda</span>:<span class="number">1</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">    parent.setdefault(x,x)</span><br><span class="line">    <span class="keyword">while</span> x != parent[x]:</span><br><span class="line">        x = parent[x]</span><br><span class="line">        <span class="comment">#路径压缩 parent[x] = parent[parent[x]];</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> cnt</span><br><span class="line">    <span class="keyword">if</span> connected(x,y): <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小的树挂到大的树上， 使树尽量平衡</span></span><br><span class="line">    xP = find(x)</span><br><span class="line">    yP = find(y)</span><br><span class="line">    <span class="keyword">if</span> size[hP] &lt; size[yP]:</span><br><span class="line">        parent[xP] = yP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[yP] = xP</span><br><span class="line">    size[xP] += size[yP]</span><br><span class="line">    <span class="comment"># 优化结束</span></span><br><span class="line">    parent[find(x)] = find(y)</span><br><span class="line">    <span class="comment"># 不优化</span></span><br><span class="line">    cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> size[xP]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">        parent[x] = <span class="literal">None</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"><span class="comment"># 检查是否有环</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="keyword">if</span> connected(a, b):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    union(a, b)</span><br><span class="line"><span class="comment"># 将每个集合组成以头为key的字典</span></span><br><span class="line">res = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> e2n:</span><br><span class="line">    res[uf.find(e)].append(e)</span><br></pre></td></tr></table></figure><h3 id="【拓扑排序模板】"><a href="#【拓扑排序模板】" class="headerlink" title="【拓扑排序模板】"></a>【拓扑排序模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【拓扑排序模板】</span></span><br><span class="line">ins = [<span class="number">0</span>] * n</span><br><span class="line">ous = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> cur, pre <span class="keyword">in</span> ps:</span><br><span class="line">    ins[cur] += <span class="number">1</span>  <span class="comment">#入度</span></span><br><span class="line">    ous[pre].append(cur)<span class="comment">#出度</span></span><br><span class="line">res = list(filter(<span class="keyword">lambda</span> x:ins[x]==<span class="number">0</span>, range(n)))</span><br><span class="line">q = collections.deque(res)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    pre = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> cur <span class="keyword">in</span> ous[pre]:   <span class="comment">#释放出度队列</span></span><br><span class="line">        ins[cur] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ins[cur]:</span><br><span class="line">            q.append(cur)  <span class="comment">#入度为0解锁</span></span><br><span class="line">            res.append(cur)</span><br></pre></td></tr></table></figure><h3 id="【单调栈模板】"><a href="#【单调栈模板】" class="headerlink" title="【单调栈模板】"></a><strong>【单调栈模板】</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s中一般存索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> ns[stack[<span class="number">-1</span>]] &lt;= ns[i]: <span class="comment"># 单调递减栈</span></span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 业务逻辑</span></span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增</strong>」第 <strong>84</strong> 题 求最大矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **84** 题 求最大矩形</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hs)):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> hs[i] &lt; hs[s[<span class="number">-1</span>]]:</span><br><span class="line">        base = s.pop()</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            H = hs[base]</span><br><span class="line">            W = i - s[<span class="number">-1</span>] - <span class="number">1</span> <span class="comment"># 当前弹出的做高，当前与次小做宽</span></span><br><span class="line">            res = max(res, H * W)</span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增,考虑剩余</strong>」第 <strong>316</strong> 题 去除重复字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **316** 题 去除重复字符</span></span><br><span class="line"><span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">and</span> c &lt; s[<span class="number">-1</span>] <span class="keyword">and</span> s[<span class="number">-1</span>] <span class="keyword">in</span> ss[i:]:</span><br><span class="line">            s.pop()</span><br><span class="line">        s.append(c)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>42</strong> 题 接雨水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **42** 题 接雨水</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hgt)):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> hgt[i] &gt; hgt[stack[<span class="number">-1</span>]]: <span class="comment">#递减栈</span></span><br><span class="line">        base = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            LH = hgt[stack[<span class="number">-1</span>]]</span><br><span class="line">            W = i - stack[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">            H = min(LH,hgt[i]) - hgt[base]</span><br><span class="line">            res += W * H</span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>739</strong> 题 每日温度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **739** 题 每日温度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> T[s[<span class="number">-1</span>]] &lt;= T[i] :   <span class="comment">#递减栈</span></span><br><span class="line">        s.pop()</span><br><span class="line">    res[i] = s[<span class="number">-1</span>] - i <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><h3 id="【二分模板】"><a href="#【二分模板】" class="headerlink" title="【二分模板】"></a>【二分模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13(5)55579 返回2</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt; ps[i] &lt;= ps[i+1]</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=len(ns))  </span><br><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13555(5)79 返回5</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt;= ps[i] &lt; ps[i+1]</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=len(ns))  </span><br><span class="line">bisect.bisect(ps, T, L=<span class="number">0</span>, R=len(ns))</span><br></pre></td></tr></table></figure><p>「<strong>中位返回</strong>」第 <strong>33</strong> 题 搜索旋转排序数组 | 第<strong>374</strong>题 猜数字大小 | 第<strong>69</strong>题  x平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位返回</span></span><br><span class="line"><span class="keyword">while</span> L &lt;= R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[M] == T:</span><br><span class="line">        <span class="keyword">return</span> M</span><br><span class="line">    <span class="keyword">elif</span> nums[M] &lt; T:</span><br><span class="line">        L = M + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R = M - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>区域压缩</strong>」第<strong>278</strong>题 第一个错误版本| 第<strong>162</strong>题 寻找峰值 | 第<strong>153</strong>题 寻找数组最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区域压缩</span></span><br><span class="line"><span class="keyword">while</span> L &lt; R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> need <span class="keyword">in</span> s[L:M]:</span><br><span class="line">        R = M</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        L = M + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="【动态规划模板】"><a href="#【动态规划模板】" class="headerlink" title="【动态规划模板】"></a>【动态规划模板】</h3><h4 id="「单串问题」"><a href="#「单串问题」" class="headerlink" title="「单串问题」"></a>「<strong>单串问题</strong>」</h4><ul><li>70 爬楼梯问题</li><li>801 使序列递增的最小交换次数</li><li>746 使用最小花费爬楼梯</li><li>300 最长上升子序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖前单个元素</span></span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + ns[i]</span><br><span class="line"><span class="comment"># 依赖前部区域元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i)</span><br><span class="line">        dp[i] = min(dp[i], f(dp[j])</span><br></pre></td></tr></table></figure><h4 id="「单串加状态问题」"><a href="#「单串加状态问题」" class="headerlink" title="「单串加状态问题」"></a>「<strong>单串加状态问题</strong>」</h4><ul><li><p>887 鸡蛋掉落</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 鸡蛋掉落</span></span><br><span class="line"><span class="keyword">while</span> cur[K] &lt; N:             <span class="comment"># 还剩 j 个蛋 测 ans 次 覆盖多少层</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>): <span class="comment"># 覆盖总层数 碎了 -1 次层数 + 1 + 没碎 -1 次层数</span></span><br><span class="line">        cur[j] = prev[j - <span class="number">1</span>] + <span class="number">1</span> + prev[j]</span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">    prev = copy.deepcopy(cur)</span><br></pre></td></tr></table></figure></li><li><p>813 最大平均值分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 813 最大平均值分组</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(K<span class="number">-1</span>):            <span class="comment">#循环k次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):          <span class="comment">#每次均依赖上次的结果</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, N):</span><br><span class="line">            dp[i] = max(dp[i], avrg(i, j) + dp[j])</span><br></pre></td></tr></table></figure></li><li><p>410 分割数组最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 410 分割数组最大值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,K):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="comment"># 0~i中分 k 段最大 即为</span></span><br><span class="line">            <span class="comment"># 0~j中分k-1段最大 和 j到i的前缀和的最大</span></span><br><span class="line">            dp[i][k] = min(dp[i][k], max(dp[j][k<span class="number">-1</span>], ps[i+<span class="number">1</span>] - ps[j+<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li></ul><h4 id="「经典双串LCS问题」"><a href="#「经典双串LCS问题」" class="headerlink" title="「经典双串LCS问题」"></a>「<strong>经典双串LCS问题</strong>」</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典双串LCS问题</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">        <span class="keyword">if</span> t1[i] == t2[j] : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j])</span><br></pre></td></tr></table></figure><h4 id="「区间动态规划」"><a href="#「区间动态规划」" class="headerlink" title="「区间动态规划」"></a>「区间动态规划」</h4><ul><li>5 最长回文子串</li><li>647 最多回文子串</li><li>516 最长回文子序列</li><li>1312 最长回文插入次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] 代表从 i 到 j 的最长子串满足条件的数量</span></span><br><span class="line"><span class="comment"># i-- &lt; j++  ==&gt; i 在 0~j 范围内 --</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">    dp[j][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(j<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> ss[i] == ss[j]:</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] +<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="「区间分治动态规划」"><a href="#「区间分治动态规划」" class="headerlink" title="「区间分治动态规划」"></a><strong>「区间分治动态规划」</strong></h4><p><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486 预测赢家</a></p><p><a href="***https://leetcode-cn.com/problems/burst-balloons/***">312 戳气球</a></p><p><a href="***https://leetcode-cn.com/problems/strange-printer/***">664 奇怪的打印机</a></p><p><a href="***https://leetcode-cn.com/problems/remove-boxes/***">546 移除盒子</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间分治动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, ns: List[int])</span> :</span></span><br><span class="line">    N = len(ns)</span><br><span class="line">    dp = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(N): <span class="comment"># 长度从小到大</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N-l): <span class="comment"># 以 i 为 开头</span></span><br><span class="line">            j = i + l           <span class="comment"># 以 j 为 终点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i,j): <span class="comment"># 以 k 为分割点，进行分治         </span></span><br><span class="line">                // Todo 业务逻辑</span><br></pre></td></tr></table></figure><p>「<strong>卡特兰数</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卡特兰数</span></span><br><span class="line">g(n) = g(<span class="number">0</span>)*g(n<span class="number">-1</span>) + g(<span class="number">1</span>)*g(n<span class="number">-2</span>) ...g(n<span class="number">-1</span>)*g(<span class="number">0</span>)</span><br><span class="line">dp=[<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[j<span class="number">-1</span>] * dp[i-j]</span><br></pre></td></tr></table></figure><h3 id="【滑动窗口】"><a href="#【滑动窗口】" class="headerlink" title="【滑动窗口】"></a>【滑动窗口】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""给定待查串s和目标串t"""</span></span><br><span class="line">nd, wd = &#123;&#125;, &#123;&#125;</span><br><span class="line">nd = collections.Counter(s1)</span><br><span class="line">L, R = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span> <span class="comment"># 满足条件个数</span></span><br><span class="line"><span class="keyword">while</span> R &lt; len(s):        <span class="comment"># 窗口右边界不断扩大，本质是搜索问题的可能解</span></span><br><span class="line">    c = s[R]      <span class="comment"># 即将加入到窗口中的字符</span></span><br><span class="line">    R += <span class="number">1</span></span><br><span class="line">    更新窗口中的数据</span><br><span class="line">    <span class="keyword">while</span> 满足窗口收缩条件：  <span class="comment"># 窗口的左边界收缩，本质是优化可行解</span></span><br><span class="line">        记录或返回结果</span><br><span class="line">        d = s[L]   <span class="comment"># 即将从窗口中删除的字符</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">        更新窗口中的数据</span><br><span class="line"><span class="keyword">return</span> 结果</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定窗口 ,比滑动窗口更快一些</span></span><br><span class="line">i = j = cnt = <span class="number">0</span>      </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt &gt; K: <span class="comment">#不满足时 平移</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> j - i + <span class="number">1</span>        </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> cnt &gt; K:</span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    res = max(res, j - i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【前缀和】"><a href="#【前缀和】" class="headerlink" title="【前缀和】"></a>【前缀和】</h3><p>「<strong>累加和存位置</strong>」</p><p>1371 最长偶数元音子数组</p><p>525 最长相等01子数组</p><p>325 最长和为k 子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前缀和初始化</span></span><br><span class="line">psd = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">    t ^= cd.get(s[i], <span class="number">0</span>) <span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[t] = i       <span class="comment"># 第一次存入数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = max(ans, i - psd[t]) <span class="comment">#已存入则开始计算</span></span><br></pre></td></tr></table></figure><p>「<strong>累加和存数量</strong>」</p><p>560 和为K的子数组数量</p><p> 统计优美子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累加和存数量</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns)):</span><br><span class="line">    s += ns[i]</span><br><span class="line">    <span class="keyword">if</span> s - T <span class="keyword">in</span> psd:</span><br><span class="line">        ans += psd[s - T] <span class="comment"># 存数量</span></span><br><span class="line">    psd[s] = psd.get(s,<span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>模K状态前缀和</strong>」</p><p>523 连续和为 k 倍 的子数组（存索引）</p><p>974 和被k 整除 子数组数量（存数量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模K状态前缀和</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:<span class="number">-1</span>&#125;</span><br><span class="line">ans = s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns)):</span><br><span class="line">    s += ns[i]<span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> T != <span class="number">0</span>: s %= abs(T)<span class="comment"># 模k状态做key，索引做值</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[s] = i</span><br><span class="line">    <span class="keyword">elif</span> i - psd[s] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>「矩阵前缀和」</strong></p><ul><li>363 不超过K的最大数值和</li><li>1074 和为目标值的子矩阵数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵前缀和</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):        <span class="comment">#固定左边界</span></span><br><span class="line">    ps = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, m): <span class="comment">#固定右边界</span></span><br><span class="line">    psS = <span class="number">0</span></span><br><span class="line">        dct = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;       <span class="comment">#初始只有一种可能</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n): <span class="comment"># 以高做前缀和</span></span><br><span class="line">            ps[k] += mtx[j][k]          <span class="comment"># 每行前缀和</span></span><br><span class="line">            psS += ps[k]                <span class="comment"># n行前缀和</span></span><br><span class="line">            cnt += dct.get(psS - T, <span class="number">0</span>)  <span class="comment"># 满足条件cnt</span></span><br><span class="line">            dct[psS] = dct.get(psS,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 保存当前状态</span></span><br><span class="line"><span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="【双指针】"><a href="#【双指针】" class="headerlink" title="【双指针】"></a>【双指针】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, ns: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    n = len(ns)</span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> ns[fast] != val:</span><br><span class="line">            ns[slow] = ns[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="【深度优先】"><a href="#【深度优先】" class="headerlink" title="【深度优先】"></a>【深度优先】</h3><p>「<strong>二叉树遍历模板</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preOrd(root.left) + self.preOrd(root.right)</span><br><span class="line">        <span class="comment"># # 中序递归</span></span><br><span class="line">        <span class="comment"># return self.inOrd(root.left) + [root.val] + self.inOrd(root.right)</span></span><br><span class="line">        <span class="comment"># # 后序递归</span></span><br><span class="line">        <span class="comment"># return self.postOrd(root.left) + self.postOrd(root.right) + [root.val]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            dfs(cur.right)</span><br><span class="line">            <span class="comment"># # 中序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># # 后序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)      </span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span></span><br><span class="line"><span class="comment"># 迭代1：前序遍历最常用模板（后序同样可以用）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     if cur.left:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.left)</span></span><br><span class="line">        <span class="comment">#     if cur.right:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.right)</span></span><br><span class="line">        <span class="comment">#     res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1：层序遍历最常用模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(q)) :</span><br><span class="line">                t = q.popleft()</span><br><span class="line">                l.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">            res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 前序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.left</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.right</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 后序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.right</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.left</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span></span><br><span class="line"><span class="comment"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span></span><br><span class="line"><span class="comment"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(<span class="number">0</span>, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            flag, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 前序，标记法</span></span><br><span class="line">                stack.append((<span class="number">0</span>, cur.right))</span><br><span class="line">                stack.append((<span class="number">0</span>, cur.left))</span><br><span class="line">                stack.append((<span class="number">1</span>, cur))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># # 后序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># # 中序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))  </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 层序，标记法</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># queue = [(0, root)]</span></span><br><span class="line">        <span class="comment"># while queue:</span></span><br><span class="line">        <span class="comment">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span></span><br><span class="line">        <span class="comment">#     if not cur: continue</span></span><br><span class="line">        <span class="comment">#     if flag == 0:</span></span><br><span class="line">                  <span class="comment"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span></span><br><span class="line">        <span class="comment">#         queue.append((1, cur))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.left))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.right))</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span></span><br><span class="line"><span class="comment"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span></span><br><span class="line"><span class="comment"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span></span><br><span class="line"><span class="comment"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span></span><br><span class="line"><span class="comment"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span></span><br><span class="line"><span class="comment"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># cur = pre = TreeNode(None)</span></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># print(cur.val)</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    <span class="comment"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span></span><br><span class="line"><span class="comment"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树简洁递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = [root.val]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res.extend(self.preorder(node))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树通用递归模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                helper(child)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树迭代方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = [root]</span><br><span class="line">        <span class="comment"># s.append(root)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            node = s.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># for child in node.children[::-1]:</span></span><br><span class="line">            <span class="comment">#     s.append(child)</span></span><br><span class="line">            s.extend(node.children[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【广度优先】"><a href="#【广度优先】" class="headerlink" title="【广度优先】"></a>【广度优先】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**无向图的遍历**」</span></span><br><span class="line">q = collections.deque([i])</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    cur = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> nxt <span class="keyword">in</span> dt[cur]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vst[nxt]:</span><br><span class="line">            vstd[nxt] = <span class="literal">True</span></span><br><span class="line">            q.append(nxt)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**二叉树层序遍历**」</span></span><br><span class="line">q = deque([root])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> q :</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(q)) :</span><br><span class="line">        t = q.popleft()</span><br><span class="line">        l.append(t.val)</span><br><span class="line">        <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">        <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">    res.append(l)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【图论】"><a href="#【图论】" class="headerlink" title="【图论】"></a>【图论】</h3><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#「Dijkstra最短路径」</span></span><br><span class="line">dic = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">    dic[u].append([v, w])</span><br><span class="line">    dic[v].append([u, w])</span><br><span class="line">q = [(<span class="number">0</span>, n)]</span><br><span class="line">dist = [<span class="number">-1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    dis, cur = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> dist[cur] &lt; <span class="number">0</span>:</span><br><span class="line">        dist[cur] = dis</span><br><span class="line">        <span class="keyword">for</span> nxt, wi <span class="keyword">in</span> dic[cur]:</span><br><span class="line">            heapq.heappush(q, [dis + wi, nxt])</span><br></pre></td></tr></table></figure><p><strong>「Floyd 求图中路径」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Floyd算法 求图中任意2点距离</span></span><br><span class="line">ds = defaultdict(int)</span><br><span class="line">st = set()</span><br><span class="line"><span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> enumerate(ess):</span><br><span class="line">    ds[(x, y)] = vs[i]</span><br><span class="line">    ds[(y, x)] = <span class="number">1</span> / vs[i]</span><br><span class="line">    st.update(&#123;x,y&#125;)</span><br><span class="line">arr = list(st)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> ds[(i, k)] <span class="keyword">and</span> ds[(k, j)]:</span><br><span class="line">                ds[(i, j)] = ds[(i, k)] * ds[(k, j)]</span><br></pre></td></tr></table></figure><h1 id="五、实战算法篇"><a href="#五、实战算法篇" class="headerlink" title="五、实战算法篇"></a>五、实战算法篇</h1><h3 id="1、URL黑名单（布隆过滤器）"><a href="#1、URL黑名单（布隆过滤器）" class="headerlink" title="1、URL黑名单（布隆过滤器）"></a><strong>1、</strong>URL黑名单（布隆过滤器）</h3><p><strong>100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中</strong></p><p>​    <strong>散列表：</strong></p><p>​        如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p><p>​    <strong>布隆过滤器：</strong></p><p>​        它实际上是一个很长的二进制矢量和一系列随机映射函数。</p><p>​        它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>​        在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ul><h3 id="2、词频统计（分文件）"><a href="#2、词频统计（分文件）" class="headerlink" title="2、词频统计（分文件）"></a>2、词频统计（分文件）</h3><p><strong>2GB内存在20亿整数中找到出现次数最多的数</strong></p><p>​        通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。</p><p>​        当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿/2^30,1GB== 2 ^30个字节 == 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。</p><p>​        解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。</p><h3 id="3、未出现的数（bit数组）"><a href="#3、未出现的数（bit数组）" class="headerlink" title="3、未出现的数（bit数组）"></a><strong>3、未出现的数</strong>（bit数组）</h3><p><strong>40亿个非负整数中找到没有出现的数</strong></p><p>​        对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B = 160亿个字节，一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。</p><p>　　我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿/8 = 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，例如，遇到20，则bitArray[20] = 1；遇到666，则bitArray[666] = 1,遍历完所有的数，将数组相应位置变为1。</p><p><strong>40亿个非负整数中找到一个没有出现的数，内存限制10MB</strong></p><p>​        10亿个字节的数据大概需要1GB空间处理，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit / 0.8亿bit = 50，那么这样最少也得分50块来处理，下面就以64块来进行分析解答吧。</p><p><strong>总结一下进阶的解法：</strong></p><p>1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</p><p>2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p><p>3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。</p><p><strong>自己的想法</strong></p><p>如果只是找一个数，可以高位模运算，写到64个不同的文件，然后在最小的文件中通过bitArray一次处理掉。</p><p><strong>40亿个无符号整数，1GB内存，找到所有出现两次的数</strong></p><p>​        对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num<em>2 + 1]和bitArr[num</em>2]设置为01，如果第二次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为10，如果第三次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为11。以后再遇到num，发现此时bitArr[num<em>2+1]和bitArr[num</em>2]已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i<em>2+1]和bitArr[i</em>2]设置为10，那么i 就是出现了两次的数。</p><h3 id="4、重复URL（分机器）"><a href="#4、重复URL（分机器）" class="headerlink" title="4、重复URL（分机器）"></a><strong>4、重复URL</strong>（分机器）</h3><p><strong>找到100亿个URL中重复的URL</strong></p><p>​        原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。</p><p>​        例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，<strong>同时哈希函数的性质决定了同一条URL不可能分给不同的机器；</strong>或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p><h3 id="5、TOPK搜索（小根堆）"><a href="#5、TOPK搜索（小根堆）" class="headerlink" title="5、TOPK搜索（小根堆）"></a><strong>5、TOPK搜索（小根堆）</strong></h3><p><strong>海量搜索词汇，找到最热TOP100词汇的方法</strong></p><p>​        最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。</p><p>​        处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p><h3 id="6、中位数（单向二分查找）"><a href="#6、中位数（单向二分查找）" class="headerlink" title="6、中位数（单向二分查找）"></a><strong>6、中位数（单向二分查找）</strong></h3><p><strong>10MB内存，找到100亿整数的中位数</strong></p><p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？</p><p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。</p><p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。</p><p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中）</p><p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。</p><p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。</p><p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。</p><p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p><h3 id="7、短域名系统（缓存）"><a href="#7、短域名系统（缓存）" class="headerlink" title="7、短域名系统（缓存）"></a><strong>7、短域名系统（缓存）</strong></h3><p><strong>设计短域名系统，将长URL转化成短的URL.</strong></p><p>（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。</p><p>（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：<a href="http://t.cn/sBc。" target="_blank" rel="noopener">t.cn/sBc。</a></p><p>（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。</p><h3 id="8、海量评论入库（消息队列）"><a href="#8、海量评论入库（消息队列）" class="headerlink" title="8、海量评论入库（消息队列）"></a><strong>8、海量评论入库（消息队列）</strong></h3><p><strong>假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</strong></p><p>前端页面直接给用户展示、通过消息队列异步方式入库</p><p>读可以进行读写分离、同时热点评论定时加载到缓存</p><h3 id="9、在线-并发用户数（Redis）"><a href="#9、在线-并发用户数（Redis）" class="headerlink" title="9、在线/并发用户数（Redis）"></a><strong>9、在线/并发用户数（Redis）</strong></h3><p>​    <strong>显示网站的用户在线数的解决思路</strong></p><p>​        维护在线用户表</p><p>​        使用Redis统计</p><p><strong>显示网站并发用户数</strong></p><ol><li>每当用户访问服务时，把该用户的 ID 写入ZSORT队列，权重为当前时间</li><li>根据权重(即时间)计算一分钟内该机构的用户数Zrange</li><li>删掉一分钟以上过期的用户Zrem</li></ol><h3 id="10、热门字符串（前缀树）"><a href="#10、热门字符串（前缀树）" class="headerlink" title="10、热门字符串（前缀树）"></a>10、热门字符串（前缀树）</h3><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><p><strong>HashMap 法</strong></p><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p><p><strong>前缀树法</strong></p><p>当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用<strong>小顶堆</strong>来对字符串的出现次数进行排序。</p><h3 id="11、红包算法"><a href="#11、红包算法" class="headerlink" title="11、红包算法"></a>11、红包算法</h3><p>线性切割法，一个区间切N-1刀。越早越多</p><p>二倍均值法，【0 ~ 剩余金额 / 剩余人数 * 2】中随机，相对均匀</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpbvl5pvj30qu0gcgm0.jpg" alt="img"></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpc3hz9dj31450ggq8k.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="11、手写快排"><a href="#11、手写快排" class="headerlink" title="11、手写快排"></a>11、手写快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常规快排 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> M = partition(arr, L, R);</span><br><span class="line">quickSort1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">quickSort1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line"><span class="keyword">int</span> lessEqual = L - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt;= arr[R])</span><br><span class="line">swap(arr, index, ++lessEqual);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, ++lessEqual, R);</span><br><span class="line"><span class="keyword">return</span> lessEqual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 荷兰国旗 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">quickSort2(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">quickSort2(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherlandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; L, R &#125;;</span><br><span class="line"><span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> more = R;</span><br><span class="line"><span class="keyword">int</span> index = L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">swap(arr, index++, ++less);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, index, --more);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, more, R);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> testTime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxSize = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> maxValue = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">long</span> T1=<span class="number">0</span>,T2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line"><span class="keyword">int</span>[] arr3 = copyArray(arr1);</span><br><span class="line"><span class="comment">//int[] arr1 = &#123;9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">quickSort1(arr1,<span class="number">0</span>,arr1.length-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">quickSort2(arr2,<span class="number">0</span>,arr2.length-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> t3 = System.currentTimeMillis();</span><br><span class="line">T1 += (t2-t1);</span><br><span class="line">T2 += (t3-t2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2) || !isEqual(arr2, arr3)) &#123;</span><br><span class="line">succeed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(T1+<span class="string">" "</span>+T2);</span><br><span class="line"><span class="comment">//System.out.println(succeed ? "Nice!" : "Oops!");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random())</span><br><span class="line">                - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">res[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> &amp;&amp; arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1.length != arr2.length)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line"><span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、手写归并"><a href="#12、手写归并" class="headerlink" title="12、手写归并"></a>12、手写归并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M)</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++)</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    printArray(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、手写堆排"><a href="#13、手写堆排" class="headerlink" title="13、手写堆排"></a>13、手写堆排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]刚来的数，往上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]位置的数，能否往下移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">        <span class="comment">// 1）只有左孩子，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">        <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>]&gt; arr[left] ? left+<span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    heapSort(arr1);</span><br><span class="line">    printArray(arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、手写单例"><a href="#14、手写单例" class="headerlink" title="14、手写单例"></a>14、手写单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">              singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15、手写LRUcache"><a href="#15、手写LRUcache" class="headerlink" title="15、手写LRUcache"></a>15、手写LRUcache</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于linkedHashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DNode</span> </span>&#123;</span><br><span class="line">        DNode prev;</span><br><span class="line">        DNode next;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, DNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    DNode head, tail;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> DNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            DNode node = map.get(key);</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            DNode node = map.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DNode newNode = <span class="keyword">new</span> DNode();</span><br><span class="line">            newNode.val = value;</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; cap) &#123;</span><br><span class="line">                map.remove(tail.prev.key);</span><br><span class="line">                removeNode(tail.prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DNode node)</span> </span>&#123;</span><br><span class="line">        DNode prevNode = node.prev;</span><br><span class="line">        DNode nextNode = node.next;</span><br><span class="line">        prevNode.next = nextNode;</span><br><span class="line">        nextNode.prev = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DNode node)</span> </span>&#123;</span><br><span class="line">        DNode firstNode = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = firstNode;</span><br><span class="line">        firstNode.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16、手写线程池"><a href="#16、手写线程池" class="headerlink" title="16、手写线程池"></a><strong>16、手写线程池</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认线程池中的线程的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORK_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//默认处理任务的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_NUM = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> workNum;<span class="comment">//线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> taskNum;<span class="comment">//任务数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;WorkThread&gt; workThreads;<span class="comment">//保存线程的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;<span class="comment">//阻塞有序队列存放任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySelfThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(WORK_NUM, TASK_NUM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySelfThreadPool</span><span class="params">(<span class="keyword">int</span> workNum, <span class="keyword">int</span> taskNum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (workNum &lt;= <span class="number">0</span>) workNum = WORK_NUM;</span><br><span class="line"><span class="keyword">if</span> (taskNum &lt;= <span class="number">0</span>) taskNum = TASK_NUM;</span><br><span class="line">taskQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(taskNum);</span><br><span class="line"><span class="keyword">this</span>.workNum = workNum;</span><br><span class="line"><span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">workThreads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//启动一定数量的线程数，从队列中获取任务处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;workNum;i++) &#123;</span><br><span class="line">WorkThread workThread = <span class="keyword">new</span> WorkThread(<span class="string">"thead_"</span>+i);</span><br><span class="line">workThread.start();</span><br><span class="line">workThreads.add(workThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">taskQueue.put(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ready close thread pool..."</span>);</span><br><span class="line"><span class="keyword">if</span> (workThreads == <span class="keyword">null</span> || workThreads.isEmpty()) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (WorkThread workThread : workThreads) &#123;</span><br><span class="line">workThread.stopWork();</span><br><span class="line">workThread = <span class="keyword">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125;</span><br><span class="line">workThreads.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">setName(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Runnable runnable = taskQueue.take();<span class="comment">//获取任务</span></span><br><span class="line"><span class="keyword">if</span> (runnable !=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">" readyexecute:"</span>+runnable.toString());</span><br><span class="line">runnable.run();<span class="comment">//执行任务</span></span><br><span class="line">&#125;</span><br><span class="line">runnable = <span class="keyword">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">interrupt();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySelfThreadPool</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_NUM = <span class="number">50</span>;<span class="comment">//任务的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MySelfThreadPool myPool = <span class="keyword">new</span> MySelfThreadPool(<span class="number">3</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TASK_NUM;i++) &#123;</span><br><span class="line">myPool.execute(<span class="keyword">new</span> MyTask(<span class="string">"task_"</span>+i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"task :"</span>+name+<span class="string">" end..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"name = "</span>+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、手写消费者生产者模式"><a href="#17、手写消费者生产者模式" class="headerlink" title="17、手写消费者生产者模式"></a><strong>17、手写消费者生产者模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + num &gt; MAX_VALUE) &#123;</span><br><span class="line">                System.out.println(<span class="string">"暂时不能执行生产任务"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"已生产产品数"</span>+num+<span class="string">" 仓库容量"</span>+list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &lt; num) &#123;</span><br><span class="line">                System.out.println(<span class="string">"暂时不能执行消费任务"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"已消费产品数"</span>+num+<span class="string">" 仓库容量"</span> + list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        storage.produce(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        storage.consume(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p2 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p3 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p4 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        Customer c2 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        Customer c3 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        p1.setNum(<span class="number">10</span>);</span><br><span class="line">        p2.setNum(<span class="number">20</span>);</span><br><span class="line">        p3.setNum(<span class="number">80</span>);</span><br><span class="line">        c1.setNum(<span class="number">50</span>);</span><br><span class="line">        c2.setNum(<span class="number">20</span>);</span><br><span class="line">        c3.setNum(<span class="number">20</span>);</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18、手写阻塞队列"><a href="#18、手写阻塞队列" class="headerlink" title="18、手写阻塞队列"></a><strong>18、手写阻塞队列</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">blockQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isNull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isFull = lock.newCondition();</span><br><span class="line">    blockQueue(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"阻塞队列满了"</span>);</span><br><span class="line">                    isFull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isFull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ++size;</span><br><span class="line">            container.add(data);</span><br><span class="line">            isNull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"阻塞队列空了"</span>);</span><br><span class="line">                    isNull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isNull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">int</span> res = container.get(<span class="number">0</span>);</span><br><span class="line">            container.remove(<span class="number">0</span>);</span><br><span class="line">            isFull.signal();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AxinBlockQueue queue = <span class="keyword">new</span> AxinBlockQueue(<span class="number">5</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            System.out.println(<span class="string">"塞入"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费"</span>+queue.take());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19、手写多线程交替打印ABC"><a href="#19、手写多线程交替打印ABC" class="headerlink" title="19、手写多线程交替打印ABC"></a><strong>19、手写多线程交替打印ABC</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syncPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRINT_COUNT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition thisCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition nextCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">syncPrinter</span><span class="params">(ReentrantLock reentrantLock, Condition thisCondtion, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reentrantLock = reentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.nextCondtion = nextCondition;</span><br><span class="line">        <span class="keyword">this</span>.thisCondtion = thisCondtion;</span><br><span class="line">        <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取打印锁 进入临界区</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连续打印PRINT_COUNT次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRINT_COUNT; i++) &#123;</span><br><span class="line">                <span class="comment">//打印字符</span></span><br><span class="line">                System.out.print(printChar);</span><br><span class="line">                <span class="comment">// 使用nextCondition唤醒下一个线程</span></span><br><span class="line">                <span class="comment">// 因为只有一个线程在等待，所以signal或者signalAll都可以</span></span><br><span class="line">                nextCondtion.signal();</span><br><span class="line">                <span class="comment">// 不是最后一次则通过thisCondtion等待被唤醒</span></span><br><span class="line">                <span class="comment">// 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; PRINT_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 本线程让出锁并等待唤醒</span></span><br><span class="line">                        thisCondtion.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition conditionA = lock.newCondition();</span><br><span class="line">        Condition conditionB = lock.newCondition();</span><br><span class="line">        Condition conditionC = lock.newCondition();</span><br><span class="line">        Thread printA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionA, conditionB,<span class="string">'A'</span>));</span><br><span class="line">        Thread printB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionB, conditionC,<span class="string">'B'</span>));</span><br><span class="line">        Thread printC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionC, conditionA,<span class="string">'C'</span>));</span><br><span class="line">        printA.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printB.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20、交替打印FooBar"><a href="#20、交替打印FooBar" class="headerlink" title="20、交替打印FooBar"></a>20、交替打印FooBar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手太阴肺经 BLOCKING Queue</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; bar = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; foo = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.put(i);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手阳明大肠经CyclicBarrier 控制先后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar6</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!fin);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            fin = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阴心经 自旋 + 让出CPU</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">            printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阳三焦经 可重入锁 + Condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition foo = lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">            &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手厥阴心包经 synchronized + 标志位 + 唤醒</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 标志位，控制执行顺序，true执行printFoo，false执行printBar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> type = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object foo=  <span class="keyword">new</span> Object(); <span class="comment">// 锁标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                type = <span class="keyword">false</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                type = <span class="keyword">true</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手太阳小肠经 信号量 适合控制顺序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();</span><br><span class="line">        printFoo.run();</span><br><span class="line">            bar.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();</span><br><span class="line">        printBar.run();</span><br><span class="line">            foo.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、个人项目"><a href="#六、个人项目" class="headerlink" title="六、个人项目"></a><strong>六、个人项目</strong></h1><h2 id="一、一站到底"><a href="#一、一站到底" class="headerlink" title="一、一站到底"></a><strong>一、一站到底</strong></h2><p>​    采用SpringBoot构建项目，主要通过分布式缓存、队列、限流保证系统高可用，Netty、缓存、反向代理保证高并发。</p><blockquote><p>双人对战答题、公司对战抢答</p></blockquote><h3 id="1、如何设计排行榜"><a href="#1、如何设计排行榜" class="headerlink" title="1、如何设计排行榜"></a>1、如何设计排行榜</h3><ul><li>个人总得分和总排名实时更新</li><li>个人排行榜按分数、时间、次数、正确率展示</li><li>日榜、过去N日榜滚动更新</li></ul><h4 id="性能优化过程"><a href="#性能优化过程" class="headerlink" title="性能优化过程"></a>性能优化过程</h4><p>​    第一条需求很简单，使用了Redis的<strong>Zset</strong>实现不过这里总得分采用了基于<strong>分数、时间、次数和正确率</strong>的混合加权。考虑到数据的<strong>持久化</strong>，以及<strong>关系数据库和缓存的一致性</strong>导致的设计的复杂性，使用了<strong>谷歌</strong>开源的<strong>JamsRanking</strong></p><p>​    优点<strong>是可以直接使用现成的setScores和getRanking接口封装了Redis和Mysql和消息队列的完成</strong>事务和一致性<strong>的使用细节。缺点是</strong>并发比较低<strong>使用Jmeter进行压测，单机只有</strong>20<strong>左右的</strong>TPS**</p><p>​    后来看了下源码，主要是它针对每一次设置都进行了分布式事务处理，并且会返回事务提交或回滚的结果。了解了底层实现以后就去谷歌的<strong>开源社区</strong>去查阅了相关的解决方案，当时官方对这个问题并没有通过<strong>配置能直接解决问题</strong>的快捷方式，不过推荐了使用者自身如果对响应时间不高的场景下可以采用<strong>批量合并事务</strong>的方式进行优化。基于这个思路，我们把写操作进行了封装并放入了<strong>队列</strong>，然后在消费者端批量取得数据后进行事务的批量处理，压测环境下整体性能达到了<strong>500TPS</strong>。已经基本满足了线上更新的需求，但是当时压测的过程中，队列偶尔的吞吐量会<strong>大范围波动</strong>，经常会持续数十秒，然后业务一次性处理完再响应，导致<strong>局部响应时间大幅度增长</strong></p><p>​    后来也是在官网上查询，了解到谷歌开源组件使用的<strong>队列服务</strong>底层是使用<strong>BigTable</strong>作为持久层，但是当BigTable分片过大时，会触发<strong>再分片</strong>的过程，再分片的过程中，是<strong>不会进行任务分发</strong>的，所以就会导致先前的问题。针对这个问题，谷歌官方的建议是提前<strong>配置队列的数量、负载策略和最大容量</strong>等信息，保证所有队列<strong>不同时触发</strong>再分片</p><p>​    进行两次优化后，压测环境已经基本可以满足预期了，在实际生产环境的部署中，发现对于事务更新失败时，JamsRanking会对失败的事务进行<strong>切分和重试</strong>，整个过程对于研发人员是<strong>透明</strong>的，不利于线上问题排查，所以我们当时特地写了一个watchdog的工具，监控事务回滚达到十次以上的事务，查明原因后通过后台管理系统进行相应补偿，保证<strong>最终一致性</strong></p><p><strong>最终结果：</strong></p><ul><li>高效快速：能在数百毫秒内找到玩家排名以及进行更新</li><li>强一致性以及持久化、排名准确</li><li><p>可以扩展到任意数量的玩家</p></li><li><p>吞吐量有限制，只能支持约每秒 500次更新。</p></li></ul><p>针对这个缺点谷歌官方也是给出了使用分片树和近似排名的解决方案，当然复杂的方案有更高的运维成本，所以我们优化工作也就到此为止</p><h4 id="方案优化过程"><a href="#方案优化过程" class="headerlink" title="方案优化过程"></a>方案优化过程</h4><h4 id="方案1：每日一个滚动榜，当日汇聚（费时间）"><a href="#方案1：每日一个滚动榜，当日汇聚（费时间）" class="headerlink" title="方案1：每日一个滚动榜，当日汇聚（费时间）"></a>方案1：每日一个滚动榜，当日汇聚（费时间）</h4><p>​    首先记录每天的排行榜和一个滚动榜，加分时同时写入这两个榜单，每日零点后跑工具将前几天数据累加写入当日滚动榜，该方案缺点是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受</p><h4 id="方案2：全局N个滚动榜同时写（费空间）"><a href="#方案2：全局N个滚动榜同时写（费空间）" class="headerlink" title="方案2：全局N个滚动榜同时写（费空间）"></a>方案2：全局N个滚动榜同时写（费空间）</h4><p>​    要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。可以写当天的滚动榜的同时，写往后N-1天的滚动榜一起写入该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，但是对于百日榜，空间消耗无法接受，1000万榜单大约消耗1G内存</p><h4 id="方案3：实时更新，常数次写操作"><a href="#方案3：实时更新，常数次写操作" class="headerlink" title="方案3：实时更新，常数次写操作"></a>方案3：实时更新，常数次写操作</h4><p>有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？</p><p>​    仍然是记录每天的排行榜和一个滚动榜，加分操作也还是同时操作当日榜和全局榜，但每日零点的离线作业改为从全局榜中减去之前过期的数据，从而实现先滚动更新。  此方案每次只需读取一个日榜做减法，时间复杂度为O(1)；但是无法做到实时更新。 这个方案的优点是在十二点前提前准备好差分榜，到了十二点直接加上当天数据就是滚动榜内容 ，这样就在常数次写操作的前提下，实现了滚动榜的实时更新</p><h3 id="2、如何解决重复答题"><a href="#2、如何解决重复答题" class="headerlink" title="2、如何解决重复答题"></a>2、<strong>如何解决重复答题</strong></h3><p>​    <strong>利用setnx防止重复答题</strong><br>​    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁推荐使用set的方式</span></span><br><span class="line">String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"EX"</span>, expireTime);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用redis+lua脚本</span></span><br><span class="line">String lua = <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;</span><br><span class="line">Object result = jedis.eval(lua, Collections.singletonList(lockKey)</span><br></pre></td></tr></table></figure><h3 id="3、一个题目被多个人抢答"><a href="#3、一个题目被多个人抢答" class="headerlink" title="3、一个题目被多个人抢答"></a><strong>3、一个题目被多个人抢答</strong></h3><p>​    <strong>利用redis来实现乐观锁（抢答）</strong>，好处是答错的人不影响状态，第一个秒杀答对的人才能得分。</p><p>1、利用redis的watch功能，监控这个 Corp:Activ:Qust: 的状态值<br>2、获取Corp:Activ:Qust: 的值，创建redis事务，给这个key的值-1<br>3、执行这个事务，如果key的值被修改过则回滚，key不变</p><h3 id="4、如何管理昵称重复"><a href="#4、如何管理昵称重复" class="headerlink" title="4、如何管理昵称重复"></a><strong>4、如何管理昵称重复</strong></h3><p>​    <strong>使用布隆过滤器：</strong></p><p>​    它实际上是一个很长的二进制矢量数组和 K 个哈希函数。当一个昵称加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。 Na</li></ul><p>​    用户新增昵称时需要首先计算K个哈希值，如果K个哈希值有一个不为0则通过，否则不通过，不通过时通过加随机字符串再次检验，检测通过后返回给前端，帮助用户自动填写。</p><p>​    布隆过滤器的好处是它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>BloomFilter 的优势是，全内存操作，性能很高。另外空间效率非常高，<strong>要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1/10，即平均单条记录占用 1.8 字节，误判率可以达到 1/1000；平均单条记录占用 2.4 字节，误判率可以到 1/10000，以此类推</strong>。这里的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0</p><p>​        </p><h3 id="5、如何管理出题定时任务"><a href="#5、如何管理出题定时任务" class="headerlink" title="5、如何管理出题定时任务"></a><strong>5、如何管理出题定时任务</strong></h3><p>​    压测环境中服务器通过Netty的主从Reactor多路复用NIO事件模型，单机可以<strong>轻松应对十万长连接</strong>，但是每个业务中，由于每个用户登录系统后需要按照指定顺序答题，例如一共要答十道，那么服务器针对这一个用户就会产生十个定时任务，所以对于系统来说，定时器的<strong>数量就是百万级别的</strong>。</p><p>​    通过压测结果发现：JDK自带的Timer，在大概三万并发时性能就急剧下降了。也是此时根据业务场景的需要，将定时任务改成了Netty自带的HashedWheelTimer时间轮方案，通过压测单机在50万级别下依然能够平滑的执行。</p><p>​    也是这个强烈的反差，使我在强烈的好奇心促使下，阅读源码了解到常规的JDK 的Timer 和 DelayedQueue 等工具类，可实现简单的定时任务，单底层用的是<strong>堆数据结构</strong>，存取复杂度都是 <strong>O(NlogN)</strong>，无法支撑海量定时任务。<strong>Netty经典的时间轮方案</strong>，正是通过将任务存取及取消操作时间复杂度降为 O(1)，而广泛应用在定时<strong>任务量大、性能要求高</strong>的场景中。</p><p>​    <img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvl9c3hp2j30py0d7q4i.jpg" alt="img" style="zoom:50%;"></p><p>​    基于Netty的Websocket底层，服务器端维护一个高效批量管理定时任务的调度模型。时间轮一般会实现成一个<strong>环形数组结构</strong>，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用<strong>双向链表</strong>存储定时任务。指针<strong>周期性地跳动</strong>，跳动到一个槽位，就执行该槽位的定时任务。</p><p>​    单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，可以考虑使用多级时间轮以及持久化存储与时间轮结合的方案。时间轮的<strong>定时任务处理逻辑</strong>如下：</p><ol><li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中</li><li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务，从链表头部开始迭代：<ul><li>属于当前时钟周期则取出运行</li><li>不属于则将其剩余的时钟周期数减一</li></ul></li><li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。</li></ol><h3 id="6：如何解决客户端断连"><a href="#6：如何解决客户端断连" class="headerlink" title="6：如何解决客户端断连"></a><strong>6：如何解决客户端断连</strong></h3><p>​    使用Netty的<strong>重连检测狗</strong>ConnectionWatchdog</p><p>​    服务端定义refreshTime，当我们从channel中read到了服务端发来的心跳响应消息的话，就刷新refreshTime为当前时间</p><p>​    客户端在state是WRITER_IDLE的时候每隔一秒就发送一个心跳包到sever端，告诉server端我还活着。</p><p>当重连成功时，会触发channelActive方法，在这里我们开启了一个定时任务去判断refreshTime和当前时间的时间差，超过5秒说明断线了，要进行重连，最后计算重连次数，尝试连接2次以上连不上就会修改header信息强制重连去连另一个服务器。</p><h2 id="二、秒杀项目"><a href="#二、秒杀项目" class="headerlink" title="二、秒杀项目"></a>二、秒杀项目</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h3><p>秒杀用到的基础组件，主要有<strong>框架、KV 存储、关系型数据库、MQ</strong>。</p><p>框架主要有 Web 框架和 RPC 框架。</p><p>其中，Web 框架主要用于提供 HTTP 接口给浏览器访问，所以 Web 框架的选型在秒杀服务中非常重要。在这里，我<strong>推荐Gin</strong>，它的性能和易用性都不错，在 <strong>GitHub 上的 Star 达到了 44k</strong>。对比性能最好的 fasthttp，虽然 fasthttp 在请求延迟低于 10ms 时性能优势明显，但其底层使用的对象池容易让人踩坑，导致其易用性较差，所以没必要过于追求性能而忽略了稳定性</p><p>至于 RPC 框架，我推荐选用 <strong>gRPC</strong>，因为它的扩展性和性能都非常不错。在秒杀系统中，Redis 中的数据主要是给秒杀接口服务使用，以便将配置从管理后台同步到 Redis 缓存中。</p><p>KV 存储方面，秒杀系统中主要是用 <strong>Redis 缓存活动配置</strong>，用 <strong>etcd 存储集群信息</strong>。</p><p>关系型数据库中，<strong>MySQL</strong> 技术成熟且稳定可靠，秒杀系统用它存储活动配置数据很合适。主要 原因还是秒杀活动信息和库存数据都缓存在 Redis 中，活动过程中秒杀服务不操作数据库， 使用 MySQL 完全能够满足需求。</p><p>MQ 有很多种，其中 <strong>Kafka</strong> 在业界认可度最高，技术也非常成熟，性能很不错，非常适合用在秒杀系统中。Kafka 支持自动创建队列，秒杀服务各个节点可以用它自动创建属于自己的队列</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p><strong>背景</strong></p><ul><li>秒杀业务简单，每个秒杀活动的商品是事先定义好的，商品有明确的类型和数量，卖完即止<br>-<br>秒杀活动定时上架，消费者可以在活动开始后，通过秒杀入口进行抢购秒杀活动</li></ul><p>-<br>  秒杀活动由于商品物美价廉，开始售卖后，会被快速抢购一空。</p><p><strong>现象</strong></p><p>-<br>  秒杀活动持续时间短，访问冲击量大，秒杀系统需要应对这种爆发性的访问模型</p><p>-<br>  业务的请求量远远大于售卖量，大部分是陪跑的请求，秒杀系统需要提前规划好处理策略</p><p>-<br>  前端访问量巨大，系统对后端数据的访问量也会短时间爆增，对数据存储资源进行良好设计</p><p>-<br>  活动期间会给整个业务系统带来超大负荷，需要制定各种策略，避免系统过载而宕机</p><p>-<br>  售卖活动商品价格低廉，存在套利空间，各种非法作弊手段层出，需要提前规划预防策略</p><p><strong>秒杀系统设计</strong></p><p>​    首先，要<strong>尽力将请求拦截在系统上游</strong>，层层设阻拦截，过滤掉无效或超量的请求。因为访问量远远大于商品数量，所有的请求打到后端服务的最后一步，其实并没有必要，反而会严重拖慢真正能成交的请求，降低用户体验。</p><p>​    秒杀系统专为秒杀活动服务，售卖商品确定，因此可以在设计秒杀商品页面时，将商品信息提前设计为静态信息，将静态的商品信息以及常规的 CSS、JS、宣传图片等静态资源，一起<strong>独立存放到 CDN 节点</strong>，加速访问，且降低系统访问压力，在访问前端也可以<strong>制定种种限制策略，</strong>比如活动没开始时，抢购按钮置灰，避免抢先访问，用户抢购一次后，也将按钮置灰，让用户排队等待，避免反复刷新。</p><p>​    其次，要<strong>充分利用缓存</strong>，提升系统的性能和可用性。</p><p>​    用户所有的请求进入秒杀系统前，通过<strong>负载均衡策略</strong>均匀分发到不同 Web 服务器，避免节点过载。在 Web 服务器中，首先检查用户的访问权限，识别并发刷订单的行为。如果发现售出数量已经达到秒杀数量，则直接返回结束，要将秒杀业务系统和其他业务系统进行功能分拆，尽量将秒杀系统及依赖服务<strong>独立分拆部署</strong>，避免影响其他核心业务系统。</p><p>​    秒杀系统需要构建访问记录缓存，记录访问 IP、用户的访问行为，发现异常访问，提前进行阻断及返回。同时还需要<strong>构建用户缓存</strong>，并针对历史数据分析，提前缓存僵尸强刷专业户，方便在秒杀期间对其进行策略限制。这些访问记录、用户数据，通过缓存进行存储，可以加速访问，另外，对用户数据还进行缓存预热，避免活动期间大量穿透。</p><h3 id="1、如何解决超卖？"><a href="#1、如何解决超卖？" class="headerlink" title="1、如何解决超卖？"></a><strong>1、如何解决超卖？</strong></h3><p>mysql乐观锁+redis预减库存+redis缓存卖完标记</p><p>第一是基于<strong>数据库乐观锁</strong>的方式保证数据并发扣减的强一致性；</p><p>第二是基于<strong>数据库的事务</strong>实现批量扣减部分失败时的数据回滚。</p><p>​    在扣减指定数量前应先做一次前置数量校验的读请求（参考<strong>读写分离</strong> + <strong>全缓存方案</strong>）</p><blockquote><p>纯数据库乐观锁+事务的方式性能比较差，但是如果不计成本和考虑场景的话也完全够用，因为任何没有机器配置的指标，都是耍流氓。如果我采用 Oracle 的数据库、100 多核的刀锋服务器、SSD 的硬盘，即使是纯数据库的扣减方案，也是可以达到单机上万的 TPS 的。</p></blockquote><p><strong>单线程Redis 的 lua 脚本实现批量扣减</strong></p><p>当用户调用扣减接口时，将扣减的 对应数量 + 脚本标示传递至 Redis 即可，所有的扣减判断逻辑均在 Redis 中的 lua 脚本中执行，lua 脚本执行完成之后返还是否成功给客户端。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j9dkq6vj30w20kowku.jpg" alt="image-20210504174103769" style="zoom:50%;"></p><p>Redis 中的 lua 脚本执行时，首先会使用 get 命令查询 uuid 进行查重。当防重通过后，会<strong>批量获取对应的剩余库存状态并进行判断</strong>，如果一个扣减的数量大于剩余数量，则返回错误并提示数量不足。</p><p>Redis 的单线程模型，确保<strong>不会出现当所有扣减数量在判断均满足后，在实际扣减时却数量不够</strong>。同时，单线程保证判断数量的步骤和后续扣减步骤之间，没有其他任何线程出现并发的执行。</p><p>当 Redis 扣减成功后，扣减接口会<strong>异步的将此次扣减内容保存至数据库</strong>。异步保存数据库的目的是防止出现极端情况—— Redis 宕机后数据未持久化到磁盘，此时我们可以使用数据库恢复或者校准数据</p><p>最后，运营后台直连数据库，是运营和商家修改库存的入口。商家在运营后台进货物进行补充。同时，运营后台的实现需要将此数量<strong>同步的增加至 Redis</strong>，因为当前方案的所有实际扣减都在 Redis 中</p><blockquote><p>纯缓存方案虽<strong>不会导致超卖</strong>，但因<strong>缓存不具备事务特性</strong>，极端情况下会存在缓存里的数据<strong>无法回滚</strong>，导致出现<strong>少卖</strong>的情况。且架构中的异步写库，也可能发生失败，导致多扣的数据丢失</p></blockquote><p>可以借助<strong>顺序写</strong>的特性，将扣减任务同步<strong>插入</strong>任务表，发现异常时，将任务表作为<strong>undolog</strong>进行回滚</p><p>可以解决由于<strong>网络不通</strong>、调用缓存<strong>扣减超时</strong>、在扣减到一半时缓存<strong>突然宕机</strong>（故障 failover）了。针对上述请求，都有相应的异常抛出，根据异常进行<strong>数据库回滚</strong>即可，最终任务库里的数据都是准的</p><p>更进一步：由于任务库是无状态的，可以进行水平分库，提升整体性能</p><h3 id="2、如何解决重复下单？"><a href="#2、如何解决重复下单？" class="headerlink" title="2、如何解决重复下单？"></a><strong>2、如何解决重复下单？</strong></h3><p>mysql唯一索引+分布式锁</p><h3 id="3、如何防刷？"><a href="#3、如何防刷？" class="headerlink" title="3、如何防刷？"></a><strong>3、如何防刷？</strong></h3><p>IP限流 | 验证码 | 单用户 | 单设备 | IMEI | 源IP |均设置规则</p><h3 id="4、热key问题如何解决？"><a href="#4、热key问题如何解决？" class="headerlink" title="4、热key问题如何解决？"></a><strong>4、热key问题如何解决？</strong></h3><p>redis集群+本地缓存+限流+key加随机值分布在多个实例中</p><p>1、<strong>缓存集群</strong>可以单节点进行<strong>主从复制和垂直扩容</strong></p><p>2、利用应用内的<strong>前置缓存</strong>，但是需注意需要设置上限</p><p>3、延迟不敏感，<strong>定时刷新</strong>，实时感知用主动刷新</p><p>4、和缓存穿透一样，限制逃逸流量，单请求进行数据<strong>回源并刷新前置</strong></p><p>5、无论如何设计，最后都要写一个<strong>兜底逻辑</strong>，千万级流量说来就来</p><h3 id="5、应对高并发的读请求"><a href="#5、应对高并发的读请求" class="headerlink" title="5、应对高并发的读请求"></a><strong>5、应对高并发的读请求</strong></h3><p>使用缓存策略将请求挡在上层中的缓存中</p><p>使用CDN，能静态化的数据尽量做到静态化，</p><p>加入限流（比如对短时间之内来自某一个用户，某一个IP、某个设备的重复请求做丢弃处理）</p><p><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。</p><ul><li><p>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</p></li><li><p>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</p></li><li><p>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</p></li><li><p>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</p><p>流量控制效果从好到差依次是：<strong>漏桶限流 &gt; 令牌桶限流 &gt; 滑动窗口限流 &gt; 计数器限流</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ja736ekj316o06640u.jpg" alt="image-20210504174148831" style="zoom:50%;"></p><p>其中，只有漏桶算法<strong>真正实现了恒定速度处理请求</strong>，能够绝对<strong>防止突发流量超过下游系统承载能力</strong>。<br>不过，漏桶限流也有个不足，就是需要分<strong>配内存资源缓存请求</strong>，这会增加内存的使用率。而<strong>令牌桶限流</strong>算法中的“桶”可以用一个整数表示，<strong>资源占用相对较小</strong>，这也让它成为最常用的限流算法。正是因为这些特点，<strong>漏桶限流和令牌桶限流</strong>经常在一些大流量系统中结合使用。</p></li></ul><h3 id="6、应对高并发的写请求"><a href="#6、应对高并发的写请求" class="headerlink" title="6、应对高并发的写请求"></a><strong>6、应对高并发的写请求</strong></h3><ul><li><p><strong>削峰</strong>：恶意用户拦截</p><p>对于单用户多次点击、单设备、IMEI、源IP均设置规则</p></li><li><p>采用比较成熟的<strong>漏桶算法、令牌桶</strong>算法，也可以使用<strong>guava</strong>开箱即用的限流算法</p><p>可以集群限流，但单机限流更加简洁和稳定</p></li><li><p>当前层<strong>直接过滤</strong>一定比例的请求，最大承载值前需要加上<strong>兜底逻辑</strong></p></li><li><p>对于已经无货的产品，<strong>本地缓存</strong>直接返回</p></li><li><p><strong>单独部署，减少对系统正常服务的影响，方便扩缩容</strong></p></li></ul><p>对于<strong>一段时间内的秒杀活动，需要保证写成功</strong>，我们可以使用 <strong>消息队列</strong>。</p><ul><li>削去秒杀场景下的峰值写流量——<strong>流量削峰</strong></li><li>通过异步处理简化秒杀请求中的业务流程——<strong>异步处理</strong></li><li>解耦，实现秒杀系统模块之间松耦合——<strong>解耦</strong></li></ul><p><strong>削去秒杀场景下的峰值写流量</strong></p><ul><li><strong>将秒杀请求暂存于消息队列</strong>，业务服务器响应用户“秒杀结果正在处理中。。。”，释放系统资源去处理其它用户的请求。</li><li><strong>削峰填谷</strong>，削平短暂的流量高峰，消息堆积会造成请求延迟处理，但秒杀用户对于短暂延迟有一定容忍度。秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到秒杀的结果，这是可以接受的。这时会<strong>并发 10 个</strong>请求到达数据库，并不会对数据库造成很大的压力。</li></ul><p><strong>通过异步处理简化秒杀请求中的业务流程</strong></p><p>​    先处理主要的业务，异步处理次要的业务。</p><ul><li>如主要流程是<strong>生成订单</strong>、<strong>扣减库存</strong>；</li><li>次要流程比如购买成功之后会给用户<strong>发优惠券</strong>，<strong>增加用户的积**</strong>分**。</li><li>此时秒杀只要处理生成订单，扣减库存的耗时，发放优惠券、增加用户积分异步去处理了。</li></ul><p><strong>解耦</strong></p><p>​    实现秒杀系统模块之间松耦合将秒杀数据同步给数据团队，有两种思路：</p><ul><li>使用 HTTP 或者 RPC 同步调用，即提供一个接口，实时将数据推送给数据服务。<strong>系统的耦合度高</strong>，如果其中一个服务有问题，可能会导致另一个服务不可用。</li><li>使用消息队列<strong>将数据全部发送给消息队列</strong>，然后<strong>数据服务订阅这个消息队列</strong>，接收数据进行处理。</li></ul><h3 id="7、如何保证数据一致性"><a href="#7、如何保证数据一致性" class="headerlink" title="7、如何保证数据一致性"></a><strong>7、如何保证数据一致性</strong></h3><p><strong>CacheAside旁路缓存</strong>读请求不命中查询数据库，查询完成写入缓存，写请求更新数据库后删除缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">redis.delKey(key);</span><br><span class="line">db.updateData(data);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为防缓存失效这一信息丢失，可用消息队列确保。</p><ul><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>另起一段非业务代码，程序订阅提取出所需要的数据以及key；</li><li>尝试删除缓存操作，若删除失败，将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作；</li></ul><p>订阅<strong>binlog程序在mysql中有现成的中间</strong>件叫canal，重试机制，主要采用的是消息队列的方式。</p><p><strong>终极方案：请求串行化</strong></p><p>真正靠谱非秒杀的方案：将访问操作串行化</p><ol><li>先删缓存，将更新数据库的<strong>写操作放进有序队列中</strong></li><li>从缓存查不到的<strong>读操作也进入有序队列</strong></li></ol><p>需要解决的问题：</p><ol><li>读请求积压，大量超时，导致数据库的压力：限流、熔断</li><li>如何避免大量请求积压：将队列水平拆分，提高并行度。</li></ol><h3 id="8、可靠性如何保障"><a href="#8、可靠性如何保障" class="headerlink" title="8、可靠性如何保障**"></a>8、可靠性如何保障**</h3><p>​    由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;"></p><p>​    当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p><h3 id="9、秒杀系统瓶颈-日志"><a href="#9、秒杀系统瓶颈-日志" class="headerlink" title="9、秒杀系统瓶颈-日志"></a>9、秒杀系统瓶颈-日志</h3><blockquote><p>秒杀服务单节点需要处理的请求 QPS 可能达到 10 万以上。一个请求从进入秒杀服务到处理失败或者成功，至少会产生两条日志。也就是说，高峰期间，一个秒杀节点每秒产生的日志可能达到 <strong>30 万条</strong>以上</p></blockquote><p>​    一块性能比较好的固态硬盘，每秒写的IOPS 大概在 3 万左右。也就是说，一个秒杀节点的每秒日志条数是固态硬盘 IOPS 的 10 倍，磁盘都扛不住，更别说通过网络写入到监控系统中。</p><ul><li><strong>每秒日志量远高于磁盘 IOPS</strong>，直接写磁盘会影响服务性能和稳定性</li><li>大量日志导致服务频繁分配，<strong>频繁释放内存，影响服务性能</strong>。</li><li>服务异常退出<strong>丢失大量日志</strong>的问题</li></ul><p><strong>解决方案</strong></p><ul><li><strong>Tmpfs</strong>，即临时文件系统，它是一种基于内存的文件系统。我们可以将秒杀服务写日志的文件放在临时文件系统中。相比直接写磁盘，在临时文件系统中写日志的性能至少<strong>能提升 100 倍</strong>，每当日志文件达到 20MB 的时候，就将<strong>日志文件转移到磁盘上</strong>，并将临时文件系统中的日志文件清空。</li><li>可以参考内存池设计，将给logger分配缓冲区，每一次的新写可以复用Logger对象</li><li>参考kafka的缓冲池设计，当缓冲区达到大小和间隔时长临界值时，调用Flush函数，减少丢失的风险</li></ul><p><strong>10、池化技术</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6japwof2j31520na4mh.jpg" alt="image-20210504174220668" title class>                <p>image-20210504174220668</p>            </figure><p>​    通常可以采用<strong>循环队列</strong>来保存空闲连接。使用的时候，可以从队列头部取出连接，用完后将空闲连接放到队列尾部。Netty中利用带缓冲区的 channel 来充当队列。</p><h2 id="三、即时通信"><a href="#三、即时通信" class="headerlink" title="三、即时通信"></a>三、即时通信</h2><h3 id="1、单聊消息可靠传输"><a href="#1、单聊消息可靠传输" class="headerlink" title="1、单聊消息可靠传输"></a>1、<strong>单聊消息可靠传输</strong></h3><p>TCP保证消息可靠传输三板斧：超时、重传、确认。服务端和客户端通信MSG和ACK的共计6个报文</p><ul><li>请求报文（request，后简称为为R），客户端主动发送给服务端。</li><li>应答报文（acknowledge，后简称为A），服务器被动应答客户端的报文。</li><li>通知报文（notify，后简称为N），服务器主动发送给客户端的报文</li></ul><p><strong>在线消息流程：</strong></p><p>​        A 消息请求  <strong>MSG:R</strong>  =&gt; S 消息应答  <strong>MSG:A</strong>  =&gt; S 消息通知B  <strong>MSG:N</strong></p><p>​        S 确认通知  <strong>ACK:N</strong>  &lt;=  S 确认应答  <strong>ACK:A</strong>  &lt;=  B确认请求S  <strong>ACK:R</strong></p><p><strong>超时与重传、确认和去重：</strong></p><p>​    A发出了 <strong>MSG:R</strong> ，收到了<strong>MSG:A</strong>之后，在一个期待的时间内，如果没有收到<strong>ACK:N</strong>，A会尝试将 <strong>MSG:R</strong>  重发。可能A同时发出了很多消息，所以A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到<strong>ACK:N</strong>，定时重发。确认ACK<strong>保证必达</strong>，去重保证<strong>唯一</strong></p><p><strong>离线消息流程</strong></p><p>​    原方案：根据离线好友的标识，交互拉取指定的消息</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8kxci29zj30b305974z.jpg" alt="IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png" title class>                <p>IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png</p>            </figure><p>优化的方案：</p><ul><li>如用户<strong>勾选全量</strong>则返回计数，在用户点击时拉取。</li><li>如用户未勾选全量则返回<strong>最近全部离线消息</strong>，客户端针对<strong>用户id进行计算</strong>。</li><li>全量离线信息可以通过客户端异步线程分页拉取，减少卡顿</li><li>将ACK和分页第二次拉取的报文重合，可以较少离线消息拉取交互的次数</li></ul><h3 id="2、群聊消息如何保证不丢不重"><a href="#2、群聊消息如何保证不丢不重" class="headerlink" title="2、群聊消息如何保证不丢不重"></a><strong>2、群聊消息如何保证不丢不重</strong></h3><blockquote><p>在线的群友能第一时间收到消息；<br>离线的群友能在登陆后收到消息。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8jswr3poj30hh078dg2.jpg" alt="IM群聊消息如此复杂，如何保证不丢不重？_1.jpg"></p><ul><li>群消息发送者x向server发出群消息；</li><li>server去db中查询群中有多少用户(x,A,B,C,D)；</li><li>server去cache中查询这些用户的在线状态；</li><li>对于群中在线的用户A与B，群消息server进行实时推送；</li><li>对于群中离线的用户C与D，群消息server进行离线存储。</li></ul><p>​    对于同一份群消息的内容，多个离线用户存储了很多份。假设群中有200个用户离线，离线消息则冗余了200份，这极大的增加了数据库的存储压力</p><ul><li>离线消息表只存储用户的群离线消息msg_id，降低数据库的冗余存储量</li><li>加入应用层的ACK，才能保证群消息一定到达，服务端幂等性校验及客户端去重，保证不重复</li><li><p>每条群消息都ACK，会给服务器造成巨大的冲击，通过批量ACK减少消息风暴扩散系数的影响</p></li><li><p>群离线消息过多：拉取过慢，可以通过分页懒拉取改善。</p></li></ul><h3 id="3、如何保证消息的时序性"><a href="#3、如何保证消息的时序性" class="headerlink" title="3、如何保证消息的时序性"></a>3、<strong>如何保证消息的时序性</strong></h3><p>方案：</p><ul><li>Id通过借鉴微信号段+跳跃的方式保证趋势递增</li><li>单聊借鉴数据库设计，单点序列化同步到其他节点保证多机时序</li><li>群聊消息使用单点序列化保证各个发送者的消息相对时序</li></ul><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8m1ge2ksj30j707gt96.jpg" alt="如何保证IM实时消息的“时序性”与“一致性”？_10.jpg" title class>                <p>如何保证IM实时消息的“时序性”与“一致性”？_10.jpg</p>            </figure><p>优化：</p><ul><li>利用服务器单点序列化时序，可能出现服务端收到消息的时序，与发出序列不一致</li><li>在A往B发出的消息中，加上发送方A本地的一个绝对时序，来表示接收方B的展现时序。</li><li>群聊消息保证一个群聊落在一个service上然后通过本地递增解决全局递增的瓶颈问题</li></ul><h3 id="4：推拉结合"><a href="#4：推拉结合" class="headerlink" title="4：推拉结合"></a><strong>4：推拉结合</strong></h3><p>历史方案：</p><ul><li>服务器在缓存集群里存储所有用户的在线状态 -&gt; 保证状态可查</li><li>用户状态实时变更，任何用户登录/登出时，需要推送所有好友更新状态</li><li>A登录时，先去数据库拉取自己的好友列表，再去缓存获取所有好友的在线状态</li></ul><p><strong>“消息风暴扩散系数”</strong>是指一个消息发出时，变成N个消息的扩散系数，这个系数与业务及数据相关，一定程度上它的大小决定了技术采用推送还是拉取。</p><p>优化方案：</p><ul><li><strong>好友状态推拉结合</strong>，首页置顶亲密、当前群聊，采用推送，否则可以采用轮询拉取的方式同步；</li><li><strong>群友的状态</strong>，由于消息风暴扩散系数过大，可以采用按需拉取，延时拉取的方式同步；</li><li><strong>系统消息/开屏广告等</strong>这种实时产生的消息，可以采用推送的方式获取消息；</li></ul><h3 id="5、好友推荐"><a href="#5、好友推荐" class="headerlink" title="5、好友推荐"></a>5、好友推荐</h3><p>Neo4j 图谱数据库</p><h2 id="四、智慧社区"><a href="#四、智慧社区" class="headerlink" title="四、智慧社区"></a>四、智慧社区</h2><p>​    18年初，针对我们Dubbo框架的智慧楼宇项目的单体服务显得十分笨重，需要采用微服务的形式进行架构的重新设计，当时，我阅读了<em>Eric Evans</em> 写的《领域驱动设计：软件核心复杂性应对之道》和<em>Martin</em> <em>fowler</em>的《微服务架构：<em>Microservice</em>》两本重量级书籍，书中了解到转型微服务的重要原因之一就是利用<strong>分治的思想</strong>减少系统的复杂性，是一种针对<strong>复杂问题的宏观设计</strong>，来应对系统后来规模越来越大，维护越来越困难的问题。然而，拆分成微服务以后，并<strong>不意味着每个微服务都是各自独立地运行</strong>，而是彼此协作地组织在一起。这就好像一个团队，<strong>规模越大越需要一些方法来组织</strong>，这正是我们需要DDD模型为我们的架构设计提供理论并实践的方法。</p><p>​    当时每次版本更新迭代动辄十几个微服务同时修改，有时一个简单的数据库字段变更，也需要同时变更多个微服务，引起了团队的反思：微服务化看上去并没有减少我们的工作量。《企业架构设计》中对于微服务的定义是<strong>小而专</strong>，但在起初的设计时，我们只片面的<strong>理解了小却忽视了专</strong>，此时我们才意识到拆分的关键是要保证微服务内高内聚，微服务间低耦合。</p><h3 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a><strong>物联网架构</strong></h3><blockquote><p>物联网是互联网的<strong>外延</strong>。将用户端<strong>延伸</strong>和扩展到物与人的连接。物联网模式中，所有<strong>物品与网络连接</strong>，并进行通信和场景联动。互联网通过<strong>电脑、移动终端</strong>等设备将参与者联系起来，形成的一种全新的<strong>信息互换方式</strong></p></blockquote><h4 id="DCM系统架构"><a href="#DCM系统架构" class="headerlink" title="DCM系统架构"></a>DCM系统架构</h4><ul><li><strong>设备感知层</strong>（Device）：利用射频识别、二维码、传感器等技术进行数据采集</li><li><strong>网络传输层</strong>（Connect）：依托通信网络和协议，实现可信的信息交互和共享</li><li><strong>应用控制层</strong>（Manage）：分析和处理海量数据和信息，实现智能化的决策和控制</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jc1stt3j31380lswso.jpg" alt="image-20210504174337327" style="zoom:50%;"></p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h4><ul><li><strong>设备联网</strong>：通过不同的网络协议和通信标准，实现设备与控制端的连接</li><li><strong>云端分析</strong>：提供监控、存储、分析等数据服务，以及保障客户的业务数据安全</li><li><strong>云边协同</strong>：云端接受设备上报数据，下发设备管控指令</li></ul><h4 id="云-边-端协同"><a href="#云-边-端协同" class="headerlink" title="云 / 边 / 端协同"></a>云 / 边 / 端协同</h4><p><strong>云端计算</strong>、<strong>终端计算</strong>和<strong>边缘计算</strong>是一个协同的系统，根据用户场景、资源约束程度、业务实时性等进行动态调 配，形成可靠、低成本的应用方案。从过去几年的发展积累来看，AI 已在物联网多个层面进行融合，比我们合作的海康威视、旷视宇视、商汤科技等纷纷发布了物联网AI相关平台和产品，和移动和小区进行了紧密的融合。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9kwux9vjj312w0li138.jpg" alt="image-20210202225351673" style="zoom:50%;"></p><h4 id="物联网平台接入"><a href="#物联网平台接入" class="headerlink" title="物联网平台接入"></a>物联网平台接入</h4><p><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/3199158061/p132750.png" alt="企业基于物联网平台的业务链路" style="zoom:50%;"></p><p>向下连接海量设备，支撑设备<strong>数据采集上云</strong>；</p><p>向上通过调用<strong>云端API</strong>将指令下发至设备端，实现<strong>远程控制</strong>。</p><p><strong>上行数据链路</strong></p><ul><li>设备建立<strong>MQTT</strong>长连接，上报数据（发布Topic和Payload）到物联网平台</li><li>物联网平台通过<strong>配置</strong>规则，通过<strong>RocketMQ</strong>、<strong>AMQP</strong>等队列转发到业务平台</li></ul><p><strong>下行指令链路</strong></p><ul><li>业务服务器基于<strong>HTTPS</strong>协议调用的API接口，发布Topic指令到物联网平台。</li><li>物联网平台通过<strong>MQTT</strong>协议，使用发布（指定Topic和Payload）到<strong>设备端</strong>。</li></ul><h4 id="门锁接入"><a href="#门锁接入" class="headerlink" title="门锁接入"></a>门锁接入</h4><p><strong>WIFI门锁</strong>：<strong>非保活</strong> 平常处于断电休眠状态，需要<strong>MCU</strong> <strong>唤醒</strong>才能传输和发送数据</p><p><strong>蓝牙门锁</strong>：<strong>MCU串口对接</strong>和<strong>SDK对接</strong>，近距离<strong>单点登录</strong>和远距离<strong>网关登录</strong></p><p><strong>Zigbee门锁</strong>：<strong>非保活</strong> 但是保持心跳，<strong>MCU</strong>对接，<strong>Zigbee协议</strong>控制。</p><p><strong>NB-Iot门锁</strong>：可以通过<strong>公网</strong>连接，把门禁变成<strong>SAAS</strong>服务，<strong>MCU</strong></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Software-as-a-Service</strong> ，提供给客户的服务是运营商运行在云计算基础设施上的应用程序。<strong>用户可以在各种设备上通过客户端界面访问应用</strong>，例如计算机浏览器。用户不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等资源，一切由 SaaS 提供商管理和运维。</td></tr><tr><td><strong>PaaS</strong></td><td><strong>Platform-as-a-Service</strong>，表示平台即服务理念，客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但<strong>客户能控制部署的应用程序</strong>，也可能控制运行应用程序的托管环境配置。</td></tr><tr><td><strong>IaaS</strong></td><td>I<strong>nfrastructure-as-a-Service</strong> ，表示基础设施即服务理念，提供的服务是对所有计算基础设施的利用，包括 CPU、内存、存储、网络等其它计算资源。<strong>用户能够部署和运行任意软件，包括操作系统和应用程序。</strong></td></tr></tbody></table><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><p><strong>HTTP协议（CS用户上网）</strong></p><p>HTTP协议是典型的CS通讯模式，由<strong>客户端主动</strong>发起连接，向服务器请求<strong>XML或JSON数据</strong>。该协议最早是为了适用web浏览器的<strong>上网浏览场景</strong>和设计的，目前在<strong>PC、手机、pad</strong>等终端上都应用广泛，但并<strong>不适用于物联网场景</strong></p><ul><li>由于必须由设备主动向服务器发送数据，难以主动向设备推送数据。</li><li>物联网场景中的<strong>设备多样</strong>，运算<strong>受限的设备</strong>，难以实现JSON数据格式的解析</li></ul><p><strong>RESTAPI（松耦合调用）</strong></p><p>REST/HTTP主要为了<strong>简化</strong>互联网中的系统架构，<strong>快速实现</strong>客户端和服务器之间交互的<strong>松耦合</strong>，降低了客户端和服务器之间的<strong>交互延迟</strong>。因此适合在物联网的应用层面，通过REST<strong>开放</strong>物联网中资源，实现服务被其他应用所调用。</p><p><strong>CoAP协议（无线传感）</strong></p><blockquote><p>简化了HTTP协议的<strong>RESTful API</strong>，它适用于在<strong>资源受限</strong>的通信的IP网络。</p></blockquote><p><strong>MQTT协议（低带宽）</strong></p><blockquote><p>MQTT协议采用<strong>发布/订阅</strong>模式，物联网终端都通过TCP连接到云端，云端通过主题的方式管理各个设备关注的通讯内容，<strong>负责</strong>将设备与设备之间<strong>消息的转发</strong></p></blockquote><p>适用范围：在低带宽、不可靠的集中<strong>星型网络架构</strong>（hub-and-spoke），不适用设备与设备之间通信，设备<strong>控制能力弱</strong>，另外<strong>实时性较差</strong>，一般都在<strong>秒级</strong>。协议要<strong>足够轻量</strong>，方便嵌入式设备去快速地解析和响应。具备<strong>足够的灵活性</strong>，使其足以为 IoT 设备和服务的多样化提供支持。应该设计为<strong>异步消息协议</strong>，这么做是因为大多数 IoT 设备的网络延迟很可能非常不稳定，若使用同步消息协议，IoT 设备需要等待服务器的响应，必须是<strong>双向通信</strong>，服务器和客户端应该可以互相发送消息。</p><p><strong>AMQP协议（互操作性）</strong></p><blockquote><p>用于业务系统例如PLM，ERP，MES等进行数据交换。</p></blockquote><p>　　适用范围：最早应用于金融系统之间的交易消息传递，在物联网应用中，主要适用于移动手持设备与后台数据中心的通信和分析。</p><p><strong>XMPP协议（即时通信）</strong></p><blockquote><p>开源形式组织产生的网络即时通信协议。被IETF国际标准组织完成了标准化工作</p></blockquote><p>　　适用范围：<strong>即时通信</strong>的应用程序，还能用在<strong>协同工具</strong>、游戏等。</p><p>​    XMPP在通讯的业务流程上是更适合物联网系统的，开发者不用花太多心思去解决设备通讯时的业务通讯流程，相对开发成本会更低。但是HTTP协议中的安全性以及计算资源消耗的硬伤并没有得到本质的解决。</p><p><strong>JMS （Java消息服务）</strong></p><p>​    Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p><strong>Zigbee协议</strong></p><p>​    低功耗，它保持IEEE 802.15.4（2003）标准</p><h3 id="IOT流量洪峰"><a href="#IOT流量洪峰" class="headerlink" title="IOT流量洪峰"></a>IOT流量洪峰</h3><p>智慧社区IOT领域，不管是嵌入式芯片还是应用服务器都需要传递消息，常见上行的消息有：<strong>人脸识别开门、烟感雾感告警</strong>、共享充电桩充电，下行的<strong>广告下发、NB门禁开门指令、</strong>超级门板显示等，由于物联网设备时不时会<strong>故障和断网导致大量的流量洪峰</strong>，传统消息队列需要针对性优化。</p><ul><li><p><strong>上下行拆分</strong></p><p>上行消息特征：并发量<strong>高</strong>、可靠性和<strong>时延性要求低</strong></p><p>下行消息特征：并发量<strong>低</strong>、控制指令的<strong>成功率要求高</strong></p></li><li><p><strong>海量Topic下性能</strong></p><p><strong>Kafka</strong>海量Topic性能会<strong>急剧下降</strong>，Zookeeper协调也有瓶颈</p><p><strong>多泳道消息队列</strong>可以实现IoT消息队列的故障<strong>隔离</strong></p></li><li><p><strong>实时消息优先处理</strong></p><p>NB门禁实时产生的开门指令必须<strong>第一优先级处理</strong>，堆积的消息降级</p><p>设计成<strong>无序、不持久化</strong>的，并与传统的FIFO队列隔离</p></li><li><p><strong>连接、计算、存储分离</strong></p><p>Broker只做<strong>流转分发</strong>，实现<strong>无状态</strong>和<strong>水平扩展</strong></p><p>计算交给<strong>Flink</strong>，存储交给nosqlDB，实现<strong>高吞吐写</strong></p></li><li><p><strong>消息策略-推拉结合</strong></p><p>MQTT针对电池类物联网设备，AMQP针对安全性较高的门禁设备</p><p>消费端离线时存到queue，在线时将<strong>实时消息和从queue中拉取的消息</strong>一起推送</p></li></ul><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goboitd4h2j30u00ciq3i.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>如果解决海量Topic</strong></p><p>​    首先要做的就是分区、分组等水平拆分的方式，接下来考虑单实例如何处理更多Topic，传统消息队列在海量Topic下顺序写会退化成随机写，性能大幅下降</p><ul><li><p><strong>人工Sharding</strong>：部署多个Kafka集群，通过不同mq连接来隔离</p></li><li><p><strong>合并Topic</strong>，客户端封装subTopic。比如一个服务的N个统计项，会消费到无关消息</p><p>​    基于这个思路，使用<strong>Kafka Streams</strong>或者<strong>Hbase列</strong>存储来聚合</p></li></ul><p>针对单个Topic海量订阅的问题，<strong>可以在上层封装广播组件来协调批量发送</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobohzda8fj30u00cgaax.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="社区直播带货"><a href="#社区直播带货" class="headerlink" title="社区直播带货"></a>社区直播带货</h3><blockquote><p>使用<strong>端 / 边 / 云</strong>三级架构，客户端加密传输，边缘节点转发、云侧转码并持久化</p></blockquote><h4 id="产品的背景"><a href="#产品的背景" class="headerlink" title="产品的背景"></a><strong>产品的背景</strong></h4><blockquote><p>上线时间，从调研到正式上线用了 3个月时间，上线后一个月内就要经历双十二挑战。在这么紧的上线时间要求下，需要用到公司提供的所有优势，包括<strong>cdn网络，直播牌照</strong>等</p></blockquote><h4 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h4><ul><li>直播数据是<strong>实时</strong>生成的，所有不能够进行<strong>预缓存</strong></li><li>直播随时会发生，举办热点活动，相关服务器资源需要<strong>动态分配</strong></li><li><p>直播的延迟对于用户体验影响很大，需要控制在<strong>秒级</strong></p></li><li><p>直播sdk是内嵌在社区应用里的，整体要求不能超过5M</p></li></ul><h4 id="协议的比较"><a href="#协议的比较" class="headerlink" title="协议的比较"></a>协议的比较</h4><table><thead><tr><th>协议</th><th>上线时间</th><th>网络兼容</th><th>端对端延迟</th><th>应用大小</th><th>问题</th></tr></thead><tbody><tr><td>WebRTC</td><td></td><td>✗</td><td></td><td></td><td>Webrtc 基于 UDP，和社区应用的网络架构不兼容</td></tr><tr><td>HTTP Upload</td><td></td><td></td><td>✗</td><td></td><td>会导致网络高延迟</td></tr><tr><td>Custom Protocol</td><td>✗</td><td></td><td></td><td></td><td>工程师需要实现自己的客户端与服务端的库，无法按时上线</td></tr><tr><td>Proprietary</td><td></td><td></td><td></td><td>✗</td><td>协议就需要几兆的空间，超出额度</td></tr><tr><td>RTMPS</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>TCP实时传输消息协议，更安全更可靠</td></tr></tbody></table><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><strong>RTMPS</strong>：基于TCP实时传输消息协议，更安全更可靠</p><p><strong>MPEG-DASH</strong>：是一种基于HTTP协议自适应比特率流媒体技术，应对复杂的环境</p><figure class="image-box">                <img src="https://i.loli.net/2021/01/25/zjwC7B8fdcpDytA.png" alt="image-20210125145103417" title class>                <p>image-20210125145103417</p>            </figure><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播数据到<strong>边缘节点</strong>（POP）</p></li><li><p>POP 使用<strong>RTMP</strong>发送数据到数据中心（DC）</p></li><li><p>DC 将数据编码成<strong>不同的清晰度</strong>并进行持久化存储</p><p><strong>云端转码</strong>主要有<strong>两种分辨率</strong>400x400 和 720x720.</p></li><li><p>播放端通过 <strong>MPEG-DASH</strong> / RTMPS 协议接收直播数据</p><p>如果用户网络不好<strong><a href="https://www.cloudflare.com/zh-cn/learning/video/what-is-mpeg-dash/" target="_blank" rel="noopener">MPEG-DASH</a></strong>会自动转换成低分辨率</p></li></ol><h4 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a><strong>直播流程</strong></h4><p><img src="https://i.loli.net/2021/01/25/GITnbhDqPdtZY2k.png" alt="image-20210125153606264" style="zoom:50%;"></p><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播流数据到 POP 内的就近的代理服务器</p></li><li><p>代理服务器<strong>转发</strong>直播流数据到数据中心的网关服务器（<strong>443转80</strong>）</p></li><li><p>网关服务器使用<strong>直播 id 的一致性哈希算法</strong>发送直播数据到指定的编码服务器</p></li><li><p>编码服务器有几项职责：</p><ul><li><p>4.1 <strong>验证直播数据</strong>的格式是否正确。</p></li><li><p>4.2 <strong>关联</strong>直播 id 以及编码服务器第一映射，保证客户端即使连接中断或者服务器扩容时，在<strong>重新连接</strong>的时候依然能够连接到相同的编码服务器</p></li><li><p>4.3 使用直播数据<strong>编码成不同解析度</strong>的输出数据</p></li><li><p>4.4 使用 <strong>DASH</strong> 协议输出数据并<strong>持久化</strong>存储</p></li></ul></li></ol><h4 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h4><p><img src="https://i.loli.net/2021/01/25/Lo5N8QYlI2DPjyO.png" alt="image-20210125154758184" style="zoom:50%;"></p><ol><li>播放端使用 HTTP <strong>DASH</strong> 协议向 POP 拉取直播数据</li><li>POP 里面的代理服务器会检查数据是否已经在 POP 的<strong>缓存</strong>内。如果是的话，缓存会返回数据给播放端，否则，代理服务器会向 DC 拉取直播数据</li><li>DC 内的代理服务器会检查数据是否在 DC 的缓存内，如果是的话，缓存会返回数据给 POP，并更新 POP 的缓存，再返回给播放端。不是的话，代理服务器会使用一致性哈希算法向对应的编码服务器请求数据，并更新 DC 的缓存，返回到 POP，再返回到播放端。</li></ol><p><strong>收获</strong></p><ol><li>项目的成功不，代码只是内功，考虑适配不同的网络、利用可利用的资源</li><li>惊群效应在热点服务器以及许多组件中都可能发生</li><li>开发大型项目需要对<strong>吞吐量和时延</strong>、<strong>安全和性能</strong>做出妥协</li><li>保证架构的灵活度和可扩展性，为内存、服务器、带宽耗尽做好规划</li></ol><h3 id="直播高可用方案"><a href="#直播高可用方案" class="headerlink" title="直播高可用方案"></a><strong>直播高可用方案</strong></h3><p><strong>网络可靠性</strong>：</p><ul><li>根据<strong>网络连接速度</strong>来自动调整视频质量</li><li>使用<strong>短时间的数据缓存</strong>来解决直播端不稳定，瞬间断线的问题</li><li>根据<strong>网络质量自动降级</strong>为音频直播以及播放</li></ul><p><strong>惊群效应：</strong></p><ul><li>当多个播放端向同一个 POP 请求直播数据的时候，如果数据不在缓存中</li><li>这时候只有一个请求 A 会到 DC 中请求数据，其他请求会等待结果</li><li>但是如果请求 A 超时没有返回数据的话，所有请求会一起向 DC 访问数据</li><li>这时候就会加大 DC 的压力，触发惊群效应</li><li>解决这个问题的方法就是通过<strong>实际的情况</strong>来调整请求超时的时间。这个时间如果太长的话会带来直播的延迟，太短的话会经常触发惊群效应（<strong>每个时间窗口只允许触发一次</strong>，设置允许最大回源数量）</li></ul><h3 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a><strong>性能优化方案</strong></h3><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobogaxxjkj304v0e7t93.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>数据库优化：</strong> 数据库是最容易成为瓶颈的组件，考虑从 SQL 优化或者数据库本身去提高它的性能。如果瓶颈依然存在，则会考虑分库分表将数据打散，如果这样也没能解决问题，则可能会选择缓存组件进行优化</p><p><strong>集群最优：</strong>存储节点的问题解决后，计算节点也有可能发生问题。一个集群系统如果获得了水平扩容的能力，就会给下层的优化提供非常大的时间空间，由最初的 3 个节点，扩容到最后的 200 多个节点，但由于人力问题，服务又没有什么新的需求，下层的优化就一直被搁置着。</p><p><strong>硬件升级：</strong>水平扩容不总是有效的，原因在于单节点的计算量比较集中，或者 JVM 对内存的使用超出了宿主机的承载范围。在动手进行代码优化之前，我们会对节点的硬件配置进行升级。</p><p><strong>代码优化</strong>：代码优化是提高性能最有效的方式，但需要收集一些数据，这个过程可能是服务治理，也有可能是代码流程优化。比如JavaAgent 技术，会无侵入的收集一些 profile 信息，供我们进行决策。</p><p><strong>并行优化：</strong>并行优化是针对速度慢的接口进行并行调用。所以我们通常使用 ContDownLatch 对需要获取的数据进行并行处理，效果非常不错，比如在 200ms 内返回对 50 个耗时 100ms 的下层接口的调用。</p><p><strong>JVM 优化</strong>： JVM 发生问题时，优化会获得巨大的性能提升。但在 JVM 不发生问题时，它的优化效果有限。但在代码优化、并行优化、JVM 优化的过程中，JVM 的知识却起到了关键性的作用</p><p><strong>操作系统优化：</strong>操作系统优化是解决问题的杀手锏，比如像 HugePage、SWAP、“CPU 亲和性”这种比较底层的优化。但就计算节点来说，对操作系统进行优化并不是很常见。运维在背后会做一些诸如文件句柄的调整、网络参数的修改，这对于我们来说就已经够用了</p><h3 id="流量回放自动化测试"><a href="#流量回放自动化测试" class="headerlink" title="流量回放自动化测试"></a>流量回放自动化测试</h3><blockquote><p>系统级的重构，测试回归的工作量至少都是以月为单位，对于人力的消耗巨大。一种应对方案是，先不改造，到系统实在扛不住了再想办法。另一种应对方案是，先暂停需求，全力进行改造。但在实际工作场景中，上述应对策略往往很难实现。</p></blockquote><p>场景：</p><p>1、读服务均是查询，它是无状态的。</p><p>2、不管是架构升级还是日常需求，读服务对外接口的出入参格式是没有变化的</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jd95rpij315g0hqn5q.jpg" alt="image-20210504174447049" style="zoom:50%;"></p><ul><li><p><strong>日志收集</strong>，主要作用是收集被测系统的真实用户请求，基于一定规则处理后作为系统用例；</p><p>Spring 里的 Interceptor 、Servlet 里的 Filter 过滤器，对所有请求的入参和出参进行记录，并通过 MQ 发送出去。（注意错峰、过滤写、去重等）</p></li><li><p>数据回放是基于收集的用例，对被测系统进行数据回放，发起自动化测试回归；</p><p><strong>离线回放：</strong>只调用新服务，将返回的数据和日志里的出参进行比较，<strong>日志比较大</strong></p><p><strong>实时回放：</strong>去实时调用线上系统和被测系统，并存储实时返回回放的结果信息，<strong>线上有负担</strong></p><p><strong>并行回放：</strong>新版本不即时上线，每次调用老版本接口时概率实时回放新版本接口，<strong>耗时间周期</strong></p></li><li><p><strong>差异对比</strong>，通过差异对比自动发现与预期不一致的用例，进而确定 Bug。</p><p>采用文本对比，可以直观地看到哪个字段数据有差异，从而更快定位到问题。正常情况下，只要存在差异的数据，均可认为是 Bug，是需要进行修复的。</p></li></ul><p><strong>方法论</strong></p><p><strong>Discovery</strong></p><p>​                考虑企业战略，分析客户需求，制定产品目标</p><p>​                    由外到内：竞争对手的方案，为什么做，以后怎么发展，如何去优化。</p><p>​                    自上而下：基于公司的战略，考虑自身能力和所处环境。</p><p>​                    自下而上：从资源、历史问题、优先级出发，形成一套可行性实施方法。</p><p><strong>Define</strong></p><p>​                基于收集的信息，综合跨业务线的抽象能力和服务，先做什么后做什么，怎么做</p><p>​                    设计新的架构，重点设计解决痛点问题。</p><p>​                    拆分业务领域，重点划分工作临界上下文。</p><p><strong>Design</strong></p><p>​                详细的业务设计，功能设计，交付计划，考核计划</p><p>​                    产品愿景，产品形态，相关竞品方案对比，价值、优势、收益</p><p>​                    梳理业务范围，要知道电商领域四大流（信息流、商流、资金流、物流）</p><p>​                    MVP最小可用比，让客户和老大看到结果，最后通编写story把故事编圆</p><p><strong>Delivery</strong></p><p>​                交付阶段，根据反馈及时调整中台战略，减少损失和增大收益</p><p>​                    合理制定每个阶段的绩效考核目标：</p><p>​                40%稳定+25%业务创新+20%服务接入+15%用户满意度</p><h1 id="七、架构设计"><a href="#七、架构设计" class="headerlink" title="七、架构设计"></a><strong>七、架构设计</strong></h1><h2 id="1、社区系统的架构"><a href="#1、社区系统的架构" class="headerlink" title="1、社区系统的架构"></a>1、社区系统的架构</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmqv8zyhkqj311s0u0q7s.jpg" alt="image-20210117182546782" style="zoom:40%;"></p><p><strong>系统拆分</strong></p><p>​        通过DDD领域模型，对服务进行拆分，将一个系统拆分为多个子系统，做成SpringCloud的微服务。微服务设计时要尽可能做到少扇出，多扇入，根据服务器的承载，进行客户端负载均衡，通过对核心服务的上游服务进行限流和降级改造。</p><p>​    一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>​    大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成<strong>订单系统、商品系统、采购系统、仓储系统、用户系统</strong>等等吧。</p><p>​    但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了<strong>供应商管理系统、采购单管理系统</strong>，订单系统又拆分成了<strong>购物车系统、价格系统、订单管理</strong>系统。</p><p><strong>CDN、Nginx静态缓存、JVM缓存</strong></p><p>​    利用Java的模板thymeleaf可以将页面和数据动态渲染好，然后通过Nginx直接返回。动态数据可以从redis中获取。其中redis里的数据由一个缓存服务来进行消费指定的变更服务。</p><p>​    商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><p><strong>缓存</strong></p><p>Redis cluster，10 台机器，5主5从，5 个节点对外提供读写服务，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，<strong>5 台机器最多是 25 万读写</strong>请求每秒。</p><p>​    <strong>32G 内存+ 8 核 CPU + 1T</strong> 磁盘，但是分配给 <strong>Redis 进程的是 10g 内存</strong>，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>​    因为每个主实例都挂了一个从实例，所以是<strong>高可用</strong>的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例<strong>会自动变成主实例</strong>继续提供读写服务。</p><p><strong>MQ</strong></p><p>​    可以通过消息队列对微服务系统进行<a href="#1、拆分微服务">解耦</a>，异步调用的更适合微服务的扩展</p><p>​    同时可以应对秒杀活动中<a href="# 6、应对高并发的写请求">应对高并发写请求</a>，比如kafka在毫秒延迟基础上可以实现10w级吞吐量</p><p>​    针对<a href="#IOT流量洪峰">IOT流量洪峰</a>做了一些特殊的优化，保证消息的及时性</p><p>​    同时可以使用消息队列保证分布式系统<a href="#7、如何保证数据一致性">最终一致性</a></p><p><strong>分库分表</strong></p><p>​        分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。<strong>在通讯录、订单和商城商品模块超过千万级别都应及时考虑分表分库</strong></p><p><strong>读写分离</strong></p><p>​        读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。比如<strong>统计监控类的微服务</strong>通过读写分离，只需访问从库就可以完成统计，例如ES</p><p><strong>ElasticSearch</strong></p><p>​        Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的<strong>查询、统计类</strong>的操作，比如<strong>运营平台上</strong>的各地市的汇聚统计，还有一些<strong>全文搜索类</strong>的操作，比如<strong>通讯录和订单</strong>的查询。</p><h2 id="2、商城系统-亿级商品如何存储"><a href="#2、商城系统-亿级商品如何存储" class="headerlink" title="2、商城系统-亿级商品如何存储"></a>2、商城系统-亿级商品如何存储</h2><p>基于 Hash 取模、一致性 Hash 实现分库分表</p><p>高并发读可以通过<a href="5、应对高并发的读请求">多级缓存</a>应对</p><p>大促销热key读的问题通过<a href="**4、热key问题如何解决？**">redis集群+本地缓存+限流+key加随机值</a>分布在多个实例中</p><p>高并发写的问题通过<strong>基于 Hash 取模、一致性 Hash 实现分库分表</strong>均匀落盘</p><p>业务分配不均导致的<strong>热key</strong>读写问题，可以根据业务场景进行range分片，将热点范围下的子key打散</p><p>具体实现：预先设定主键的生成规则，根据规则进行数据的分片路由，但这种方式会侵入商品各条线主数据的业务规则，更好的方式是基于<strong>分片元数据服务器</strong>（即每次访问分片前先询问分片元服务器在路由到实际分片）不过会带来复杂性，比如保证元数据服务器的<strong>一致性</strong>和可用性。</p><h2 id="3、对账系统-分布式事务一致性"><a href="#3、对账系统-分布式事务一致性" class="headerlink" title="3、对账系统-分布式事务一致性"></a>3、对账系统-分布式事务一致性</h2><blockquote><p>尽量避免分布式事务，单进程用数据库事务，跨进程用消息队列</p></blockquote><p>主流实现分布式系统事务一致性的方案：</p><ol><li><strong>最终一致性</strong>：也就是基于 MQ 的可靠消息投递的机制，</li><li>基于重试加确认的的<strong>最大努力通知方案</strong>。</li></ol><p>理论上也可以使用（2PC两阶段提交、3PC三阶段提交、TCC短事务、SAGA长事务方案），但是这些方案工业上落地代价很大，不适合互联网的业界场景。针对金融支付等需要强一致性的场景可以通过前两种方案实现。（<strong>展开说的话参考分布式事务</strong>）</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh4oifej30xq0auq7p.jpg" alt="image-20210321212516364" title class>                <p>image-20210321212516364</p>            </figure><p>本地数据库事务原理：<strong>undo log</strong>（原子性） + <strong>redo log</strong>（持久性） + <strong>数据库锁</strong>（原子性&amp;隔离性） + <strong>MVCC</strong>（隔离性）</p><p>分布式事务原理：<strong>全局事务协调器（原子性）</strong> + 全局锁（隔离性） + <strong>DB本地事务（原子性、持久性）</strong></p><p>一、我们公司账单系统和第三方支付系统对账时，就采用“<strong>自研补偿/MQ方案 + 人工介入</strong>”方式</p><p>落地的话：方案最“轻”，性能损失最少。可掌控性好，简单易懂，易维护。<br>考虑到分布式事务问题是小概率事件，留有补救余地就行，性能的损失可是实打实的反应在线上每一个请求上</p><p>二、也了解到业界比如阿里成熟<strong>Seata AT</strong>模式，平均性能会降低35%以上</p><p>我觉得不是特殊的场景不推荐</p><p>三、RocketMQ事务消息</p><p>听起来挺好挺简单的方案，但它比较挑业务场景，同步性强的处理链路不适合。<br>【重要】要求下游MQ消费方一定能成功消费消息。否则转人工介入处理。<br>【重要】千万记得实现幂等性。</p><h2 id="4、用户系统-多线程数据割接"><a href="#4、用户系统-多线程数据割接" class="headerlink" title="4、用户系统-多线程数据割接"></a>4、用户系统-多线程数据割接</h2><p>由于项目需要进行数据割接，保证用户多平台使用用户感知的一致，将广东项目的几百万用户及业务数据按照一定的逻辑灌到社区云平台上，由于依赖了第三方统一认证和省侧crm系统，按照之前系统内割接的方法，通过数据库将用户的唯一标识查出来然后使用多线程向省侧crm系统获取结果。</p><p>但是测试的过程中，发现每个线程请求的数据发生了错乱，导致每个请求处理的数据有重复，于是立即停止了脚本，当时怀疑是多线程对资源并发访问导致的，于是把ArrayList 改成了CopyOnWriteArrayList，但是折腾了一晚上，不管怎么修改，线程之间一直有重复数据，叫了一起加班的同事也没看出问题来，和同事估算了一下不使用多线程，大概30-40个小时能跑完，想了下也能接受，本来已经准备放弃了。</p><p>不过回到家，我还是用多线程仔细单步模拟了下，整个处理的过程，发现在起线程的时候，有些子线程并没有把分配给他的全部id的list处理完，导致最终状态没更新，新线程又去执行了一遍，然后我尝试通过修改在线程外深拷贝一个List再作为参数传入到子线程里，（后续clear的时候也是clear老的List）果然，整个测试过程中再也没出现过重复处理的情况。</p><p>事后，我也深究了下原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayBuffer.length == <span class="number">99</span>) &#123;</span><br><span class="line"> val asList = arrayBuffer.toList</span><br><span class="line"> exec.execute ( openIdInsertMethod(asList) )</span><br><span class="line"> arrayBuffer.clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。不过主线程先启动占用了cpu资源，因此主线程总是优于子线程。然而，即使设置了优先级，也无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>所以主线程上的clear操作有可能先执行，那么子线程中未处理完的数据就变成一个空的数组，所以就出现了多个线程出现了重复数据的原因，所以我们要保证的是子线程每次执行完后再进行clear即可。而不是一开始定位的保证ArrayList的安全性。所以将赋值(buffer-&gt;list)操作放在外面去执行后，多线程数据就正常了。</p><h2 id="5、秒杀系统场景设计"><a href="#5、秒杀系统场景设计" class="headerlink" title="5、秒杀系统场景设计"></a>5、秒杀系统场景设计</h2><p><a href="# 二、秒杀项目">见秒杀项目方案设计</a></p><h2 id="6、统计系统-海量计数"><a href="#6、统计系统-海量计数" class="headerlink" title="6、统计系统-海量计数"></a><strong>6、统计系统-海量计数</strong></h2><p><strong>中小规模的计数服务</strong>（万级）</p><p>最常见的计数方案是采用缓存 + DB 的存储方案。当计数变更时，先变更计数 DB，计数加 1，然后再变更计数缓存，修改计数存储的 Memcached 或 Redis。这种方案比较通用且成熟，但在高并发访问场景，支持不够友好。在互联网社交系统中，有些业务的计数变更特别频繁，比如微博 feed 的阅读数，计数的变更次数和访问次数相当，每秒十万到百万级以上的更新量，如果用 DB 存储，会给 DB 带来巨大的压力，DB 就会成为整个计数服务的瓶颈所在。即便采用聚合延迟更新 DB 的方案，由于总量特别大，同时请求均衡分散在大量不同的业务端，巨大的写压力仍然是 DB 的不可承受之重。</p><p><strong>大型互联网场景</strong>（百万级）</p><p>直接把计数全部存储在 Redis 中，通过 hash 分拆的方式，可以大幅提升计数服务在 Redis 集群的写性能，通过主从复制，在 master 后挂载多个从库，利用读写分离，可以大幅提升计数服务在 Redis 集群的读性能。而且 Redis 有持久化机制，不会丢数据</p><p>一方面 Redis 作为通用型存储来存储计数，内存存储效率低。以存储一个 key 为 long 型 id、value 为 4 字节的计数为例，Redis 至少需要 65 个字节左右，不同版本略有差异。但这个计数理论只需要占用 12 个字节即可。内存有效负荷只有 12/65=18.5%。如果再考虑一个 long 型 id 需要存 4 个不同类型的 4 字节计数，内存有效负荷只有 (8+16)/(65*4)= 9.2%。</p><p>另一方面，Redis 所有数据均存在内存，单存储历史千亿级记录，单份数据拷贝需要 10T 以上，要考虑核心业务上 1 主 3 从，需要 40T 以上的内存，再考虑多 IDC 部署，轻松占用上百 T 内存。就按单机 100G 内存来算，计数服务就要占用上千台大内存服务器。存储成本太高。</p><p><strong>微博、微信、抖音</strong>（亿级）</p><p>定制数据结构，共享key 紧凑存储，提升计数有效负荷率</p><p>超过阈值后数据保存到SSD硬盘，内存里存索引</p><p>冷key从SSD硬盘中读取后，放入到LRU队列中</p><p>自定义主从复制的方式，海量冷数据异步多线程并发复制</p><h2 id="7、系统设计-微软"><a href="#7、系统设计-微软" class="headerlink" title="7、系统设计 - 微软"></a>7、系统设计 - 微软</h2><h3 id="1、需求收集"><a href="#1、需求收集" class="headerlink" title="1、需求收集"></a><strong>1、需求收集</strong></h3><p>确认<strong>使用的对象</strong>（ToC：高并发，ToB：高可用）</p><p><strong>系统的服务场景</strong>（<strong>即时通信</strong>：低延迟，<strong>游戏</strong>：高性能，<strong>购物</strong>：秒杀-一致性）</p><p><strong>用户量级</strong>（<strong>万级</strong>：双机、<strong>百万</strong>：集群、<strong>亿级</strong>：弹性分布式、容器化编排架构）</p><p><strong>百万读</strong>：3主6从，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，可以实现15万，30万读性能</p><p><strong>亿级读</strong>，通过CDN、静态缓存、JVM缓存等多级缓存来提高读并发</p><p><strong>百万写</strong>，通过消息队列削峰填谷，通过hash分拆，水平扩展分布式缓存</p><p><strong>亿级写</strong>，redis可以定制数据结构、SSD+内存LRU、冷数据异步多线程复制</p><p>持久化，（Mysql）承受量约为 1K的QPS，读写分离提升<strong>读并发</strong>，分库分表提升<strong>写并发</strong></p><h3 id="2、顶层设计"><a href="#2、顶层设计" class="headerlink" title="2、顶层设计"></a><strong>2、顶层设计</strong></h3><p>核心功能包括什么：</p><p>写功能：发送微博</p><p>读功能：热点资讯</p><p>交互：点赞、关注</p><h3 id="3、系统核心指标"><a href="#3、系统核心指标" class="headerlink" title="3、系统核心指标"></a><strong>3、系统核心指标</strong></h3><ul><li>系统<strong>性能</strong>和<strong>延迟</strong><ul><li>边缘计算 | 动静分离 | 缓存 |  多线程 |</li></ul></li><li><strong>可扩展性</strong>和<strong>吞吐量</strong><ul><li>负载均衡 | 水平扩展 | 垂直扩展 | 异步 | 批处理 | 读写分离</li></ul></li><li><strong>可用性</strong>和<strong>一致性</strong><ul><li>主从复制 | 哨兵模式 | 集群 | 分布式事务</li></ul></li></ul><h3 id="4、数据存储"><a href="#4、数据存储" class="headerlink" title="4、数据存储"></a>4、数据存储</h3><p>键值存储 : Redis ( 热点资讯 )</p><p>文档存储 : MongoDB ( 微博文档分类)</p><p>分词倒排：Elasticsearch（搜索）</p><p>列型存储：Hbase、BigTable（大数据）</p><p>图形存储：Neo4j （社交及推荐）</p><p>多媒体：FastDfs（图文视频微博）</p><h2 id="7、如何设计一个微博"><a href="#7、如何设计一个微博" class="headerlink" title="7、如何设计一个微博"></a>7、如何设计一个微博</h2><p><strong>实现哪些功能：</strong></p><p>筛选出核心功能（Post a Tweet，Timeline，News Feed，Follow/Unfollow a user，Register/Login）</p><p><strong>承担多大QPS：</strong></p><p>QPS = 100，那么用我的笔记本作Web服务器就好了</p><p>QPS = 1K，一台好点的Web 服务器也能应付，需要考虑单点故障；</p><p>QPS = 1m，则需要建设一个1000台Web服务器的集群，考虑动态扩容、负载分担、故障转移</p><p>一台 SQL Database （Mysql）承受量约为 1K的QPS；</p><p>一台 NoSQL Database (Redis) 约承受量是 20k 的 QPS；</p><p>一台 NoSQL Database (Memcache) 约承受量是 200k 的 QPS；</p><p><strong>微服务战略拆分</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqql81gj30p20c5q45.jpg" alt="img" style="zoom:67%;"></p><p><strong>针对不同服务选择不同存储</strong></p><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-13cab4d5f56e3ecb682c351c0eb4a24b_1440w.jpg?source=1940ef5c" alt="img" title class>                <p>img</p>            </figure><p><strong>设计数据表的结构</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruu4homyj31400ht405.jpg" alt="img" title class>                <p>img</p>            </figure><p>基本差不多就形成了一个解决方案，但是并不是完美的，仍然需要小步快跑的不断的针对<strong>消息队列、缓存、分布式事务、分表分库、大数据、监控、可伸缩</strong>方面进行优化</p><h1 id="八、领域模型落地"><a href="#八、领域模型落地" class="headerlink" title="八、领域模型落地"></a>八、领域模型落地</h1><h3 id="1、拆分微服务"><a href="#1、拆分微服务" class="headerlink" title="1、拆分微服务"></a>1、拆分微服务</h3><blockquote><p>​    微服务内高内聚，微服务间低耦合</p></blockquote><p><strong>微服务内高内聚</strong>即单一职责原则</p><p>​    每个微服务中的代码变化都是同一类原因。因这类原因而需要变更的代码都在这个微服务中，与其他微服务无关，那么就可以将代码修改的范围缩小到这个微服务内。把这个微服务修改好了，独立修改、独立发布，该需求就实现了。这样，微服务的优势才能发挥出来。</p><p><strong>微服务间低耦合</strong>开放封闭原则</p><p>​    就是说在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，就应当将这些过程交给其他微服务去实现，你只需要对它的接口进行调用。这样，微服务之间的调用就实现了解耦。</p><p>​    <strong>领域建模</strong>就是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景，每个子域的边界就是“<strong>限界上下文</strong>”。该业务场景会涉及许多领域对象，但<strong>分析建模</strong>始终需要围绕着业务场景的上下文进行。</p><p>​    <strong>领域事件通知机制</strong>最有效的方式就是通过消息队列，实现领域事件在微服务间的通知。</p><blockquote><p>“核心通讯录”微服务只负责发送变更消息到消息队列，不管谁会接收并处理这些消息；</p><p>“门禁管理”微服务只负责接收照片变更消息，不管谁发送的这个消息。</p></blockquote><h3 id="2、关联微服务"><a href="#2、关联微服务" class="headerlink" title="2、关联微服务"></a>2、关联微服务</h3><ol><li><p>按照<strong>限界上下文</strong>进行微服务的拆分，将领域模型<strong>划分到多个问题子域</strong></p></li><li><p>基于<strong>充血模型</strong>与<strong>贫血模型</strong>设计各个微服务的业务领域层（Service、Entity、Value）</p></li><li><p>通过<strong>领域事件通知机制</strong>和<strong>微服务调用</strong>的推拉结合，将各个子域进行解耦关联</p><ul><li><strong>核心</strong>：</li></ul></li></ol><ul><li><p>通讯录 | 短信 | 推送通知 | 支付 | 文件服务</p></li><li><p><strong>智慧通行</strong></p><blockquote><p>解决物业多品牌、多系统应用造成的<strong>信息孤岛</strong>，<strong>数据混乱</strong>的问题</p></blockquote><ul><li>人脸门禁 | 可视对讲 | 电梯梯控 | 停车系统 | 访客预约</li></ul></li><li><p><strong>安全社区</strong></p><blockquote><p>通过<strong>图像视频识别</strong>、<strong>传感数据采集</strong>，实现<strong>报警联动</strong>和<strong>风险预警</strong></p></blockquote><ul><li>视频监控 | 周界报警 | 高空抛物 | 跨域追踪</li></ul></li><li><p><strong>全屋智能</strong></p><blockquote><p>围绕业主需求，逐步引入社区医疗、社区养老、<strong>社区团购</strong>、<strong>社区家政</strong>等服务</p></blockquote><ul><li>超级面板 | 无线门锁 | 烟感雾感</li></ul></li><li><p><strong>增值服务</strong></p><blockquote><p>实现跨品牌的产品体验，支持基于<strong>matrix引擎</strong>的智能生活场景裂变能力</p></blockquote><ul><li>智能充电 | 云广播 | 出入提醒 | 定向投放</li></ul></li></ul><h3 id="3、微服务的落地"><a href="#3、微服务的落地" class="headerlink" title="3、微服务的落地"></a><strong>3、微服务的落地</strong></h3><blockquote><p>​    通过合理的微服务设计，尽量让每次的需求变更都交给某个小团队独立完成，让需求变更落到某个微服务上进行变更。唯有这样，每次变更只需独立地修改这个微服务，独立打包、独立升级，新需求独立实现，才能发挥微服务的优势。</p></blockquote><ul><li><strong>数据隔离：</strong>数据库中用户信息表的读写只有<strong>通讯录</strong>微服务。当其他微服务需要读写用户信息时，就不能直接读取用户信息表，而是通过 API 接口去调用<strong>通讯录</strong>微服务。</li><li><strong>接口复用：</strong>因此，当多个团队向你提需求时，必须要对这些接口进行规划，通过复用<strong>尽可能少的接口满足他们的需求；</strong>当有新的接口提出时，要尽量通过现有接口解决问题。</li><li><strong>向前兼容：</strong>当调用方需要接口变更时怎么办？变更现有接口应当尽可能向前兼容，即接口的名称与参数都不变，只是在内部增加新的功能。<strong>宁愿增加一个新的接口也最好不要去变更原有的接口。</strong></li><li><strong>本地调用：</strong>在<strong>访客申请</strong>微服务的本地，增加一个<strong>查询用户Service</strong>的 feign 接口。这样，<strong>访客申请Service</strong>就像本地调用一样调用<strong>查询用户Service</strong>，再通过 feign 接口实现远程调用。这种<strong>防腐层</strong>的设计，可以隔离当前微服务以外的其他微服务拆分变更导致的接口的失效的影响。</li><li><p><strong>数据库去中心化：</strong></p><ul><li>微服务中<strong>通讯录服务</strong>与<strong>健康码服务</strong>分别对应的<strong>用户库与权限库</strong>，它们的共同特点是数据量小但频繁读取，可以选用小型的 MySQL 数据库并在前面架设 Redis 来提高查询性能；</li><li>微服务中<strong>访客通行</strong>与<strong>生活缴费</strong>分别对应的<strong>通行记录库、订单库</strong>，其特点是数据量大并且高并发写，选用一个数据库显然扛不住这样的压力，因此可以选用了 TiDB 这样的 NewSQL 数据库进行分布式存储，将数据压力分散到多个数据节点中，从而解决 I/O 瓶颈；</li><li>微服务中<strong>数据分析</strong>与<strong>通讯录查询</strong>这样的查询分析业务，则选用 <strong>NoSQL 数据库</strong>或<strong>大数据平台</strong>，通过读写分离将生产库上的数据同步过来进行分布式存储，然后宽表一系列的预处理，应对海量历史数据的决策分析与秒级查询。（ NoSQL 为空的字段是不占用空间的，因此字段再多都不影响查询性能）</li></ul></li></ul><h3 id="4、领域模型的意义"><a href="#4、领域模型的意义" class="headerlink" title="4、领域模型的意义"></a>4、领域模型的意义</h3><p>​    <strong>贫血模型、充血模型、策略模式、装饰者模式</strong>只是DDD实现的方式，而DDD的真谛是<strong>领域建模</strong>。</p><p>​    做事不能仅凭一腔热血，一定要符合自然规律。其实软件的设计开发过程也是这样。对业务理解不深刻全局架构设计往往是过度设计，这时候<strong>应该抓主要流程</strong>，开始领域建模。</p><ul><li>接着，每次添加新功能的时候，一方面要满足当前的需求，另一方面业务相关的<strong>领域建模设计</strong>刚刚满足需求，从而使设计最简化、代码最少。</li><li>这样的设计过程叫<strong>小步快跑</strong>。采用小步快跑的设计方法，一开始不用思考那么多问题，从简单问题开始逐步深入。<strong>领域模型</strong>就像小树一样一点儿一点儿成长，最后完成所有的功能。</li></ul><blockquote><p>保持软件设计不退化的关键在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计，才能保证软件以一种良性循环的方式不断维护下去。</p></blockquote><p>​    有没有一种方法，让我们在第十次变更、第二十次变更、第三十次变更时，依然能够找到正确的设计呢？有，那就是<strong>领域驱动设计</strong></p><p>​    那么在每次需求变更时，将变更还原到真实世界中，看看真实世界是什么样子的，根据真实世界进行变更。</p><h3 id="5、战略建模"><a href="#5、战略建模" class="headerlink" title="5、战略建模"></a>5、战略建模</h3><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jet6kizj310c0ngtp4.jpg" alt="image-20210504174616848" style="zoom:50%;"></p><h3 id="6、相关名词"><a href="#6、相关名词" class="headerlink" title="6、相关名词"></a><strong>6、相关名词</strong></h3><p><strong>领域和子域（Domain/Subdomain）</strong></p><p>​    在<strong>上下文地图</strong>构建的领域中，对应模块，使用<strong>限界上下文</strong>划分领域，对应微服务</p><p><strong>限界上下文（Bounded Context）</strong></p><p>​    在一个领域/子域中，有概念上的领域边界，任何<strong>领域对象</strong>在该边界内部的有不依赖外部的确切含义。</p><p><strong>领域对象</strong></p><p>​    服务、实体与值对象是领域驱动设计的领域对象，可以通过<strong>贫血模型</strong>和<strong>充血模型</strong>转换为程序设计</p><p><strong>实体和值对象</strong></p><p>​    通过一个<strong>唯一标识字段来区分</strong>真实世界中的每一个个体的领域对象，称为实体。真实世界中那些<strong>一成不变的</strong>、本质性的事物的领域对象，称为值对象。    <strong>可变性</strong>是实体的特点，而<strong>不变性</strong>则是值对象的本质。</p><p><strong>贫血模型与充血模型</strong></p><p>​    POJO对象中只保存get/set方法，没有任何业务逻辑，这样的设计被称为<strong>贫血模型</strong></p><p>​    <strong>充血模型</strong>是封装和继承思想的体现，门禁设备实体中，包含特征值下发、广告下发、通行记录回调等方法，不同厂商的实体针对多态进行<strong>聚合</strong>，并通过<strong>工厂或仓库</strong>对外提供服务。在充血模型中， Service 只干一件非常简单的事，就是直接去调用对象中的<strong>工厂方法</strong>生成不同产品，其他的什么都不干。</p><p><strong>聚合</strong></p><p>​    聚合体现的是一种<strong>整体与部分</strong>的关系。正是因为有这样的关系，在操作整体的时候，整体就封装了对部分的操作。如何正确理解是否存在聚合的关系：就是当<strong>整体不存在</strong>时，部分就变得<strong>没有了意义</strong>。部分是整体的一个部分，与<strong>整体有相同的生命周期</strong>。</p><p><strong>工厂</strong></p><p><strong>通过装配，创建领域对象，是领域对象生命周期的起点。</strong>譬如，系统要通过 ID 装载一个访客申请：</p><ol><li><p>表单工厂分别调用表单信息DAO、表单明细 DAO 和用户DAO 去进行查询；</p></li><li><p>将得到的表单明细对象、用户对象进行装配，分别 set 到<strong>表单信息对象</strong>的<strong>表单明细</strong>与<strong>用户属性</strong>中；</p></li><li>最后，表单工厂将装配好的表单对象返回给表单仓库。</li></ol><p><strong>仓库</strong></p><p>​    如果服务器是一个非常强大的服务器，那么我们不需要任何数据库。系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。</p><ul><li><p>当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到<strong>缓存中进行查找</strong>：</p></li><li><p>查找到了，则<strong>直接返回</strong>，不需要查询数据库；</p></li><li><p>没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后<strong>装配成领域对象返回给仓库</strong>。</p></li><li><p>仓库在收到这个领域对象以后，在返回给客户程序的同时，将该<strong>对象放到缓存中</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一es篇&quot;&gt;一、ES篇&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1概述&quot;&gt;1、概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#特点&quot;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#功能&quot;&gt;功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/技术/"/>
    
    
    <category term="java" scheme="https://github.com/missionOdd/tags/java/"/>
    
    <category term="技术" scheme="https://github.com/missionOdd/tags/技术/"/>
    
    <category term="面试" scheme="https://github.com/missionOdd/tags/面试/"/>
    
    <category term="复习" scheme="https://github.com/missionOdd/tags/复习/"/>
    
  </entry>
  
  <entry>
    <title>求众数II （摩尔投票法）用类似俄罗斯方块消除的游戏例子讲解</title>
    <link href="https://github.com/missionOdd/2021/12/14/majority-element-ii/"/>
    <id>https://github.com/missionOdd/2021/12/14/majority-element-ii/</id>
    <published>2021-12-14T12:50:37.000Z</published>
    <updated>2022-01-12T14:11:41.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>求众数 II<br>给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。<br>示例 1：</p><p>输入：[3,2,3]<br>输出：[3]<br>示例 2：</p><p>输入：nums = [1]<br>输出：[1]</p><p>示例 3：<br>输入：[1,1,1,3,3,2,2,2]<br>输出：[1,2]</p><p>提示：<br>1 &lt;= nums.length &lt;= 5 * 104<br>-109 &lt;= nums[i] &lt;= 109<br>进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p></blockquote><h1 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我从设计一个游戏入手，为你讲解摩尔投票的思路。</p><h3 id="设计一款类似俄罗斯方块的简单消除游戏"><a href="#设计一款类似俄罗斯方块的简单消除游戏" class="headerlink" title="设计一款类似俄罗斯方块的简单消除游戏"></a>设计一款类似俄罗斯方块的简单消除游戏</h3><p>游戏主板块是<strong>三个纵向列队槽</strong>组成的无上限空间，如图。设计一下落方块数组，比如 [A,A,A,B,B,C]，一个方块能占一个槽位。</p><p>元素方块按数组顺序轮流出现，落入板块中。你将左右移动操作下落中的方块，直到下降至其中一个槽位，完成方块堆叠。<em>（其实就是俄罗斯方块的玩法）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|口口口|    &lt;--方块从上向下堆叠</span><br><span class="line">|口口口|</span><br><span class="line">|口口口|      </span><br><span class="line">|口口口|       </span><br><span class="line">|口口口|    &lt;--&quot;口&quot;是槽位，有三列           </span><br><span class="line">--------</span><br></pre></td></tr></table></figure></p><p>我们的规则是：<strong>当一层填满，且元素均不相同，该层立马发生消除</strong>。消除后剩余方块最少则胜利。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|口口口|        |口口口|</span><br><span class="line">|口口口|  ==&gt;   |口口口|</span><br><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|        |A 口口|</span><br><span class="line">|A̶ ̶B̶ ̶C̶ | 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>根据规则，一旦同一层出现相同元素，则无法消除，因此我们要保证同一层均不相同，采取攻略：<strong>遇到相同元素叠在一起，遇到不同元素则放在其他槽位，最后使一层填满并完成消除</strong>。这样会发现，底层总是在消除，所以<strong>必定会有一列是空队槽</strong>。</p><p>试一局就清楚了，数组：[A,B,C,A,B,C,A,B,C,A,A,B]<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,A   相同，堆叠在左边槽位，此时面板左边存储了AA<br>B    与A不相同，放在不同槽位，此时面板左边存储了AA，中间存储B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|  ==&gt;   |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |A 口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ | 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>按照图中堆叠，<strong>抵消后剩下结果A B，由于数组只有ABC三种元素，那么剩下结果都是个数超过N/3的元素。</strong></p><p>再试一局，数组：[X,Y,B,Q,R,T,A,A,B,C,A,B]<br>X,Y,B 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>Q,R,T 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,A   相同，堆叠在左边槽位，此时面板左边存储了AA<br>B    与A不相同，放在不同槽位，此时面板左边存储了AA，中间存储B<br>C    与A，B不相同，放在不同槽位，A,B,C一层满消除，，此时面板左边存储了AA，中间存储B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|  ==&gt;   |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |口口口|</span><br><span class="line">|̶Q̶ ̶R̶ ̶T̶ |        |A 口口|</span><br><span class="line">|̶X̶ ̶Y̶ ̶B̶ ̶| 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>按照图中堆叠，<strong>抵消后剩下结果A B，由于数组本身没有个数超过N/3的元素，说明剩下的元素也没有个数超过N/3的</strong>。</p><p>就是说，在每遇3个不同元素就互相抵消的玩法下，如果存在数量超过N/3的元素，抵消后一定有此元素的剩余；但剩余的，不一定都是数量超过N/3的元素。</p><p><strong>所以，我们只需要取得消除后剩余的元素，通过遍历数组对其计数，判断个数是否满足大于N/3即可得到本题的答案</strong></p><h3 id="游戏替换成摩尔投票"><a href="#游戏替换成摩尔投票" class="headerlink" title="游戏替换成摩尔投票"></a>游戏替换成摩尔投票</h3><p>每次元素方块下落，就相当于对其元素的一次投票。<br>当一层的每个槽位（候选人）都有一票，因为这些票不影响最终结果，互相进行抵消。<br>被投票个数超过N/3一定会留到最后不被消除。</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ol><li>初始化两个槽位以及其存储元素个数。<br><em>（为什么不定义三个槽位？ 有一个槽位必然用于抵消掉其他槽位，存储元素必是0，只需关注其他槽位存储情况即可）</em></li><li>优先进槽位1，当前元素与槽位1相同元素则堆叠，不符合则入槽位2</li><li>入槽位2时，当前元素与槽位2相同元素则堆叠；不符合则入空队槽</li><li>优先入空槽1，否则空槽2，否则入剩余槽</li><li>入剩余槽时，会与其他槽发生一次抵消，此槽又变回空槽</li><li>最后获得剩下在队槽的元素，并数出对应元素在数组中的个数是否满足大于 N/3<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化两个槽位以及其存储元素个数。</span></span><br><span class="line">        <span class="comment">//（为什么不定义三个槽位？ 有一个槽位必然用于抵消掉其他槽位，存储元素必是0，只需关注其他槽位存储情况即可）</span></span><br><span class="line">        <span class="keyword">int</span> slot1 = nums[<span class="number">0</span>], count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slot2 = nums[<span class="number">0</span>], count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摩尔投票法</span></span><br><span class="line">        <span class="comment">// 入队槽和抵消过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slot1 == num) &#123; <span class="comment">// 相同元素入相同的队槽</span></span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (slot2 == num) &#123; <span class="comment">// 相同元素入相同的队槽</span></span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123; <span class="comment">// 存储在候选空槽</span></span><br><span class="line">                slot1 = num;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123; <span class="comment">// 存储在候选空槽</span></span><br><span class="line">                slot2 = num;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">// 入最后剩余的空槽，且与其他槽发生一次抵消，此槽又变回空槽</span></span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数过程</span></span><br><span class="line">        <span class="comment">// 此时，获得剩下在队槽的元素，并数出对应元素在数组中的个数是否满足大于 N/3</span></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 == num) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (slot2 == num) count2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.length / <span class="number">3</span>)&#123;</span><br><span class="line">            res.add(slot1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.length / <span class="number">3</span>)&#123;</span><br><span class="line">            res.add(slot2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element-ii/&quot; target</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="摩尔投票法" scheme="https://github.com/missionOdd/tags/摩尔投票法/"/>
    
  </entry>
  
  <entry>
    <title>双串题 | kmp算法的简单理解 （java）</title>
    <link href="https://github.com/missionOdd/2021/12/12/kmp-algorithm/"/>
    <id>https://github.com/missionOdd/2021/12/12/kmp-algorithm/</id>
    <published>2021-12-12T07:50:37.000Z</published>
    <updated>2022-01-12T15:41:55.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>实现 strStr()<br>给你两个字符串&nbsp;<code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回&nbsp; <code>-1</code><strong> </strong>。<br><strong>说明：</strong><br>当&nbsp;<code>needle</code>&nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当&nbsp;<code>needle</code>&nbsp;是空字符串时我们应当返回 0 。这与 C 语言&gt; &gt; 的&nbsp;<a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strstr()</a>&nbsp;以及 Java 的&nbsp;<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>)&nbsp;定义相符。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><p><strong>输入：</strong>haystack = “hello”, needle = “ll”<br><strong>输出：</strong>2</p></blockquote><blockquote><p><strong>示例 2：</strong></p><p><strong>输入：</strong>haystack = “aaaaa”, needle = “bba”<br><strong>输出：</strong>-1</p></blockquote><blockquote><p><strong>示例 3：</strong></p><p><strong>输入：</strong>haystack = “”, needle = “”<br><strong>输出：</strong>0</p></blockquote><blockquote><p>&nbsp;</p><p><strong>提示：</strong></p><ul><li><code>0 &amp;lt;= haystack.length, needle.length &amp;lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先，想想暴力解法的大致思路。<br>可以用两个指针分别在两字符串上游走，让p和s一个一个字符遍历匹配。<br>匹配过程中，s被看作分成四个区域：<code>已放弃匹配</code>，<code>完成匹配</code>，<code>正在匹配</code>，<code>未匹配</code>。tips: 正在匹配区域是1个字符。<br>p被看作分成两个区域：<code>匹配</code>，<code>未匹配（包括正在匹配）</code>。<br>如果发现字符匹配失败，就s要丢弃掉此次匹配情况，进入下一个匹配情况：<br>即完成匹配区域清0，已放弃匹配区域+1，正在匹配区域回退至已放弃匹配区域末端+1，剩下就是被增大的未匹配区域。<br>此时相应的，指针也都要回退： s回退到上次完成匹配区间的开始字符的下一个，p回退到开始，再遍历一个个匹配。</p><p><strong>kmp其实是对回退过程的优化。</strong><br>在发生匹配失败的时候，它能够通过观察p的当前<code>匹配区域</code>，看其前后<strong>两端</strong>是否具备镜像字符串。<br>记下最长的镜像字符串，p要回退到前边的最长镜像字符串末端+1，s不用回退<br>也就是说，要在p的匹配前缀的区域内，找<strong>最长相等前后缀</strong>，p上指针回退到最长相等前缀的末端+1，s不用回退；</p><hr><p><strong>Q:为什么找p匹配的两端镜像字符串（找最长相等前后缀）能够优化回退过程？</strong><br><strong>A：</strong> p匹配区的末端部分与s匹配区的末端部分原本确定是匹配吻合；<br>如果找到镜像字符串后，即p匹配区的前端镜像字符串部分=p匹配区的末端镜像字符串部分，也就可以确定p匹配区的前端镜像字符串部分与s匹配区末端部分也能匹配吻合。<br><code>tips：这里说s匹配区不包括正在匹配的字符，是指s匹配前缀。</code><br>那么在回退时，就可以巧妙地跳过这一已知吻合部分的比对匹配操作，直接从p匹配区的前端镜像字符串部分末尾+1与s当前匹配字符进行比对，节省时间。若比对匹配失败再回退。</p><p><strong>Q: 回退过程如何找到跳跃落地点？</strong><br><strong>A:</strong> 这需要提前完成模式串p前缀表的初始化，我们会定义一个next数组，记下每一段的最长相等前后缀长度。<br><code>tips：其实该值真正的表示是：最长相等前缀末尾+1元素的下标。</code><br>匹配失败时，找p当前匹配区末端的对应的next元素值进行跳跃，则回退到正在匹配字符能够匹配成功的情况，没有就回到p的开始。</p><hr><p>以上简单地理解了kmp的思想，至于如何实现，具体细节要回到代码当中。</p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol><li>要初始化前缀表，记下每一段的最长相等前后缀长度，存入next数组，其实该长度值真正的表示是：最长相等前缀末尾+1元素的下标<br>1.1 定义左右指针，右指针递增<br>1.2 如果左右字符不相等，则回退到相等的情况，没有相等就回到p的开始<br>1.3 相等则最长相等前后缀长度增加，左指针负责增加，右指针负责记录</li><li>文本串s和模式串p匹配<br>2.1 定义两个指针i，j分别在两字符串中游走<br>2.2 当匹配失败时，p通过next数组进行回退到匹配相等的情况<br>2.3 否则，逐个匹配，增加匹配长度，一直到完全匹配成功</li><li>完全匹配不了，返回-1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// next 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">1</span>;right&lt;len;right++)&#123; <span class="comment">//right go forward</span></span><br><span class="line">            <span class="comment">//left 回退</span></span><br><span class="line">            <span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp; p[left] != p[right])&#123;</span><br><span class="line">                left= next[left-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配长度增加</span></span><br><span class="line">            <span class="keyword">if</span>(p[left] == p[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.length;i++)&#123; <span class="comment">//s go forward</span></span><br><span class="line">            <span class="comment">//p回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != p[j])&#123;</span><br><span class="line">                j= next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配长度增加</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j])&#123;</span><br><span class="line">                j++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//完全匹配</span></span><br><span class="line">            <span class="keyword">if</span>(j == len) <span class="keyword">return</span> i-len+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot; target=&quot;_</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="kmp" scheme="https://github.com/missionOdd/tags/kmp/"/>
    
    <category term="双串题" scheme="https://github.com/missionOdd/tags/双串题/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 | 硬核图文讲解</title>
    <link href="https://github.com/missionOdd/2021/12/10/os-notes/"/>
    <id>https://github.com/missionOdd/2021/12/10/os-notes/</id>
    <published>2021-12-10T05:50:37.000Z</published>
    <updated>2022-02-08T03:28:42.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-冯诺伊曼体系"><a href="#1-冯诺伊曼体系" class="headerlink" title="1 冯诺伊曼体系"></a>1 冯诺伊曼体系</h1><h3 id="1-1-冯诺伊曼体系简介"><a href="#1-1-冯诺伊曼体系简介" class="headerlink" title="1.1 冯诺伊曼体系简介"></a>1.1 冯诺伊曼体系简介</h3><p>现代计算机之父<code>冯诺伊曼</code>最先提出程序存储的思想，并成功将其运用在计算机的设计之中，该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是<strong>中央处理器（CPU）、内存、输入设备、输出设备、总线</strong>。</p><figure class="image-box">                <img src="image-20220208105256415.png" alt="image-20220208105256415" title class>                <p>image-20220208105256415</p>            </figure><ol><li><strong>存储器</strong>：代码跟数据在RAM跟ROM中是线性存储， 数据存储的单位是一个二进制位。最小的存储单位是字节。</li><li><strong>总线</strong>：总线是用于 CPU 和内存以及其他设备之间的通信，总线主要有三种：</li></ol><blockquote><ol><li><code>地址总线</code>：用于指定 CPU 将要操作的内存地址。</li><li><code>数据总线</code>：用于读写内存的数据。</li><li><code>控制总线</code>：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后响应，这时也需要控制总线。</li></ol></blockquote><ol><li><strong>输入/输出设备</strong>：输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。比如键盘按键时需要和 CPU 进行交互，这时就需要用到控制总线。</li><li><strong>CPU</strong>：中央处理器，类比人脑，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU用寄存器存储计算时所需数据，寄存器一般有三种：</li></ol><blockquote><ol><li><code>通用寄存器</code>：用来存放需要进行运算的数据，比如需进行加法运算的两个数据。</li><li><code>程序计数器</code>：用来存储 CPU 要执行下一条指令所在的内存地址。</li><li><code>指令寄存器</code>：用来存放程序计数器指向的指令本身。</li></ol></blockquote><p><strong>在冯诺伊曼体系下电脑指令执行的过程</strong>：</p><ol><li>CPU读取程序计数器获得指令内存地址，CPU控制单元操作地址总线从内存地址拿到数据，数据通过数据总线到达CPU被存入指令寄存器。</li><li>CPU分析指令寄存器中的指令，如果是计算类型的指令交给逻辑运算单元，如果是存储类型的指令交给控制单元执行。</li><li>CPU 执行完指令后程序计数器的值通过自增指向下个指令，比如32位CPU会自增4。</li><li>自增后开始顺序执行下一条指令，不断循环执行直到程序结束。</li></ol><p><strong>CPU位宽</strong>：32位CPU一次可操作计算4个字节，64位CPU一次可操作计算8个字节，这个是硬件级别的。平常我们说的32位或64位操作系统指的是软件级别的，指的是程序中指令多少位。<br><strong>线路位宽</strong>：CPU操作指令数据通过高低电压变化进行数据传输，传输时候可以串行传输，也可以并行传输，多少个并行等于多少个位宽。</p><h3 id="1-2-CPU-简介"><a href="#1-2-CPU-简介" class="headerlink" title="1.2 CPU 简介"></a>1.2 CPU 简介</h3><p><code>Central Processing Unit 中央处理器，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</code>。</p><figure class="image-box">                <img src="image-20220208105332463.png" alt="cpu" title class>                <p>cpu</p>            </figure>CPU<br><br>1. <code>CPU核心</code>：一般一个CPU会有多个CPU核心，平常说的多核是指在一枚处理器中集成两个或多个完整的计算引擎。核跟CPU的关系是：核属于CPU的一部分。<br><br>2. <code>寄存器</code>：最靠近CPU对存储单元，32位CPU寄存器可存储4字节，64位寄存器可存储8字节。寄存器访问速度一般是半个CPU时钟周期，属于纳秒级别，<br><br>3. <code>L1缓存</code>：每个CPU核心都有，用来缓存数据跟指令，访问空间大小一般在32～256KB，访问速度一般是2～4个CPU时钟周期。<br><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/size # L1 数据缓存</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index1/size # L1 指令缓存</span><br></pre></td></tr></table></figure><ol start="4"><li><p><code>L2缓存</code>：每个CPU核心都有，访问空间大小在128KB～2MB，访问速度一般是10～20个CPU时钟周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index2/size # L2 缓存容量大小</span><br></pre></td></tr></table></figure></li><li><p><code>L3缓存</code>：多个CPU核心共用，访问空间大小在2MB～64MB，访问速度一般是20～60个CPU时钟周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index3/size # L3 缓存容量大小</span><br></pre></td></tr></table></figure></li><li><p><code>内存</code>：多个CPU共用，现在一般是4G～512G，访问速度一般是200～300个CPU时钟周期。</p></li><li><p><code>固体硬盘SSD</code>：现在台式机主流都会配备，上述的寄存器、缓存、内存都是断电数据立马丢失的，而SSD里不会丢失，大小一般是128G～1T，比内存慢10～1000倍。</p></li><li><p><code>机械盘HDD</code>：很早以前流行的硬盘了，容量可在512G～8T不等，访问速度比内存慢10W倍不等。</p></li><li><p><code>访问数据顺序</code>：CPU在拿数据处理的时候几乎也是按照上面说得流程来操纵的，只有上面一层找不到才会找下一层。</p></li><li><p><code>Cache Line</code> :  CPU读取数据时会按照 Cache Line 方式把数据加载到缓存中，每个Cacheline = 64KB，因为L1、L2是每个核独有到可能会触发<strong>伪共享</strong>，就是 所以可能会将数据划分到不同到CacheLine中来避免伪共享，比如在JDK8 新增加的 LongAdder 就涉及到此知识点。</p></li></ol><blockquote><ol><li><strong>伪共享</strong>：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</li></ol></blockquote><ol><li><code>JMM</code>: 数据经过种种分层会导致访问速度在不断提升，同时也带来了各种问题，多个CPU同时操作相同数据可能会造成各种BU个，需要加锁，这里在<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489439&amp;idx=1&amp;sn=df404e70a8e55b4019317ef2036fbe7d&amp;chksm=ebdef6a7dca97fb1e1a0dfd2eab194fa87f4971cd6b88645db072bcc9c98614b0ad30dc43399&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JUC</a>并发已详细探讨过。</li></ol><h3 id="1-3-CPU-访问方式"><a href="#1-3-CPU-访问方式" class="headerlink" title="1.3 CPU 访问方式"></a>1.3 CPU 访问方式</h3><figure class="image-box">                <img src="image-20220208105404666.png" alt="image-20220208105404666" title class>                <p>image-20220208105404666</p>            </figure>CPU访问方式<br><br><br>内存数据映射到CPU Cache 时通过公式<code>Block N % CacheLineMax</code>决定内存Block数据放到那个CPU Cache Line 里。CPU Cache 主要有4部分组成。<br><br><br><br>1. <strong>Cache Line Index</strong> ：CPU缓存读取数据时不是按照字节来读取的，而是按照CacheLine方式存储跟读取数据的。<br>2. <strong>Valid Bit</strong> : 有效位标志符，值为0时表示无论 CPU Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。<br>3. <strong>Tag</strong>：组标记，用来标记内存中不同BLock映射到相同CacheLine，用Tag来区分不同的内存Block。<br>4. <strong>Data</strong>：真实到内存数据信息。<br><br>CPU真实访问内存数据时只需要指定三个部分即可。<br><br>1. <strong>Cache Line Index</strong> ：要访问到Cache Line 位置。<br>2. <strong>Tag</strong>：表示用那个数据块。<br>3. <strong>Offset</strong>：CPU从CPU Cache 读取数据时不是直接读取Cache Line整个数据块，而是读取CPU所需的数据片段，称为Word。如何找到Word就需要个偏移量Offset。<br><br>### 1.4 CPU 访问速度<br><br><figure class="image-box">                <img src="image-20220208105417253.png" alt="image-20220208105417253" title class>                <p>image-20220208105417253</p>            </figure>访问耗时对比<br><br><br>如上图所示，CPU访问速度是逐步变慢，所以CPU访问数据时需尽量在距离CPU近的高速缓存区访问，根据摩尔定律CPU访问速度每18个月就会翻倍，而内存的访问每18个月也就增长10% 左右，导致的结果就是CPU跟内存访问性能差距逐步变大，那如何尽可能提高CPU缓存命中率呢？<br><br><br>\1. <code>数据缓存</code>：遍历数据时候按照内存布局顺序访问，因为CPU Cache是根据Cache Line批量操作数据的，所以你顺序读取数据会提速，道理跟磁盘顺序写一样。<br><br>1. <code>指令缓存</code>：尽可能的提供有规律的条件分支语句，让 CPU 的分支预测器发挥作用，进一步提高执行的效率，因为CPU是自带<code>分支预测器</code>，自动提前将可能需要的指令放到指令缓存区。<br>2. <code>线程绑定到CPU</code>：一个任务A在前一个时间片用CPU核心1 运行，后一个时间片用CPU核心2 运行，这样缓存L1、L2就浪费了。因此操作系统提供了将进程或者线程绑定到某一颗 CPU 上运行的能力。如 Linux 上提供了 sched_setaffinity 方法实现这一功能，其他操作系统也有类似功能的 API 可用。当多线程同时执行密集计算，且 CPU 缓存命中率很高时，如果将每个线程分别绑定在不同的 CPU 核心上，性能便会获得非常可观的提升。<br><br>### 1.5  操作系统<br><br><figure class="image-box">                <img src="image-20220208105427891.png" alt="image-20220208105427891" title class>                <p>image-20220208105427891</p>            </figure><p>有了冯诺伊曼计算机体系后，电脑想要为用户提供便捷的服务还需要安装个操作系统<code>Operation System</code>，操作系统是覆盖在硬件上的一层特殊软件，它管理计算机的硬件和软件资源，为其他应用程序提供大量服务。可以理解为操作系统是日常应用程序跟硬件之间的接口。日常你经常在用Windows/Linux 系统，操作系统给我们提供了超级大的便利，但是你了解操作系统么？操作系统是如何进行<strong>内存管理</strong>、<strong>进程管理</strong>、<strong>文件管理</strong>、<strong>输入输出管理</strong>的呢？</p><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><p>你的电脑是32位操作系统，那可支持的最大内存就是4G，你有没有好奇为什么可以同时运行2个以上的2G内存的程序。应用程序不是直接使用的物理地址，操作系统为每个运行的进程分配了一套<code>虚拟地址</code>，每个进程都有自己的<code>虚拟内存地址</code>，进程是无法直接进行<code>物理内存地址</code>的访问的。至于虚拟地址跟物理地址的映射，进程是感知不到的！<code>操作系统自身会提供一套机制将不同进程的虚拟地址和不同内存的物理地址进行映射</code>。</p><figure class="image-box">                <img src="image-20220208105446194.png" alt="image-20220208105446194" title class>                <p>image-20220208105446194</p>            </figure><h3 id="2-1-MMU"><a href="#2-1-MMU" class="headerlink" title="2.1  MMU"></a>2.1  MMU</h3><p><code>Memory Management Unit 内存管理单元</code>是一种负责处理CPU内存访问请求的计算机硬件。它的功能包括<strong>虚拟地址到物理地址的转换、内存保护、中央处理器高速缓存的控制</strong>。现代 CPU 基本上都选择了使用 MMU。</p><p>当进程持有虚拟内存地址的时候，CPU执行该进程时会操作虚拟内存，而MMU会自动的将虚拟内存的操作映射到物理内存上。</p><figure class="image-box">                <img src="image-20220208105504831.png" alt="image-20220208105504831" title class>                <p>image-20220208105504831</p>            </figure><p>这里提一下，Java操作的时候你看到的地址是<code>JVM地址</code>，不是真正的物理地址。</p><h3 id="2-2-内存管理方式"><a href="#2-2-内存管理方式" class="headerlink" title="2.2  内存管理方式"></a>2.2  内存管理方式</h3><p>操作系统主要采用<code>内存分段</code>和<code>内存分页</code>来管理虚拟地址与物理地址之间的关系，其中分段是很早前的方法了，现在大部分用的是分页，不过分页也不是完全的分页，是在分段的基础上再分页。</p><h5 id="2-2-1-内存分段"><a href="#2-2-1-内存分段" class="headerlink" title="2.2.1 内存分段"></a>2.2.1 内存分段</h5><figure class="image-box">                <img src="image-20220208105534576.png" alt="image-20220208105534576" title class>                <p>image-20220208105534576</p>            </figure><p>我们以上图的<a href="https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489183&amp;idx=1&amp;sn=02ab3551c473bd2c8429862e3689a94b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JVM</a>内存模型举例，程序员会认为我们的代码是由代码段、数据段、栈段、堆段组成。不同的段是有不同的属性的，用户并不关心这些元素所在内存的位置，而分段就是支持这种用户视图的内存管理方案。逻辑地址空间是由一组段构成。每个段都有名称和长度。地址指定了段名称和段内偏移。因此用户<code>段编号</code>和<code>段偏移</code>来指定不同属性的地址。而虚拟内存地址跟物理内存地址中间是通过段表进行映射的，口说无凭，看图吧。</p><figure class="image-box">                <img src="image-20220208105557349.png" alt="image-20220208105557349" title class>                <p>image-20220208105557349</p>            </figure><p>如上虚拟地址有 5 个段，各段按如图所示来存储。每个段都在段表中有一个条目，它包括段在物理内存内的开始的基地址和该段的界限长度。例如段 2 为 400 字节长，开始于位置 4300。因此对段 2 字节 53 的引用映射成位置 4300 + 53 = 4353。对段 3 字节 852 的引用映射成位置 3200 + 852 = 4052。</p><p>分段映射很简单，但是会导致<code>内存碎片</code>跟<code>内存交互效率低</code>。这里先普及下在内存管理中主要有<code>内部内存碎片</code>跟<code>外部内存碎片</code>。</p><ol><li><strong>内部碎片</strong>：已经被分配出去的的内存空间不经常使用，并且分配出去的内存空间大于请求所需的内存空间。</li><li><strong>外部碎片</strong>：指可用空间还没有分配出去，但是可用空间由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。</li></ol><p>以上图为例，现在系统空闲是1400 +  800 + 600 = 2800。那如果有个程序想要连续的使用2000，内存分段模式下提供不了啊！上述三个是<code>外部内存碎片</code>。当然可以使用系统的<code>Swap</code>空间，先把段0写入到磁盘，然后再重新给段0分配空间。这样可以实现最终可用，可是但凡涉及到磁盘读写就会导致<code>内存交互效率低</code>。</p><figure class="image-box">                <img src="image-20220208105626772.png" alt="image-20220208105626772" title class>                <p>image-20220208105626772</p>            </figure>swap空间利用<br><br>##### 2.2.2 内存分页<br><br>内存分页，<code>整个虚拟内存和物理内存切成一段段固定尺寸的大小</code>。每个固定大小的尺寸称之为<code>页Page</code>，在 Linux 系统中Page = 4KB。然后虚拟内存跟物理内存之间通过<code>页表</code>来实现映射。<br><br>采用<strong>内存分页</strong>时内存的释放跟使用都是以页为单位的，也就不会产生内存碎片了。当空间还不够时根据操作系统调度算法，可能将最少用的内存页面 swap-out换出到磁盘，用时候再swap-in换入，尽可能的减少磁盘刷写量，提高内存交互效率。<br><br>分页模式下虚拟地址主要有<code>页号</code>跟<code>页内偏移量</code>两部分组成。通过页号查询页表找到物理内存地址，然后再配合页内偏移量就找到了真正的物理内存地址。<br><br><figure class="image-box">                <img src="image-20220208105654323.png" alt="image-20220208105654323" title class>                <p>image-20220208105654323</p>            </figure><p>32位操作系统环境下进程可操作的虚拟地址是4GB，假设一个虚拟页大小为4KB，那需要4GB/4KB = <code>2^20</code> 个页信息。一行页表记录为4字节，<code>2^20</code>等价于4MB页表存储信息。这只是一个进程需要的，如果10个、100个、1000个呢？仅仅是页表存储都占据超大内存了。</p><p>为了解决这个问题就需要用到 <code>多级页表</code>，核心思想就是<strong>局部性</strong>分配。在32位的操作系统中将将4G空间分为 1024 行页目录项目(4KB)，每个页目录项又对应1024行页表项。如下图所示：</p><figure class="image-box">                <img src="image-20220208105706021.png" alt="image-20220208105706021" title class>                <p>image-20220208105706021</p>            </figure><p>控制寄存器cr3中存放了页目录的物理地址，通过cr3寄存器可以找到页目录，而32位线性地址中的Directory部分决定页目录中的目录项，而页目录项中存放了要找的页表的物理基地址，再结合线性地址中的中间10位页表项，就可以找到页框的页表项。线性地址中的Offset部分占12位，因此页框的物理地址 + 线性地址Offset部分 = 页框中的任何一个字节。</p><p>分页后一级页就等价于4G虚拟地址空间，并且如果一级页表中那些地址没有就不需要再创建二级页表了！核心思想就是按需创建，当系统给每个进程分配4G空间，进程不可能占据全部内存的，如果一级目录页只有10%用到了，此时页表空间 = 一级页表4KB + 0.1 * 4MB  。这比单独的每个进程占据4M好用多了！</p><p>多层分页的弊端就是访问时间的<strong>增加</strong>。</p><ol><li>使用页表时读取内存中一页内容需要2次访问内存，访问页表项 + 并读取的一页数据。</li><li>使用二级页表的话需要三次访问，访问页目录项 + 访问页表项 + 访问并读取的一页数据。访存次数的增加也就意味着访问数据所花费的总时间增加。</li></ol><p>而对于64位系统，二级分页就无法满足了，Linux 从2.6.11开始采用四级分页模型。</p><ol><li>Page Global Directory 全局页目录项</li><li>Page Upper Directory 上层页目录项</li><li>Page Middle Directory 中间页目录项</li><li>Page Table Entry 页表项</li><li>Offset 偏移量。</li></ol><figure class="image-box">                <img src="image-20220208105725267.png" alt="image-20220208105725267" title class>                <p>image-20220208105725267</p>            </figure><h5 id="2-2-2-TLB"><a href="#2-2-2-TLB" class="headerlink" title="2.2.2 TLB"></a>2.2.2 TLB</h5><p>Translation Lookaside Buffer 可翻译为<code>地址转换后援缓冲器</code>，简称为<code>快表</code>，属于CPU内部的一个模块，TLB是MMU的一部分，实质是cache，它所缓存的是最近使用的数据的页表项（虚拟地址到物理地址的映射）。他的出现是为了加快访问数据（内存）的速度，减少重复的页表查找。当然它不是必须要有的，但有它，速度就更快。</p><figure class="image-box">                <img src="image-20220208105732620.png" alt="image-20220208105732620" title class>                <p>image-20220208105732620</p>            </figure><p>TLB很小，因此缓存的东西也不多。主要缓存最近使用的数据的数据映射。TLB结构如下图：</p><figure class="image-box">                <img src="image-20220208105743431.png" alt="image-20220208105743431" title class>                <p>image-20220208105743431</p>            </figure><p>如果一个需要访问内存中的一个数据，给定这个数据的虚拟地址，查询TLB，发现有hit，直接得到物理地址，在内存根据物理地址取数据。如果TLB没有这个虚拟地址miss，那么只能费力的通过页表来查找了。日常CPU读取一个数据的流程如下：</p><figure class="image-box">                <img src="image-20220208105753365.png" alt="image-20220208105753365" title class>                <p>image-20220208105753365</p>            </figure><p>当进程地址空间进行了<code>上下文切换</code>时，比如现在是进程1运行，TLB中放的是进程1的相关数据的地址，突然切换到进程2，TLB中原有的数据不是进程2相关的，此时TLB刷新数据有两种办法。</p><ol><li><strong>全部刷新</strong>：很简单，但花销大，很多不必刷新的数据也进行刷新，增加了无畏的花销。</li><li><strong>部分刷新</strong>：根据标志位，刷新需要刷新的数据，保留不需要刷新的数据。</li></ol><h5 id="2-2-3-段页式管理"><a href="#2-2-3-段页式管理" class="headerlink" title="2.2.3 段页式管理"></a>2.2.3 段页式管理</h5><p><code>内存分段</code>跟<code>内存分页</code>不是对立的，这俩可以组合起来在同一个系统中使用的，那么组合起来后通常称为<code>段页式内存管理</code>。段页式内存管理实现的方式：</p><ol><li>先对数据不同划分出不同的段，也就是前面说的分段机制。</li><li>然后再把每一个段进行分页操作，也就是前面说的分页机制。</li><li>此时 地址结构 = 段号 + 段内页号 + 页内位移。</li></ol><p>每一个进程有一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。</p><figure class="image-box">                <img src="image-20220208105806478.png" alt="image-20220208105806478" title class>                <p>image-20220208105806478</p>            </figure>段页式管理<br><br><br>同时我们经常看到两个专业词<code>逻辑地址</code>跟<code>线性地址</code>。<br><br><br><br>1. <code>逻辑地址</code>：指的是没被段式内存管理映射的地址。<br>2. <code>线性地址</code>：通过段式内存管理映射且页式内存管理转换前的地址，俗称虚拟地址。<br><br>目前 Intel X86 CPU 采用的是内存分段 +  内存分页的管理方式，其中分页的意思是在由段式内存管理所映射而成的的地址上再加上一层地址映射。<br><br><figure class="image-box">                <img src="image-20220208105815982.png" alt="image-20220208105815982" title class>                <p>image-20220208105815982</p>            </figure><h5 id="2-2-4-Linux-内存管理"><a href="#2-2-4-Linux-内存管理" class="headerlink" title="2.2.4 Linux 内存管理"></a>2.2.4 Linux 内存管理</h5><p>先说结论：Linux系统基于X86 CPU 而做的操作系统，所以也是用的段页式内存管理方式。</p><figure class="image-box">                <img src="image-20220208105825019.png" alt="image-20220208105825019" title class>                <p>image-20220208105825019</p>            </figure><p>我们知道32位的操作系统可寻址范围是4G，操作系统会将4G的可访问内存空间分为<strong>用户空间</strong>跟<strong>内核空间</strong>。</p><ol><li><code>内核空间</code>：操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。内核态下CPU可执行任何指令，可自由访问任何有效地址。</li><li><code>用户空间</code>：普通应用程序可访问的内存区域。被执行代码会受到CPU众多限制，进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。</li></ol><p>那为啥要搞俩空间呢?现在嵌入式环境跟以前的WIN98系统是没有区分俩空间的，须知俩空间是CPU分的，而操作系统是在上面运行的，单一用户、单一任务服务的操作系统，是没有分所谓用户态和内核态的必要。用户态和内核态是因为有多用户，多任务的需求，然后在CPU硬件厂商配合之后，产生的一个操作系统解决多用户多任务需求的方案。方案就是<strong>限制</strong>，通过硬件手段（也只能硬件手段才能做到），限制某些代码，使其无法控制整个物理硬件，进而使各个不同用户，不同任务的代码，无权修改整个物理硬件，再进而保护操作系统的核心底层代码和其他用户的数据不被无意或者有意地破坏和盗取。</p><figure class="image-box">                <img src="image-20220208105839460.png" alt="image-20220208105839460" title class>                <p>image-20220208105839460</p>            </figure><p>后来研究者根据<strong>CPU</strong>的运行级别，分成了Ring0~Ring3四个级别。Ring0是最高级别，Ring1次之，Rng2更次之，拿Linux+x86来说，  操作系统内核的代码运行在最高运行级别Ring0上，可以使用特权指令，控制中断、修改页表、访问设备等。 应用程序的代码运行在最低运行级别上Ring3上，不能做受控操作，只能访问用户被分配的空间。如果要做访问磁盘跟写文件等操作，那就要通过执行系统调用函数，执行系统调用的时候，CPU的运行级别会发生从Ring3到Ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从Ring0返回Ring3。这个过程也称作<strong>用户态和内核态的切换</strong>。</p><p>用户态想要使用计算机设备或IO需通过系统调用完成sys call，系统调用就是让内核来做这些操作。而系统调用是影响整个当前进程上下文的，ＣＰＵ提供了个软中断来是实现保护线程，获取系统调用号跟参数，交给内核对应系统调用函数执行。</p><figure class="image-box">                <img src="image-20220208105855383.png" alt="image-20220208105855383" title class>                <p>image-20220208105855383</p>            </figure><p>可以看到每个应用程序都各自有独立的虚拟内存地址，但每个虚拟内存中对应的内核地址其实是相同的一大块，这样当进程切换到内核态后可以很方便地访问内核空间内存。比如Java代码创建线程<code>new Thread</code>调用<code>start</code>方法后跟踪<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489183&amp;idx=1&amp;sn=02ab3551c473bd2c8429862e3689a94b&amp;chksm=ebdef7a7dca97eb17194c3d935c86ade240d3d96bbeaf036233a712832fb94af07adeafa098b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><code>JVM</code></a>源码你会发现是调用<code>pthread_create</code>来创建线程的，这就涉及到了用户态到内核态的切换。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h1><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><p>进程是程序的一次执行，是一个程序及其数据在机器上顺序执行时所发生的活动，是具有独立功能的程序在一个数据集合上的一次运行过程，是系统进行资源分配和调度的一个基本单位。进程的<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489439&amp;idx=1&amp;sn=df404e70a8e55b4019317ef2036fbe7d&amp;chksm=ebdef6a7dca97fb1e1a0dfd2eab194fa87f4971cd6b88645db072bcc9c98614b0ad30dc43399&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">调度状态</a>如下：</p><figure class="image-box">                <img src="640.png" alt="图片" title class>                <p>图片</p>            </figure>状态变化图<br><br><br>重点说下<code>挂起</code>跟<code>阻塞</code>：<br><br><br><br>1. 阻塞一般是当系统执行IO操作时，此时进程进入阻塞状态，等待某个事件的返回。<br>2. 挂起是指进程没有占有物理内存，被写到磁盘上了。这时进程状态是挂起状态。<br><br>&gt; 1. <code>阻塞挂起</code>：进程被写入硬盘并等待某个事件的出现。<br>&gt; 2. <code>就绪挂起</code>：进程被写入硬盘，进入内存可直接进入就绪状态。<br><br>### 3.2 PCB<br><br>为了描述跟控制进程的运行，系统为每个进程定义了一个数据结构——<code>进程控制块 Process Control Block</code>，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。<br><br>PCB 的作用是<strong>使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程</strong> :<br><br>1. 作为独立运行基本单位的标志<br>2. 实现间断性的运行方式<br>3. 提供进程管理所需要的信息<br>4. 提供进程调度所需要的信息<br>5. 实现与其他进程的同步与通信<br><br>##### 3.2.1 PCB 信息<br><br>PCB为实现上述功能，内部包含众多信息：<br><br>1. <strong>进程标识符</strong>：用于唯一地标识一个进程，一个进程通常有两种标识符：<br><br>&gt; 1. <code>内部进程标识符</code>：标识各个进程，每个进程都有一个并且唯一的标识符，设置内部标识符主要是为了方便系统使用。<br>&gt; 2. <code>外部进程标识符</code>：它由创建者提供，可设置用户标识，以指示拥有该进程的用户。往往是由用户进程在访问该进程时使用。一般为了描述进程的家族关系，还应设置父进程标识及子进程标识。<br><br>1. <strong>处理机状态</strong>：由各种寄存器组成。包含许多信息都放在寄存器中，方便程序restart。<br><br>&gt; 1. 通用寄存器、指令计数器、程序状态字PSW、用户栈指针等信息。<br><br>1. <strong>进程调度信息</strong><br><br>&gt; 1. 进程状态：指明进程的当前状态，作为进程调度和对换时的依据。<br>&gt; 2. 进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机<br>&gt; 3. 进程调度所需的其它信息：与所采用的进程调度算法有关，如进程已等待CPU的时间总和、进程已执行的时间总和等。<br>&gt; 4. 事件：指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。<br><br>1. <strong>资源清单</strong><br><br>&gt; 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。<br><br>##### 3.2.2 PCB 组织方式<br><br>操作系统中有太多 PCB，如何管理是个问题，一般有如下方式。<br><br><figure class="image-box">                <img src="image-20220208105914468.png" alt="image-20220208105914468" title class>                <p>image-20220208105914468</p>            </figure><ol><li><strong>线性方式</strong>：</li></ol><blockquote><ol><li>将系统所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域</li><li>实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统</li></ol></blockquote><figure class="image-box">                <img src="image-20220208105928416.png" alt="image-20220208105928416" title class>                <p>image-20220208105928416</p>            </figure>索引方式<br><br>1. <strong>索引方式</strong>：<br><br>&gt; 1. 将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。<br><br><figure class="image-box">                <img src="image-20220208105942343.png" alt="image-20220208105942343" title class>                <p>image-20220208105942343</p>            </figure><ol><li><strong>链接方式</strong>：</li></ol><blockquote><ol><li>把同一状态的PCB链接成一个队列，形成就绪队列、阻塞队列、空白队列等。对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前。</li><li>因为进程创建、销毁、调度频繁，所以<strong>一般采用此模式</strong>。</li></ol></blockquote><h3 id="3-3-进程控制"><a href="#3-3-进程控制" class="headerlink" title="3.3 进程控制"></a>3.3 进程控制</h3><p>进程控制是进程管理最基本的功能，主要包括<code>创建新进程</code>，<code>终止已完成的进程</code>，<code>将发生异常的进程置于阻塞状态</code>，<code>将进程唤醒</code>等。</p><h5 id="3-3-1-进程创建"><a href="#3-3-1-进程创建" class="headerlink" title="3.3.1 进程创建"></a>3.3.1 进程创建</h5><p>父进程可创建子进程，父进程终止后子进程也会被终止。子进程可继承父进程所有资源，子进程终止需将自己所继承的资源归还父进程。接下来看下创建的大致流程。</p><ol><li>为新进程分配唯一进件标识号，然后创建一个空白PCB，需注意PCB数量是有限的，所以可能会创建失败。</li><li>尝试为新进程分配所需资源，如果资源不足进程会进入等待状态。</li><li>初始化PCB，有如下几个操作。</li></ol><blockquote><ol><li>标识信息：将系统分配的标识符和父进程标识符填入新PCB</li><li>处理机状态信息：使程序计数器指向程序入口地址，使栈指针指向栈顶</li><li>处理机控制信息：将进程设为就绪/静止状态，通常设为最低优先级</li></ol></blockquote><ol><li>如果进程调度队列能接纳新进程，就将进程插入到就绪队列，等待被调度运行。</li></ol><h5 id="3-3-2-进程终止"><a href="#3-3-2-进程终止" class="headerlink" title="3.3.2 进程终止"></a>3.3.2 进程终止</h5><p>进程终止情况一般分为正常结束、异常结束、外界干预三种。</p><ol><li>正常结束</li><li>异常结束</li></ol><blockquote><ol><li>越界错：访问的存储区越出该进程的区域</li><li>保护错：试图访问不允许访问的资源，或以不适当的方式访问（写只读）</li><li>非法指令：试图执行不存在的指令（可能是程序错误地转移到数据区，数据当成了指令）</li><li>特权指令出错：用户进程试图执行一条只允许OS执行的指令</li><li>运行超时：执行时间超过指定的最大值</li><li>等待超时：进程等待某件事超过指定的最大值</li><li>算数运算错：试图执行被禁止的运算（被0除）</li><li>I/O故障</li></ol></blockquote><ol><li>外界干预</li></ol><blockquote><ol><li>操作员或OS干预（死锁）</li><li>父进程请求，子进程完成父进程指定的任务时</li><li>父进程终止，所有子进程都应该结束</li></ol></blockquote><p><strong>终止过程</strong>：</p><ol><li>根据被终止进程的标识符，从PCB集合中检索出该PCB，读取进程状态</li><li>若处于执行状态则立即终止执行，将CPU资源分配给其他进程。</li><li>若进程有子孙进程则将其所有子孙进程终止。</li><li>全部资源还给父进程或操作系统。</li><li>该进程的PCB从所在队列/链表中移出。</li></ol><h5 id="3-3-3-进程阻塞"><a href="#3-3-3-进程阻塞" class="headerlink" title="3.3.3 进程阻塞"></a>3.3.3 进程阻塞</h5><p>意思是该进程执行半路被阻塞，必须由某个事件进程唤醒该进程。常见的就是IO读取操作。常见阻塞时机/事件如下：</p><ol><li>请求共享资源失败，系统无足够资源分配</li><li>等待某种操作完成</li><li>新数据尚未到达（相互合作的进程）</li><li>等待新任务</li></ol><p><strong>阻塞流程</strong>：</p><ol><li>找到要被阻塞进程标识号对应的 PCB。</li><li>将该进程由运行状态转换为阻塞状态。</li><li>将该 进程PCB 插入的阻塞队列中去。</li></ol><h5 id="3-3-4-进程唤醒"><a href="#3-3-4-进程唤醒" class="headerlink" title="3.3.4 进程唤醒"></a>3.3.4 进程唤醒</h5><p>唤醒 原语 wake up，一般和阻塞成对使用。唤醒过程如下：</p><ol><li>从阻塞队列找到所需PCB。</li><li>PCB从阻塞队列溢出，然后变为就绪状态。</li><li>从阻塞队列溢出该PCB然后插入到就绪状态队列等待被分配CPU资源。</li></ol><h3 id="3-4-进程调度"><a href="#3-4-进程调度" class="headerlink" title="3.4 进程调度"></a>3.4 进程调度</h3><p>进程数一般会大于CPU个数，进程状态切换主要由调度程序进行调度。一般情况下CPU调度时主要分为<code>抢占式调度</code>跟<code>非抢占式调度</code>。</p><ol><li><code>非抢占式</code>：让进程运行直到结束或阻塞的调度方式， 容易实现，适合专用系统。</li><li><code>抢占式</code>：每个进程获得时间片才可以被CPU调度运行， 可防止单一进程长时间独占CPU 系统开销大。</li></ol><h5 id="3-4-1-进程调度原则"><a href="#3-4-1-进程调度原则" class="headerlink" title="3.4.1 进程调度原则"></a>3.4.1 进程调度原则</h5><ol><li><strong>CPU 利用率</strong></li></ol><blockquote><ol><li>CPU利用率 = 忙碌时间 / 总时间。</li><li>调度程序应该尽量让 CPU 始终处于忙碌的状态，这可提高 CPU 的利用率。比如当发生IO读取时候，不要傻傻等待，去执行下别的进程。</li></ol></blockquote><ol><li><strong>系统吞吐量</strong></li></ol><blockquote><ol><li>系统吞吐量 = 总共完成多少个作业 / 总共花费时间。</li><li>长作业的进程会占用较长的 CPU 资源导致降低吞吐量，相反短作业的进程会提升系统吞吐量。</li></ol></blockquote><ol><li><strong>周转时间</strong></li></ol><blockquote><ol><li>周转时间 = 作业完成时间 - 作业提交时间。</li><li>平均周转时间 = 各作业周转时间和 / 作业数</li><li>带权周转时间 = 作业周转时间 / 作业实际运行时间</li><li>平均带权周转时间 = 各作业带权周转时间之和 / 作业数</li><li>尽可能使周转时间降低。</li></ol></blockquote><ol><li><strong>等待时间</strong></li></ol><blockquote><ol><li>指的是进程在等待队列中等待的时间，一般也需要尽可能短。</li><li><strong>响应时间</strong><br>响应时间 = 系统第一次响应时间 - 用户提交时间，在交互式系统中响应时间是衡量调度算法好坏的主要标准。</li></ol></blockquote><h5 id="3-4-2-调度算法"><a href="#3-4-2-调度算法" class="headerlink" title="3.4.2 调度算法"></a>3.4.2 调度算法</h5><p><strong>FCFS 算法</strong></p><ol><li>First Come First Severd 先来先服务算法，遵循先来后端原则，每次从就绪队列拿等待时间最久的，运行完毕后再拿下一个。</li><li>该模式对长作业有利，适用 CPU 繁忙型作业的系统，不适用 I/O 型作业，因为会导致进程CPU利用率很低。</li></ol><p><strong>SJF 算法</strong></p><ol><li>Shortest Job First 最短作业优先算法，该算法会优先选择运行所需时间最短的进程执行，可提高吞吐量。</li><li>跟FCFS正好相反，对长作业很不利。</li></ol><p><strong>SRTN 算法</strong></p><ol><li>Shortest Remaining Time Next 最短剩余时间优先算法，可以认为是SJF的抢占式版本，当一个新就绪的进程比当前运行进程具有更短完成时间时，系统抢占当前进程，选择新就绪的进程执行。</li><li>有最短的平均周转时间，但不公平，源源不断的短任务到来，可能使长的任务长时间得不到运行。</li></ol><p><strong>HRRN 算法</strong></p><ol><li>Highest Response Ratio Next 最高响应比优先算法，为了平衡前面俩而生，按照响应优先权从高到低依次执行。属于前面俩的折中权衡。</li><li>优先权 = (等待时间 + 要求服务时间) / 要求服务时间</li></ol><p><strong>RR 算法</strong></p><ol><li>Round Robin 时间片轮转算法，操作系统设定了个时间片Quantum，时间片导致每个进程只有在该时间片内才可以运行，这种方式导致每个进程都会均匀的获得执行权。</li><li>时间片一般20ms~50ms，如果太小会导致系统频繁进行上下文切换，太大又可能引起对短的交互请求的响应变差。</li></ol><p><strong>HPF 算法</strong></p><ol><li>Highest Priority First 最高优先级调度算法，从就绪队列中选择最高优先级的进程先执行。</li><li>优先级的设置有初始化固定死的那种，也有在代码运转过程中根据等待时间或性能动态调整 这两种思路。</li><li>缺点是可能导致低优先级的一直无法被执行。</li></ol><p><strong>MFQ 算法</strong></p><ol><li><p>Multilevel Feedback Queue 多级反馈队列调度算法 ，可以认为是 RR 算法 跟 HPF 算法 的综合体。</p></li><li><p>系统会同时存在多个就绪队列，每个队列优先级从高到低排列，同时优先级越高获得是时间片越短。</p></li><li><p>新进程会先加入到最高优先级队列，如果新进程优先级高于当前在执行的进程，会停止当前进程转而去执行新进程。新进程如果在时间片内没执行完毕需下移到次优先级队列。</p><p><img src="image-20220208110001762.png" alt="image-20220208110001762">多级反馈队列调度算法</p></li></ol><h3 id="3-5-线程"><a href="#3-5-线程" class="headerlink" title="3.5 线程"></a>3.5 线程</h3><h5 id="3-5-1-线程定义"><a href="#3-5-1-线程定义" class="headerlink" title="3.5.1 线程定义"></a>3.5.1 线程定义</h5><p>早期操作系统是没有线程概念的，线程是后来加进来的。为啥会有线程呢？那是因为以前在多进程阶段，经常会涉及到进程之间如何通讯，如何共享数据的问题。并且进程关联到PCB的生命周期，管理起来开销较大。为了解决这个问题引入了线程。</p><p>线程是进程当中的一个执行流程。同一个进程内的多个线程之间可以共享进程的代码段、数据段、打开的文件等资源。同时每个线程又都有一套独立的寄存器和栈来确保线程的控制流是独立的。</p><p>进程有个<code>PCB</code>来管理，同理操作系统通过 <code>Thread Control Block</code>线程控制块来实现线程的管控。</p><h5 id="3-5-2-线程优缺点"><a href="#3-5-2-线程优缺点" class="headerlink" title="3.5.2 线程优缺点"></a>3.5.2 线程优缺点</h5><p><strong>优点</strong></p><ol><li>一个进程中可以同时存在1~N个线程，这些线程可以并发的执行。</li><li>各个线程之间可以共享地址空间和文件等资源。</li></ol><p><strong>缺点</strong></p><ol><li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。</li><li>多线程编程，让人头大的东西。</li><li>线程执行开销小，但不利于资源的隔离管理和保护，而进程正相反。</li></ol><h5 id="3-5-3-进程跟线程关联"><a href="#3-5-3-进程跟线程关联" class="headerlink" title="3.5.3 进程跟线程关联"></a>3.5.3 进程跟线程关联</h5><p><strong>进程</strong>：</p><ol><li>是系统进行资源分配和调度的一个独立单位.</li><li>是程序的一次执行，每个进程都有自己的地址空间、内存、数据栈及其他辅助记录运行轨迹的数据</li></ol><p><strong>线程</strong>：</p><ol><li>是进程的一个实体，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位</li><li>所有的线程运行在同一个进程中，共享相同的运行资源和环境</li><li>线程一般是并发执行的，使得实现了多任务的并行和数据共享。</li></ol><p><strong>进程线程区别</strong>：</p><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>CPU分配资源给进程，但真正在CPU上运行的是线程。</li><li>线程不能够独立执行，必须依存在进程中。</li></ol><p><strong>线程快在哪儿</strong>？</p><ol><li>线程创建的时有些资源不需要自己管理，直接从进程拿即可，线程管理寄存器跟栈的生命周期即可。</li><li>同进程内多线程共享数据，所以进程数据传输可以用zero copy技术，不需要经过内核了。</li><li>进程使用一个虚拟内存跟页表，然后多线程共用这些虚拟内存，如果同进程内两个线程进行上下文切换比进程提速很多。</li></ol><h5 id="3-5-4-线程实现"><a href="#3-5-4-线程实现" class="headerlink" title="3.5.4 线程实现"></a>3.5.4 线程实现</h5><p>在前面的内存管理中说到了内核态跟用户态。相对应的线程的创建也分为<code>用户态线程</code>跟<code>内核态线程</code>。</p><h6 id="3-5-4-1-用户态线程"><a href="#3-5-4-1-用户态线程" class="headerlink" title="3.5.4.1 用户态线程"></a>3.5.4.1 用户态线程</h6><p>在用户空间实现的线程，由用户态的线程库来完成线程的管理。操作系统按进程维度进行调度，<strong>当线程在用户态创建时应用程序在用户空间内要实现线程的创建、维护和调度。操作系统对线程的存在一无所知</strong>！操作系统只能看到进程看不到线程。所有的线程都是在用户空间实现。在操作系统看来，每一个进程只有一个线程。</p><figure class="image-box">                <img src="image-20220208110024780.png" alt="image-20220208110024780" title class>                <p>image-20220208110024780</p>            </figure>用户态线程<br><br><strong>好处</strong>：<br><br>1. 及时操作系统不支持线程模式也可以通过用户层库函数来支持线程模式，TCB 由用户级线程库函数来维护。<br>2. 使用库函数模式实现线程可以避免用户态到内核态的切换。<br><br><strong>坏处</strong>：<br><br>1. CPU不知道线程存在，CPU的时间片切换是以进程为维度的，某个线程因为IO等操作导致线程阻塞，操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。<br>2. 用户态线程没法打断正在运行中的线程，除非线程主动交出CPU使用权。<br><br>###### 3.5.4.2 内核态线程<br><br>在内核中实现的线程，是由内核管理的线程，线程对应的 TCB 在操作系统里，这样线程的创建、终止和管理都是由操作系统负责。内线程模式下一个用户线程对应一个内核线程。<br><br><figure class="image-box">                <img src="image-20220208110103377.png" alt="image-20220208110103377" title class>                <p>image-20220208110103377</p>            </figure>内核态线程<br><br><br><strong>注意</strong>：Linux中的JVM从1.2版以后是基于pthread实现的，<code>所以现在Java中线程的本质就是操作系统中的线程</code>。<br><br><strong>优点</strong>：<br><br>1. 一个进程中某个线程阻塞不会影响其他内核线程运行。<br>2. 用户态模式一个时间片分给多个线程，内核态模式直接分配给线程的时间片增加。<br><br><strong>缺点</strong>：<br><br>1. 内核级线程调度开销较大。调度内核线程的代价可能和调度进程差不多昂贵，代价要比用户级线程大很多。一个线程默认栈=1M，线程多了会导致内存消耗很大。<br>2. 线程表是存放在操作系统固定的表格空间或者堆栈空间里，所以内核级线程的数量是有限的。<br><br>###### 3.4.4.3 轻量级进程<br><br>最初的进程定义都包含程序、资源及其执行三部分，其中程序通常指代码，资源在操作系统层面上通常包括内存资源、IO资源、信号处理等部分，而程序的执行通常理解为执行上下文，包括对CPU的占用，后来发展为线程。在线程概念出现以前，为了减小进程切换的开销，操作系统设计者逐渐修正进程的概念，逐渐允许将进程所占有的资源从其主体剥离出来，允许某些进程共享一部分资源，例如文件、信号，数据内存，甚至代码，这就发展出轻量进程的概念。<br><br>Light-weight process <strong>轻量级进程是内核支持的用户线程</strong>，它是基于内核线程的高级抽象，系统只有先支持内核线程才能有 LWP。一个进程可有1~N个LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。<br><br><figure class="image-box">                <img src="image-20220208110121188.png" alt="image-20220208110121188" title class>                <p>image-20220208110121188</p>            </figure>LWP模式<br><br><strong>轻量级进程本质还是进程</strong>，只是跟普通进程相比LWP跟其他进程共享大部分逻辑地址空间跟系统资源，LWP轻量体现在它只有一个最小的执行上下文和调度程序所需的统计信息。他是进程的执行部分，只带有执行相关的信息。<br><br><strong>Linux特性</strong>：<br><br>1. Linux中没有真正的线程，因为Linux并没有为线程准备特定的数据结构。在内核看来只有进程而没有线程，在调度时也是当做进程来调度。Linux所谓的线程其实是与其他进程共享资源的进程。但windows中确实有线程。<br>2. Linux中没有的线程，线程是由进程来模拟实现的。<br>3. 所以在Linux中在CPU角度看，进程被称作轻量级进程LWP。<br><br>##### 3.5.5 协程<br><br>###### 3.5.5.1 协程定义<br><br>大多数web服务跟互联网服务本质上大部分都是 IO 密集型服务，IO 密集型服务的瓶颈不在CPU处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。以前有两种解决方案：<br><br>1. <code>多进程</code>：存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。<br>2. <code>多线程</code>：高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题。<br><br>此时协程出现了，协程 Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程。可以简单的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。<br><br><figure class="image-box">                <img src="image-20220208110132404.png" alt="image-20220208110132404" title class>                <p>image-20220208110132404</p>            </figure><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多，一般在Python、Go中会涉及到协程的知识，尤其是现在高性能的脚本Go。</p><h6 id="3-5-5-2-协程注意事项"><a href="#3-5-5-2-协程注意事项" class="headerlink" title="3.5.5.2 协程注意事项"></a>3.5.5.2 协程注意事项</h6><p>协程运行在线程之上，并且协程调用了一个阻塞IO操作，此时操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作时，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度。</p><p>因此在协程中不能调用导致线程阻塞的操作，比如打印、读取文件、Socket接口等。<code>协程只有和异步IO结合</code>起来才能发挥最大的威力。并且<strong>协程只有在IO密集型的任务中才会发挥作用</strong>。</p><h3 id="3-6-进程通信"><a href="#3-6-进程通信" class="headerlink" title="3.6 进程通信"></a>3.6 进程通信</h3><p>进程的用户地址空间是相互独立的，不可以互相访问，但内核空间是进程都共享的，所以进程之间要通信必须通过内核。<strong>进程间通信主要通过管道、消息队列、共享内存、信号量、信号、Socket编程</strong>。</p><h5 id="3-6-1-管道"><a href="#3-6-1-管道" class="headerlink" title="3.6.1 管道"></a>3.6.1 管道</h5><p>管道主要分为匿名管道跟命名管道两种，可以实现数据的单向流动性。<strong>使用起来很简单，但是管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。</p><p><strong>匿名管道</strong>：</p><ol><li>日常Linux系统中的<code>|</code>就是匿名管道。指令的前一个输入是后一个指令的输出。</li></ol><p><strong>命名管道</strong>：</p><ol><li>一般通过<code>mkfifo SoWhatPipe</code>创建管道。通过<code>echo &quot;sw&quot; &gt; SoWhatPipe</code>跟<code>cat &lt; SoWhatPipe</code> 实现输入跟输出。</li></ol><p>匿名管道的实现依赖<code>int pipe(int fd[2])</code>函数，其中<code>fd[0]</code>是读取断描述符，<code>fd[1]</code>是管道写入端描述符。它的本质就是在内核中创建个属于内存的缓存，从一端输入无格式数据一端输出无格式数据，需注意管道传输大小是有限的。</p><figure class="image-box">                <img src="image-20220208110149376.png" alt="image-20220208110149376" title class>                <p>image-20220208110149376</p>            </figure>管道通信底层<br><br><br>匿名管道的通信范围是存在父子关系的进程。由于管道没有实体，也就是没有管道文件，不会涉及到文件系统。只能通过<code>fork</code>子进程来复制父进程 fd 文件描述符，父子进程通过共用特殊的管道文件实现跨进程通信，并且因为管道只能一端写入，另一端读出，所以通常父子进程遵从如下要求：<br><br><br><br>1. 父进程关闭读取的 fd[0]，只保留写入的 fd[1]。<br>2. 子进程关闭写入的 fd[1]，只保留读取的 fd[0]。<br><br><figure class="image-box">                <img src="image-20220208110206417.png" alt="image-20220208110206417" title class>                <p>image-20220208110206417</p>            </figure>shell管道通信<br><br><br>需注意Shell执行匿名管道 a | b其实是通过Shell父进程fork出了两个子进程来实现通信的，而ab之间是不存在父子进程关系的。而命名管道是可以直接在不想关进程间通信的，因为有管道文件。<br><br>##### 3.6.2 消息队列<br><br><figure class="image-box">                <img src="image-20220208110230770.png" alt="image-20220208110230770" title class>                <p>image-20220208110230770</p>            </figure>消息队列<br><br>消息队列是保存在<strong>内核</strong>中的消息链表，<strong>会涉及到用户态跟内核态到来回切换</strong>，双方约定好消息体到数据结构，然后发送数据时将数据分成一个个独立的数据单元消息体，需注意消息队列及单个消息都有上限，日常我们到<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247490325&amp;idx=1&amp;sn=ab7cfedc7b8f2361cc1fab9418b314b8&amp;chksm=ebdefa2ddca9733b76cffbcba2d5f8c0c61bd36d5ebba20aaecb07148aa0fd7a5781e16ab03e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">RabbitMQ</a>、<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247488832&amp;idx=1&amp;sn=5999893d7fe773f54f7d097ac1c2074d&amp;chksm=ebdef478dca97d6e2433abdeecf600669ffbb1b68eb2b744e7ed72aac4cd5c4cabf19b0d8f19&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Redis </a>都涉及到消息队列。<br><br>##### 3.6.3 共享内存<br><br><figure class="image-box">                <img src="image-20220208110245494.png" alt="image-20220208110245494" title class>                <p>image-20220208110245494</p>            </figure>共享空间<br><br><br>现代操作系统对内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和进程B虚拟地址是一样的，真正访问的也是不同的物理内存地址，该模式不涉及到用户态跟内核态来回切换，JVM 就是用的共享内存模式。并且并发编程也是个难点。<br><br>##### 3.6.4 信号量<br><br>既然共享内存容易造成数据紊乱，那为了简单的实现共享数据在任意时刻只能被一个进程访问，此时需要信号量。<br><br><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。<br><br>信号量表示资源的数量，核心点在于原子性的控制一个数据的值，控制信号量的方式有<strong>PV两种原子操作</strong>：<br><br>1. P 操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待。相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。<br>2. V 操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行。相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程。<br><br>##### 3.6.5 信号<br><br>对于异常状态下进程工作模式需要用到信号工作方式来通知进程。比如Linux系统为了响应各种事件提供了很多异常信号<code>kill -l</code>，<strong>信号是进程间通信机制中唯一的异步通信机制</strong>，可以在任何时候发送信号给某一进程。比如：<br><br>1. kill -9 1412 ，表示给 PID 为 1412 的进程发送 SIGKILL 信号，用来立即结束该进程。<br>2. 键盘 Ctrl+C 产生 SIGINT 信号，表示终止该进程。<br>3. 键盘 Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束。<br><br>有信号发生时，进程一般有三种方式响应信号：<br><br>1. 执行默认操作：Linux操作系统为众多信号配备了专门的处理操作。<br>2. 捕捉信号：给捕捉到的信号配备专门的信号处理函数。<br>3. 忽略信号：专门用来忽略某些信号，但 SIGKILL 和 SEGSTOP是无法被忽略的，为了能在任何时候结束或停止某个进程而存在。<br><br>##### 3.6.6 Socket编程<br><br>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，<strong>那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocal)</span><br></pre></td></tr></table></figure><p>上面是socket编程的核心函数，可以指定IPV4或IPV6类型，TCP或UDP类型。比如<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247490719&amp;idx=1&amp;sn=9590fea26b75698ddb37b24ef34e0c8c&amp;chksm=ebdefda7dca974b16ac1e3ae78ff0222c4ad4bd181a70a233df8683cb3fb6199395e14bd65e6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><strong>TCP</strong></a>协议通信的 socket 编程模型如下：</p><figure class="image-box">                <img src="image-20220208110306777.png" alt="image-20220208110306777" title class>                <p>image-20220208110306777</p>            </figure>Socket编程<br><br>1. 服务端和客户端初始化 <code>socket</code>，得到文件描述符。<br>2. 服务端调用<code>bind</code>，将绑定在 IP 地址和端口。<br>3. 服务端调用 <code>listen</code>，进行监听。<br>4. 服务端调用 <code>accept</code>，等待客户端连接。<br>5. 客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求。<br>6. 服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符。<br>7. 客户端调用 <code>write</code> 写入数据，服务端调用 <code>read</code> 读取数据。<br>8. 客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了<code>EOF</code>，待处理完数据后，服务端调用 close，表示连接关闭。<br>9. 服务端调用 <code>accept</code>时，连接成功会返回一个已完成连接的 <code>socket</code>，后续用来传输数据。服务端有俩<code>socket</code>，一个叫作监听 <code>socket</code>，一个叫作已完成连接 <code>socket</code>。<br>10. 成功连接建立之后双方开始通过 read 和 write 函数来读写数据。<br><br><figure class="image-box">                <img src="image-20220208110319666.png" alt="image-20220208110319666" title class>                <p>image-20220208110319666</p>            </figure>UDP传输<br><br><br>UDP比较简单，属于类似广播性质的传输，不需要维护连接。但也需要 bind，每次通信时调用 sendto 和 recvfrom 都要传入目标主机的 IP 地址和端口。<br><br>### 3.7 多线程编程<br><br>既然多进程开销过大，那平常我们经常使用到的就是多线程编程了。期间可能涉及到内存模型、JMM、Volatile、临界区等等。这些在<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1663052626025840644&amp;__biz=MzI4NjI1OTI4Nw==&amp;uin=&amp;key=&amp;devicetype=Windows+7+x64&amp;version=63010043&amp;lang=zh_CN&amp;ascene=7&amp;fontgear=2" target="_blank" rel="noopener">Java并发编程专栏</a>有讲。<br><br># 4 文件管理<br><br>### 4.1 VFS 虚拟文件系统<br><br>文件系统在操作系统中主要负责将文件数据信息存储到磁盘中，起到持久化文件的作用。文件系统的基本组成单元就是文件，文件组成方式不同就会形成不同的文件系统。<br><br>文件系统有很多种而不同的文件系统应用到操作系统后需要提供统一的对外接口，此时用到了一个设计理念<code>没有什么是加一层解决不了的</code>，在用户层跟不同的文件系统之间加入一个虚拟文件系统层 <code>Virtual File System</code>。<br><br>虚拟文件系统层<code>定义了一组所有文件系统都支持的数据结构和标准接口</code>，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。<br><br><figure class="image-box">                <img src="image-20220208110333436.png" alt="image-20220208110333436" title class>                <p>image-20220208110333436</p>            </figure>虚拟文件系统<br><br><br>日常的文件系统一般有如下三种：<br><br><br><br>1. <code>磁盘文件系统</code>：就是我们常见的EXT 2/3/4系列。<br>2. <code>内存文件系统</code>：数据没存储到磁盘，占用内存数据，比如<code>/sys</code>、<code>/proc</code>。进程中的一些数据映射到/proc中了。<br>3. <code>网络文件系统</code>：常见的网盘挂载NFS等，通过访问其他主机数据实现。<br><br>### 4.2 文件组成<br><br>以Linux系统为例，在Linux系统中一切皆文件，Linux文件系统会为每个文件分配<code>索引节点 inode</code>跟<code>目录项directory entry</code>来记录文件内容跟目录层次结构。<br><br>##### 4.2.1 inode<br><br>要理解<code>inode</code>要从文件储存说起。文件存储在硬盘上，硬盘的最小存储单位叫做扇区。每个扇区储存512字节。操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，一般一次性连续读取8个扇区(4KB)来当做一块，这种由多个扇区组成的<strong>块</strong>，是文件存取的最小单位。<br><br>文件数据都储存在块中，我们还必须找到一个地方储存文件的元信息，比如inode编号、文件大小、创建时间、修改时间、磁盘位置、访问权限等。几乎除了文件名以为的所有文件元数据信息都存储在一个叫叫索引节点inode的地方。可通过<code>stat 文件名</code>查看 inode 信息<br><br>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件，用户可通过<code>ls -i</code>查看每个文件对应编号。对于系统来说文件名只是inode号码便于识别的别称或者绰号。特殊名字的文件不好删除时可以尝试用inode号删除，移动跟重命名不会导致文件inode变化，当用户尝试根据文件名打开文件时，实际上系统内部将这个过程分成三步：<br><br>1. 系统找到这个文件名对应的inode号码。<br>2. 通过inode号码，获取inode信息，进行权限验证等操作。<br>3. 根据inode信息，找到文件数据所在的block，读出数据。<br><br>需注意 inode也会消耗硬盘空间，硬盘格式化后会被分成<strong>超级块</strong>、<strong>索引节点区</strong>和<strong>数据块区</strong>三个区域：<br><br>1. <code>超级块区</code>：用来存储文件系统的详细信息，比如块大小，块个数等信息。一般文件系统挂载后就会将数据信息同步到内存。<br><br>2. <code>索引节点区</code>：用来存储索引节点 inode  table。每个inode一般为128字节或256字节，一般每1KB或2KB数据就需设置一个inode。一般为了加速查询会把索引数据缓存到内存。<br><br>3. <code>数据块区</code>：真正存储磁盘数据的地方。<br><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -i # 查看每个硬盘分区的inode总数和已经使用的数量</span><br><span class="line">sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot; # 查看每个inode节点的大小</span><br></pre></td></tr></table></figure><h5 id="4-2-2-目录"><a href="#4-2-2-目录" class="headerlink" title="4.2.2 目录"></a>4.2.2 目录</h5><p>Unix/Linux系统中<strong>目录directory也是一种文件</strong>，打开目录实际上就是打开目录文件。目录文件内容就是一系列目录项的列，目录项的内容包含<strong>文件的名字、文件类型、索引节点指针以及与其他目录项的层级关系</strong>。</p><p>为避免频繁读取磁盘里的目录文件，内核会把已经读过的目录文件用<code>目录项</code>这个数据结构缓存在内存，方便用户下次读取目录信息，目录项可包含目录或文件，不要惊讶于可以保存目录，目录格式的目录项里面保存的是目录里面一项一项的文件信息。</p><h5 id="4-2-3-软连接跟硬链接"><a href="#4-2-3-软连接跟硬链接" class="headerlink" title="4.2.3 软连接跟硬链接"></a>4.2.3 软连接跟硬链接</h5><figure class="image-box">                <img src="image-20220208110345265.png" alt="image-20220208110345265" title class>                <p>image-20220208110345265</p>            </figure>软连接跟硬链接<br><br><br><strong>硬链接</strong>：老文件A被创建若干个硬链接B、C后。A、B、C三个文件的inode是相同的，所以不能跨文件系统。同时只有ABC全部删除，系统才会删除源文件。<br><strong>软链接</strong>：相当于基于老文件A新建了个文件B，该文件B有新的inode，不过文件B内容是老文件A的路径。所以软链接可以跨文件系统。当老文件A删除后，文件B仍然存在，不过找不到指定文件了。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[sowhat@localhost ~]$ ln [选项] 源文件 目标文件</span><br><span class="line">选项：</span><br><span class="line">-s：建立软链接文件。如果不加 &quot;-s&quot; 选项，则建立硬链接文件；</span><br><span class="line">-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</span><br></pre></td></tr></table></figure><h3 id="4-3-文件存储"><a href="#4-3-文件存储" class="headerlink" title="4.3 文件存储"></a>4.3 文件存储</h3><p>说文件存储前需了解<strong>文件系统操作基本单位是数据块</strong>，而平常用户操作字节到数据块之间是需要转换的，当然这些文件系统都帮我们对接好了。接下来看文件系统是如何按照数据块， 文件在磁盘中存储时候主要分为<code>连续空间存储</code>跟<code>非连续空间存储</code></p><h5 id="4-3-1-连续空间存储"><a href="#4-3-1-连续空间存储" class="headerlink" title="4.3.1 连续空间存储"></a>4.3.1 连续空间存储</h5><ol><li><p><code>实现</code>：连续空间存储的意思就跟数组存储一样，找个连续的空间一次性把数据存储进去，<strong>文件头</strong>存储起始位置跟数据长度即可。</p></li><li><p><code>优势</code>：读写效率高，磁盘寻址一次即可。</p></li><li><p><code>劣势</code>：容易产生空间碎片，并且文件扩容不方便。</p><p><img src="image-20220208110358288.png" alt="image-20220208110358288">连续存储</p></li></ol><h5 id="4-3-2-非连续空间存储之链表"><a href="#4-3-2-非连续空间存储之链表" class="headerlink" title="4.3.2 非连续空间存储之链表"></a>4.3.2 非连续空间存储之链表</h5><p><strong>隐式链表</strong></p><ol><li><code>实现</code>：文件头包含StartBlock、EndBlock。每个BLock有隐藏的next指针，跟单向链表一样。</li><li><code>缺点</code>：只能通过链式不断往下查找数据，不支持快速直接访问。</li></ol><figure class="image-box">                <img src="image-20220208110410511.png" alt="image-20220208110410511" title class>                <p>image-20220208110410511</p>            </figure><p><strong>显式链表</strong></p><ol><li><p><code>实现</code>：把每个Block中的next指针存储到内存<code>文件分配表</code>中，通过遍历数组方式实现拿到全部数据。</p></li><li><p><code>缺点</code>：前面说1KB就有个inode指针，如果磁盘数据很大那就需要很大的<strong>文件分配表</strong>来存储映射关系了，</p><p><img src="image-20220208110425596.png" alt="image-20220208110425596">显示链表</p></li></ol><h5 id="4-3-3-非连续空间存储之索引"><a href="#4-3-3-非连续空间存储之索引" class="headerlink" title="4.3.3 非连续空间存储之索引"></a>4.3.3 非连续空间存储之索引</h5><ol><li><code>实现</code>：整个文件类型一本新华字典，真实的数据块在词典实际位置存储着，但文件所需数据块的索引位置会被汇总起来形成目录索引放在字典前头。</li><li><code>优势</code>：不会产生碎片，文件可动态扩容，并且支持顺序跟随机读写。</li><li><code>劣势</code>：可能一个小文件都要占用一个目录索引，文件过大导致索引指针一个容不下，可能还需要有<code>多级索引</code>或<code>索引+链表</code>模式。</li></ol><figure class="image-box">                <img src="image-20220208110436521.png" alt="image-20220208110436521" title class>                <p>image-20220208110436521</p>            </figure>索引存储<br><br><br>这些存储方式各有利弊，所以操作系统才存储的时候一般是根据文件的大小进行动态的变化存储方式的，跟STL中的快排底层 = 快排 + 插入排序 + 堆排 一样的道理。<br><br>##### 4.3.4 空闲空间管理<br><br>为了避免用户存储数据时候遍历全部磁盘空间来寻找可以数据块，一般有如下几种记录方法。<br><br>1. <code>空闲表</code>：动态的维护一个空闲数据块列表，每行存储空闲块的开始位置跟空闲长度。适合少量有少量空闲数据块时。<br><br>   <img src="image-20220208110452631.png" alt="image-20220208110452631">空闲表<br><br>2. <code>空闲链表</code>：将空闲的数据库用next指针串联起来，缺点是不能随机访问。<br><br>   <img src="image-20220208110504160.png" alt="image-20220208110504160">空闲链表<br><br>3. <code>位图法</code>：利用Bit的 01 表示数据块可用跟不可用，简单方便，<strong>inode跟空闲数据库都用的此方法</strong>。<br><br>   <img src="image-20220208110514002.png" alt="image-20220208110514002">位图法<br><br># 5  输入输出管理<br><br>### 5.1 设备控制器跟驱动程序<br><br>##### 5.1.1 设备控制器<br><br><figure class="image-box">                <img src="image-20220208110525266.png" alt="image-20220208110525266" title class>                <p>image-20220208110525266</p>            </figure>设备控制器<br><br><br>操作系统为统一管理众多的设备并且屏蔽设备之间的差异，给每个设备都安装了个小CPU叫<strong>设备控制器</strong>。每个设备控制器都知道自己对应外设的功能跟用法，并且每个<strong>设备控制器</strong>都有独有的寄存器用来跟CPU通信。<br><br><br><br>1. 读设备寄存器值了解设备状态，是否可以接收新指令。<br>2. 操作系统给设备寄存器写入一些指令可以实现发送数据、接收数据等等操作。<br><br>控制器一般分为<strong>数据寄存器、命令寄存器跟状态寄存器</strong>，CPU 通过读、写设备控制器中的寄存器来便捷的控制设备：<br><br>1. <code>数据寄存器</code>：CPU 向 I/O 设备写入需要传输的数据，比如打印what，CPU 就要先发送一个w字符给到对应的 I/O 设备。<br>2. <code>命令寄存器</code>：CPU 发送命令来告诉 I/O 设备要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。<br>3. <code>状态寄存器</code>：用来告诉 CPU 现在已经在工作或工作已经完成，只有状态寄存标记成已完成，CPU 才能发送下一个字符和命令。<br><br>同时输入输出设备可分为<code>块设备</code>跟<code>字符设备</code>。<br><br>1. <code>块设备</code>：用来把数据存储在固定大小的块中，每个块有自己的地址，硬盘、U盘等是常见的块设备。块设备一般数据传输较大为避免频繁IO，控制器中有个可读写等<strong>数据缓冲区</strong>。Linux操作系统为屏蔽不同块设备带来的差异引入了<strong>通用块层</strong>，<strong>通用块层</strong>是处于文件系统和磁盘驱动中间的一个块设备抽象层，主要提供如下俩功能：<br><br>&gt; 1. 向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面提供一个框架来管理这些设备的驱动程序。<br>&gt; 2. 通用层还会给文件系统和应用程序发来的 I/O进行<strong>调度</strong>，主要目的是为了提高磁盘读写的效率。<br><br>1. <code>字符设备</code>：以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。<br><br>CPU一般通过<strong>IO端口</strong>跟<strong>内存映射IO</strong>来跟设备的控制寄存器和数据缓冲区进行通信<br><br>1. <code>IO端口</code>：每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 in/out 类似的指令。<br>2. <code>内存映射IO</code>：将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。<br><br>##### 5.1.2 驱动接口<br><br><figure class="image-box">                <img src="image-20220208110540638.png" alt="image-20220208110540638" title class>                <p>image-20220208110540638</p>            </figure>驱动程序<br><br>设备控制器屏蔽了设备细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，它属于硬件。在操作系统图范畴内为了屏蔽设备控制器的差异，引入了<strong>设备驱动程序</strong>，<strong>不同设备到驱动程序会提供统一接口给操作系统来调用</strong>，这样操作系统内核会像调用本地代码一样使用设备驱动程序接口。<br><br>设备发出IO请求就是在<strong>设备驱动程序</strong>中来响应到，它会根据中断类型调用响应到中断处理程序进行处理。<br><br><figure class="image-box">                <img src="image-20220208110624410.png" alt="image-20220208110624410" title class>                <p>image-20220208110624410</p>            </figure>中断请求流程<br><br>### 5.2 IO 控制<br><br>CPU发送指令让那个设备控制器去读写数据，完毕后如何通知CPU呢？<br><br>##### 5.2.1 轮询模式<br><br>控制器中有个<strong>状态寄存器</strong>，CPU不断<strong>轮</strong>询查看寄存器状态，该模式会傻瓜式的一直占用CPU。<br><br><figure class="image-box">                <img src="image-20220208110635167.png" alt="image-20220208110635167" title class>                <p>image-20220208110635167</p>            </figure>轮询模式<br><br>##### 5.2.2 IO 中断请求<br><br><figure class="image-box">                <img src="image-20220208110646262.png" alt="image-20220208110646262" title class>                <p>image-20220208110646262</p>            </figure>中断模式<br><br><br>控制器有个中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU来处理中断请求。中断有两种，一种是<strong>软中断</strong>，比如代码调用 INT 指令触发。一种是<strong>硬件中断</strong>，硬件通过中断控制器触发的。但中断方式对于频繁读写磁盘数据的操作就不太友好了，会频繁打断CPU。<br><br>这里说下磁盘高速缓存 <strong>PageCache</strong>，它是用来缓存最近被CPU访问的数据到内存中，并且还具有预读功能，可能你读前16KB数据，已经把后16KB数据给你缓存好了。<br><br>&gt; 1. <strong>pagecache</strong> : 页缓存，当进程需读取磁盘文件时，linux先分配一些内存，将数据从磁盘读区到内存中，然后再将数据传给进程。当进程需写数据到磁盘时，linux先分配内存接收用户数据，然后再将数据从内存写到磁盘。同时pagecache由于大小受限，所以一般只缓存最近被访问的数据，数据不足时还需访问磁盘。<br><br>##### 5.2.3 DMA 模式<br><br><code>Direct Memory Access</code> 直接内存访问，在硬件DMA控制器的支持下，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，让CPU 去处理别的事</strong>。<br><br><figure class="image-box">                <img src="image-20220208110700883.png" alt="image-20220208110700883" title class>                <p>image-20220208110700883</p>            </figure>DMA模式<br><br>可以发现整个数据传输过程中CPU是不会直接参与数据搬运工作，由DMA来直接负责数据读取工作，现如今每个IO设备一般都自带DMA控制器。读数据时候仅仅在传送开始跟结束时需要CPU干预。<br><br>##### 5.2.4 Zero Copy<br><br>Zero Copy 全程不会通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的，中间只需要经过2次上下文切换跟2次DMA数据拷贝，相比最原始读写方式至少速度翻倍。其实在Kafka中已经讲过Zero Copy了。<br><br>###### 5.2.4.1 老版本读写<br><br>老版本的简单读写操作中间不对数据做任何操作。期间会发生<strong>4次用户态跟内核态的切换。2次DMA数据拷贝，2次CPU数据拷贝</strong>。<br><br><figure class="image-box">                <img src="image-20220208110717472.png" alt="image-20220208110717472" title class>                <p>image-20220208110717472</p>            </figure>老式读写<br><br><br>提速方法就是需减少用户态与内核态的上下文切换和内存拷贝的次数。数据传输时从内核的读缓冲区拷贝到用户的缓冲区，再从用户缓冲区拷贝到 socket 缓冲区的这个过程是没有必要的。接下来<br><br>接下来按照三个版本说下Zero Copy 发展史。<br><br>###### 5.2.4.2  mmap 跟 write<br><br><figure class="image-box">                <img src="image-20220208110728516.png" alt="image-20220208110728516" title class>                <p>image-20220208110728516</p>            </figure>mmap + write<br><br><br>思路就是用<strong>mmap</strong>替代read函数，mmap调用时会<strong>直接把内核缓冲区里的数据映射到用户空间</strong>，此时减少了一次数据拷贝，但仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><h6 id="5-2-4-3-sendfile"><a href="#5-2-4-3-sendfile" class="headerlink" title="5.2.4.3 sendfile"></a>5.2.4.3 sendfile</h6><p>Linux 内核版本 2.1版本提供了函数 <strong>sendfile()</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line">out_fd : 目的文件描述符</span><br><span class="line">in_fd:源文件描述符</span><br><span class="line">offset:源文件内偏移量</span><br><span class="line">count:打算复制数据长度</span><br><span class="line">ssize_t:实际上复制数据的长度</span><br></pre></td></tr></table></figure><p>可以发现一个 sendfile = read + write，避免了2次用户态跟内核态来回切换，并且可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，这样就只有 2 次上下文切换，和 3 次数据拷贝。</p><figure class="image-box">                <img src="image-20220208110742002.png" alt="image-20220208110742002" title class>                <p>image-20220208110742002</p>            </figure>sendfile模式<br><br>###### 5.2.4.4 真正的零拷贝<br><br>Linux 内核 2.4如果网卡支持SG-DMA 技术，可以减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure><p>SG-DMA 技术可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝。</p><p><figure class="image-box">                <img src="image-20220208110800158.png" alt="image-20220208110800158" title class>                <p>image-20220208110800158</p>            </figure>ZeroCopy</p><h6 id="5-2-4-5-文件传输规则"><a href="#5-2-4-5-文件传输规则" class="headerlink" title="5.2.4.5 文件传输规则"></a>5.2.4.5 文件传输规则</h6><p>不要以为会了Zero Copy后，无论大小文件都用Zero Copy。实际工作中一般小文件采用Zero Copy技术，而大文件会用异步IO。至于为啥，且看如下分析：</p><p>前面说的数据从磁盘读到内核缓冲区就是读到PageCache中，PageCache具有缓存跟预读功能。但当传输超大文件时PageCache会不失效，因为大文件会快速占满PageCache区，但这些文件又只是一次访问，会造成其他热点小文件无法使用PageCache，所以索性不用PageCache，使用异步IO的了。至于异步IO是啥呢？下文在说。</p><h3 id="5-3-IO分层"><a href="#5-3-IO分层" class="headerlink" title="5.3 IO分层"></a>5.3 IO分层</h3><p><figure class="image-box">                <img src="image-20220208110811235.png" alt="image-20220208110811235" title class>                <p>image-20220208110811235</p>            </figure>IO分层</p><p>Linux 存储系统的 I/O 由上到下可以分为<strong>文件系统层</strong>、<strong>通用块层</strong>、<strong>设备层</strong>。</p><ol><li>文件系统层向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li><li>通用块层包括块设备的 I/O 队列和 I/O 调度器，通过IO调度器处理IO请求。</li><li>设备层包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作。</li></ol><p>Linux系统中的IO<strong>读取提速</strong>：</p><ol><li>为提高文件访问效率会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，目的是为了减少对块设备的直接调用。</li><li>为了提高块设备的访问效率， 会使用缓冲区，来缓存块设备的数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-冯诺伊曼体系&quot;&gt;&lt;a href=&quot;#1-冯诺伊曼体系&quot; class=&quot;headerlink&quot; title=&quot;1 冯诺伊曼体系&quot;&gt;&lt;/a&gt;1 冯诺伊曼体系&lt;/h1&gt;&lt;h3 id=&quot;1-1-冯诺伊曼体系简介&quot;&gt;&lt;a href=&quot;#1-1-冯诺伊曼体系简介&quot; cla</summary>
      
    
    
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/技术/"/>
    
    
    <category term="技术" scheme="https://github.com/missionOdd/tags/技术/"/>
    
    <category term="原理" scheme="https://github.com/missionOdd/tags/原理/"/>
    
    <category term="操作系统" scheme="https://github.com/missionOdd/tags/操作系统/"/>
    
  </entry>
  
  <entry>
    <title>消息队列| kafka中间件原理 &amp;&amp; 知识点</title>
    <link href="https://github.com/missionOdd/2021/12/08/kafka-notes/"/>
    <id>https://github.com/missionOdd/2021/12/08/kafka-notes/</id>
    <published>2021-12-08T05:50:37.000Z</published>
    <updated>2022-01-12T15:31:32.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>首先了解一下使用分布式消息队列的优点，总结主要包括以下几个方面：</p><ul><li><p>解耦 tags: None</p><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>冗余</p><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p></li><li><p>扩展性</p><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p></li><li><p>灵活性 &amp; 峰值处理能力</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p></li><li><p>可恢复性</p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p></li><li><p>顺序保证</p><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。［Kafka保证一个Partition内的消息的有序性；nsq不保证消息的顺序性］</p></li><li><p>缓冲</p><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p></li><li><p>异步通信<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ul><p>不同的Message Queue各具特色，此处以nsq和kafka这两种平台为例，做简要介绍</p><h3 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h3><p>NSQ是基于Go语言开发的实时的分布式消息平台，具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。</p><p>四个重要组件：</p><ul><li>nsqd：一个负责接收、排队、转发消息到客户端的守护进程</li><li>nsqlookupd：管理拓扑信息并提供最终一致性的发现服务的守护进程</li><li>nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行各种各样的管理任务</li><li>utilities：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq</li></ul><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul><li>支持无 SPOF 的分布式拓扑</li><li>水平扩展(没有中间件，无缝地添加更多的节点到集群)</li><li>低延迟消息传递 (性能)</li><li>结合负载均衡和多播消息路由</li><li>擅长面向流(高吞吐量)和任务(低吞吐量)工作负载</li><li>主要是内存中(除了高水位线消息透明地保存在磁盘上)</li><li>运行时为消费者提供发现生产者的服务(nsqlookupd)</li><li>传输层安全性 (TLS)</li><li>数据格式不可知</li><li>较少依赖(容易部署)和健全的、有界、默认配置</li><li>简单 TCP 协议，可以支持任何语言的客户端库</li><li>HTTP 接口统计、管理行为和生产者(不需要客户端库发布)</li><li>集成了statsd来实现实时检测</li><li>健壮的集群管理界面 (nsqadmin)</li></ul><h4 id="担保："><a href="#担保：" class="headerlink" title="担保："></a>担保：</h4><ul><li>支持消息内存队列的大小设置，默认完全持久化（值为0），消息即可持久到磁盘也可以保存在内存中</li><li>保证消息至少传递一次,以确保消息可以最终成功发送</li><li>收到的消息是无序的, 实现了松散订购</li><li>发现服务nsqlookupd具有最终一致性,消息最终能够找到所有Topic生产者</li></ul><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>NSQ中的数据流模型是由stream和consumer组成。Topic是一种独特的stream，Channel是一个订阅了给定Topic的consumer逻辑分组。NSQ的数据流模型结构如下图所示：</p><figure class="image-box">                <img src="uigd95fik9.gif" alt="uigd95fik9" title class>                <p>uigd95fik9</p>            </figure><p>从上图可以看出，单个nsqd可以有多个Topic，每个Topic又可以有多个Channel。</p><p>Channel能够接收Topic所有消息的副本，从而实现了消息多播分发；</p><p>而Channel上的每个消息被分发给它的订阅者，从而实现负载均衡，所有这些就组成了一个可以表示各种简单和复杂拓扑结构的强大框架。</p><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h4><ul><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ul><h4 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h4><ul><li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer：负责发布消息到Kafka broker</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li></ul><h4 id="Kafka拓扑结构"><a href="#Kafka拓扑结构" class="headerlink" title="Kafka拓扑结构"></a>Kafka拓扑结构</h4><figure class="image-box">                <img src="1025005-20160924125839231-370630847.png" alt="kafka架构图" title class>                <p>kafka架构图</p>            </figure><p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><h4 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h4><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。</p><h4 id="Producer消息路由"><a href="#Producer消息路由" class="headerlink" title="Producer消息路由"></a>Producer消息路由</h4><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。</p><p>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。</p><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>（本节所有描述都是基于Consumer hight level API而非low level API）。</p><p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p><figure class="image-box">                <img src="70.png" alt="img" title class>                <p>img</p>            </figure><p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p><h3 id="NSQ-vs-Kafka"><a href="#NSQ-vs-Kafka" class="headerlink" title="NSQ vs Kafka"></a>NSQ vs Kafka</h3><table><thead><tr><th></th><th>NSQ</th><th>Kafka</th></tr></thead><tbody><tr><td>语言</td><td>Go</td><td>Scala</td></tr><tr><td>消息存储</td><td>内存&amp;&amp;磁盘</td><td>磁盘，文件方式</td></tr><tr><td>顺序保证</td><td>无序，松散订阅</td><td>保证有序</td></tr></tbody></table><p>至于在实际应用中，两种消息队列如何选择，要根据业务需求和消息队列的特性做出合理选择。以“问答”服务端为例，目前NSQ和Kafka两种消息队列都在使用中：</p><p>比如对用户行为进行统计的相关消息，我们采用nsq，主要是因为nsq消息主要保存在内存，它在处理消息上更快；并且统计用户行为的消息，只需要对消息事件记录即可，并不要求严格的顺序。</p><p>而对于提交类的事件，就需要保证严格的顺序性。比如用户提交一个答案，随后又立刻删除；由于后台和data相关业务方是根据发送的消息作相关处理，如果删除答案的消息先发送，后台和data相关业务方将会出现错误；对于此类需要严格保证消息顺序的事件，我们就采用kafka。</p><hr><h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><h2 id="KafkaServer"><a href="#KafkaServer" class="headerlink" title="KafkaServer"></a>KafkaServer</h2><p>使用消息队列的主要好处有：</p><ul><li>解耦</li><li>峰值处理能力、异步</li><li>持久化</li><li>顺序保证</li><li>扩展性</li></ul><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><strong>Broker：</strong></p><p>Kafka集群中的一台服务器。</p><p><strong>Topic：</strong></p><p>主题。消息的分类，是逻辑上的概念，实际以partition的形式存放在各Broker服务器上。</p><p><strong>Partition：</strong></p><ul><li>分区。是物理上的概念，组成Topic的单位。</li></ul><p><strong>Replica：</strong></p><p>副本。是具体的分区，比Partition更具体的物理概念，一个真实的目录，存放在一台Broker服务器上。在代码中又分为leader和follower。</p><p><strong>Producer：</strong></p><ul><li>生产者。负责发送消息到Broker。</li></ul><p><strong>Consumer：</strong></p><ul><li>消费者。负责订阅Topic并拉取消息。</li></ul><p><strong>CousumerGroup：</strong></p><p>消费者组。每条消息只被组内成员消费一次。</p><h3 id="1-2-逻辑架构"><a href="#1-2-逻辑架构" class="headerlink" title="1.2 逻辑架构"></a>1.2 逻辑架构</h3><figure class="image-box">                <img src="60af40353a110cbc9948067b4502a75d.png" alt="image" title class>                <p>image</p>            </figure><h3 id="1-3-物理架构"><a href="#1-3-物理架构" class="headerlink" title="1.3 物理架构"></a>1.3 物理架构</h3><h4 id="1-3-1-集群物理架构"><a href="#1-3-1-集群物理架构" class="headerlink" title="1.3.1 集群物理架构"></a>1.3.1 集群物理架构</h4><ul><li>*<figure class="image-box">                <img src="0993d208eeb5dfe12a9e6f132e9d0eef.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>如上图，本集群有：</p><ul><li>4台broker。broker_1 到 broker_4</li><li>2个topic。topic_A和topic_B</li><li>topic_A的分区数是4。topicA_0 到 topic_3</li><li>topic_A的副本因子是2。例如topicA_0这个分区，有两个副本，分别分布在broker_1和broker_3两台机器上。</li></ul><h4 id="1-3-2-一个副本目录结构"><a href="#1-3-2-一个副本目录结构" class="headerlink" title="1.3.2 一个副本目录结构"></a>1.3.2 一个副本目录结构</h4><p>上图中的topicA-0是一个partition，准确的说应该称之为一个副本，即Replica。它是broker_1服务器上的一个日志目录，其内部由多个segment文件组成。topicA-0目录结构：</p><ul><li>*<figure class="image-box">                <img src="15917459e5a10f3a6839bc535f0afbc6.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p><strong>*.log文件</strong>：日志文件</p><p><strong>*.index文件</strong>：稀疏索引文件</p><p><strong>*.timeindex文件</strong>：时间戳索引文件。根据时间戳快速定位消息所在位置。（Kafka API offsetsForTimes方法所使用）</p><p>index文件与log文件关系:</p><ul><li>*<figure class="image-box">                <img src="42a9581fb80035875abcaff0e6902542.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h3 id="1-4-代码架构"><a href="#1-4-代码架构" class="headerlink" title="1.4 代码架构"></a>1.4 代码架构</h3><h4 id="1-4-1-线程池"><a href="#1-4-1-线程池" class="headerlink" title="1.4.1 线程池"></a>1.4.1 线程池</h4><p>KafkaServer在启动时，初始化KafkaRequestHandlerPool线程池</p><p>KafkaRequestHandlerPool（线程池）由KafkaRequestHandler组成</p><p>KafkaRequestHandler调用KafkaApis处理request</p><p>下图：Kafka处理request的线程池</p><ul><li>*<figure class="image-box">                <img src="83fbd9155e52d987bb704a028f719772.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>kafkaServer接收的请求，包括来自客户端的请求和来自其他server的请求。客户端请求例如producer发送消息请求、consumer消费消息请求。其他broker请求例如副本同步日志请求。请求类型有21个枚举值。</p><p>所有的请求最终会收敛到Broker服务器上的KafkaApis.handle方法，如下图：</p><ul><li>*<figure class="image-box">                <img src="9fb206ff88bb93e7d92cf7dced0e540b.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h4 id="1-4-2-处理request的组件"><a href="#1-4-2-处理request的组件" class="headerlink" title="1.4.2 处理request的组件"></a>1.4.2 处理request的组件</h4><p>有3个重要组件处理上图21种请求，它们分别是：</p><ul><li><strong>ReplicaManager</strong><ul><li>把Produce日志写入磁盘</li><li>如果副本是follower，启动副本同步线程，发送fetch请求</li><li>如果副本是leader，处理来自副本的fetch请求</li></ul></li><li><strong>Coordinator</strong><ul><li>管理Consumer的balance</li></ul></li><li><strong>KafkaController</strong><ul><li>Broker 的上线、下线</li><li>新建 topic 或已有 topic 的扩容，topic 删除</li><li>处理replica的分配、迁移、leader 选举、leader 切换</li></ul></li></ul><p>下图：处理request请求</p><ul><li>*<figure class="image-box">                <img src="d85330c319388dddad5de8b90e743c9a.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h2 id="2-可用性、可靠性保障"><a href="#2-可用性、可靠性保障" class="headerlink" title="2. 可用性、可靠性保障"></a>2. 可用性、可靠性保障</h2><h3 id="2-1-集群高可用性"><a href="#2-1-集群高可用性" class="headerlink" title="2.1 集群高可用性"></a>2.1 集群高可用性</h3><p>在应对单点故障时，kafka仍然能够对外提供服务，主要通过以下特性保证：</p><ul><li>分布式集群模式，多台服务器，分散单服务器压力。</li><li>一个topic拆分成多partition分区</li><li>一个partition建立n个副本，分为leader和follower，保持同步。leader一旦宕机从follower选举出新的leader提供读写日志服务。</li></ul><h3 id="2-2-消息可靠性与一致性"><a href="#2-2-消息可靠性与一致性" class="headerlink" title="2.2 消息可靠性与一致性"></a><strong>2.2 消息可靠性与一致性</strong></h3><p>面对故障时是否仍然保持最终一致。</p><ul><li>producer.ACKS = [ -1, 0, 1] 保证日志生产的准确性。</li><li>HW和LEO机制。保证日志同步的准确性。</li></ul><h4 id="2-2-1-producer-ACKs"><a href="#2-2-1-producer-ACKs" class="headerlink" title="2.2.1 producer.ACKs"></a>2.2.1 producer.ACKs</h4><p><strong>ACKs=1</strong></p><ul><li>producer发送日志，只要Leader写入成功，则返回producer成功</li></ul><p><strong>ACKs=0</strong></p><ul><li>producer发送日志，不需要等待leader返回成功</li><li>传输效率最高，可靠性最差</li></ul><p><strong>ACKs=-1</strong></p><ul><li>producer发送日志，Leader需要等待ISR中所有的Replica同步完成后，才返回给客户端成功</li><li>可靠性最高，效率最差。集群的瓶颈卡在了最差的那台机器</li></ul><h4 id="2-2-2-HW和LEO"><a href="#2-2-2-HW和LEO" class="headerlink" title="2.2.2 HW和LEO"></a>2.2.2 HW和LEO</h4><p><strong>LEO</strong></p><ul><li>LogEndOffset，日志末端偏移量</li><li>每个Replica最后一条log所在的位置</li></ul><p><strong>HW</strong></p><ul><li>HighWaterMark，高水位</li><li>HW = min( ISR.LEO )</li><li>已经被ISR完成同步的消息的位置</li><li>Consumer最多只能消费到HW所在的位置</li><li>对于内部Replica的同步消息请求，没有HW的限制</li></ul><p>如下图，HW与LEO位置示意：</p><figure class="image-box">                <img src="b9466c871eb1de0157d41377cd06d94a.png" alt="image" title class>                <p>image</p>            </figure><p><strong>HW与LEO更新过程：</strong></p><figure class="image-box">                <img src="d64eb94018321663dfe38c6ea278bbde.png" alt="image" title class>                <p>image</p>            </figure><p><strong>HW与LEO更新过程（详细）：</strong></p><p>HW与LEO存在于每一个副本，并不仅仅存在于leader。</p><p>leader中维护了两套LEO，一套是自己的，另一套是follower的。</p><p>假设目前消息队列为空，follower启动的同步消息线程，不会获取到任何消息，也不会更新HW和LEO</p><ul><li>*<figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/ec19a2cae1dc96baef8fe646f758b97a.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>此时，Producer给leader发送了一条日志</p><ol><li>leader的LEO + 1</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li></ol><ul><li>*<figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/219fab4d24791360c434d96ad75c71e8.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>follower发送fetch请求：</p><ul><li>*<figure class="image-box">                <img src="65578cc63bfff21a8529caed7fd904ff.png" alt="image" title class>                <p>image</p>            </figure></li></ul><ol><li>req的offset参数是0，表示从第0个消息开始fetch</li><li>leader更新remote LEO=0，这是因为follower request的offset是0</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新LEO=1，更新HW仍然是0</li></ol><p>follower发送第二轮fetch请求:</p><figure class="image-box">                <img src="a730c7a7e7b6ea34fa9d3a71e1911f57.png" alt="image" title class>                <p>image</p>            </figure><ol><li>req的offset参数是1，表示请求同步第一个消息</li><li>leader更新remote LEO=1，因为follower request的offset是1</li><li>leader尝试更新HW，HW=min(LEO)，<strong>此时更新HW=1</strong></li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新HW，<strong>此时更新HW=1</strong></li></ol><p>至此，producer生产的消息已经保存到kafka的各个副本上了，Consumer已经可以消费到HW位置了。</p><p>一个消息从写入kafka到完成更新HW，需要follower发送两轮fetch请求。 第一轮fetch是follow告诉leader自己的leo, 以及更新offset以及leo. 第二轮fetch是告诉producer自己最新的leo用于leader更新hw.</p><h2 id="3-常见的选举、分配、Rebalance"><a href="#3-常见的选举、分配、Rebalance" class="headerlink" title="3. 常见的选举、分配、Rebalance"></a>3. 常见的选举、分配、Rebalance</h2><p>Kafka集群依赖Zookeeper，Zookeeper的数据模型是一棵树，kafka的组件把回调函数注册到zk树节点下，在节点发生变更时，zk通过回调通知kafka。</p><h3 id="3-1-Controller选举"><a href="#3-1-Controller选举" class="headerlink" title="3.1 Controller选举"></a>3.1 Controller选举</h3><p>KafkaController的选举过程比较简单，所有的broker启动时，抢占注册Zookeeper的/Controller节点，注册成功即成为Controller。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def elect: Boolean = &#123;</span><br><span class="line">    leaderId = getControllerID   // 查询当前集群ControllerId</span><br><span class="line"></span><br><span class="line">    if(leaderId != -1) &#123;  // Controller早已存在了</span><br><span class="line">       return amILeader</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        zkCheckedEphemeral.create()  // 注册到zookeeper leader节点</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        case _: ZkNodeExistsException =&gt;   // leader被别人注册，抛异常</span><br><span class="line">        leaderId = getControllerID</span><br><span class="line">    &#125;</span><br><span class="line">    return amILeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Consumer启动触发Rebalance"><a href="#3-2-Consumer启动触发Rebalance" class="headerlink" title="3.2 Consumer启动触发Rebalance"></a>3.2 Consumer启动触发Rebalance</h3><p>由于Broker数量通常不会很多，所以Controller选举采用抢占注册的方式不会给zookeeper带来很大压力。</p><p>但是对于Consumer而言，一个大的Topic可能对应创建了数量庞大的Consumer，Kafka老版本也确实是这么实现的，这种情况下，存在两个问题：</p><ul><li>羊群效应：任何一个Consumer的增减都会触发所有Consumer的Rebalance</li><li>脑裂效应：每个Consumer分别单独通过Zookeeper判断哪些Consumer 宕机了，那么不同Consumer在同一时刻从Zookeeper看到的视角就可能不一样。这就会造成不正确的Reblance尝试。</li></ul><p>新版本的Kafka对此做了优化，使用了“协调员”这一角色，作为“权威”“指挥”Consumer Rebalance</p><p>新版本，Consumer启动过程如下：</p><figure class="image-box">                <img src="5849ad51359fe5c181c7c4673b8f6da8.png" alt="image" title class>                <p>image</p>            </figure><ol><li>Consumer启动，向任意一台broker发送请求，得到响应。响应内容为“协调员的地址”。</li><li>Consumer找到自己的Coordinator，<strong>持续</strong>发送心跳请求</li><li>Consumer判断心跳请求的响应的ErrorCode，如果没有异常则消费数据。如果有IllegalGeneration异常，说明Coordinator正在计算rebalance，统一给Consumer分配Partition。</li><li>Consumer给Coordinator发送JonGroup请求，得到响应，得知自己被分配了哪个Partition，连接那个partition进行消费。</li></ol><h3 id="3-3-Leader-Replica宕机触发Rebalance"><a href="#3-3-Leader-Replica宕机触发Rebalance" class="headerlink" title="3.3 Leader Replica宕机触发Rebalance"></a>3.3 Leader Replica宕机触发Rebalance</h3><figure class="image-box">                <img src="c981ddff865953bf37066940aa92cc28.png" alt="image" title class>                <p>image</p>            </figure><p>图：broker宕机触发replica选举</p><p>Replica分布在broker上，Replica leader掉线其实就是leader所在的broker的宕机，从宕机到集群恢复稳定态过程：</p><ol><li>Broker启动，在zookeeper的broker/ids路径注册临时节点</li><li>Controller启动，注册watcher函数，监听zookeeper上述路径的节点变化</li><li>Broker因为网络、断电、机器故障等原因宕机</li><li>zookeeper监听到broker节点掉线，触发controller注册的watcher，通过回调函数通知Controller</li><li>Controller决定一个set_p集合，包含宕机broker上的所有partition</li><li>对于上述的partition，Controller从/brokers/topics/[topic]/partitions/[partition]/state读取该 Partition 当前的 ISR</li><li>Controller从上述ISR中选出Leader。选举算法是quorum（法定人数）算法，通过数据冗余来保证数据一致性的投票算法。对于Kafka而言，选举人数就是ISR。</li><li>Controller将新的 Leader、ISR 和新的leader_epoch及controller_epoch写入/brokers/topics/[topic]/partitions/[partition]/state</li><li>向set_p相关的broker发送LeaderAndIsrRequest通知受影响的broker更新信息</li></ol><h3 id="3-4-topic分配到broker"><a href="#3-4-topic分配到broker" class="headerlink" title="3.4 topic分配到broker"></a>3.4 topic分配到broker</h3><ol><li>用户调用脚本创建topic，指定分区数和副本数</li><li>Controller接收CreateTopic请求，计算broker与partition的对应关系</li><li>Controller向Broker发送LeaderAndIsr请求，通知Broker有了新的Topic，各broker负责创建Partition</li></ol><p>副本分配算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* To achieve this goal for replica assignment without considering racks, we:</span><br><span class="line">* 1. Assign the first replica of each partition by round-robin, starting from a random position in the broker list.</span><br><span class="line">* 2. Assign the remaining replicas of each partition with an increasing shift.</span><br><span class="line">*</span><br><span class="line">* Here is an example of assigning</span><br><span class="line">* broker-0  broker-1  broker-2  broker-3  broker-4</span><br><span class="line">* p0        p1        p2        p3        p4       (1st replica)</span><br><span class="line">* p5        p6        p7        p8        p9       (1st replica)</span><br><span class="line">* p4        p0        p1        p2        p3       (2nd replica)</span><br><span class="line">* p8        p9        p5        p6        p7       (2nd replica)</span><br><span class="line">* p3        p4        p0        p1        p2       (3nd replica)</span><br><span class="line">* p7        p8        p9        p5        p6       (3nd replica)</span><br></pre></td></tr></table></figure><hr><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>kafka使用tcp, io多路复用即信号驱动io, 生产者有同步和异步2种类型</p></li><li><p>选择由producer向broker push消息并由consumer从broker pull消息。</p></li><li><p>kafka和nsq对比：</p><ul><li>kafka是pull，有序，吞吐高；nsq消息是无序的，吞吐低，有requeue和defer功能，不持久化，不可回溯，pull，用内存，所以速度快。</li></ul></li><li><p>kafka数据可靠性和重复消费</p><ol><li>需要消费者操作幂等，来保证重复消费无影响</li><li>处理后提交commit，保证消息被消费到，事务保证</li><li>生产者生产消息失败时，报error。</li><li>如果要保证有序，让消息到1个partition就行了，partition内部消费是有序的</li></ol></li><li><p>kafka基于zk.</p></li><li><p>kafka是发布-订阅模型。</p></li><li><p>Zookeeper 主要为 Kafka 做了下面这些事情：</p><ol><li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li><strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li><li>……</li></ol></li><li><p>ISR:In-Sync Replicas 副本同步队列 AR:Assigned Replicas 所有副本</p><p>HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。</p><p>LEO:LogEndOffset 当前日志文件中下一条待写信息的offset</p><p>HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。</p><p>LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</p><p>LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li><a href="https://juejin.cn/post/6844903889003610119" target="_blank" rel="noopener">kafka面试题</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/message-queue/Kafka常见面试题总结.md">kafka面试题2</a></li><li><a href="http://trumandu.github.io/2019/04/13/Kafka面试题与答案全套整理/" target="_blank" rel="noopener">整理，答案不全的</a></li><li><a href="https://cloud.tencent.com/developer/article/1541215" target="_blank" rel="noopener">面试题3</a></li></ul><h2 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h2><ul><li><p>控制器是如何被选出来的？</p><ul><li><p>你一定很想知道，控制器是如何被选出来的呢？我们刚刚在前面说过，每台 Broker 都能充当控制器，那么，当集群启动后，Kafka 怎么确认控制器位于哪台 Broker 呢？</p><p>实际上，Broker 在启动时，会尝试去 ZooKeeper 中创建 /controller 节点。Kafka 当前选举控制器的规则是：第一个成功创建 /controller 节点的 Broker 会被指定为控制器。</p></li></ul></li><li><p>控制器是做什么的？</p><ul><li><p>1.主题管理（创建、删除、增加分区）</p><p>2.分区重分配</p><p>3.Preferred 领导者选举</p><p>4.集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）</p><p>5.数据服务</p></li></ul></li><li><p>保存的数据：</p></li><li><figure class="image-box">                <img src="20210523170815.png" alt="image-20210523170815843" title class>                <p>image-20210523170815843</p>            </figure></li></ul><h2 id="consumer管理offset"><a href="#consumer管理offset" class="headerlink" title="consumer管理offset"></a>consumer管理offset</h2><p><strong>kafka内部有个主题，__consumer_offset</strong></p><p>老版本 Consumer 的位移管理是依托于 Apache ZooKeeper 的，它会自动或手动地将位移数据提交到 ZooKeeper 中保存。当 Consumer 重启后，它能自动从 ZooKeeper 中读取位移数据，从而在上次消费截止的地方继续消费。这种设计使得 Kafka Broker 不需要保存位移数据，减少了 Broker 端需要持有的状态空间，因而有利于实现高伸缩性。</p><p>但是，ZooKeeper 其实并不适用于这种高频的写操作，因此，Kafka 社区自 0.8.2.x 版本开始，就在酝酿修改这种设计，并最终在新版本 Consumer 中正式推出了全新的位移管理机制，自然也包括这个新的位移主题。</p><p>新版本 Consumer 的位移管理机制其实也很简单，就是将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 <strong>consumer_offsets 中。可以这么说，</strong>consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。它要求这个提交过程不仅要实现高持久性，还要支持高频的写操作。显然，Kafka 的主题设计天然就满足这两个条件，因此，使用 Kafka 主题来保存位移这件事情，实际上就是一个水到渠成的想法了。</p><p>位移主题的 Key 中应该保存 3 部分内容：gourpId, topic, partitionId</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h1&gt;&lt;p&gt;首先了解一下使用分布式消息队列的优点，总结主要包括以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解耦 tags: None</summary>
      
    
    
    
    <category term="中间件" scheme="https://github.com/missionOdd/categories/中间件/"/>
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/中间件/技术/"/>
    
    
    <category term="技术" scheme="https://github.com/missionOdd/tags/技术/"/>
    
    <category term="原理" scheme="https://github.com/missionOdd/tags/原理/"/>
    
    <category term="消息队列" scheme="https://github.com/missionOdd/tags/消息队列/"/>
    
    <category term="kafka" scheme="https://github.com/missionOdd/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat架构原理解析到架构设计借鉴</title>
    <link href="https://github.com/missionOdd/2021/12/06/tomcat-architecture/"/>
    <id>https://github.com/missionOdd/2021/12/06/tomcat-architecture/</id>
    <published>2021-12-06T05:50:37.000Z</published>
    <updated>2022-02-08T02:32:05.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat-架构原理解析到架构设计借鉴"><a href="#Tomcat-架构原理解析到架构设计借鉴" class="headerlink" title="Tomcat 架构原理解析到架构设计借鉴"></a>Tomcat 架构原理解析到架构设计借鉴</h1><blockquote><p>Tomcat 发展这么多年，已经比较成熟稳定。在如今『追新求快』的时代，Tomcat 作为 Java Web 开发必备的工具似乎变成了『熟悉的陌生人』，难道说如今就没有必要深入学习它了么？学习它我们又有什么收获呢？</p></blockquote><p><strong>静下心来，细细品味经典的开源作品</strong> 。提升我们的「内功」，具体来说就是学习大牛们如何设计、架构一个中间件系统，并且让这些经验为我所用。</p><p>美好的事物往往是整洁而优雅的。但这并不等于简单，而是要将复杂的系统分解成一个个小模块，并且各个模块的职责划分也要清晰合理。</p><p>与此相反的是凌乱无序，比如你看到城中村一堆互相纠缠在一起的电线，可能会感到不适。维护的代码一个类几千行、一个方法好几百行。方法之间相互耦合糅杂在一起，你可能会说 what the f*k！</p><figure class="image-box">                <img src="1f3cb57ab959b4592513f10ba9cbd1ed.webp" alt="img" title class>                <p>img</p>            </figure><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><h3 id="掌握-Tomcat-架构设计与原理提高内功"><a href="#掌握-Tomcat-架构设计与原理提高内功" class="headerlink" title="掌握 Tomcat 架构设计与原理提高内功"></a>掌握 Tomcat 架构设计与原理提高内功</h3><p><strong>宏观上看</strong></p><p>Tomcat 作为一个 「<code>Http</code> 服务器 + <code>Servlet</code> 容器」，对我们屏蔽了应用层协议和网络通信细节，给我们的是标准的 <code>Request</code> 和 <code>Response</code> 对象；对于具体的业务逻辑则作为变化点，交给我们来实现。我们使用了<code>SpringMVC</code> 之类的框架，可是却从来不需要考虑 <code>TCP</code> 连接、 <code>Http</code> 协议的数据处理与响应。就是因为 Tomcat 已经为我们做好了这些，我们只需要关注每个请求的具体业务逻辑。</p><p><strong>微观上看</strong></p><p><code>Tomcat</code> 内部也隔离了变化点与不变点，使用了组件化设计，目的就是为了实现「俄罗斯套娃式」的高度定制化（组合模式），而每个组件的生命周期管理又有一些共性的东西，则被提取出来成为接口和抽象类，让具体子类实现变化点，也就是模板方法设计模式。</p><p>当今流行的微服务也是这个思路，按照功能将单体应用拆成「微服务」，拆分过程要将共性提取出来，而这些共性就会成为核心的基础服务或者通用库。「中台」思想亦是如此。</p><p>设计模式往往就是封装变化的一把利器，合理的运用设计模式能让我们的代码与系统设计变得优雅且整洁。</p><p>这就是学习优秀开源软件能获得的「内功」，从不会过时，其中的设计思想与哲学才是根本之道。从中借鉴设计经验，合理运用设计模式封装变与不变，更能从它们的源码中汲取经验，提升自己的系统设计能力。</p><h3 id="宏观理解一个请求如何与-Spring-联系起来"><a href="#宏观理解一个请求如何与-Spring-联系起来" class="headerlink" title="宏观理解一个请求如何与 Spring 联系起来"></a>宏观理解一个请求如何与 Spring 联系起来</h3><p>在工作过程中，我们对 Java 语法已经很熟悉了，甚至「背」过一些设计模式，用过很多 Web 框架，但是很少有机会将他们用到实际项目中，让自己独立设计一个系统似乎也是根据需求一个个 Service 实现而已。脑子里似乎没有一张 Java Web 开发全景图，比如我并不知道浏览器的请求是怎么跟 Spring 中的代码联系起来的。</p><p>为了突破这个瓶颈，为何不站在巨人的肩膀上学习优秀的开源系统，看大牛们是如何思考这些问题。</p><p>学习 Tomcat 的原理，我发现 <code>Servlet</code> 技术是 Web 开发的原点，几乎所有的 Java Web 框架（比如 Spring）都是基于 <code>Servlet</code> 的封装，Spring 应用本身就是一个 <code>Servlet</code>（<code>DispatchSevlet</code>），而 Tomcat 和 Jetty 这样的 Web 容器，负责加载和运行 <code>Servlet</code>。如图所示：</p><figure class="image-box">                <img src="fb04017c2304f79fd043ed4a9e90190f.webp" alt="img" title class>                <p>img</p>            </figure><h3 id="提升自己的系统设计能力"><a href="#提升自己的系统设计能力" class="headerlink" title="提升自己的系统设计能力"></a>提升自己的系统设计能力</h3><p>学习 Tomcat ，我还发现用到不少 Java 高级技术，比如 Java 多线程并发编程、Socket 网络编程以及反射等。之前也只是了解这些技术，为了面试也背过一些题。但是总感觉「知道」与会用之间存在一道沟壑，通过对 Tomcat 源码学习，我学会了什么场景去使用这些技术。</p><p>还有就是系统设计能力，比如面向接口编程、组件化组合模式、骨架抽象类、一键式启停、对象池技术以及各种设计模式，比如模板方法、观察者模式、责任链模式等，之后我也开始模仿它们并把这些设计思想运用到实际的工作中。</p><h2 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h2><p>今天咱们就来一步一步分析 Tomcat 的设计思路，一方面我们可以学到 Tomcat 的总体架构，学会从宏观上怎么去设计一个复杂系统，怎么设计顶层模块，以及模块之间的关系；另一方面也为我们深入学习 Tomcat 的工作原理打下基础。</p><p>Tomcat 启动流程：<code>startup.sh -&gt; catalina.sh start -&gt;java -jar org.apache.catalina.startup.Bootstrap.main()</code></p><p>Tomcat 实现的 2 个核心功能：</p><ul><li>处理 <code>Socket</code> 连接，负责网络字节流与 <code>Request</code> 和 <code>Response</code> 对象的转化。</li><li>加载并管理 <code>Servlet</code> ，以及处理具体的 <code>Request</code> 请求。</li></ul><p><strong>所以 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）。连接器负责对外交流，容器负责内部 处理</strong></p><p><code>Tomcat</code>为了实现支持多种 <code>I/O</code> 模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。</p><figure class="image-box">                <img src="4e76498e3179b855b480be0924de5da5.webp" alt="img" title class>                <p>img</p>            </figure>Tomcat整体架构<br><br>- Server 对应的就是一个 Tomcat 实例。<br>- Service 默认只有一个，也就是一个 Tomcat 实例默认一个 Service。<br>- Connector：一个 Service 可能多个 连接器，接受不同连接协议。<br>- Container: 多个连接器对应一个容器，顶层容器其实就是 Engine。<br><br><strong>每个组件都有对应的生命周期，需要启动，同时还要启动自己内部的子组件，比如一个 Tomcat 实例包含一个 Service，一个 Service 包含多个连接器和一个容器。而一个容器包含多个 Host， Host 内部可能有多个 Contex t 容器，而一个 Context 也会包含多个 Servlet，所以 Tomcat 利用组合模式管理组件每个组件，对待过个也想对待单个组一样对待</strong>。整体上每个组件设计就像是「俄罗斯套娃」一样。<br><br>### 连接器<br><br>在开始讲连接器前，我先铺垫一下 <code>Tomcat</code>支持的多种 <code>I/O</code> 模型和应用层协议。<br><br><code>Tomcat</code>支持的 <code>I/O</code> 模型有：<br><br>- <code>NIO</code>：非阻塞 <code>I/O</code>，采用 <code>Java NIO</code> 类库实现。<br>- <code>NIO2</code>：异步<code>I/O</code>，采用 <code>JDK 7</code> 最新的 <code>NIO2</code> 类库实现。<br>- <code>APR</code>：采用 <code>Apache</code>可移植运行库实现，是 <code>C/C++</code> 编写的本地库。<br><br>Tomcat 支持的应用层协议有：<br><br>- <code>HTTP/1.1</code>：这是大部分 Web 应用采用的访问协议。<br>- <code>AJP</code>：用于和 Web 服务器集成（如 Apache）。<br>- <code>HTTP/2</code>：HTTP 2.0 大幅度的提升了 Web 性能。<br><br>所以一个容器可能对接多个连接器。连接器对 <code>Servlet</code> 容器屏蔽了网络协议与 <code>I/O</code> 模型的区别，无论是 <code>Http</code> 还是 <code>AJP</code>，在容器中获取到的都是一个标准的 <code>ServletRequest</code> 对象。<br><br>细化连接器的功能需求就是：<br><br>- 监听网络端口。<br>- 接受网络连接请求。<br>- 读取请求网络字节流。<br>- 根据具体应用层协议（<code>HTTP/AJP</code>）解析字节流，生成统一的 <code>Tomcat Request</code> 对象。<br>- 将 <code>Tomcat Request</code> 对象转成标准的 <code>ServletRequest</code>。<br>- 调用 <code>Servlet</code>容器，得到 <code>ServletResponse</code>。<br>- 将 <code>ServletResponse</code>转成 <code>Tomcat Response</code> 对象。<br>- 将 <code>Tomcat Response</code> 转成网络字节流。<br>- 将响应字节流写回给浏览器。<br><br>需求列清楚后，我们要考虑的下一个问题是，连接器应该有哪些子模块？优秀的模块化设计应该考虑<strong>高内聚、低耦合</strong>。<br><br>- <strong>高内聚</strong>是指相关度比较高的功能要尽可能集中，不要分散。<br>- <strong>低耦合</strong>是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。<br><br>我们发现连接器需要完成 3 个<strong>高内聚</strong>的功能：<br><br>- 网络通信。<br>- 应用层协议解析。<br>- <code>Tomcat Request/Response</code> 与 <code>ServletRequest/ServletResponse</code> 的转化。<br><br>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 <code>EndPoint、Processor 和 Adapter</code>。<br><br>网络通信的 I/O 模型是变化的, 应用层协议也是变化的，但是整体的处理逻辑是不变的，<code>EndPoint</code> 负责提供字节流给 <code>Processor</code>，<code>Processor</code>负责提供 <code>Tomcat Request</code> 对象给 <code>Adapter</code>，<code>Adapter</code>负责提供 <code>ServletRequest</code>对象给容器。<br><br><strong>封装变与不变</strong><br><br>因此 Tomcat 设计了一系列抽象基类来<strong>封装这些稳定的部分</strong>，抽象基类 <code>AbstractProtocol</code>实现了 <code>ProtocolHandler</code>接口。每一种应用层协议有自己的抽象基类，比如 <code>AbstractAjpProtocol</code>和 <code>AbstractHttp11Protocol</code>，具体协议的实现类扩展了协议层抽象基类。<br><br>这就是模板方法设计模式的运用。<br><br><figure class="image-box">                <img src="30457ee2c65903a81f033e32c5e60251.webp" alt="img" title class>                <p>img</p>            </figure>应用层协议抽象<br><br>总结下来，连接器的三个核心组件 <code>Endpoint</code>、<code>Processor</code>和 <code>Adapter</code>来分别做三件事情，其中 <code>Endpoint</code>和 <code>Processor</code>放在一起抽象成了 <code>ProtocolHandler</code>组件，它们的关系如下图所示。<br><br><figure class="image-box">                <img src="88f9b28eb4cef2749e180bc4517d470d.webp" alt="img" title class>                <p>img</p>            </figure>连接器<br><br>#### ProtocolHandler 组件<br><br>主要处理 <strong>网络连接</strong> 和 <strong>应用层协议</strong> ，包含了两个重要部件 EndPoint 和 Processor，两个组件组合形成 ProtocoHandler，下面我来详细介绍它们的工作原理。<br><br>##### EndPoint<br><br><code>EndPoint</code>是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 <code>EndPoint</code>是用来实现 <code>TCP/IP</code> 协议数据读写的，本质调用操作系统的 socket 接口。<br><br><code>EndPoint</code>是一个接口，对应的抽象实现类是 <code>AbstractEndpoint</code>，而 <code>AbstractEndpoint</code>的具体子类，比如在 <code>NioEndpoint</code>和 <code>Nio2Endpoint</code>中，有两个重要的子组件：<code>Acceptor</code>和 <code>SocketProcessor</code>。<br><br>其中 Acceptor 用于监听 Socket 连接请求。<code>SocketProcessor</code>用于处理 <code>Acceptor</code> 接收到的 <code>Socket</code>请求，它实现 <code>Runnable</code>接口，在 <code>Run</code>方法里调用应用层协议处理组件 <code>Processor</code> 进行处理。为了提高处理能力，<code>SocketProcessor</code>被提交到线程池来执行。<br><br>我们知道，对于 Java 的多路复用器的使用，无非是两步：<br><br>1. 创建一个 Seletor，在它身上注册各种感兴趣的事件，然后调用 select 方法，等待感兴趣的事情发生。<br>2. 感兴趣的事情发生了，比如可以读了，这时便创建一个新的线程从 Channel 中读数据。<br><br>在 Tomcat 中 <code>NioEndpoint</code> 则是 <code>AbstractEndpoint</code> 的具体实现，里面组件虽然很多，但是处理逻辑还是前面两步。它一共包含 <code>LimitLatch</code>、<code>Acceptor</code>、<code>Poller</code>、<code>SocketProcessor</code>和 <code>Executor</code> 共 5 个组件，分别分工合作实现整个 TCP/IP 协议的处理。<br><br>- LimitLatch 是连接控制器，它负责控制最大连接数，NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。<br>- <code>Acceptor</code>跑在一个单独的线程里，它在一个死循环里调用 <code>accept</code>方法来接收新连接，一旦有新的连接请求到来，<code>accept</code>方法返回一个 <code>Channel</code> 对象，接着把 <code>Channel</code>对象交给 Poller 去处理。<br>- <code>Poller</code> 的本质是一个 <code>Selector</code>，也跑在单独线程里。<code>Poller</code>在内部维护一个 <code>Channel</code>数组，它在一个死循环里不断检测 <code>Channel</code>的数据就绪状态，一旦有 <code>Channel</code>可读，就生成一个 <code>SocketProcessor</code>任务对象扔给 <code>Executor</code>去处理。<br>- SocketProcessor 实现了 Runnable 接口，其中 run 方法中的 <code>getHandler().process(socketWrapper, SocketEvent.CONNECT_FAIL);</code> 代码则是获取 handler 并执行处理 socketWrapper，最后通过 socket 获取合适应用层协议处理器，也就是调用 Http11Processor 组件来处理请求。Http11Processor 读取 Channel 的数据来生成 ServletRequest 对象，Http11Processor 并不是直接读取 Channel 的。这是因为 Tomcat 支持同步非阻塞 I/O 模型和异步 I/O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 AsynchronousSocketChannel 和 SocketChannel，为了对 Http11Processor 屏蔽这些差异，Tomcat 设计了一个包装类叫作 SocketWrapper，Http11Processor 只调用 SocketWrapper 的方法去读写数据。<br>- <code>Executor</code>就是线程池，负责运行 <code>SocketProcessor</code>任务类，<code>SocketProcessor</code> 的 <code>run</code>方法会调用 <code>Http11Processor</code> 来读取和解析请求数据。我们知道，<code>Http11Processor</code>是应用层协议的封装，它会调用容器获得响应，再把响应通过 <code>Channel</code>写出。<br><br>工作流程如下所示：<br><br><figure class="image-box">                <img src="3c0b315759fc82801d7ddc156969113e.webp" alt="img" title class>                <p>img</p>            </figure>NioEndPoint<br><br>##### Processor<br><br>Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。<br><br><figure class="image-box">                <img src="9bcbb1ffd832ab7098eb70981a0e368f.webp" alt="img" title class>                <p>img</p>            </figure><p><strong>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 HttpProcessor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法，方法内部通过 以下代码将请求传递到容器中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calling the container</span></span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure><h4 id="Adapter-组件"><a href="#Adapter-组件" class="headerlink" title="Adapter 组件"></a>Adapter 组件</h4><p>由于协议的不同，Tomcat 定义了自己的 <code>Request</code> 类来存放请求信息，这里其实体现了面向对象的思维。但是这个 Request 不是标准的 <code>ServletRequest</code> ，所以不能直接使用 Tomcat 定义 Request 作为参数直接容器。</p><p>Tomcat 设计者的解决方案是引入 <code>CoyoteAdapter</code>，这是适配器模式的经典运用，连接器调用 <code>CoyoteAdapter</code> 的 <code>Sevice</code> 方法，传入的是 <code>Tomcat Request</code> 对象，<code>CoyoteAdapter</code>负责将 <code>Tomcat Request</code> 转成 <code>ServletRequest</code>，再调用容器的 <code>Service</code>方法。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>连接器负责外部交流，容器负责内部处理。具体来说就是，连接器处理 Socket 通信和应用层协议的解析，得到 <code>Servlet</code>请求；而容器则负责处理 <code>Servlet</code>请求。</p><p>容器：顾名思义就是拿来装东西的， 所以 Tomcat 容器就是拿来装载 <code>Servlet</code>。</p><p>Tomcat 设计了 4 种容器，分别是 <code>Engine</code>、<code>Host</code>、<code>Context</code>和 <code>Wrapper</code>。<code>Server</code> 代表 Tomcat 实例。</p><p>要注意的是这 4 种容器不是平行关系，属于父子关系，如下图所示：</p><figure class="image-box">                <img src="4e5eb57d725c843208604aa7369cb4c2.webp" alt="img" title class>                <p>img</p>            </figure>容器<br><br>你可能会问，为啥要设计这么多层次的容器，这不是增加复杂度么？其实这背后的考虑是，<strong>Tomcat 通过一种分层的架构，使得 Servlet 容器具有很好的灵活性。因为这里正好符合一个 Host 多个 Context， 一个 Context 也包含多个 Servlet，而每个组件都需要统一生命周期管理，所以组合模式设计这些容器</strong><br><br><code>Wrapper</code> 表示一个 <code>Servlet</code> ，<code>Context</code> 表示一个 Web 应用程序，而一个 Web 程序可能有多个 <code>Servlet</code> ；<code>Host</code> 表示一个虚拟主机，或者说一个站点，一个 Tomcat 可以配置多个站点（Host）；一个站点（ Host） 可以部署多个 Web 应用；<code>Engine</code> 代表 引擎，用于管理多个站点（Host），一个 Service 只能有 一个 <code>Engine</code>。<br><br>可通过 Tomcat 配置文件加深对其层次关系理解。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span> // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span>  // 顶层组件，包含一个 Engine ，多个连接器</span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span>  // 连接器</span><br><span class="line"></span><br><span class="line"> // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host</span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">   // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context</span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   // 容器组件：处理特定 Context Web应用的所有客户端请求</span><br><span class="line">   <span class="tag">&lt;<span class="name">Context</span>&gt;</span>Context&gt;</span><br><span class="line">      Host&gt;</span><br><span class="line">    Engine&gt;</span><br><span class="line">  Service&gt;</span><br><span class="line">Server&gt;</span><br></pre></td></tr></table></figure><p>如何管理这些容器？我们发现容器之间具有父子关系，形成一个树形结构，是不是想到了设计模式中的 <strong>组合模式</strong> 。</p><p>Tomcat 就是用组合模式来管理这些容器的。具体实现方法是，<strong>所有容器组件都实现了 <code>Container</code>接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</strong>。这里单容器对象指的是最底层的 <code>Wrapper</code>，组合容器对象指的是上面的 <code>Context</code>、<code>Host</code>或者 <code>Engine</code>。<code>Container</code> 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Container extends Lifecycle &#123;</span><br><span class="line">    public void setName(String name);</span><br><span class="line">    public Container getParent();</span><br><span class="line">    public void setParent(Container container);</span><br><span class="line">    public void addChild(Container child);</span><br><span class="line">    public void removeChild(Container child);</span><br><span class="line">    public Container findChild(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了<code>getParent</code>、<code>SetParent</code>、<code>addChild</code>和 <code>removeChild</code>等方法，这里正好验证了我们说的组合模式。我们还看到 <code>Container</code>接口拓展了 <code>Lifecycle</code> ，Tomcat 就是通过 <code>Lifecycle</code> 统一管理所有容器的组件的生命周期。通过组合模式管理所有容器，拓展 <code>Lifecycle</code> 实现对每个组件的生命周期管理 ，<code>Lifecycle</code> 主要包含的方法<code>init()、start()、stop() 和 destroy()</code>。</p><h4 id="请求定位-Servlet-的过程"><a href="#请求定位-Servlet-的过程" class="headerlink" title="请求定位 Servlet 的过程"></a>请求定位 Servlet 的过程</h4><p>一个请求是如何定位到让哪个 <code>Wrapper</code> 的 <code>Servlet</code> 处理的？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p><p><code>Mapper</code> 组件的功能就是将用户请求的 <code>URL</code> 定位到一个 <code>Servlet</code>，它的工作原理是：<code>Mapper</code>组件里保存了 Web 应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如 <code>Host</code>容器里配置的域名、<code>Context</code>容器里的 <code>Web</code>应用路径，以及 <code>Wrapper</code>容器里 <code>Servlet</code> 映射的路径，你可以想象这些配置信息就是一个多层次的 <code>Map</code>。</p><p>当一个请求到来时，<code>Mapper</code> 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 <code>Servlet</code>。请你注意，一个请求 URL 最后只会定位到一个 <code>Wrapper</code>容器，也就是一个 <code>Servlet</code>。</p><figure class="image-box">                <img src="c7c4351fa0f7cdfacb2d2dd1d531b863.webp" alt="img" title class>                <p>img</p>            </figure><p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p><ol><li><strong>首先根据协议和端口号确定 Service 和 Engine</strong>。Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</li><li><strong>根据域名选定 Host。</strong> Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是<code>user.shopping.com</code>，因此 Mapper 会找到 Host2 这个容器。</li><li><strong>根据 URL 路径找到 Context 组件。</strong> Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是 /order，因此找到了 Context4 这个 Context 容器。</li><li><strong>根据 URL 路径找到 Wrapper（Servlet）。</strong> Context 确定后，Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</li></ol><p>连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet，最先拿到请求的是 Engine 容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推，最后这个请求会传给 Wrapper 容器，Wrapper 会调用最终的 Servlet 来处理。那么这个调用过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p><p><code>Pipeline-Valve</code> 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理，Valve 表示一个处理点（也就是一个处理阀门），因此 <code>invoke</code>方法就是来处理请求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>继续看 Pipeline 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pipeline</code>中有 <code>addValve</code>方法。Pipeline 中维护了 <code>Valve</code>链表，<code>Valve</code>可以插入到 <code>Pipeline</code>中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，<code>Valve</code>完成自己的处理后，调用 <code>getNext.invoke()</code> 来触发下一个 Valve 调用。</p><p>其实每个容器都有一个 Pipeline 对象，只要触发了这个 Pipeline 的第一个 Valve，这个容器里 <code>Pipeline</code>中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</p><p>这是因为 <code>Pipeline</code>中还有个 <code>getBasic</code>方法。这个 <code>BasicValve</code>处于 <code>Valve</code>链表的末端，它是 <code>Pipeline</code>中必不可少的一个 <code>Valve</code>，负责调用下层容器的 Pipeline 里的第一个 Valve。</p><figure class="image-box">                <img src="ebb0f141d836202a2f7f9a174b40e584.webp" alt="img" title class>                <p>img</p>            </figure><p>整个过程分是通过连接器中的 <code>CoyoteAdapter</code> 触发，它会调用 Engine 的第一个 Valve：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="comment">// Calling the container</span></span><br><span class="line">    connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">        request, response);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 <code>doFilter()</code> 方法，最终会调到 <code>Servlet</code>的 <code>service</code>方法。</p><p>前面我们不是讲到了 <code>Filter</code>，似乎也有相似的功能，那 <code>Valve</code> 和 <code>Filter</code>有什么区别吗？它们的区别是：</p><ul><li><code>Valve</code>是 <code>Tomcat</code>的私有机制，与 Tomcat 的基础架构 <code>API</code>是紧耦合的。<code>Servlet API</code>是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li><li>另一个重要的区别是 <code>Valve</code>工作在 Web 容器级别，拦截所有应用的请求；而 <code>Servlet Filter</code> 工作在应用级别，只能拦截某个 <code>Web</code> 应用的所有请求。如果想做整个 <code>Web</code>容器的拦截器，必须通过 <code>Valve</code>来实现。</li></ul><h4 id="Lifecycle-生命周期"><a href="#Lifecycle-生命周期" class="headerlink" title="Lifecycle 生命周期"></a>Lifecycle 生命周期</h4><p>前面我们看到 <code>Container</code>容器 继承了 <code>Lifecycle</code> 生命周期。如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。也就是说，Tomcat 需要动态地管理这些组件的生命周期。</p><p>如何统一管理组件的创建、初始化、启动、停止和销毁？如何做到代码逻辑清晰？如何方便地添加或者删除组件？如何做到组件启动和停止不遗漏、不重复？</p><h5 id="一键式启停：LifeCycle-接口"><a href="#一键式启停：LifeCycle-接口" class="headerlink" title="一键式启停：LifeCycle 接口"></a>一键式启停：LifeCycle 接口</h5><p>设计就是要找到系统的变化点和不变点。这里的不变点就是每个组件都要经历创建、初始化、启动这几个过程，这些状态以及状态的转化是不变的。而变化点是每个具体组件的初始化方法，也就是启动方法是不一样的。</p><p>因此，Tomcat 把不变点抽象出来成为一个接口，这个接口跟生命周期有关，叫作 LifeCycle。LifeCycle 接口里定义这么几个方法：<code>init()、start()、stop() 和 destroy()</code>，每个具体的组件（也就是容器）去实现这些方法。</p><p>在父组件的 <code>init()</code> 方法里需要创建子组件并调用子组件的 <code>init()</code> 方法。同样，在父组件的 <code>start()</code>方法里也需要调用子组件的 <code>start()</code> 方法，因此调用者可以无差别的调用各组件的 <code>init()</code> 方法和 <code>start()</code> 方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是 Server 组件的 <code>init()</code>和<code>start()</code> 方法，整个 Tomcat 就被启动起来了。所以 Tomcat 采取组合模式管理容器，容器继承 LifeCycle 接口，这样就可以向针对单个对象一样一键管理各个容器的生命周期，整个 Tomcat 就启动起来。</p><h5 id="可扩展性：LifeCycle-事件"><a href="#可扩展性：LifeCycle-事件" class="headerlink" title="可扩展性：LifeCycle 事件"></a>可扩展性：LifeCycle 事件</h5><p>我们再来考虑另一个问题，那就是系统的可扩展性。因为各个组件<code>init()</code> 和 <code>start()</code> 方法的具体实现是复杂多变的，比如在 Host 容器的启动方法里需要扫描 webapps 目录下的 Web 应用，创建相应的 Context 容器，如果将来需要增加新的逻辑，直接修改<code>start()</code> 方法？这样会违反开闭原则，那如何解决这个问题呢？开闭原则说的是为了扩展系统的功能，你不能直接修改系统中已有的类，但是你可以定义新的类。</p><p><strong>组件的 <code>init()</code> 和 <code>start()</code> 调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除</strong>，这就是典型的<strong>观察者模式</strong>。</p><p>以下就是 <code>Lyfecycle</code> 接口的定义:</p><p><img src="6c0d1f851e590155176af9ad27f92a6f.webp" alt="img"><code>Lyfecycle</code></p><h5 id="重用性：LifeCycleBase-抽象基类"><a href="#重用性：LifeCycleBase-抽象基类" class="headerlink" title="重用性：LifeCycleBase 抽象基类"></a>重用性：LifeCycleBase 抽象基类</h5><p>再次看到抽象模板设计模式。</p><p>有了接口，我们就要用类去实现接口。一般来说实现类不止一个，不同的类在实现接口时往往会有一些相同的逻辑，如果让各个子类都去实现一遍，就会有重复代码。那子类如何重用这部分逻辑呢？其实就是定义一个基类来实现共同的逻辑，然后让各个子类去继承它，就达到了重用的目的。</p><p>Tomcat 定义一个基类 LifeCycleBase 来实现 LifeCycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class LifecycleBase implements Lifecycle&#123;</span><br><span class="line">    // 持有所有的观察者</span><br><span class="line">    private final List lifecycleListeners = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 发布事件</span><br><span class="line">     *</span><br><span class="line">     * @param type  Event type</span><br><span class="line">     * @param data  Data associated with event.</span><br><span class="line">     */</span><br><span class="line">    protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">        LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">        for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 模板方法定义整个启动流程，启动所有容器</span><br><span class="line">    @Override</span><br><span class="line">    public final synchronized void init() throws LifecycleException &#123;</span><br><span class="line">        //1. 状态检查</span><br><span class="line">        if (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //2. 触发 INITIALIZING 事件的监听器</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZING, null, false);</span><br><span class="line">            // 3. 调用具体子类的初始化方法</span><br><span class="line">            initInternal();</span><br><span class="line">            // 4. 触发 INITIALIZED 事件的监听器</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZED, null, false);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            setStateInternal(LifecycleState.FAILED, null, false);</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;lifecycleBase.initFail&quot;,toString()), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat 为了实现一键式启停以及优雅的生命周期管理，并考虑到了可扩展性和可重用性，将面向对象思想和设计模式发挥到了极致，<code>Containaer</code>接口维护了容器的父子关系，<code>Lifecycle</code> 组合模式实现组件的生命周期维护，生命周期每个组件有变与不变的点，运用模板方法模式。分别运用了<strong>组合模式、观察者模式、骨架抽象类和模板方法</strong>。</p><p>如果你需要维护一堆具有父子关系的实体，可以考虑使用组合模式。</p><p>观察者模式听起来 “高大上”，其实就是当一个事件发生后，需要执行一连串更新操作。实现了低耦合、非侵入式的通知与更新机制。</p><figure class="image-box">                <img src="844ce454077ebe51f60e86504dde3f8f.webp" alt="img" title class>                <p>img</p>            </figure><p><code>Container</code> 继承了 LifeCycle，StandardEngine、StandardHost、StandardContext 和 StandardWrapper 是相应容器组件的具体实现类，因为它们都是容器，所以继承了 ContainerBase 抽象基类，而 ContainerBase 实现了 Container 接口，也继承了 LifeCycleBase 类，它们的生命周期管理接口和功能接口是分开的，这也符合设计中<strong>接口分离的原则</strong>。</p><h3 id="Tomcat-为何打破双亲委派机制"><a href="#Tomcat-为何打破双亲委派机制" class="headerlink" title="Tomcat 为何打破双亲委派机制"></a>Tomcat 为何打破双亲委派机制</h3><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>我们知道 <code>JVM</code>的类加载器加载 Class 的时候基于双亲委派机制，也就是会将加载交给自己的父加载器加载，如果 父加载器为空则查找<code>Bootstrap</code> 是否加载过，当无法加载的时候才让自己加载。JDK 提供一个抽象类 <code>ClassLoader</code>，这个抽象类中定义了三个关键方法。对外使用<code>loadClass(String name) 用于子类重写打破双亲委派：loadClass(String name, boolean resolve)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 查找该 class 是否已经被加载过</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 委托给父加载器去加载，递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器为空，查找 Bootstrap 是否加载过</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若果依然加载不到，则调用自己的 findClass 去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 根据传入的类名 name，到在特定目录下去寻找类文件，把.class 文件读入内存</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 调用 defineClass 将字节数组转成 Class 对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节码数组解析成一个 Class 对象，用 native 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Class <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 中有 3 个类加载器，另外你也可以自定义类加载器，它们的关系如下图所示。</p><figure class="image-box">                <img src="bfaaa526706997606a0cb622dfc35396.webp" alt="img" title class>                <p>img</p>            </figure>类加载器<br><br>- <code>BootstrapClassLoader</code>是启动类加载器，由 C 语言实现，用来加载 <code>JVM</code>启动时所需要的核心类，比如<code>rt.jar</code>、<code>resources.jar</code>等。<br>- <code>ExtClassLoader</code>是扩展类加载器，用来加载<code>\jre\lib\ext</code>目录下 JAR 包。<br>- <code>AppClassLoader</code>是系统类加载器，用来加载 <code>classpath</code>下的类，应用程序默认用它来加载类。<br>- 自定义类加载器，用来加载自定义路径下的类。<br><br>这些类加载器的工作原理是一样的，区别是它们的加载路径不同，也就是说 <code>findClass</code>这个方法查找的路径不同。双亲委托机制是为了保证一个 Java 类在 JVM 中是唯一的，假如你不小心写了一个与 JRE 核心类同名的类，比如 <code>Object</code>类，双亲委托机制能保证加载的是 <code>JRE</code>里的那个 <code>Object</code>类，而不是你写的 <code>Object</code>类。这是因为 <code>AppClassLoader</code>在加载你的 Object 类时，会委托给 <code>ExtClassLoader</code>去加载，而 <code>ExtClassLoader</code>又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code>类。我们最多只能 获取到 <code>ExtClassLoader</code>这里注意下。<br><br>#### Tomcat 热加载<br><br>Tomcat 本质是通过一个后台线程做周期性的任务，定期检测类文件的变化，如果有变化就重新加载类。我们来看 <code>ContainerBackgroundProcessor</code>具体是如何实现的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBackgroundProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请注意这里传入的参数是 " 宿主类 " 的实例</span></span><br><span class="line">        processChildren(ContainerBase.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processChildren</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 调用当前容器的 backgroundProcess 方法。</span></span><br><span class="line">            container.backgroundProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 遍历所有的子容器，递归调用 processChildren，</span></span><br><span class="line">            <span class="comment">// 这样当前容器的子孙都会被处理</span></span><br><span class="line">            Container[] children = container.findChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span></span><br><span class="line">                <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    processChildren(children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Tomcat 的热加载就是在 Context 容器实现，主要是调用了 Context 容器的 reload 方法。抛开细节从宏观上看主要完成以下任务：</p><ol><li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li><li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li><li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li><li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li><li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li></ol><p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p><h4 id="Tomcat-的类加载器"><a href="#Tomcat-的类加载器" class="headerlink" title="Tomcat 的类加载器"></a>Tomcat 的类加载器</h4><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 <code>ClassLoader</code>的两个方法：<code>findClass</code>和 <code>loadClass</code>。</p><h5 id="findClass-方法"><a href="#findClass-方法" class="headerlink" title="findClass 方法"></a>findClass 方法</h5><p><code>org.apache.catalina.loader.WebappClassLoaderBase#findClass</code>;为了方便理解和阅读，我去掉了一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在 Web 应用目录下查找类</span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先在 Web 应用本地目录下查找要加载的类。</li><li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 <code>AppClassLoader</code>。</li><li>如何父加载器也没找到这个类，抛出 <code>ClassNotFound</code>异常。</li></ol><h5 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h5><p>再来看 Tomcat 类加载器的 <code>loadClass</code>方法的实现，同样我也去掉了一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地 cache 查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的 cache 中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索 class 并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有六个步骤：</p><ol><li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li><li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li><li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的 <strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委托机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 <code>ExtClassLoader</code>去加载，因为 <code>ExtClassLoader</code>会委托给 <code>BootstrapClassLoader</code>去加载，<code>BootstrapClassLoader</code>发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li><li>如果 <code>ExtClassLoader</code>加载器加载失败，也就是说 <code>JRE</code>核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li><li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li><li>如果上述加载过程全部失败，抛出 <code>ClassNotFound</code>异常。</li></ol><h4 id="Tomcat-类加载器层次"><a href="#Tomcat-类加载器层次" class="headerlink" title="Tomcat 类加载器层次"></a>Tomcat 类加载器层次</h4><p>Tomcat 作为 <code>Servlet</code>容器，它负责加载我们的 <code>Servlet</code>类，此外它还负责加载 <code>Servlet</code>所依赖的 JAR 包。并且 <code>Tomcat</code>本身也是也是一个 Java 程序，因此它需要加载自己的类和依赖的 JAR 包。首先让我们思考这一下这几个问题：</p><ol><li>假如我们在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 <code>Servlet</code>，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 <code>Servlet</code>类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li><li>假如两个 Web 应用都依赖同一个第三方的 JAR 包，比如 <code>Spring</code>，那 <code>Spring</code>的 JAR 包被加载到内存后，<code>Tomcat</code>要保证这两个 Web 应用能够共享，也就是说 <code>Spring</code>的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，<code>JVM</code>的内存会膨胀。</li><li>跟 JVM 一样，我们需要隔离 Tomcat 本身的类和 Web 应用的类。</li></ol><figure class="image-box">                <img src="bc3f88a879d635e79609c0f7e1ddb640.webp" alt="img" title class>                <p>img</p>            </figure><h5 id="1-WebAppClassLoader"><a href="#1-WebAppClassLoader" class="headerlink" title="1. WebAppClassLoader"></a>1. WebAppClassLoader</h5><p>Tomcat 的解决方案是自定义一个类加载器 <code>WebAppClassLoader</code>， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 <code>Context</code>容器负责创建和维护一个 <code>WebAppClassLoader</code>加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p><h5 id="2-SharedClassLoader"><a href="#2-SharedClassLoader" class="headerlink" title="2.SharedClassLoader"></a>2.SharedClassLoader</h5><p>本质需求是两个 Web 应用之间怎么共享库类,并且不能重复加载相同的类。在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗。</p><p>因此 Tomcat 的设计者又加了一个类加载器 <code>SharedClassLoader</code>，作为 <code>WebAppClassLoader</code>的父加载器，专门来加载 Web 应用之间共享的类。如果 <code>WebAppClassLoader</code>自己没有加载到某个类，就会委托父加载器 <code>SharedClassLoader</code>去加载这个类，<code>SharedClassLoader</code>会在指定目录下加载共享类，之后返回给 <code>WebAppClassLoader</code>，这样共享的问题就解决了。</p><h5 id="3-CatalinaClassloader"><a href="#3-CatalinaClassloader" class="headerlink" title="3. CatalinaClassloader"></a>3. CatalinaClassloader</h5><p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p><p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，基于此 Tomcat 又设计一个类加载器 <code>CatalinaClassloader</code>，专门来加载 Tomcat 自身的类。</p><p>这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p><p>老办法，还是再增加一个 <code>CommonClassLoader</code>，作为 <code>CatalinaClassloader</code>和 <code>SharedClassLoader</code>的父加载器。<code>CommonClassLoader</code>能加载的类都可以被 <code>CatalinaClassLoader</code>和 <code>SharedClassLoader</code>使用</p><h2 id="整体架构设计解析收获总结"><a href="#整体架构设计解析收获总结" class="headerlink" title="整体架构设计解析收获总结"></a>整体架构设计解析收获总结</h2><p>通过前面对 Tomcat 整体架构的学习，知道了 Tomcat 有哪些核心组件，组件之间的关系。以及 Tomcat 是怎么处理一个 HTTP 请求的。下面我们通过一张简化的类图来回顾一下，从图上你可以看到各种组件的层次关系，图中的虚线表示一个请求在 Tomcat 中流转的过程。</p><figure class="image-box">                <img src="3eea333acf49278cb00d07818fa5d0f8.webp" alt="img" title class>                <p>img</p>            </figure><p>Tomcat 整体组件关系</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>Tomcat 的整体架构包含了两个核心组件连接器和容器。连接器负责对外交流，容器负责内部处理。连接器用 <code>ProtocolHandler</code>接口来封装通信协议和 <code>I/O</code>模型的差异，<code>ProtocolHandler</code>内部又分为 <code>EndPoint</code>和 <code>Processor</code>模块，<code>EndPoint</code>负责底层 <code>Socket</code>通信，<code>Proccesor</code>负责应用层协议解析。连接器通过适配器 <code>Adapter</code>调用容器。</p><p>对 Tomcat 整体架构的学习，我们可以得到一些设计复杂系统的基本思路。<strong>首先要分析需求，根据高内聚低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，在抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。</strong></p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>运用了<strong>组合模式 管理容器、通过 观察者模式 发布启动事件达到解耦、开闭原则。骨架抽象类和模板方法抽象变与不变，变化的交给子类实现，从而实现代码复用，以及灵活的拓展</strong>。使用责任链的方式处理请求，比如记录日志等。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>为了隔离 Web 应用打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>，使用 <strong>ExtClassLoader</strong> 去加载，这样即打破了双亲委派，又能安全加载。</p><h2 id="如何阅读源码持续学习"><a href="#如何阅读源码持续学习" class="headerlink" title="如何阅读源码持续学习"></a>如何阅读源码持续学习</h2><p><strong>学习是一个反人类的过程，是比较痛苦的</strong>。尤其学习我们常用的优秀技术框架本身比较庞大，设计比较复杂，在学习初期很容易遇到 “挫折感”，debug 跳来跳去陷入恐怖细节之中无法自拔，往往就会放弃。</p><p><strong>找到适合自己的学习方法非常重要，同样关键的是要保持学习的兴趣和动力，并且得到学习反馈效果</strong>。</p><p>学习优秀源码，我们收获的就是架构设计能力，遇到复杂需求我们学习到可以利用合理模式与组件抽象设计了可拓展性强的代码能力。</p><h3 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h3><p>比如我最初在学习 Spring 框架的时候，一开始就钻进某个模块啃起来。然而由于 Spring 太庞大，模块之间也有联系，根本不明白为啥要这么写，只觉得为啥设计这么 “绕”。</p><h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><ul><li>陷入细节，不看全局：<strong>我还没弄清楚森林长啥样，就盯着叶子看</strong> ，看不到全貌和整体设计思路。所以阅读源码学习的时候不要一开始就进入细节，而是宏观看待整体架构设计思想，模块之间的关系。</li><li>还没学会用就研究如何设计：首先基本上框架都运用了设计模式，我们最起码也要了解常用的设计模式，即使是“背”，也得了然于胸。在学习一门技术，我推荐先看官方文档，看看有哪些模块、整体设计思想。然后下载示例跑一遍，最后才是看源码。</li><li>看源码深究细节：到了看具体某个模块源码的时候也要下意识的不要去深入细节，重要的是学习设计思路，而不是具体一个方法实现逻辑。除非自己要基于源码做二次开发。</li></ul><h4 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h4><ul><li>定焦原则：抓主线（抓住一个核心流程去分析，不要漫无目的的到处阅读）。</li><li>宏观思维：从全局的视角去看待，上帝视角理出主要核心架构设计，先森林后树叶。切勿不要试图去搞明白每一行代码。</li><li>断点：合理运用调用栈（观察调用过程上下文）。</li></ul><h3 id="带着目标去学"><a href="#带着目标去学" class="headerlink" title="带着目标去学"></a>带着目标去学</h3><p>比如某些知识点是面试的热点，那学习目标就是彻底理解和掌握它，当被问到相关问题时，你的回答能够使得面试官对你刮目相看，有时候往往凭着某一个亮点就能影响最后的录用结果。</p><p>又或者接到一个稍微复杂的需求，<strong>学习从优秀源码中借鉴设计思路与优化技巧。</strong></p><p><strong>最后就是动手实践</strong>，将所学运用在工作项目中。只有动手实践才会让我们对技术有最直观的感受。有时候我们听别人讲经验和理论，感觉似乎懂了，但是过一段时间便又忘记了。</p><h2 id="实际场景运用"><a href="#实际场景运用" class="headerlink" title="实际场景运用"></a>实际场景运用</h2><p>简单的分析了 Tomcat 整体架构设计，从 【连接器】 到 【容器】，并且分别细说了一些组件的设计思想以及设计模式。接下来就是如何学以致用，借鉴优雅的设计运用到实际工作开发中。<strong>学习，从模仿开始。</strong></p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>在工作中，有这么一个需求，用户可以输入一些信息并可以选择查验该企业的 【工商信息】、【司法信息】、【中登情况】等如下如所示的一个或者多个模块，而且模块之间还有一些公共的东西是要各个模块复用。</p><p>这里就像一个请求，会被多个模块去处理。所以每个查询模块我们可以抽象为 <strong>处理阀门</strong>，使用一个 List 将这些 阀门保存起来，这样新增模块我们只需要新增一个<strong>阀门</strong>即可，实现了<strong>开闭原则</strong>，<strong>同时将一堆查验的代码解耦到不同的具体阀门中</strong>，使用抽象类提取 “<strong>不变的</strong>”功能。</p><figure class="image-box">                <img src="58f80e12c2dd2b9abd20c16b832fd4b4.webp" alt="img" title class>                <p>img</p>            </figure><p>具体示例代码如下所示：</p><p>首先抽象我们的处理阀门， <code>NetCheckDTO</code>是请求信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链模式：处理每个模块阀门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象基类，复用代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCheckValve</span> <span class="keyword">implements</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AnalysisReportLogDO <span class="title">getLatestHistoryData</span><span class="params">(NetCheckDTO netCheckDTO, NetCheckDataTypeEnum checkDataTypeEnum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取历史记录，省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取查验数据源配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getModuleSource</span><span class="params">(String querySource, ModuleEnum moduleEnum)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体每个模块处理的业务逻辑，比如 【百度负面新闻】对应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduNegativeValve</span> <span class="keyword">extends</span> <span class="title">AbstractCheckValve</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是管理用户选择要查验的模块，我们通过 List 保存。用于触发所需要的查验模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetCheckService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入所有的阀门</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map valveMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送查验请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckRequest</span><span class="params">(NetCheckDTO netCheckDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于保存客户选择处理的模块阀门</span></span><br><span class="line">        List valves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        CheckModuleConfigDTO checkModuleConfig = netCheckDTO.getCheckModuleConfig();</span><br><span class="line">        <span class="comment">// 将用户选择查验的模块添加到 阀门链条中</span></span><br><span class="line">        <span class="keyword">if</span> (checkModuleConfig.getBaiduNegative()) &#123;</span><br><span class="line">            valves.add(valveMap.get(<span class="string">"baiduNegativeValve"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码.......</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(valves)) &#123;</span><br><span class="line">            log.info(<span class="string">"网查查验模块为空，没有需要查验的任务"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发处理</span></span><br><span class="line">        valves.forEach(valve -&gt; valve.invoke(netCheckDTO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>需求是这样的，可根据客户录入的财报 excel 数据或者企业名称执行财报分析。</p><p>对于非上市的则解析 excel -&gt; 校验数据是否合法-&gt;执行计算。</p><p>上市企业：判断名称是否存在 ，不存在则发送邮件并中止计算-&gt; 从数据库拉取财报数据，初始化查验日志、生成一条报告记录，触发计算-&gt; 根据失败与成功修改任务状态 。</p><figure class="image-box">                <img src="23cf73882200a0622108b396eb8710c3.webp" alt="img" title class>                <p>img</p>            </figure><p>重要的 ”变“ 与 ”不变“，</p><ul><li><strong>不变</strong>的是整个流程是<strong>初始化查验日志、初始化一条报告</strong>、<strong>前期校验数据</strong>（若是上市公司校验不通过还需要构建邮件数据并发送）、从不同来源拉取财报数据并且适配通用数据、然后触发计算，任务异常与成功都需要修改状态。</li><li><strong>变化</strong>的是上市与非上市校验规则不一样，获取财报数据方式不一样，两种方式的财报数据需要适配</li></ul><p>整个算法流程是固定的模板，但是需要将<strong>算法内部变化的部分</strong>具体实现延迟到不同子类实现，这正是模板方法模式的最佳场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnalysisTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交财报分析模板方法，定义骨架流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reportAnalysisRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FinancialAnalysisResultDTO <span class="title">doProcess</span><span class="params">(FinancialReportAnalysisRequest reportAnalysisRequest)</span> </span>&#123;</span><br><span class="line">        FinancialAnalysisResultDTO analysisDTO = <span class="keyword">new</span> FinancialAnalysisResultDTO();</span><br><span class="line">  <span class="comment">// 抽象方法：提交查验的合法校验</span></span><br><span class="line">        <span class="keyword">boolean</span> prepareValidate = prepareValidate(reportAnalysisRequest, analysisDTO);</span><br><span class="line">        log.info(<span class="string">"prepareValidate 校验结果 = &#123;&#125; "</span>, prepareValidate);</span><br><span class="line">        <span class="keyword">if</span> (!prepareValidate) &#123;</span><br><span class="line">   <span class="comment">// 抽象方法：构建通知邮件所需要的数据</span></span><br><span class="line">            buildEmailData(analysisDTO);</span><br><span class="line">            log.info(<span class="string">"构建邮件信息，data = &#123;&#125;"</span>, JSON.toJSONString(analysisDTO));</span><br><span class="line">            <span class="keyword">return</span> analysisDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        String reportNo = FINANCIAL_REPORT_NO_PREFIX + reportAnalysisRequest.getUserId() + SerialNumGenerator.getFixLenthSerialNumber();</span><br><span class="line">        <span class="comment">// 生成分析日志</span></span><br><span class="line">        initFinancialAnalysisLog(reportAnalysisRequest, reportNo);</span><br><span class="line">  <span class="comment">// 生成分析记录</span></span><br><span class="line">        initAnalysisReport(reportAnalysisRequest, reportNo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法：拉取财报数据，不同子类实现</span></span><br><span class="line">            FinancialDataDTO financialData = pullFinancialData(reportAnalysisRequest);</span><br><span class="line">            log.info(<span class="string">"拉取财报数据完成, 准备执行计算"</span>);</span><br><span class="line">            <span class="comment">// 测算指标</span></span><br><span class="line">            financialCalcContext.calc(reportAnalysisRequest, financialData, reportNo);</span><br><span class="line">   <span class="comment">// 设置分析日志为成功</span></span><br><span class="line">            successCalc(reportNo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"财报计算子任务出现异常"</span>, e);</span><br><span class="line">   <span class="comment">// 设置分析日志失败</span></span><br><span class="line">            failCalc(reportNo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> analysisDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后新建两个子类继承该模板，并实现抽象方法。这样就将上市与非上市两种类型的处理逻辑解耦，同时又复用了代码。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>需求是这样，要做一个万能识别银行流水的 excel 接口，假设标准流水包含【交易时间、收入、支出、交易余额、付款人账号、付款人名字、收款人名称、收款人账号】等字段。现在我们解析出来每个必要字段所在 excel 表头的下标。但是流水有多种情况：</p><ol><li>一种就是包含所有标准字段。</li><li>收入、支出下标是同一列，通过正负来区分收入与支出。</li><li>收入与支出是同一列，有一个交易类型的字段来区分。</li><li>特殊银行的特殊处理。</li></ol><p>也就是我们要<strong>根据解析对应的下标找到对应的处理逻辑算法</strong>，我们可能在一个方法里面写超多 <code>if else</code> 的代码，整个流水处理都偶合在一起，假如未来再来一种新的流水类型，还要继续改老代码。最后可能出现 “又臭又长，难以维护” 的代码复杂度。</p><p>这个时候我们可以用到<strong>策略模式</strong>，<strong>将不同模板的流水使用不同的处理器处理，根据模板找到对应的策略算法去处理</strong>。即使未来再加一种类型，我们只要新加一种处理器即可，高内聚低耦合，且可拓展。</p><figure class="image-box">                <img src="bc69c1f573168ded681da5bc39642a57.webp" alt="img" title class>                <p>img</p>            </figure><p>定义处理器接口，不同处理器去实现处理逻辑。将所有的处理器注入到 <code>BankFlowDataHandler</code> 的<code>data_processor_map</code>中，根据不同的场景取出对已经的处理器处理流水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理流水数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bankFlowTemplateDO 流水下标数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BankTransactionFlowDO <span class="title">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO, List row)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持处理该模板,不同类型的流水策略根据模板数据判断是否支持解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器的上下文</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankFlowDataContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将所有处理器注入到 map 中</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List processors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找对对应的处理器处理流水</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         DataProcessor processor = getProcessor(bankFlowTemplateDO);</span><br><span class="line">        <span class="keyword">for</span>(DataProcessor processor ：processors) &#123;</span><br><span class="line">           <span class="keyword">if</span> (processor.isSupport(bankFlowTemplateDO)) &#123;</span><br><span class="line">             <span class="comment">// row 就是一行流水数据</span></span><br><span class="line">           processor.doProcess(bankFlowTemplateDO, row);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义默认处理器，处理正常模板，新增模板只要新增处理器实现 <code>DataProcessor</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认处理器：正对规范流水模板</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"defaultDataProcessor"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataProcessor</span> <span class="keyword">implements</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BankTransactionFlowDO <span class="title">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略处理逻辑细节</span></span><br><span class="line">        <span class="keyword">return</span> bankTransactionFlowDO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strategy</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略判断是否支持解析该流水</span></span><br><span class="line">      <span class="keyword">boolean</span> isDefault = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isDefault;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过策略模式，我们将不同处理逻辑分配到不同的处理类中，这样完全解耦，便于拓展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat-架构原理解析到架构设计借鉴&quot;&gt;&lt;a href=&quot;#Tomcat-架构原理解析到架构设计借鉴&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 架构原理解析到架构设计借鉴&quot;&gt;&lt;/a&gt;Tomcat 架构原理解析到架构设计借鉴&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/技术/"/>
    
    
    <category term="技术" scheme="https://github.com/missionOdd/tags/技术/"/>
    
    <category term="原理" scheme="https://github.com/missionOdd/tags/原理/"/>
    
    <category term="tomcat" scheme="https://github.com/missionOdd/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>整数反转 | 数学 | 当前值除以10与上一个值比较，判断是否溢出（java）</title>
    <link href="https://github.com/missionOdd/2021/12/01/reverse-integer/"/>
    <id>https://github.com/missionOdd/2021/12/01/reverse-integer/</id>
    <published>2021-12-01T07:50:37.000Z</published>
    <updated>2022-01-12T14:10:01.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：<br>输入：x = 123<br>输出：321<br>示例 2：<br>输入：x = -123<br>输出：-321<br>示例 3：<br>输入：x = 120<br>输出：21<br>示例 4：<br>输入：x = 0<br>输出：0</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目不允许存储 64 位整数，不能用long类型；<br>想要使用最大最小的数值边界判断，你其实根本记不住；<br>最好的办法就是：在每次增大数字的时候，就要逆向计算一下，判断数值是否溢出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span> &amp;&amp; x&gt;-<span class="number">10</span>) <span class="keyword">return</span> x; <span class="comment">//个位数情况</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>, pev;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            pev=cur; <span class="comment">//保存上次的值</span></span><br><span class="line">            cur=cur*<span class="number">10</span>+x%<span class="number">10</span>;   <span class="comment">//旋转数字，不断从末尾插入新值，总值不断扩大</span></span><br><span class="line">            <span class="keyword">if</span>((cur-x%<span class="number">10</span>)/<span class="number">10</span>!=pev) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//当逆向计算发现不相同，说明数溢出，直接返回0</span></span><br><span class="line">            x/=<span class="number">10</span>;  <span class="comment">//删除个位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<br><code>if((cur-x%10)/10!=pev) return 0;</code><br>x%10是个位数，cur减去它后个位数是0，不减就是x%10。<br>无论减不减最后/10的结果都一样，因此直接换成<br><code>if(cur/10!=pev) return 0;</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span> &amp;&amp; x&gt;-<span class="number">10</span>) <span class="keyword">return</span> x; <span class="comment">//个位数情况</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>, pev;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            pev=cur; <span class="comment">//保存上次的值</span></span><br><span class="line">            cur=cur*<span class="number">10</span>+x%<span class="number">10</span>;   <span class="comment">//旋转数字，不断从末尾插入新值，总值不断扩大</span></span><br><span class="line">            <span class="keyword">if</span>(cur/<span class="number">10</span>!=pev) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//当逆向计算发现不相同，说明数溢出，直接返回0</span></span><br><span class="line">            x/=<span class="number">10</span>;  <span class="comment">//删除个位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/&quot; target=&quot;_b</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="数学" scheme="https://github.com/missionOdd/tags/数学/"/>
    
  </entry>
  
  <entry>
    <title>最小覆盖子串 | 哈希表+队列+滑动窗口</title>
    <link href="https://github.com/missionOdd/2021/11/15/minimum-window-substring/"/>
    <id>https://github.com/missionOdd/2021/11/15/minimum-window-substring/</id>
    <published>2021-11-15T02:50:37.000Z</published>
    <updated>2022-01-12T15:41:56.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：<br>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：<br>输入：s = “a”, t = “a”<br>输出：”a”<br>示例 3:<br>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><p>提示：<br>1 &lt;= s.length, t.length &lt;= 105<br>s 和 t 由英文字母组成</p><p>进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>为了使用队列，减少对哈希表数组操作的遍历次数，设置了zoreNeed平衡点，定义了匹配字符在窗口中是否需要的平衡界限</li><li>左指针采用队列记录，实现左指针跳跃，相比左指针+1循环的方式减少了遍历次数<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">""</span> || t == <span class="string">""</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] tt = t.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> zoreNeed = ss.length; <span class="comment">//设置0平衡，定义了匹配字符在窗口中是否需要的平衡界限，作用是：使匹配字符的need最小无法达到0， 非匹配字符都是need=0，保证能区分开，来决定能否加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建hash表：匹配字符-&gt; zoreNeed + 实际需要数；非匹配字符 -&gt; 0</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">123</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: tt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need[c]==<span class="number">0</span>) need[c]+=zoreNeed;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//2. 匹配字符位置队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> needSum = tt.length,  ansStart=<span class="number">0</span>,  ansSize=Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//3. 窗口随着右指针end递增而增大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end= <span class="number">0</span>; end&lt;ss.length; end++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need[ss[end]]&gt;zoreNeed)&#123; <span class="comment">//4. 判断窗口是否需要当前字符,需要的话needSum-1</span></span><br><span class="line">                needSum--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need[ss[end]]&gt;<span class="number">0</span>)&#123; <span class="comment">//5. 若是则匹配字符加入队列</span></span><br><span class="line">                queue.add(end);</span><br><span class="line">                need[ss[end]]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//6. 窗口匹配成功</span></span><br><span class="line">            <span class="keyword">if</span>(needSum == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//6.1 从队列中不断取start，窗口随着左指针start递增而增大</span></span><br><span class="line">                start = queue.poll();  <span class="comment">//此时队列不可能为空，取队列第一个匹配字符（左指针指向第一次匹配字符位置 或 上一次成功匹配后将左指针指向下一个匹配字符位置）</span></span><br><span class="line">                <span class="keyword">while</span>(need[ss[start]]&lt;zoreNeed)&#123; <span class="comment">//缩小窗口，直到刚好匹配则结束</span></span><br><span class="line">                    need[ss[start]]++;</span><br><span class="line">                    start = queue.poll();  <span class="comment">//取出并删掉多余的匹配字符</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//6.2 取最小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(end-start&lt;ansSize)&#123;</span><br><span class="line">                    ansStart = start;</span><br><span class="line">                    ansSize = end-start;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//6.3 左指针右移，继续缩小窗口。 这里只先释放增加左指针指向匹配字符的需要数，真正右移是在等下一次匹配成功后，第一次调用 start = queue.poll();</span></span><br><span class="line">                need[ss[start]]++;</span><br><span class="line">                needSum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansSize == Integer.MAX_VALUE? <span class="string">""</span> :s.substring(ansStart, ansStart+ansSize+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-window-substring/&quot; t</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="摩尔投票法" scheme="https://github.com/missionOdd/tags/摩尔投票法/"/>
    
  </entry>
  
  <entry>
    <title>颜色分类LeetCode题 | 三指针，2指针循环去重写法改编</title>
    <link href="https://github.com/missionOdd/2021/11/13/sort-colors/"/>
    <id>https://github.com/missionOdd/2021/11/13/sort-colors/</id>
    <published>2021-11-13T04:30:37.000Z</published>
    <updated>2022-01-12T15:41:56.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p> 颜色分类<br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：<br>输入：nums = [2,0,1]<br>输出：[0,1,2]<br>示例 3：<br>输入：nums = [0]<br>输出：[0]<br>示例 4：<br>输入：nums = [1]<br>输出：[1]</p><p>提示：<br>n == nums.length<br>1 &lt;= n &lt;= 300<br>nums[i] 为 0、1 或 2</p><p>进阶：<br>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p></blockquote><p><strong>思路</strong><br>根据快排的2指针循环去重写法，改编的3指针法</p><p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r= nums.length-<span class="number">1</span>, m=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(m&lt;r &amp;&amp; nums[r]==<span class="number">2</span>)&#123;   <span class="comment">//右指针过滤2，找到待替换位置</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==<span class="number">0</span>)&#123;   <span class="comment">//左指针过滤0，找到待替换位置</span></span><br><span class="line">                l++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(m&lt;r &amp;&amp; nums[m]==<span class="number">1</span>)&#123;   <span class="comment">//中指针过滤1，找到替换的位置</span></span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==<span class="number">0</span>)&#123;         </span><br><span class="line">                swap(nums, l ,m);   <span class="comment">// 左替换</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums, m ,r);    <span class="comment">//右替换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp =nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/sort-colors/&quot; target=&quot;_blank</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="三指针" scheme="https://github.com/missionOdd/tags/三指针/"/>
    
  </entry>
  
  <entry>
    <title>旋转链表 | 哈希表存储链表索引，定位查找链表环切断点</title>
    <link href="https://github.com/missionOdd/2021/11/12/rotate-list/"/>
    <id>https://github.com/missionOdd/2021/11/12/rotate-list/</id>
    <published>2021-11-12T07:50:37.000Z</published>
    <updated>2022-01-12T15:41:55.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">the leetcode link</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>计算链表长度，同时初始化哈希索引</li><li>取余去重</li><li>形成环，链尾指向链头</li><li>定位到翻转后的尾结点</li><li>断链</li><li>返回新链头<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哈希索引存储</span></span><br><span class="line">        Map&lt;Integer,ListNode&gt; map  = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算链表长度， 同时初始化哈希索引</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(len++, cur);</span><br><span class="line">            cur =cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重，转n*len+k次，等价于转k%len次，k%len=0等价与0次翻转</span></span><br><span class="line">        <span class="keyword">if</span>((k=(k%len))==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形成环</span></span><br><span class="line">        cur.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到翻转后的尾结点</span></span><br><span class="line">        ListNode newTail = map.get(len-k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开头尾</span></span><br><span class="line">        ListNode newHead = newTail.next;</span><br><span class="line">        newTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rotate-list/&quot; target=&quot;_blank</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="链表" scheme="https://github.com/missionOdd/tags/链表/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍 II | 动态规划 | 环看作两个队列 （JAVA）</title>
    <link href="https://github.com/missionOdd/2021/11/10/house-robber-ii/"/>
    <id>https://github.com/missionOdd/2021/11/10/house-robber-ii/</id>
    <published>2021-11-10T07:50:37.000Z</published>
    <updated>2022-01-12T14:10:41.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>打家劫舍 II<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2：<br>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 3：<br>输入：nums = [0]<br>输出：0</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 1000</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>环拆成两个队列，对每个队列动态规划求最优解（这里需掌握: 打家劫舍1），然后比较两者取最大值</p><h1 id="Q：环为什么能当成两个队列？"><a href="#Q：环为什么能当成两个队列？" class="headerlink" title="Q：环为什么能当成两个队列？"></a>Q：环为什么能当成两个队列？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: 不妨列举出所有可能出现的最优偷取情况来验证</span><br><span class="line">偷：  1</span><br><span class="line">不偷：0</span><br><span class="line">有一队列：[x, x, x, x, x, x, x, x, x]  n个元素</span><br><span class="line">0 ~ n-1队列最优解所有可能情况</span><br><span class="line">情况1：   [1, 0, x, x, x, x, 0, 1] 0</span><br><span class="line">情况2：   [1, 0, x, x, x, x, 1, 0] 0</span><br><span class="line">情况3：   [0, 1, x, x, x, x, 0, 1] 0</span><br><span class="line">情况4：   [0, 1, x, x, x, x, 1, 0] 0</span><br><span class="line">1 ~ n  队列最优解所有可能情况</span><br><span class="line">情况1：    0 [1, 0, x, x, x, x, 0, 1]</span><br><span class="line">情况2：    0 [1, 0, x, x, x, x, 1, 0]</span><br><span class="line">情况3：    0 [0, 1, x, x, x, x, 0, 1]</span><br><span class="line">情况4：    0 [0, 1, x, x, x, x, 1, 0]</span><br><span class="line">对于 0~n 队列，自己的最优解可能情况与上述所有情况取差集，得到自己的剩下最优解可能情况</span><br><span class="line">剩下情况： [1, 0, x, x, x, x, x, 0, 1]</span><br><span class="line">假设是 0~n 环结构，会发现，只有“剩下情况”不成立，其他情况均成立。</span><br><span class="line">也就是说：</span><br><span class="line">0~n 环最优解所有可能情况 = （0 ~ n-1）队列最优解所有可能情况 + （1 ~ n） 队列最优解所有可能情况</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,n-<span class="number">1</span>),rob(nums,<span class="number">1</span>, n));        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//动态规划 dp空间优化为first，second</span></span><br><span class="line">        <span class="keyword">int</span> first= nums[start];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(first, nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">2</span>; i&lt;end;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = second;</span><br><span class="line">           second = Math.max(second, first + nums[i]);</span><br><span class="line">           first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> second;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_b</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="动态规划" scheme="https://github.com/missionOdd/tags/动态规划/"/>
    
    <category term="环" scheme="https://github.com/missionOdd/tags/环/"/>
    
    <category term="队列" scheme="https://github.com/missionOdd/tags/队列/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组 | 二分法</title>
    <link href="https://github.com/missionOdd/2021/11/05/search-in-rotated-sorted-array/"/>
    <id>https://github.com/missionOdd/2021/11/05/search-in-rotated-sorted-array/</id>
    <published>2021-11-05T02:50:37.000Z</published>
    <updated>2022-02-08T01:49:21.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="search-in-rotated-sorted-array">the leetcode link</a></p><blockquote><p>搜索旋转排序数组<br>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br>示例 2：<br>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br>示例 3：<br>输入：nums = [1], target = 0<br>输出：-1</p><p>提示：<br>1 &lt;= nums.length &lt;= 5000<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;= target &lt;= 10^4</p><p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二分查找法</p><p>Q:翻转数组的样子是怎么样的？<br><strong>A:部分有序。</strong><br>Q:划分中值后，有什么规律？<br><strong>A:一定有一侧是有序的。</strong><br>Q:有序侧和无序侧对查找有何影响？<br><strong>A:有序侧能通过between比较方式，O(1)时间判断target是否存在；<br>无序侧仅靠自身不能以O(1)时间判断存在，要借助有序侧判断。</strong><br>因此，我们先判断哪一侧是有序侧，再通过between比较方式判断target在不在有序侧，不在有序侧则说明是在无序侧，不断缩小范围，反复判断。<br><figure class="image-box">                <img src="https://pic.leetcode-cn.com/1640451129-ZRVuIB-binary.png" alt="binary.png" title class>                <p>binary.png</p>            </figure></p><p>left 最左下标；right 最右下标；mid中间值下标；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">翻转情况1：</span><br><span class="line">条件：nums[left]&lt;=nums[mid]</span><br><span class="line">    图中target可能出现情况依次是：</span><br><span class="line">    1. nums[left]&lt;= target &lt;= nums[mid]     （左侧绿点，有序侧）</span><br><span class="line">    2. target &gt;= nums[mid]                  （右侧1绿点）</span><br><span class="line">    3. target &lt;= nums[left]                 （右侧2绿点）</span><br><span class="line">2,3合并为 !(nums[left]&lt;= target &lt;= nums[mid])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">翻转情况2：</span><br><span class="line">条件：nums[left]&gt; nums[mid]</span><br><span class="line">    图中target可能出现情况依次是：</span><br><span class="line">    4. target &gt;= nums[right]                （左侧1绿点）</span><br><span class="line">    5. target &lt;= nums[mid]                  （左侧2绿点）</span><br><span class="line">    6. nums[mid]&lt;= target &lt;= nums[right]    （右侧绿点，有序侧）</span><br><span class="line">4,5合并为 !(nums[mid]&lt;= target &lt;= nums[right])</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r =n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m =(l+r)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target)&#123; <span class="comment">//中值等于马上返回</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=nums[m])&#123;       <span class="comment">//翻转情况1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[l]==target)&#123; <span class="comment">//左值等于马上返回</span></span><br><span class="line">                    <span class="keyword">return</span> l;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l]&lt;target &amp;&amp; target&lt;nums[m])&#123;</span><br><span class="line">                    r=m-<span class="number">1</span>; <span class="comment">//target情况1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l=m+<span class="number">1</span>; <span class="comment">//target情况2,3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//翻转情况2</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[r]==target)&#123; <span class="comment">//右值等于马上返回</span></span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[m]&lt;target &amp;&amp; target&lt;nums[r])&#123;</span><br><span class="line">                    l=m+<span class="number">1</span>; <span class="comment">//target情况6</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r=m-<span class="number">1</span>; <span class="comment">//target情况4,5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;search-in-rotated-sorted-array&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;bl</summary>
      
    
    
    
    <category term="算法" scheme="https://github.com/missionOdd/categories/算法/"/>
    
    
    <category term="算法" scheme="https://github.com/missionOdd/tags/算法/"/>
    
    <category term="二分法" scheme="https://github.com/missionOdd/tags/二分法/"/>
    
  </entry>
  
  <entry>
    <title>Java深度复习，大杂烩整理笔记</title>
    <link href="https://github.com/missionOdd/2021/11/03/java-interview/"/>
    <id>https://github.com/missionOdd/2021/11/03/java-interview/</id>
    <published>2021-11-03T00:38:07.000Z</published>
    <updated>2022-02-07T19:07:26.713Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先感谢龙哥，向博主整理并提供资料，爱了~</strong></p><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><p>互联网的快速发展给了Oak机会 因为Oak的小巧 Sun公司首先推出了可以嵌入网页并且快速在网络上传输的Applet 非常适合网络传播</p><p>随后 各大公司竞相购买了Java使用许可证</p><p>申请注册商标时，发现Oak已经被人使用了，然后他们正在咖啡馆喝Java咖啡，灵机一动Oak语言改名为Java</p><p>Java吸收C++ 的很多优点 精简了很多东西（还摒弃了C++ 里难以理解的多继承、指针等概念） 当时被人称为 C++-</p><p>这一年的5月23日Java 1.0版本正式在SunWorld大会上发布 喊出了”Write Once，Run Anywhere”的口号 体现了其跨平台的特性</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>相信大家都具备基本的常识: 被final修饰的变量是不能够被改变的. 但是这里的”不能够被改变”对于不同的数据类型是有不同的含义的.</p><p>当final修饰的是一个基本数据类型数据时, 这个数据的值在初始化后将不能被改变; 当final修饰的是一个引用类型数据时, 也就是修饰一个对象时, 引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的.</p><h2 id="被final修饰的常量在编译阶段会被放入常量池中"><a href="#被final修饰的常量在编译阶段会被放入常量池中" class="headerlink" title="被final修饰的常量在编译阶段会被放入常量池中"></a>被final修饰的常量在编译阶段会被放入常量池中</h2><ul><li>final是用于定义常量的, 定义常量的好处是: 不需要重复地创建相同的变量. 而常量池是Java的一项重要技术, 由final修饰的变量会在编译阶段放入到调用类的常量池中.</li><li>请看下面这段演示代码. 这个示例是专门为了演示而设计的, 希望能方便大家理解这个知识点.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int n1 = 2019;          //普通变量</span><br><span class="line">    final int n2 = 2019;    //final修饰的变量</span><br><span class="line"></span><br><span class="line">    String s = &quot;20190522&quot;;  </span><br><span class="line">    String s1 = n1 + &quot;0522&quot;;//拼接字符串&quot;20190512&quot;</span><br><span class="line">    String s2 = n2 + &quot;0522&quot;;</span><br><span class="line"></span><br><span class="line">    System.out.println(s == s1);//false</span><br><span class="line">    System.out.println(s == s2);//true</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>首先要介绍一点: 整数-127-128是默认加载到常量池里的, 也就是说如果涉及到-127-128的整数操作, 默认在编译期就能确定整数的值. 所以这里我故意选用数字2019(大于128), 避免数字默认就存在常量池中.</p></blockquote><ul><li>上面的代码运作过程是这样的:</li><li>首先根据final修饰的常量会在编译期放到常量池的原则, n2会在编译期间放到常量池中.</li><li>然后s变量所对应的”20190522”字符串会放入到字符串常量池中, 并对外提供一个引用返回给s变量.</li><li>这时候拼接字符串s1, 由于n1对应的数据没有放入常量池中, 所以s1暂时无法拼接, 需要等程序加载运行时才能确定s1对应的值.</li><li>但在拼接s2的时候, 由于n2已经存在于常量池, 所以可以直接与”0522”拼接, 拼接出的结果是”20190522”. 这时系统会查看字符串常量池, 发现已经存在字符串20190522, 所以直接返回20190522的引用. 所以s2和s指向的是同一个引用, 这个引用指向的是字符串常量池中的20190522.</li></ul><ul><li>当程序执行时, n1变量才有具体的指向.</li><li>当拼接s1的时候, 会创建一个新的String类型对象, 也就是说字符串常量池中的20190522会对外提供一个新的引用.</li><li>所以当s1与s用”==”判断时, 由于对应的引用不同, 会返回false. 而s2和s指向同一个引用, 返回true.</li></ul><blockquote><p>总结: 这个例子想说明的是: 由于被final修饰的常量会在编译期进入常量池, 如果有涉及到该常量的操作, 很有可能在编译期就已经完成.</p></blockquote><pre><code>3. 探索: 为什么局部/匿名内部类在使用外部局部变量时, 只能使用被final修饰的变量?</code></pre><blockquote><p>提示: 在JDK1.8以后, 通过内部类访问外部局部变量时, 无需显式把外部局部变量声明为final. 不是说不需要声明为final了, 而是这件事情在编译期间系统帮我们做了. 但是我们还是有必要了解为什么要用final修饰外部局部变量.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Outter &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int a = 10;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>在上面这段代码, 如果没有给外部局部变量a加上final关键字, 是无法通过编译的. 可以试着想想: 当main方法已经执行完后, main方法的栈帧将会弹出, 如果此时Thread对象的生命周期还没有结束, 还没有执行打印语句的话, 将无法访问到外部的a变量.</li><li>那么为什么加上final关键字就能正常编译呢? 我们通过查看反编译代码看看内部类是怎样调用外部成员变量的.</li><li>我们可以先通过javac编译得到.class文件(用IDE编译也可以), 然后在命令行输入<code>javap -c .class文件的绝对路径</code>, 就能查看.class文件的反编译代码.  以上的Outter类经过编译产生两个.class文件, 分别是<code>Outter.class和Outter$1.class</code>, 也就是说内部类会单独编译成一个.class文件. 下面给出<code>Outter$1.class</code>的反编译代码.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Outter.java&quot;</span><br><span class="line">final class forTest.Outter$1 extends java.lang.Thread &#123;</span><br><span class="line">  forTest.Outter$1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public void run();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: bipush        10</span><br><span class="line">       5: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>定位到<code>run()</code>方法反编译代码中的第3行:</li><li><code>3: bipush 10</code></li><li>我们看到a的值在内部类的<code>run()</code>方法执行过程中是以压栈的形式存储到本地变量表中的, 也就是说在内部类打印变量a的值时, 这个变量a不是外部的局部变量a, 因为如果是外部局部变量的话, 应该会使用<code>load</code>指令加载变量的值. 也就是说系统以拷贝的形式把外部局部变量a复制了一个副本到内部类中, 内部类有一个变量指向外部变量a所指向的值.</li></ul><ul><li>但研究到这里好像和final的关系还不是很大, 不加final似乎也可以拷贝一份变量副本, 只不过不能在编译期知道变量的值罢了. 这时该思考一个新问题了: 现在我们知道内部类的变量a和外部局部变量a是两个完全不同的变量, 那么如果在执行run()方法的过程中, 内部类中修改了a变量所指向的值, 就会产生数据不一致问题.</li><li>正因为我们的原意是内部类和外部类访问的是同一个a变量, 所以当在内部类中使用外部局部变量的时候应该用final修饰局部变量, 这样局部变量a的值就永远不会改变, 也避免了数据不一致问题的发生.</li></ul><h2 id="String-、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String 、StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?"></a>String 、StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?</h2><p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><strong>线程安全性</strong></p><p>-=</p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p><p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><ol><li><p>操作1111少量的数据: 适用 <code>String</code></p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></p><p><img src="20180411092328691.png" alt="img"></p></li></ol><h2 id="HashCode（）与-equals"><a href="#HashCode（）与-equals" class="headerlink" title="HashCode（）与 equals"></a>HashCode（）与 equals</h2><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><p><strong>散列表存储</strong>的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>hashCode（）与 equals（）的相关规定</strong></p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的;</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true;</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的（不同的对象也可能产生相同的 hashcode，概率性问题）;</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h2 id="包装类Intege和Int的区别"><a href="#包装类Intege和Int的区别" class="headerlink" title="包装类Intege和Int的区别"></a>包装类Intege和Int的区别</h2><p><strong>二者的区别：</strong></p><p><strong>1. 声明方式不同：</strong></p><p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br> <strong>2. 存储方式及位置不同：</strong></p><p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br> <strong>3. 初始值不同：</strong></p><p>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</p><p><strong>4. 使用方式不同：</strong></p><p>基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</p><p><strong>5.函数传参</strong></p><p>有些函数传入参数需要object 类，这时可以传入包装类。</p><p>因为new生成的是两个对象，其内存地址不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>因为 Integer变量 指向的是 java 常量池 中的对象，<br>而 new Integer() 的变量指向 堆中 新建的对象，两者在<strong>内存中的地址</strong>不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>两个<code>Integer</code> 变量比较，如果两个变量的值在区间-128到127 之间，<strong>有缓存数组</strong>，则比较结果为true，如果两个变量的值  不在此区间，则比较结果为 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>因为包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>); <span class="comment">//自动拆箱为 int i=100; 此时，相当于两个int的比较</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>二者的区别：</strong></p><p><strong>1. 声明方式不同：</strong></p><p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br> <strong>2. 存储方式及位置不同：</strong></p><p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br> <strong>3. 初始值不同：</strong></p><p>基本类型的初始   </p><p><strong>自动装箱和自动拆箱</strong></p><p>Integer number = 10; //自动装箱</p><p>int count = number; //自动拆箱</p><ul><li><strong>什么情况会触发自动装箱操作？</strong><br>当基本类型赋值给包装类型引用时，会触发自动装箱操作，调用包装类型的valueOf()方法。</li><li><strong>什么情况会触发自动拆箱操作？</strong><br>当包装类型参与运算时会触发自动拆箱操作，调用包装类型对应的***Value()方法，例如Integer类为intValue()。Why？因为运算是基本数据类型要做的事情。</li></ul><hr><p><strong>Integer 缓存数组相关</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里的low是-128，high是127</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="comment">// 这里说只要在-128~127这个返回，就会返回已经创建好的对象，这些对象就是存放在一个cache数组里面的。所以只要i是一样的，那么返回的对象也就是同一个。</span></span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 如果执行这一步，那么说明只能创建一个新的对象了，创建新对象，那么就表示所返回的地址肯定不一样啦！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>]; <span class="comment">//定于数组的大小</span></span><br><span class="line"><span class="keyword">int</span> j = low;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length ; k ++) <span class="comment">//每个数组存储了一个Integer对象，对象的values的范围就是-128~127</span></span><br><span class="line">    cache[k] = <span class="keyword">new</span> Integer(j ++);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是下列情况也会返回false，因为在cache范围内的，没有new的话，3是会直接指向创建好的对象（cache数组），</span></span><br><span class="line"><span class="comment">//而b  new了以后就是一个新对象。</span></span><br><span class="line">Integer a = <span class="number">3</span>;</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer();</span><br><span class="line">sout(a == b) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>机制:<strong>将类的各个组成部分封装成其他的对象。</strong></p><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</li></ul><p><strong>反射是框架设计的灵魂</strong></p><p>在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。</p><p><strong>spring反射实现:</strong></p><p>Spring 通过 XML 配置模式装载 Bean 的过程：</p><ol><li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li><li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li><li>使用反射机制，根据这个字符串获得某个类的Class实例</li><li>动态配置实例的属性</li></ol><p>Spring这样做的好处是：</p><ul><li>不用每一次都要在代码里面去new或者做其他的事情</li><li>以后要改的话直接改配置文件，代码维护起来就很方便了</li><li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现</li></ul><p>1、可以在程序运行中，操作这些对象。</p><p>2、可以解耦，提高程序的可扩展性。</p><h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h2><figure class="image-box">                <img src="image-20210317024116844.png" alt="image-20210317024116844" title class>                <p>image-20210317024116844</p>            </figure><p><strong>一、若该对象所属的类没有加载，则先执行类加载</strong></p><p><strong>二、创建对象</strong></p><p><strong>1、在堆区分配对象需要的内存</strong></p><p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p><p><strong>2、对所有实例变量赋默认值</strong></p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p><p><strong>3、执行实例初始化代码</strong></p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p><p><strong>4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</strong></p><p>需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问</p><p>补充：</p><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p><p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。</p><p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p><h2 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h2><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>short：16位，最<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="noopener">大数据</a>存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>boolean：只有true和false两个取值。</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><strong>Collection：代表一组任意类型的对象，无下标、无序、不能重复。</strong></p><p><img src="1998506-20200830225616629-1434055405.png" alt="img"></p><p><strong>细节1：</strong></p><p>JDK1.7:ArrayList像饿汉式，直接创建一个初始容量为10的数组</p><p>JDK1.8:ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元 素时再创建一个始容量为10的数组</p><p><strong>细节2：</strong></p><p>ArrayList 源码中为何定义两个 Object 数组呢？EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 各有什么用处？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于默认大小的空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时扩容多少。</span></span><br><span class="line"><span class="comment"> * MARK:无参构造函数 使用该数组初始化 与EMPTY_ELEMENTDATA的区别主要是区分作用，用来减少空数组的存在，优化内存使用 1.8后的优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这两个类常量EE和DEE都是表示空数组，只是名字不一样而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array. 这里</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来看看add(E e)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当第一次调用add(E e)方法的时候，判读是不是无参构造函数创建的对象，如果是，</span></span><br><span class="line"><span class="comment">// 将DEFAULT_CAPACITY即10作为ArrayList的容量，此时minCapacity = 1</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他add方法如：add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)中都有ensureCapacityInternal(int minCapacity)方法，确保无参构成函数创建的实例al在添加第一个元素时，<em>最小的容量</em>是默认大小10。那有参构造函数创建的空实例al1、al2在通过add(E e)添加元素的时候是怎么样的呢？al1、al2容量增长是这样子的：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;6-&gt;9-&gt;13…，这样的增长是很慢的。具体扩容方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：两个类常量都是表示空数组，为什么要用两个呢？在Java7中只有一个类常量表示空数组，就是EE。Java8中添加了DEE代替了EE。</p><p>在Java7中ArrayList的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                          initialCapacity);</span><br><span class="line">   <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   elementData = c.toArray();</span><br><span class="line">   size = elementData.length;</span><br><span class="line">   <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">   <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全就是DEE代替了EE。那EE干什么去了，看一下构造函数中EE安排在哪里了？都是在判断容量为空的情况下，赋值给elementData。Java7中如果容量是0的话，会创建一个空数组，赋值给elementData:<code>this.elementData = new Object[initialCapacity];</code>、<code>elementData = Arrays.copyOf(elementData, size, Object[].class);</code>。如果一个应用中有很多这样ArrayList空实例的话，就会有很多的空数组，无疑EE是为了优化性能，所有ArrayList空实例都指向同一个空数组。问题解决。</p><h2 id="ArraysList（基于动态数组实现）"><a href="#ArraysList（基于动态数组实现）" class="headerlink" title="ArraysList（基于动态数组实现）"></a><strong>ArraysList（基于动态数组实现）</strong></h2><blockquote><p>ArrayList的底层是基于一个动态数组实现的，LinkedList的底层是基于一个双向链表实现的，</p><p>ArrayList对象创建时有一个空参构造器还有一个给定数组容量的构造器，如果不规定数组容量，则默认是0。</p><p>当往数组里添加元素，数组容量将会变为10，数组元素数量超过了10，将会自动扩容，通过一个位运算将现在的容量右移一位再加上现在的容量，变成原数组的1.5倍，JDK1.7之前是1.5+1，然后创建一个新的数组，将原数组的复制进新数组，从而实现了动态扩容。</p><p>有一个细节是他的底层源码定义了两个空数组，一个是默认空数组，一个人创建对象时主动传0，也是空数组。</p><p>默认容量大小为10 （注意：集合中没有任何元素时，它的容量为0，添加一个元素以后，容量变成10，但数组size=1）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>扩容机制(每次扩容为原来的1.5倍)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//原来的数组大小加上 原来数组大小右移一位运算</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">//将新数组复制</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用来存放元素的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p><strong>add()方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题四：ArrayList 的 add 操作如何优化？</strong></p><blockquote><p>扩容需要移动数据，非常影响性能。那么优化的重点就是尽量避免 ArrayList 内部进行内部扩容。对于add 操作，如果添加的元素个数已知，最好使用指定初始容量的构造方法创建 ArrayList 实例或者在添加元素之前执行ensureCapacity 方法确保有足够的容量来存放add 操作的元素。</p></blockquote><p><strong>为什么不取扩容固定容量呢？</strong><br>扩容的目的需要综合考虑这两种情况：</p><ol><li>扩容容量不能太小，防止频繁扩容，频繁申请内存空间 + 数组频繁复制</li><li>扩容容量不能太大，需要充分利用空间，避免浪费过多空间；</li></ol><p>而扩容固定容量，很难决定到底取多少值合适，取任何具体值都不太合适，因为所需数据量往往由数组的客户端在具体应用场景决定。</p><p>因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</p><h2 id="LinkList（双向链表）"><a href="#LinkList（双向链表）" class="headerlink" title="LinkList（双向链表）"></a><strong>LinkList</strong>（双向链表）</h2><blockquote><p>LinkList是双向链表，链表的特点就是插入、删除操作时间复杂度为1，而查找的时间复制度为n。</p><p>增删速度相对于数组快，也不需要扩容操作，而查找、修改（需要先查找）速度相对慢一些。</p><p>LinkList也是非线程安全的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add()</strong></p><p>普通增加，就是在链表尾部添加数据。</p><p>可以看到源码，把 <strong>last</strong> 链表最后一个节点，先用 <strong>l</strong> 保存，然后 <strong>last</strong> 指向 <strong>newNode</strong> 新节点。</p><p>判断如果链表为空，那 <strong>first</strong> 头结点指向 <strong>newNode</strong>。</p><p>否则之前保存的最后一个节点 <strong>l</strong> 的 <strong>next</strong> 后指针指向 <strong>newNode</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeSet-有序不可重复"><a href="#TreeSet-有序不可重复" class="headerlink" title="TreeSet(有序不可重复)"></a>TreeSet(有序不可重复)</h2><p><strong>特点</strong></p><ul><li>基于排列顺序实现元素不重复</li><li>实现SortedSet接口，对集合元素自动排序</li><li>元素对象的类型必须实现<strong>Comparable接口</strong>，指定排序规则</li><li>通过<strong>CompareTo</strong>方法确定是否为重复元素</li></ul><p><strong>存储结构：红黑树</strong></p><p>创建集合 <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;()</code></p><p>添加元素 <code>treeSet.add();</code></p><p>删除元素 <code>treeSet.remove();</code></p><p>遍历 1. 增强for 2. 迭代器</p><p>判断 <code>treeSet.contains();</code></p><p>补充：TreeSet集合的使用</p><p>Comparator 实现定制比较（比较器）</p><p>Comparable 可比较的</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>用于存储任意键值对（key - value）</p><p>键：无序、无下标、不允许重复（唯一）</p><p>值：无序、无下标、允许重复</p></blockquote><p><strong>Map的遍历</strong></p><p>得到一个Map的Key集合，装入Set集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 遍历</span></span><br><span class="line"><span class="comment">// 3.1 使用KeySet()</span></span><br><span class="line"><span class="comment">//Set&lt;String&gt; keyset = map.keySet(); // 所有Key的set集合</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keyset)&#123;</span><br><span class="line">  sout(key + <span class="string">"---"</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map.entrySet()遍历的效率更高，因为可以一次获取到键值对，而keySet拿到以后可以获取到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 使用entrySet()</span></span><br><span class="line"><span class="comment">//Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entries)&#123;</span><br><span class="line">  sout(entry.getKey() + <span class="string">"---"</span> + entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原码分析总结：</p><ol><li>HashMap刚创建时，table是null，节省空间，当添加第一个元素时，table容量调整为16</li><li>当元素个数大于阈值（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li><li>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64时，会调整成红黑树，目的是提高效率</li><li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li><li>jdk1.8 以前，链表时头插入，之后为尾插入</li></ol><h1 id="Hash大礼包"><a href="#Hash大礼包" class="headerlink" title="Hash大礼包"></a>Hash大礼包</h1><p><strong>源码分析总结：</strong></p><ol><li>HashMap刚创建时，table是null，节省空间，当添加第一个元素时，table容量调整为16</li><li>当元素个数大于阈值（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li><li><strong>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64时，会调整成红黑树，目的是提高效率</strong></li><li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li><li>jdk1.8 以前，链表时头插入，之后为尾插入</li></ol><p><strong>负载因子</strong></p><p>Q：为什么负载因子是0.75？</p><blockquote><p>当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p></blockquote><p>jdk官方文档给出了一份计算结果：同一个哈希桶中哈希碰撞生成链表长度地概率。数据中哈希桶中有8个元素的概率低至0.000006%，所以0.75这个负载因子比较合适。</p><p><img src="v2-4e6b224503e39e90b9419946ba2f7166_720w.jpg" alt="img" style="zoom:67%;"></p><p><img src="v2-2936da1806372ffe26efa072de7da934_720w.jpg" alt="img" style="zoom:67%;"></p><h2 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h2><h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><p><img src="v2-f43eafe4e5d4d7616f885335fc185f3d_720w.jpg" alt="img" style="zoom:67%;"></p><h2 id="put方法流程"><a href="#put方法流程" class="headerlink" title="put方法流程"></a>put方法流程</h2><p>1.7：头插法</p><p>1.8：尾插法</p><p>Q：为什么1.8改成尾插法？因为1.8引入了红黑树，尾插法会遍历整个链表，顺带地知道当前链表长度，判断是否需要树化。</p><p><img src="v2-bb8ee0ee1c0cc51537ae5f8e02038102_720w.jpg" alt="img" style="zoom: 80%;"></p><p>多线程下HashMap put方法可能形成环形链表</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h2><blockquote><p>简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)</p></blockquote><p>Q：为什么要有红黑树？</p><p>红黑树的话是一个平衡搜索树，在大数据量下查找效率比单条的链表更高。链表需要遍历，红黑树采用的是二分查找的思想进行检索。</p><p><strong>特征：</strong></p><p>（1）每个节点只有两种颜色：红色和黑色。</p><p>（2）根节点是黑色的。</p><p>（3）每个叶子节点（NIL）都是黑色的空节点。</p><p>（4）从根节点到叶子节点，不会出现两个连续的红色节点。（<strong>红色的节点不能挨在一起</strong>）</p><p>（5）从任何一个节点出发，到叶子节点，这条路径上都有相同数目的黑色节点。</p><p><img src="image-20210327014042927.png" alt="image-20210327014042927" style="zoom:67%;"></p><p><strong>颜色变换规则</strong></p><p>旋转和变换规则：所有插入点默认为红色。</p><figure class="image-box">                <img src="image-20210328005814087.png" alt="image-20210328005814087" title class>                <p>image-20210328005814087</p>            </figure><p><strong>左旋规则</strong></p><figure class="image-box">                <img src="image-20210328005737527.png" alt="image-20210328005737527" title class>                <p>image-20210328005737527</p>            </figure><p><strong>右旋规则</strong></p><figure class="image-box">                <img src="image-20210328005635454.png" alt="image-20210328005635454" title class>                <p>image-20210328005635454</p>            </figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p> <strong>并发编程的三个重要特性</strong></p><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><p><strong>线程和进程的区别</strong></p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p><strong>进程是一个可执行的程序，是系统资源分配的基本单位。</strong>线程是进程内部相对独立的可执行单元，是操作系统进行任务调度的基本单位。</p><p>java没有权限开启线程，通过本地方法调用c++，java无法直接操作硬件</p><p>并发（多线程操作同一个资源）</p><ul><li>CPU一核，模拟出来多个线程</li></ul><p>并行（多个线程可以同时执行）</p><ul><li><p>CPU多核，多个线程可以同时执行</p><p>一、进程的并行和并发</p><p><strong>并行:</strong> 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p><p><strong>并发:</strong> 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p></li></ul><p>二、并行和并发的区别</p><p>   并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。</p><p>   并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p><hr><p><strong>创建线程的几种方法</strong></p><p>继承<strong>Thread类</strong>，重写run()方法，利用Thread.start()启动线程。</p><p>实现<strong>Runnable接口</strong>，重写run()方法，通过new Thread(Runnable a)创建线程，并调用start()方法启动线程。</p><p>通过<strong>callable</strong>和futuretask创建线程，实现callable接口，重写call方法，利用future对象包装callable实例，通过new Thread方法创建线程。</p><blockquote><p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大：call()方法可以有返回值，可以声明抛出异常。</p></blockquote><p>通过线程池创建线程。</p><hr><p><strong>多线程的优缺点</strong></p><p>优点：</p><ul><li>充分利用多核多cpu的资源，提高cpu的使用率，提高了程序的运行效率。</li></ul><p>缺点：</p><ul><li>线程数过多会影响性能，操作系统会在线程切换之间增加内存的开销。</li><li>存在线程同步和安全问题</li><li>可能产生死锁</li><li>增加了开发人员的技术难度</li></ul><hr><p><strong>线程有几种状态</strong></p><p>一共五种状态：分别是新建，就绪，运行，阻塞和死亡状态。详细见下图：</p><figure class="image-box">                <img src="d782ed346ccb4839bb148884b1745566~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li><strong>新建状态：</strong>当用new创建一个线程时，线程还没有开始运行，此时线程处于新建状态。处于新建状态的线程还没有开始运行。</li><li><strong>就绪状态：</strong>一个新建的线程并不会自动运行，要执行线程，要手动调用线程的start()方法，当start()方法返回后，线程就处于就绪状态，等待处理器的调度。</li><li><strong>运行状态：</strong>当线程获取了CPU的时间后，它才进入运行状态，真正的执行run()方法里的内容。</li><li><strong>阻塞状态：</strong>线程运行过程中，可能因为各种原因进入阻塞状态：比如调用sleep()进入休眠状态；调用一个在IO上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；等待获取锁被阻塞；线程在等待其他的触发条件。所谓的阻塞状态就是正在运行的线程没有运行结束，暂时让出CPU资源。</li><li><strong>死亡状态：</strong>有两个原因会导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法而导致线程猝死。</li></ul><hr><p><strong>经典题：一个线程OOM了，其他线程是否还能运行？</strong></p><p>答案是还能运行。虽然说堆是线程共享的区域，一个线程堆抛出OOM异常，你可能会觉得其他线程也会抛出OOM异常。但其实不然，<strong>当一个线程抛出OOM异常后，它所占据的内存会全部释放掉</strong>，从而不会影响其他线程的运行。 另外如果主线程异常了，子线程还能运行吗？这个问题也是可以运行的。线程不像进程，一个进程之间的线程之间是没有父子之分的，都是平级关系。即线程都是一样的，退出了一个不会影响另外一个。</p><p><strong>sleep和wait方法的区别？</strong></p><ul><li>wait只能在synchronized中调用，属于对象级别的方法，sleep不需要，属于Thread的方法</li><li>调用wait方法会释放锁，sleep不会释放锁</li><li>wait超时之后线程进入就绪状态，等待获取cpu继续执行。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><blockquote><p>volatile作用是在并发编程中保证共享变量的可见性，同时防止这个JVM指令重排。每个线程在运行过程中都有自己的工作内存。因为JMM模型主要是是线程各自的工作内存和主内存。线程运行的时候会将主内存的变量读到工作内存，修改完毕后再写入主存。</p><p>volatile关键字修饰的变量值一经修改会立即写入主存，假设有AB两个线程，并且B线程操作volatile修饰的变量的时候，会导致A线程工作内存中的缓存volatile变量无效，A线程发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值，从而保证他的可见性。其中涉及到CPU总线嗅探机制和缓存一致性协议。工作内存和主存之间有一个总线，总线相当于工作内存和主存数据传输的主干道，当其中一个工作内存中的值被修改了并且写回内存以后，其他处理器会被通知，使得各自的缓存失效，线程就必须从主存中去读取最新的数据。</p><p>volatile第二个呢就是防止JVM指令重排，因为对程序的优化，JVM和CPU会对指令进行重新排序，但不会影响最后的结算结果，如果指令中有对volatile变量进行操作的指令，那么这条指令相当于一个内存屏障，在它之前的指令和在他之后的指令不允许交换位置，保证到达这条指令前，在他之前的指令已经全部完成。</p></blockquote><p>那么线程A在运行的时候，会将变量的值拷贝一份放在自己的工作内存当中。</p><p>那么当线程B更改了变量的值之后，但是还没来得及写入主存当中，线程B转去做其他事情了，那么线程A由于不知道线程B对变量的更改，因此还会一直循环下去。</p><p><strong>volatile的实现原理</strong></p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内部的数据读到内部缓存后在进行操作，但操作完之后不知道什么时候会写入内存。</p><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条<strong>Lock前缀的指令</strong>，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p><p><strong>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏</strong>），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><hr><p><strong>指令重排</strong></p><p>Q：为什么产生指令重排？ CUP的乱序执行</p><p>编译器：不进行指令重排</p><p>运行期：DCL（懒汉式双重锁检验）+volatile</p><p><strong>内存屏障</strong></p><p><strong>happens-before</strong></p><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条<strong>Lock前缀的指令</strong>，将这个变量所在缓存行的数据写会到系统内存。</p><p><strong>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏</strong>），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><figure class="image-box">                <img src="image-20210317010023428.png" alt="image-20210317010023428" title class>                <p>image-20210317010023428</p>            </figure><p>Java内存模型 (JMM)</p><p><img src="image-20210314184754409.png" alt="image-20210314184754409" style="zoom: 67%;"></p><p><strong>总线嗅探机制+缓存一致性协议</strong></p><figure class="image-box">                <img src="1472972-20200710225123177-483858511.png" alt="img" title class>                <p>img</p>            </figure><p>工作内存 = <strong>虚拟机栈</strong>    主内存 = 堆+ 方法区</p><p><img src="image-20210314185428706.png" alt="image-20210314185428706"></p><p>volatileの读：每一次都从<strong>主存</strong>中获取数据，然后写入<strong>虚拟机栈（工作内存）</strong> read-load</p><p>volatileの写：</p><p><img src="image-20210314190329333.png" alt="image-20210314190329333" style="zoom: 67%;"></p><p>线程和主存之间存在一条总线，加入关键字以后机会<strong>缓存一致性协议</strong>，监听共享变量。</p><p>DCL双重锁校验</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p> 并发编程的三个重要特性</p><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h3><p>对synchronized的理解?</p><blockquote><p>synchronized在jdk1.6属于Java中的重量级锁，同时也是一种互斥锁，重量级锁是因为需要依靠操作系统来实现互斥锁的，这导致大量上下文切换，消耗大量CPU，影响性能。在JDK1.6以后逐步地对sychronized进行了优化，加入了锁升级的机制，从而不用每次调用sychronized都直接上重量级锁。sychronized的实现依靠的每个对象头中的 mark word的所指向的monitor，monitor中从存储了关联对象的owner、waitSet和EntryList，当A线程竞争</p></blockquote><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有几个关键字段：</p><p><strong>_owner：</strong>指向持有ObjectMonitor对象的线程<br><strong>_WaitSet：</strong>存放处于wait状态的线程队列<br><strong>_EntryList：</strong>存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p><p><strong>Synchronized 的具体用法</strong></p><table><thead><tr><th>修饰位置</th><th>上锁对象</th></tr></thead><tbody><tr><td>普通方法/this关键字</td><td>该类的实例对象</td></tr><tr><td>同步代码块/.class</td><td>整个类对象</td></tr></tbody></table><ul><li><strong>Synchronized修饰普通方法时，锁对象默认为this,锁住的是该类的实例对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Synchronized修饰静态方法时，锁住的类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testStaticMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>同步代码块,this时，锁住的是类的实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>同步代码块，Demo.class,锁住的是类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Demo<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Synchroinzed 锁的实现原理</strong>、</p><p>每个对象的对象头中有一个字段指向monitor对象，这个monitor是每个对象都有的。</p><p><img src="e691866125e34425820f025eb56b5c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="对象头" style="zoom:33%;"></p><p><strong>mark word</strong></p><p><img src="b75c46c4d41d40a89035a90eb6f2716d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" style="zoom: 33%;"></p><blockquote><p>biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。<br><strong>age：</strong>4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为15的原因。<br><strong>identity_hashcode：</strong>25位的对象标识Hash码，采用延迟加载技术。调用<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。<br><strong>thread：</strong>持有偏向锁的线程ID。<br>epoch：偏向时间戳。<br>ptr_to_lock_record：指向栈中锁记录的指针。<br><strong>ptr_to_heavyweight_monitor：</strong>指向管程Monitor的指针。</p></blockquote><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有几个关键字段：</p><p><strong>_owner：</strong>指向持有ObjectMonitor对象的线程<br><strong>_WaitSet：</strong>存放处于wait状态的线程队列<br><strong>_EntryList：</strong>存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p><p><strong>JVM 对 synchronized 的处理</strong><br>上面了解了 monitor 的机制，那虚拟机是如何将 synchronized 和 monitor 关联起来的呢？分两种情况：<br>如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。<br>如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//反编译后的结果</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header = <span class="literal">NULL</span>;</span><br><span class="line">  _count = <span class="number">0</span>; <span class="comment">// 线程获取锁的次数</span></span><br><span class="line">  _waiters = <span class="number">0</span>,</span><br><span class="line">  _recursions = <span class="number">0</span>; <span class="comment">// 递归，锁的重入次数</span></span><br><span class="line">  _object = <span class="literal">NULL</span>;</span><br><span class="line">  _owner = <span class="literal">NULL</span>;   <span class="comment">// 持有monitor的线程</span></span><br><span class="line">  _WaitSet = <span class="literal">NULL</span>; <span class="comment">// 处于 wait 状态, 即等待monitor的线程，会被加入到 _WaitSet</span></span><br><span class="line">  _WaitSetLock = <span class="number">0</span> ; <span class="comment">// 自旋</span></span><br><span class="line">   _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">   _SpinFreq = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>如图所示 [<figure class="image-box">                <img src="https://imgchr.com/i/y4j5pF" alt="y4j5pF.jpg](872e78995be24c90b4e8d8aafdf89360~tplv-k3u1fbpfcp-zoom-1.image)" title class>                <p>y4j5pF.jpg](872e78995be24c90b4e8d8aafdf89360~tplv-k3u1fbpfcp-zoom-1.image)</p>            </figure></strong></p><ol><li><strong>当Thread1、Thread2访问同步代码块时Thread1,Thread2会先进入ObjectMonitor的EntryList中等待；</strong></li><li><strong>接下来当Thread1获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，Thread1申请 Mutex 成功，则持 有该 Mutex，其它线程将无法获取到该 Mutex。ObjectMonitor的owner属性指向Thread1，EntryList中还剩Thread2在等待</strong></li><li><strong>如果Thread1调用了wait()方法，就会释放当前持有的 Mutex，Thread1进入WaitSet并释放锁，ObjectMonitor的owner属性等于null。</strong></li></ol><p><strong>如果Thread1执行完毕，也会释放所持有的Mutex。 4. Thread2获取到锁进入同步代码块，ObjectMonitor owner属性指向Thread2，任务执行完退出同步代码之前调用notifyAll， Thread1被唤醒，从WaitSet转到EntryList中等待锁，Thread2退出同步代码块，ObjectMonitor owner属性为null；</strong></p><p><strong>所以，Monitor依赖操作系统实现，存在用户态和内核态的切换，增加了性能开销。</strong></p><p><strong>说说 synchronized 关键字和 volatile 关键字的区别</strong></p><p><strong><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</strong></p><ul><li><strong>volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比 synchronized 关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</strong></li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li><li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h3><blockquote><p>    <strong>CAS属于乐观锁，乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</strong></p></blockquote><p><strong>原理：</strong></p><p><strong>CAS全称是Compare and Swap，即比较并交换，是通过原子指令来实现多线程的同步功能，将获取存储在内存地址的原值和指定的内存地址进行比较，只有当他们相等时，交换指定的预期值和内存中的值，这个操作是原子操作，若不相等，则重新获取存储在内存地址的原值。</strong></p><hr><p><strong>CAS的流程</strong></p><p>     <strong>CAS是一种无锁算法，有3个关键操作数，内存地址，旧的内存中预期值，要更新的新值，当内存值和旧的内存中预期值相等时，将内存中的值更新为新值。</strong></p><p><strong>首先看一看AtomicInteger当中常用的自增方法 incrementAndGet：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：</span><br><span class="line"><span class="number">1</span>.获取当前值。</span><br><span class="line"><span class="number">2</span>.当前值+<span class="number">1</span>，计算出目标值。</span><br><span class="line"><span class="number">3</span>.进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤。</span><br></pre></td></tr></table></figure><p><strong>那CAS有什么缺陷吗？</strong></p><p><strong>我：CAS虽然高效的解决了原子问题，但是还是存在一些缺陷的，主要体现在三个方面：</strong><br> <strong>1、循环时间太长：如果自旋CAS长时间不成功，则会给CPU带来非常大的开销，在JUC中，有些地方就会限制CAS自旋的次数。</strong><br> <strong>2、只能保证一个共享变量原子操作：看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了。或者把多个变量整成一个变量也可以用CAS。</strong><br> <strong>3、ABA问题：CAS需要检查操作值有没有发生改变，如果没有发生改变则更新，但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题的解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A-&gt;B-&gt;A，变成1A-&gt;2B-&gt;3A。例如原子类中AtomicInteger会发生ABA问题，使用AtomicStampedReference可以解决ABA问题。</strong></p><p><strong>PS：总结1、长时间自旋不成功，会给CPU带来非常大的开销。</strong></p><p><strong>2、只能保证一个共享变量的原子操作，多个共享变量需要用到锁。</strong></p><p><strong>3、ABA问题：CAS对操作的值进行检查，检查它是否有被修改过。但有这么一种情况，它被别的县城改过了，但是又改回去了，此时依旧当前线程的期望值，但是实质上它被改动过了。这样就对当前线程造成了一种欺骗。用AtomicStampedReference可以解决ABA为题（即在变量上加上一个版本号）</strong></p><hr><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><blockquote><p><em>其实一句话总结：<strong>AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。</strong></em></p><p><strong><em>它包含了state变量、加锁线程、等待队列等并发中的核心组件。</em></strong></p></blockquote><p><strong>AQS 全称 AbstractQueuedSynchronizer。AQS 中有两个重要的成员：</strong><br><strong>成员变量 state。用于表示锁现在的状态，用 volatile 修饰，保证内存一致性。同时所用对 state 的操作都是使用 CAS 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。</strong><br><strong>还有一个双向链表，链表除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。</strong><br><strong>下面以 ReentrantLock 非公平锁的代码看看 AQS 的原理。</strong></p><p><strong>AbstractQueuedSynchronizer，抽象队列同步器</strong></p><p>如图：</p><p>ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。</p><figure class="image-box">                <img src="v2-d8386b404a820482d3080939e434d4a9_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>1、当线程1 CAS成功获取锁时</strong></p><figure class="image-box">                <img src="v2-f5d569e61d5aef81ab00f43c19586dd2_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>2、线程2来尝试获取锁 调用tryAcquire（CAS原理）（尝试将state=0变为1） 原理CAS  发现state并不等于0</strong></p><figure class="image-box">                <img src="v2-3985f7789b288baa2ac33091f2361d35_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>3、加锁失败，线程2进入等待队列</strong> 【队列是AQS内部的队列，专门存放获取锁失败的线程】</p><figure class="image-box">                <img src="v2-649ab6887475f84e6951469136b788e7_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！<strong>他释放锁的过程非常的简单</strong>，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！</p><p><strong>CLH队列</strong></p><p>QS通过内置的FIFO(first-in-first-out)同步队列来控制获取共享资源的线程。CLH队列是FIFO的双端双向队列，AQS的同步机制就是依靠这个CLH队列完成的。队列的每个节点，都有前驱节点指针和后继节点指针。</p><blockquote><p><strong>头结点并不在阻塞队列内！</strong></p></blockquote><figure class="image-box">                <img src="16f922162108de3b" alt="AQS-Node.jpg" title class>                <p>AQS-Node.jpg</p>            </figure><hr><h3 id="ReentrantLock-Lock锁"><a href="#ReentrantLock-Lock锁" class="headerlink" title="ReentrantLock Lock锁"></a>ReentrantLock <strong>Lock锁</strong></h3><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h3><p><strong>对象的组成</strong></p><p><strong><figure class="image-box">                <img src="e691866125e34425820f025eb56b5c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="对象头" title class>                <p>对象头</p>            </figure></strong></p><p> <strong>实例变量</strong></p><p>  <strong>即实例数据。存放类的属性数据信息，包括父类的属性信息。</strong></p><p><strong>对其填充why?</strong></p><p> <strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。   如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></p><p><strong>对象头中数据（mark word 和 类型指针 组成）</strong></p><p><strong>mark word</strong></p><p> <strong>即标记字段。用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。   Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit</strong></p><p><strong><figure class="image-box">                <img src="b75c46c4d41d40a89035a90eb6f2716d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></strong></p><p><strong>锁升级的过程</strong></p><blockquote><p><strong>synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁</strong></p><p><strong>无锁，偏向锁，轻量级锁（CAS）都是在用户空间完成</strong></p><p><strong>重量级锁是需要向内核申请的</strong></p></blockquote><p><strong>当线程A启动后，获得了对象的锁，此时线程A的线程ID将保存到对象的对象头中，对象头中的偏向锁标志位变为1。此时如果第二个线程B想访问这个对象，线程A、B之间就存在一个竞争的关系，但是此时偏向锁是偏向于线程A的，即A是优先的，偏向锁将会升级为轻量级锁，以此来保证持有对象锁的的线程A运行。此时线程B将会进行CAS，CAS也叫做自旋锁，B会去检查对象的锁是否还是属于A的，如果是，那B将会继续自选，直到对象锁被释放，B马上就会获取对象的锁。但是假如长时间无法获取到对象的锁，CAS是会消耗CPU的性能的，尤其当许多个线程竞争同一个对象的锁时，CPU资源占用会大大提高，此时锁将会再次升级，对象锁将升级为重量级锁。此时，所有竞争的线程将进入阻塞队列，等待cup的调度。</strong></p><p><strong><figure class="image-box">                <img src="image-20210313015823511.png" alt="image-20210313015823511" title class>                <p>image-20210313015823511</p>            </figure></strong></p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title=".公平锁 VS 非公平锁"></a><strong>.公平锁 VS 非公平锁</strong></h3><blockquote><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></blockquote><p><strong>公平锁：tryAcquire（）</strong>:</p><p>//假如tryacquire方法返回true表示为获取锁成功,&amp;&amp; 后面的表达式不会执行</p><p>//假如tryAcqyire方法返回false表示获取锁失败,进入等待队列并执行selfInterrupt() 中断当前线程</p><p><strong>hasQueuedPredecessors（）</strong>：判断队列中是否存在等待的线程</p><blockquote><p><code>hasQueuedPredecessors</code>就是<strong>判断锁是否公平的关键</strong>，如果在当前线程之前还有排队的线程就返回true，这时候当前线程就不会去竞争锁。从而保证了锁的公平性。</p></blockquote><figure class="image-box">                <img src="image-20210316020031393.png" alt="image-20210316020031393" title class>                <p>image-20210316020031393</p>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;<span class="comment">//这个方法是父类AQS的方法    acquire(1);&#125;public final void acquire(int arg) &#123;//上面有提过 tryAcquire 方法,尝试获取锁,需要子类实现    //当前类为FairSync 所以调用的 FairSync.tryAcquire 方法    //假如tryacquire方法返回true表示为获取锁成功,&amp;&amp; 后面的表达式不会执行    //假如tryAcqyire方法返回false表示获取锁失败,进入等待队列并执行selfInterrupt 中断当前线程    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;// java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire(int) 参数值为1protected final boolean tryAcquire(int acquires) &#123;//获取当前线程        final Thread current = Thread.currentThread();        //获取AQS.state的值,state 就是用来判断是否存在线程获取到锁        int c = getState();        //假如为0 表示 现在没有线程获取到锁        if (c == 0) &#123;        //hasQueuedPredecessors 方法 判断等待队列中是否存在 等待的线程 (因为是公平锁)            //compareAndSetState CAS 操作设置 state 的值            //setExclusiveOwnerThread 设置当前获取锁的线程为 当前线程           //所以  这个 if 中的表达式的意思 是:             //等待队列中没有线程在等待 并 CAS 操作成功 并且设置线程成功 则返回 true  表示获取锁成功            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 假如 state 的值不为 0 表示存在线程争取这个锁        //判断争取到锁的线程是否当前线程 (可重入锁)        else if (current == getExclusiveOwnerThread()) &#123;        // 假如是 累加 state的值,表示重入次数            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        &#125;        return false;    &#125;</span></span><br></pre></td></tr></table></figure><h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p>可重入锁的字面意思是“可以重新进入的锁”，即<strong>允许同一个线程多次获取同一把锁</strong>。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是<strong>可重入锁</strong>（因为这个原因可重入锁也叫做<strong>递归锁</strong>）<strong>。</strong></p><p>Java里只要以Reentrant开头命名的锁都是可重入锁，而且<strong>JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。</strong></p><p>getExclusiveOwnerThread()：获取线程当前专属拥有者</p><p><strong>run和start()的区别：</strong></p><blockquote><p><strong>run 方法是执行任务的地方，它就是一个普通的方法，可以多次被调用，只调用 run 方法并不会启动一个线程。而 start 方法才会真正的启动线程，start 方法会调用到 native 底层方法，然后才会调用 run 方法执行任务。start 方法只能执行一次，执行多次会抛出异常。</strong></p></blockquote><p><strong>为什么要有锁升级这个过程呢？</strong></p><blockquote><p><strong>那为什么不直接上来就上<code>轻量级锁</code>或者<code>重量级锁</code>呢？</strong><br><strong>这是因为当线程执行到被锁住的代码块时，锁的获取是会消耗资源的。<code>轻量级锁</code>的实现原理是<code>CAS自旋</code>，就像while loop 一样，消耗CPU资源。<code>重量级锁</code>需要<code>操作系统</code>的<code>调度机制</code>接入，也会消耗资源。而大部分时候只有一个线程默默的干活，并不存在锁竞争，每次这个孤单的线程执行一块上了轻量级锁锁住的代码时需要过一遍CAS，执行一块重量级锁锁住的代码时需要等操作系统的发令，自己和自己竞争一下，这效率就有点低了。</strong><br><strong>当一个对象还没有上锁时，<code>偏向锁</code>会直接来往markword里贴上线程ID，表示锁住了，没有CAS自旋和操作系统调用这些耗时的锁竞争机制，提高了性能。 偏向锁假定了这对象还没锁，所以偏向锁又叫做<code>乐观锁</code>。</strong></p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h2><p><strong>什么叫死锁？</strong></p><p><strong>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，他们都将无法进行运行下去。</strong></p><p><strong>死锁产生的必要条件</strong></p><ul><li><strong>互斥条件：进程要求对所分配的资源在一段时间内只能由一个进程所拥有。</strong></li><li><strong>不可剥夺条件：资源在进程未使用完成之前，不能被其他进程夺走，除非是主动释放。</strong></li><li><strong>请求和保持条件：进程已经保持了至少一个资源，但是又申请新的资源，但是该资源已经被其他进程所拥有，这就陷入了死循环。</strong></li><li><strong>循环等待条件：总的来说，就是进程资源循环等待，A拥有资源1，B拥有资源2，同时A在没有释放资源1的情况下又去申请资源2，B在没有释放资源2的情况下又去申请资源1。</strong></li></ul><p><strong>如何避免死锁</strong></p><ul><li><strong>加锁顺序要合理：线程要按照一定的顺序加锁</strong></li><li><strong>加锁时限要适当：线程尝试获取锁的时候要加上一定时限，超时就要放弃锁请求，并释放自己占有的锁。不能无限等待。</strong></li><li><strong>死锁检测</strong></li></ul><p><strong>细节</strong></p><p>死锁排查</p><h2 id="ArrayBlockingQueue（阻塞队列）"><a href="#ArrayBlockingQueue（阻塞队列）" class="headerlink" title="ArrayBlockingQueue（阻塞队列）"></a><strong>ArrayBlockingQueue</strong>（阻塞队列）</h2><p><strong><figure class="image-box">                <img src="image-20210313044739282.png" alt="image-20210313044739282" title class>                <p>image-20210313044739282</p>            </figure></strong></p><p><img src="e5bdc645374f436fbccf86ffecd2e149~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>SynchronousQueue：同步队列</strong></p><p>不存储元素put元素以后必须take取出来，否则不能put进去元素。</p><p>任意时间只能一个线程操作。</p><h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，<strong>信号量控制的是线程并发的数量</strong>。</p><p>public Semaphore(int permits)<br> 其中参数permits就是允许同时运行的线程数目;</p><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore</p><p>主要有acquire()、release()这两个方法</p><p><strong>acquire()：</strong>当前线程调用该方法的目的是希望获取一个信号量资源。如果当前信号量个数大于0,则当前信号量的计数会减1，然后该方法直接返回。<strong>否则如果当前信号量个数等0，则当前线程会被放入AQS的阻塞队列</strong>。</p><p><strong>release()</strong>：<strong>该方法的作用是把当前Semaphore对象的信号量值增加1</strong>，如果当前有线程因为调用aquire方法被阻塞而被放入了AQS的阻塞 队列，则会根据公平策略选择一个信号量个数能被满足的线程进行激活， 激活的线程会尝试获取刚增加的信号量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量法 ：3线程交替打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建3个信号量</span></span><br><span class="line"><span class="comment">//semaphore1持有【1】个信号量</span></span><br><span class="line">Semaphore semaphore1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//semaphore2持有【0】个信号量</span></span><br><span class="line">Semaphore semaphore2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//semaphore3持有【0】个信号量</span></span><br><span class="line">Semaphore semaphore3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore1信号量-1</span></span><br><span class="line">            semaphore1.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore2信号量+1 release():该方法的作用是把当前Semaphore对象的信号量值增加1</span></span><br><span class="line">            semaphore2.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore2信号量-1</span></span><br><span class="line">            semaphore2.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore3信号量+1</span></span><br><span class="line">            semaphore3.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore3信号量-1</span></span><br><span class="line">            semaphore3.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore1信号量+1</span></span><br><span class="line">            semaphore1.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>为了避免系统频繁的创建和销毁线程，我们可以让创建的线程复用。我们可以使用一个线程池维护一些线程，当你需要使用线程的时候，可以从池子中随便拿一个空闲线程，当完成工作时，并不急着关闭线程，而是将这些线程退回到线程池中，方便下次使用。</p><p>简而言之，再使用线程池后，创建线程编程了从线程池中获得空闲线程，关闭线程变为想线程池归还线程。</p><h3 id="3大创建线程池的方法："><a href="#3大创建线程池的方法：" class="headerlink" title="3大创建线程池的方法："></a>3大创建线程池的方法：</h3><p>//可伸缩线程池<br>ExecutorService threadPool1 = Executors.newCachedThreadPool();<br>//单个线程池<br>ExecutorService threadPool2 = Executors.newSingleThreadExecutor();<br>//固定数量线程池  7个<br>ExecutorService threadPool3 = Executors.newFixedThreadPool(11);</p><p><img src="image-20210315024654123.png" alt="image-20210315024654123"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可伸缩线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="comment">//最小为0个，最大为2的31次方个，OOM风险</span></span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单个线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//固定数量线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上3个源码的本质</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大核心线程池大小  最多可同时处理的线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//超时释放时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//超时时长</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列  等待队列长度</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;<span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);<span class="comment">//线程工厂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大核心线程池如何确定？</p><p><strong>int maximumPoolSize,//最大核心线程池大小：</strong></p><p><strong>CPU 密集型任务(N+1)：</strong></p><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比x CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>I/O 密集型任务(2N)：</strong></p><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取CUP的核数System.out.println(Runtime.getRuntime().availableProcessors());//4</span></span><br></pre></td></tr></table></figure><h3 id="7大ThreadPoolExecutor常用参数"><a href="#7大ThreadPoolExecutor常用参数" class="headerlink" title="7大ThreadPoolExecutor常用参数"></a><strong>7大ThreadPoolExecutor常用参数</strong></h3><p><strong>1. corePoolSize ：核心线程线程数</strong></p><p>定义了最小可以同时运行的线程数量。</p><p><strong>2. maximumPoolSize ：最大线程数</strong></p><p>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量会扩大到最大线程数。</p><p><strong>3. keepAliveTime ：等待时间</strong></p><p>当线程数大于核心线程数时，多余的空闲线程存活的最长时间。</p><p><strong>4. unit ：时间单位。</strong></p><p>keepAliveTime 参数的时间单位，包括 <code>TimeUnit.SECONDS</code>、<code>TimeUnit.MINUTES</code>、<code>TimeUnit.HOURS</code>、<code>TimeUnit.DAYS</code> 等等。</p><p><strong>5. workQueue ：任务队列</strong></p><p>任务队列，用来储存等待执行任务的队列。</p><p><strong>6. threadFactory ：线程工厂</strong></p><p>线程工厂，用来创建线程，一般默认即可。</p><p><strong>7. handler ：拒绝策略</strong></p><h3 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a><strong>4大拒绝策略</strong></h3><p><strong>ThreadPoolExecutor.AbortPolicy：</strong> 抛出 <code>RejectedExecutionException</code>  来拒绝新任务的处理，是 Spring 中使用的默认拒绝策略。</p><p><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong> 线程调用运行该任务的 <code>execute</code> 本身，也就是直接在调用 <code>execute</code> 方法的线程中运行 (<code>run</code>) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度，但可能造成延迟。若应用程序可以承受此延迟且不能丢弃任何一个任务请求，可以选择这个策略。</p><p><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</p><p><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求</p><p><img src="image-20210317214636190.png" alt="image-20210317214636190"></p><h2 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h2><p>ThreadLocal是一个线程内部的数据存储类，可以在指定线程中存储数据，且只有在该指定线程中才可以获取存储数据。</p><ul><li>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组 table。</li><li><p>ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</p><p><strong>作用</strong></p></li><li><p>线程隔离：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用。</p></li><li>传递数据：减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</li></ul><p><strong>使用场景</strong></p><p><strong>某个数据是以线程为作用域且不同线程具有不同的 Lopper</strong></p><p>如果不采取 ThreadLocal，那么系统就必须提供一个全局的哈希表来 Handler 查找指定线程的 Lopper，这样一来就必须提供一个类似于 LooperManager 的类。</p><p><strong>复杂逻辑下的对象传递（如监听器的传递）</strong></p><p>有时一个线程中的任务过于复杂，可能表现为函数调用栈比较深以及代码入口的多样性，这时又要监听器能够贯穿整个线程的执行过程。</p><p>如果采用 ThreadLocal 可以让监听器作为线程内的全局对象而存在，在线程内部只要通过 get 方法就可以获取监听器。</p><p>如果不采取 ThreadLocal，就只能采用另外两种办法：</p><ul><li>讲监听器作为参数的形式在函数调用栈中传递：函数调用栈越深，越容易混乱。</li><li>将监听器作为静态变量供线程访问：不具有可扩展性，有几个线程在调用，就要提供几个静态监听器对象。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Boolean 类型的 ThreadLocal 对象</span></span><br><span class="line">ThreadLocal&lt;Boolean&gt; mBooleanThread = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class="line">mBooleanThread.set(<span class="keyword">true</span>);  <span class="comment">// 主线程中设置为 true</span></span><br><span class="line">mBooleanThread.get();      <span class="comment">// 主线程中获取为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread #1"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBooleanThread.set(<span class="keyword">false</span>);  <span class="comment">// 子线程1中设置为 false</span></span><br><span class="line">        mBooleanThread.get();       <span class="comment">// 子线程1中获取为 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread #2"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;             <span class="comment">// 子线程2中不去设置</span></span><br><span class="line">        mBooleanThread.get();       <span class="comment">// 子线程2中获取为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从 ThreadLocal 的 <code>set()</code> 和 <code>get()</code> 方法可以看出，他们所操作的对象都是当前线程的 localValues 对象和 table 数组，因此在不同线程中访问同一个 ThreadLocal 的 <code>set()</code> 和 <code>get()</code> 方法，它们对 ThreadLocal 所做的读写操作仅限于各自内部，这就是为什么 ThreadLocal 可以在多个线程找那个互不干扰的存储和修改数据。</p><hr><p> <strong>早期方案</strong></p><p>每个 ThreadLocal 都创建一个 ThreadLocalMap，用 Thread 作为 Map 的key，要存储的局部变量作为 Map 的 value。</p><figure class="image-box">                <img src="a4abc3c4e8ea435fbcf522511d461014~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><p><strong>JAVA 8 方案</strong></p><p>每个 Thread 维护一个 ThreadLocalMap，用 ThreadLocal 实例本身 Map 的 key，要存储的局部变量作为 Map 的 value。</p><ul><li>每个 Thread 线程内部都有一 个Map（ThreadLocalMap）</li><li>Map 里面存储 ThreadLocal 对象（ key）和线程的变量副本（value）</li><li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><figure class="image-box">                <img src="3f17325a42a1439d8eb008f8623794d1~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><p><strong>【优点】</strong></p><ul><li>每个Map所存储的元素数量变少了。</li><li>当Thread销毁时，ThreadLocalMap也被销毁，减少内存。</li></ul><p><strong>ThreadLocal 核心方法源码</strong></p><table><thead><tr><th><strong>方法声明</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set(T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><p><strong>set 方法</strong></p><p>先获取当前线程的 ThreadLocalMap 变量，如果存在则设置值，不存在则创建并设置值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前线程绑定的局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象所维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// map不为空，则设置或更新值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// map 为空，则为线程t创建一个ThreadLocalMap对象，并把value存放其中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程所维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为线程创建一个ThreadLocalMap对象，并赋予初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this是调用此方法的ThreadLocal对象</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>ThreadLocal 内存泄漏</strong></p><p><strong>当key是强引用</strong></p><p>ThreadLocalMap 中的 key 使用了强引用，会导致 threadLocal 和 value 出现内存泄漏。</p><figure class="image-box">                <img src="16a8dd89547242e08e21af965c6ea9c3~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li>假设在业务代码中使完 ThreadLocal，threadLocalRef被回收了。</li><li>由于 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收。</li><li>在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，始终有引用链 threadRef -&gt; currentThread -&gt; threadLocalMap -&gt; entry，Entry就不会被回收，导致Entry内存泄漏（threadLocal 和 value 同时出现内存泄漏）。</li></ul><p><strong>当key是弱引用</strong></p><p>ThreadLocalMap 中的 key 使用了弱引用，会导致 value 出现内存泄漏。</p><figure class="image-box">                <img src="75c1d22fbcac4c8a829f8d66190b022a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li>假设在业务代码中使完 ThreadLocal，threadLocalRef被回收了。</li><li>由于 ThreadLocalMap 只持有 ThreadLocal 的弱引用，没有任何强引用指向 threadlocal 实例，所以 threadlocal 就可以顺利被gc回收，此时 Entry 中的 key=null。</li><li>在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，也存在有强引用链 threadRef -&gt; currentThread -&gt; threadLocalMap -&gt; entry -&gt; value，value不会被回收，而这块 value 永远不会被访问到了，导致 value 内存泄漏。</li></ul><h3 id="3-2-3-导致内存泄漏的原因"><a href="#3-2-3-导致内存泄漏的原因" class="headerlink" title="3.2.3. 导致内存泄漏的原因"></a>3.2.3. 导致内存泄漏的原因</h3><ul><li>没有手动删除相应的Entry对象</li><li>当前线程依然在运行</li></ul><p><strong>【解决办法】</strong></p><ul><li>使用完 ThreadLocal，调用其 remove 方法删除对应的 Entry。</li><li>使用完 ThreadLocal，当前 Thread 也随之运行结束。（不好控制，线程池中的核心线程不会销毁）</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：</strong></p><p>代理类和目标类都属于硬性编码，在编译器就确定下来了，不利于程序的扩展。同时，每一个代理类都只为一个目标类服务，时间长了下来总会产生过多的代理类。</p><p><strong>动态代理：</strong></p><p>可以根据不同目标类实现的接口，通过反射获取目标类的接口，然后获取接口中的方法，对方法进行统一的处理。</p><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h1><p><strong>实现跨平台的原理</strong></p><p><strong>Java是一门跨平台语言，所谓跨平台就是，Java源文件会被编译成为字节码文件，不管是Windows，Linux还是Mac，都有其适配的JVM，也就是字节码文件可以随意在这些JVM上去运行。</strong></p><p><strong>其他的语言，例如c语言和汇编，编译成为机器码之后，由于底层的机器语言支持不一样，编译后的机器语言文件是不可以跨操作系统运行的。而Java则是把兼容的工作，交给了JVM。不同的JVM负责去适配不同的操作系统。</strong></p><p>虚拟机内部的组成部分：堆，栈，方法区，本地方法栈，方法区，程序计数器</p><p><img src="image-20210628162346871.png" alt="image-20210628162346871"></p><p><img src="https://upload-images.jianshu.io/upload_images/16876298-ee51191fac8bd277.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img"></p><p><strong>Hotspot是基于栈的指令架构：</strong></p><p><strong>优点：1、设计和实现比较简单，适用于资源受限的系统。</strong></p><p><strong>JDK1.8之前：</strong></p><p><strong><figure class="image-box">                <img src="3e821b49984dd98980d20665ddfff290.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>JDK 1.8 ：</strong></p><p><strong><figure class="image-box">                <img src="d70dce6e7f061a82e78b3277888b5b72.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>线程私有的：</strong></p><ul><li><strong>程序计数器</strong></li><li><strong>虚拟机栈</strong></li><li><strong>本地方法栈</strong></li></ul><p><strong>线程共享的：</strong></p><ul><li><strong>堆</strong></li><li><strong>方法区</strong></li><li><strong>直接内存 (非运行时数据区的一部分)</strong></li></ul><p><strong><figure class="image-box">                <img src="image-20210227150521780.png" alt="image-20210227150521780" title class>                <p>image-20210227150521780</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210303010657779.png" alt="image-20210303010657779" title class>                <p>image-20210303010657779</p>            </figure></strong></p><h2 id="加载-过程√"><a href="#加载-过程√" class="headerlink" title="加载 过程√"></a><strong>加载 <a href="#类加载">过程</a>√</strong></h2><h2 id="类加载器的介绍"><a href="#类加载器的介绍" class="headerlink" title="类加载器的介绍"></a>类加载器的介绍</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，(验证，准备，解析)，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li>将class文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="2-1-2-连接"><a href="#2-1-2-连接" class="headerlink" title="2.1.2 连接"></a>2.1.2 连接</h4><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</p><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extention ClassLoader: 加载扩展的jar包</li><li>App ClassLoader：指定的classpath下面的jar包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><p><strong><figure class="image-box">                <img src="image-20210217002723701.png" alt="image-20210217002723701" title class>                <p>image-20210217002723701</p>            </figure></strong></p><figure class="image-box">                <img src="image-20210701153004154.png" alt="image-20210701153004154" title class>                <p>image-20210701153004154</p>            </figure><p>简单来说就算先从下往上找，找到了就执行上面的，没找到就又从上往下找，找到了就执行下面的</p><p><strong>一些热点代码（反复高频执行的）会在虚拟机中缓存起来，使用时用JIT编译器编译</strong></p><p><strong>魔数</strong></p><blockquote><p><strong>每个class文件的前四个字节表示魔数，他的唯一作用是确定这个文件是否是一个能被虚拟机接受的class文件</strong></p><p><strong>前4个字节为魔数</strong></p><p><strong>紧接着魔数的4个字节后，第5个和第6个表示次版本号。第7、8表示主版本号。如下图</strong></p><p><strong>用16进制编辑器打开 可以看见前4个字节的16进制表示的是 0xCAFEBASE 表示魔数，0x00表示次版本号</strong></p><p><strong>0x32为主版本号 即为十进制的50 也就是说这个class文件可以被jdk1.6以上版本的虚拟机所执行。</strong></p></blockquote><p><strong><figure class="image-box">                <img src="20180528140355597" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>类加载的环节： <a name="类加载"></a></strong></p><blockquote><p><strong>类加载主要包括三个阶段，加载、链接、初始化。</strong></p><p><strong>第一个阶段是加载，通过一个类的全限定名获取此类的二进制字节流（流中实际保存的是字节码文件），通过这个字节流所代表的静态存储结构转化为<a href="#方法区">方法区</a>运行时数据结构，实际就是将这个字节码文件加载进内存里。然后在内存中（堆）生成一个该类的Class对象（反射），作为方法区这个类的数据访问入口。</strong></p><p><strong>在此阶段运行中，验证阶段就已开始，交叉进行。只有通过了验证阶段，字节流才会进入内存的方法区中进行存储。</strong></p><p><strong>第二个阶段是链接，分为验证、准备、解析三步。验证是验证class字节码文件包含的信息的正确性，保证对虚拟机不会产生危害。准备是为类变量分配空间并设置该变量的默认初始值。解析是将常量池的符号引用转换为直接引用。</strong></p><p><strong>第三个阶段是初始化，初始化阶段就是执行类构造器方法clinit，这个方法是编译器收集整个类中的<code>类变量</code>的赋值以及<code>静态代码块</code>而形成的，顺序按照源文件中类变量的复制顺序生成的，这个阶段开始，算是真正开始执行代码了。</strong></p></blockquote><p><strong><code>符号引用</code>：见上文中class文件中常量池的图片，我们可以知道常量池中有描述类，方法，字段等常量，这些常量通过一组符号（比如UTF8字符串）描述所引用的目标。虽然在验证阶段已经对此进行了验证，但是这些毕竟只是一些字符串，并不能拿来直接为虚拟机使用，并不指向任何真实的内存地址。</strong></p><p> <strong><code>直接引用</code>：直接引用则是指向这些目标的指针，偏移量或者句柄。</strong></p><p><strong>①加载：</strong></p><p><strong><figure class="image-box">                <img src="image-20210228211948061.png" alt="image-20210228211948061" title class>                <p>image-20210228211948061</p>            </figure></strong></p><p><strong>拓展：类初始化的时机</strong></p><p><strong>②链接：</strong></p><p><strong>Q：链接之验证？</strong></p><blockquote><p><strong>比如.class文件的魔数是否为cafebabe，前四个字节的一般都是固定的，用来让虚拟机识别是否为符合要求的文件，5，6位字节一般是次版本号，7，8位的话是主版本号，这三者信息代表着当前JVM版本是否可以运行，一般高版本的虚拟是向下兼容低版本的，除了这些验证还有元数据验证，字节码验证等。</strong></p></blockquote><p><strong>Q：链接之准备？</strong></p><blockquote><p><strong>准备是为static变量分配内存和初始化零值，这里的初始化是默认值。但是static final修饰的变量在编译期就分配了内存，这里会显式初始化。</strong></p></blockquote><p><strong>Q：符号引用和直接引用？</strong></p><blockquote><p><strong>符号引用就是用字符串符号表示的形式来引用，例如创建一个String s=”abc”的字符串s，输出的时候直接用s来代表这个String字符串，这就是符号引用。符号引用通常是设计字符串的——用文本形式来表示引用关系。</strong></p><p><strong>直接引用是是JVM所能直接使用的形式，这种引用可能是指针、也可能是用索引直接定位。</strong></p></blockquote><p><strong><figure class="image-box">                <img src="image-20210224212159865.png" alt="image-20210224212159865" title class>                <p>image-20210224212159865</p>            </figure></strong></p><p><strong>③初始化：</strong></p><p><strong>Q：初始化？</strong></p><p><strong>初始化就是执行类构造器clinit的过程，这个过程会收集类中所定义的所有类变量的复制动作，然后按照代码在源文件的顺序，为变量进行复制，这一步开始才真正开始执行java代码。</strong></p><p><strong><figure class="image-box">                <img src="image-20210224213335168.png" alt="image-20210224213335168" title class>                <p>image-20210224213335168</p>            </figure></strong></p><p><strong>对象创建环节：</strong></p><p><strong>对象头信息：运行时元数据（）、类型指针（指向方法区）</strong></p><p><strong><figure class="image-box">                <img src="image-20210305010045281.png" alt="image-20210305010045281" title class>                <p>image-20210305010045281</p>            </figure></strong></p><p><strong>加载器种类：</strong></p><ol start="2"><li><strong>启动类加载器Bootstrap ClassLoader</strong></li><li><strong>扩展类加载器Extension ClassLoader</strong></li><li><strong>应用程序类加载器Application ClassLoader</strong></li></ol><p><strong>加载指的是将类的class文件（字节码文件）读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</strong></p><p>  <strong>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</strong></p><p>  <strong>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</strong></p><ul><li><strong>从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。</strong></li><li><strong>从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。</strong></li><li><strong>通过网络加载class文件。</strong></li><li><strong>把一个Java源文件动态编译，并执行加载。</strong></li></ul><p><strong><figure class="image-box">                <img src="1458123-20191224224841067-1374425461.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227131317516.png" alt="image-20210227131317516" title class>                <p>image-20210227131317516</p>            </figure></strong></p><h2 id="JVM内存分配方式√"><a href="#JVM内存分配方式√" class="headerlink" title="JVM内存分配方式√"></a><strong>JVM内存分配方式√</strong></h2><p><strong>Q：JVM的内存分配？</strong></p><blockquote><p><strong>JVM的内存分配分为两种情况，一种是如果内存是绝对规整的，如堆内存的新生区常使用复制算法来进行GC，这种情况就使用指针碰撞的方法进行分配，指针记录了上一次内存分配结束的地址，那么进行下次内存分配的时候，则只需要在这个指针后进行分配就可以了。第二种情况是内存不规整的，例如在老年代，每次GC后都可能产生内存碎片，这种情况就使用空闲列表，找到一块足够大的空间进行分配。</strong></p></blockquote><p><strong>在内存分配绝对规则的情况下，会用指针记录上一次内存分配结束的地址。在进行下次的内存分配时，会从内存指针所在的位置往后进行分配。</strong></p><p><strong>指针碰撞：假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边。中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲空间那边挪动一段与对象大小相等的距离。这种方式则属于指针碰撞。</strong></p><p><strong>空闲列表：如果堆中的内存并不是规整的，已使用的内存和空闲内存相互交错，显然无法使用指针碰撞。虚拟机就必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新记录表上的数据。这种方式属于空闲列表。</strong></p><p><strong>具体选择哪种分配方式由Java堆决定，而Java堆是否规整，则有GC收集器决定。因此使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞。而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用的空闲列表。</strong></p><h2 id="双亲委派机制：安全√"><a href="#双亲委派机制：安全√" class="headerlink" title="双亲委派机制：安全√"></a><strong>双亲委派机制：安全√</strong></h2><blockquote><p><strong>双亲委派机制，是类加载机制的一个工作模型，他其实没有一个双的概念，我认为这是译者的不专业所产生的错误译词，我一个称为上溯委派机制，类加载器收到请求以后，会检查这个类是否已经加载过。<code>会向自己的父类加载器进行委托</code>，如果当前加载器还有父类加载器，递归这个操作，一直委托到最上层的根加载器，委托到最上层以后会检查当前类加载器是否能加载，如果不能加载则向下委派，直到可以加载或者抛出classNotFound异常。双亲委派机制的作用就是为了防止核心的api被篡改，如果假如我在自己的项目下创建一个跟已存在的java.lang包下已存在取的类同样的名字，然后运行运行起来就会报SecurityException。</strong></p></blockquote><p>总结为， 向上检索，向下操作。</p><p>1.除了bootstrap classloader其他所有的类加载器都有父类加载器</p><p>2.一个类加载器在接受到一个类加载请求时，它首先不会自己去尝试加载，而是会先把这个加载请求委派给它的父类加载器去先请求加载，每个层次的类加载器都会如此去做，所以最后的类加载请求都会委派到顶层类加载器bootstrap classloader，只有在父类加载器反馈无法加载该请求时，子类加载器才会自己去加载。</p><p>戏称：啃老机制</p><p><strong>细节：</strong></p><p><strong>双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器的实现方式。大部分的类加载器都遵循这个模型，但双亲委派模型也可以被破坏，破坏并不是不好，而是在有足够意义和理由的情况下，突破已有的规则进行创建，实现特定的功能。</strong></p><p><strong>三种破坏双亲委派模型的方式</strong></p><ul><li><strong>重写 loadClass() 方法</strong></li><li><strong>逆向使用类加载器，引入线程上下文类加载器</strong></li><li><strong>追求程序的动态性：代码热替换、模块热部署等技术</strong></li></ul><p><strong>作用：</strong></p><p><strong>1、避免类的重复加载</strong></p><p><strong>2、保护程序安全，防止核心api被随意篡改，如自定义类java.lang.String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader;classLoader.getParent(); <span class="comment">// jre\lib\ext文件夹classLoader.getParent().getParent(); // rt.jar RunTime包</span></span><br></pre></td></tr></table></figure><p><strong>委派方向：先寻找应用程序类加载器（Application ClassLoader）—&gt;扩展类加载器（Extension ClassLoader）—&gt;启动类加载器（Bootstrap ClassLoader）</strong></p><p>为什么是双亲委派模式 而不叫单亲委派模式呢？</p><p>这就是名称问题而已，不管是继承自一个类还是实现多个接口，本质都要用到invoke指令。双亲单亲仅仅是个名称而已。</p><p>双亲委派的原文是”parents delegate”。parents在英文中是“父母”、“双亲”的意思，常用翻译是“父母”,但也有“上溯，母体，祖先”这一类的意思，这里其实表达的是“父母这一辈”的人的意思。实际上这个模型中，只是表达“父母这一辈”的class loader而已，并不是说真的有一个父亲的class loader和一个母亲class loader。本人观点是叫做上溯委派机制。</p><p><strong>机制：</strong></p><ol><li><strong>类加载器收到请求</strong></li><li><strong>将这个请求委托给父类加载器去完成，一直向上委托，直到启动类加载器</strong></li><li><strong>启动类加载器检查是否能够加载当前这个类，能加载就使用当前加载器，否则抛出异常</strong></li><li><strong>重复步骤3</strong></li></ol><p><strong>PS：若输出当前类加载器值为NULL，则该加载器不存在或调用不到（比如用C++、C语言写的就调用不到）</strong></p><p><strong><figure class="image-box">                <img src="image-20210227144108510.png" alt="image-20210227144108510" title class>                <p>image-20210227144108510</p>            </figure></strong></p><h1 id="拓展：-双亲委派机制的BUG"><a href="#拓展：-双亲委派机制的BUG" class="headerlink" title="拓展： 双亲委派机制的BUG"></a>拓展： 双亲委派机制的BUG</h1><p><a href="https://zhuanlan.zhihu.com/p/345534653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/345534653</a></p><h5 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1 工作流程"></a>1 工作流程</h5><ul><li><p>当一个类加载器收到一个类加载请求 在 JDK9 后，会首先搜索它的内建加载器定义的所有“具名模块”：</p></li><li><ul><li>如果找到合适的模块定义，将会使用该加载器来加载</li><li>如果未找到，则会将该请求委派给父级加载器去加载</li></ul></li></ul><ul><li>因此所有的类加载请求最终都应该被传入到启动类加载器(Bootstrap ClassLoader)中，只有当父级加载器反馈无法完成这个列的加载请求时（它的搜索范围内不存在这个类），子级加载器才尝试加载。</li></ul><p>在类路径下找到的类将成为这些加载器的无名模块。</p><p><strong>这里的父子关系是组合而不是继承</strong>。</p><ul><li>双亲委派模型示意图</li></ul><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-cebbc2df3aeb45700e1fbcfac72d37bc_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h5 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h5><ul><li>避免重复加载 父类已经加载了，子类就不需要再次加载。 eg，object 类。它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器加载，因此 object 类在程序的各种加载环境中都是同一个类。</li><li>更安全 解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心 API，会带来安全隐患。</li></ul><h5 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // 首先先检查该类已经被加载过了</span><br><span class="line">           Class c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;//该类没有加载过，交给父类加载</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;//交给父类加载</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;//父类不存在，则交给启动类加载器加载</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                  //父类加载器抛出异常，无法完成类加载请求</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;//</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   //父类加载器无法完成类加载请求时，调用自身的findClass方法来完成类加载</span><br><span class="line">                   c = findClass(name);</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-类加载的方式"><a href="#3-3-类加载的方式" class="headerlink" title="3.3 类加载的方式"></a>3.3 类加载的方式</h5><ol><li>通过命令行启动应用时由JVM初始化加载含有main()方法的主类。</li><li>通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</li><li>通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</li></ol><h2 id="拓展：破坏双亲委派模型"><a href="#拓展：破坏双亲委派模型" class="headerlink" title="拓展：破坏双亲委派模型"></a>拓展：破坏双亲委派模型</h2><p>双亲模型有个问题：父加载器无法向下识别子加载器加载的资源。</p><ul><li>如下证明 JDBC 是启动类加载器加载，但 mysql 驱动是应用类加载器。而 JDBC 运行时又需要去访问子类加载器加载的驱动，就破坏了该模型。</li></ul><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-ebe7177191430f24e606c80ff0e24bde_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>JDK 自己为解决该问题，引入线程上下问类加载器，可以通过Thread的setContextClassLoader()进行设置</p><ul><li>当为启动类加载器时，使用当前实际加载驱动类的类加载器</li></ul><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-d1d03fa21efba80b0e90eab73648b298_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h2><p>比如OSGI的模块化热部署，它的类加载器就不再是严格按照双亲委派模型，很多 可能就在平级的类加载器中执行了。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>ClassLoader通过一个类全限定名来获取二进制流，如果我们需通过自定义类加载其来加载一个Jar包的时候,难道要自己遍历jar中的类,然后依次通过ClassLoader进行加载吗?或者说我们怎么来加载一个jar包呢? 对于动态加载jar而言，JVM默认会使用第一次加载该jar中指定类的类加载器作为默认的ClassLoader。</li></ol><p>假设我们现在存在名为sbbic的jar包，该包中存在ClassA和ClassB类(ClassA中没有引用ClassB)。 现在我们通过自定义的ClassLoaderA来加载在ClassA这个类，此时ClassLoaderA就成为sbbic.jar中其他类的默认类加载器。即ClassB默认也会通过ClassLoaderA去加载。</p><ol><li>如果一个类引用的其他的类,那么这个其他的类由谁来加载?</li></ol><p>如果ClassA中引用了ClassB呢? 当类加载器在加载ClassA的时候，发现引用了ClassB，此时类加载如果检测到ClassB还没有被加载，则先回去加载。当ClassB加载完成后，继续回来加载ClassA。即类会通过自身对应的来加载其加载其他引用的类。</p><ol><li>既然类可以由不同的加载器加载,那么如何确定两个类如何是同一个类?</li></ol><p>JVM规定：对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性。即在jvm中判断两个类是否是同一个类取决于类加载和类本身，也就是同一个类加载器加载的同一份Class文件生成的Class对象才是相同的，类加载器不同，那么这两个类一定不相同。</p><h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h1><p><strong>沙箱基本组件:</strong></p><ol><li><strong>字节码校验器（确保代码遵循java语言规范。这样可以帮助java程序实现内存保护，但并不是所有类文件都能经过字节码校验，比如核心类（比如String）。）</strong></li><li><strong>存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</strong></li><li><strong>安全管理器：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</strong></li><li><strong>安全软件包：</strong></li></ol><figure class="image-box">                <img src="image-20210701181806141.png" alt="image-20210701181806141" title class>                <p>image-20210701181806141</p>            </figure><h2 id="堆-amp-逃逸分析-√"><a href="#堆-amp-逃逸分析-√" class="headerlink" title="堆&amp;逃逸分析 √"></a><strong>堆&amp;<a href="#逃逸分析">逃逸分析</a> √</strong></h2><blockquote><p><strong>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。堆空间划分为新生代1/3，老年代2/3，新生代又分为伊甸园区，同时也是主要GC区域。</strong></p></blockquote><blockquote><p><strong>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p></blockquote><p><strong>锁消除</strong></p><p><strong>细节</strong></p><p><strong><figure class="image-box">                <img src="image-20210304212603211.png" alt="image-20210304212603211" title class>                <p>image-20210304212603211</p>            </figure></strong></p><h2 id="1-2-Java-虚拟机栈（以栈帧为单位）√"><a href="#1-2-Java-虚拟机栈（以栈帧为单位）√" class="headerlink" title="1.2 Java 虚拟机栈（以栈帧为单位）√"></a><strong>1.2 Java 虚拟机栈（以栈帧为单位）√</strong></h2><blockquote><p> <strong>局部变量表的基本存储单元是变量槽slot，主要存放当前栈帧的方法参数和局部变量和部分返回结果等等，方法被调用的时候，JVM会给变量槽分配一个索引，通过这个索引就可以访问对应的局部变量值，同时局部变量的变量槽可以复用，当一个变量使用后被销毁，即可以让下一个变量使用被销毁变量的变量槽。</strong></p><p> <strong>操作数栈主要对变量值进行运算，运算完成后会将结果压入栈，jvm执行引擎虚拟机时基于栈的执行引擎，这个栈指的就是操作数栈。</strong></p><p> <strong>动态链接就是将class文件一部分符号引用在运行期间转化为直接引用，另外一部分是在类加载的第一阶段由符号引用转化为直接引用，叫做静态解析。</strong> (找到代码)</p><p> <strong>方法出口：最后就是方法返回地址，正常返回时，这个就是将当前栈帧的结果返回到当前方法的调用者，调用者的PC寄存器就时返回地址。如果是异常返回且没有被处理，则返回结果中时没有值的。</strong></p><p> 不会有垃圾回收。</p></blockquote><figure class="image-box">                <img src="image-20210628165938450.png" alt="image-20210628165938450" title class>                <p>image-20210628165938450</p>            </figure><p><strong>Java 虚拟机栈也线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong></p><figure class="image-box">                <img src="image-20210628170802813.png" alt="image-20210628170802813" title class>                <p>image-20210628170802813</p>            </figure><p>java 反汇编命令</p><p>javap  -c  Math.class</p><figure class="image-box">                <img src="image-20210628165426208.png" alt="image-20210628165426208" title class>                <p>image-20210628165426208</p>            </figure><p><strong>JAVA栈的模型</strong></p><blockquote><p><strong>Java 虚拟机栈是由一个个栈帧组成，</strong></p><p><strong>栈帧：局部变量表、操作数栈、动态链接、方法出口信息。</strong></p><p><strong>idea VM参数：Xss256K 设置虚拟机栈的大小为256K</strong></p></blockquote><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>【方法索引，输入输出，本地变量，Class File:引用，父帧，子帧】</p><p>正在执行的方法在栈顶</p><p>StackOverflowError 错误</p><h3 id="栈帧-局部变量表"><a href="#栈帧-局部变量表" class="headerlink" title="栈帧-局部变量表"></a><strong>栈帧-局部变量表</strong></h3><p><strong>在编译期就分配了空间</strong></p><p><strong>问：栈帧中的局部变量表有什么作用？</strong></p><blockquote><p><strong>局部变量表的基本存储单元称为是slot(变量槽)，主要存放着当前栈帧的用于存储方法参数和局部变量，部分结果的返回值等等，当方法被调用的时候，JVM会为每个变量槽分配一个索引，通过这个索引访问索引对应的局部变量值。当方法被调用的时候，会按照局部变量的的产生顺序写到局部变量表上的slot槽上。</strong></p></blockquote><p><strong>局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）、主要影响着栈帧的大小。</strong></p><h3 id="栈帧-动态链接"><a href="#栈帧-动态链接" class="headerlink" title="栈帧-动态链接"></a><strong>栈帧-动态链接</strong></h3><p><strong>Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会<code>在类加载阶段或第一次使用时转化为直接引用</code>，这种转化称为静态解析。另一部分将在每一次<code>运行期间转化为直接引用</code>，这部分称为动态连接</strong></p><p><strong><figure class="image-box">                <img src="image-20210302211215497.png" alt="image-20210302211215497" title class>                <p>image-20210302211215497</p>            </figure></strong></p><p><strong>常量池：作用就是为了提供一些符号和常量，便于指令的识别</strong></p><p><strong>早期绑定：在编译时就能确定下来。比如：java当中的方法只有final，static，private和构造方法是前期绑定</strong></p><p><strong>晚期绑定：在编译期无法确定下来。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。</strong></p><p><strong><figure class="image-box">                <img src="image-20210302225908600.png" alt="image-20210302225908600" title class>                <p>image-20210302225908600</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227183359462.png" alt="image-20210227183359462" title class>                <p>image-20210227183359462</p>            </figure></strong></p><p><strong>栈顶缓存技术</strong></p><h3 id="栈帧-操作数栈"><a href="#栈帧-操作数栈" class="headerlink" title="栈帧-操作数栈"></a><strong>栈帧-操作数栈</strong></h3><blockquote><p><strong>操作数栈会根据字节码指令对变量的值进行压栈然后运算，运算完毕后变量就弹出栈，然后将结果再压入操作数栈，<code>Java</code>虚拟机的解释执行引擎被称为基于栈的执行引擎 ，其中所指的栈就是指－操作数栈。</strong></p></blockquote><p><strong>操作数栈实现方式是数组，在编译完成以后就确定了深度</strong></p><p><strong>细节1</strong></p><p><strong>slot重复利用：一些在变量在方法执行期间被销毁，但是变量槽依旧存在，会被一些变量重新利用起来。</strong></p><p><strong>细节2：</strong></p><p><strong>栈帧中性能调优关系最密切的是局部变量表。可以作为垃圾回收的根节点。涉及到垃圾回收算法指<a href="#标记">可达性分析</a></strong></p><p><strong><figure class="image-box">                <img src="image-20210228165257622.png" alt="image-20210228165257622" title class>                <p>image-20210228165257622</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210228165045672.png" alt="image-20210228165045672" title class>                <p>image-20210228165045672</p>            </figure></strong></p><p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p><ul><li><strong><code>StackOverFlowError</code>： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</strong></li><li><strong><code>OutOfMemoryError</code>： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</strong></li></ul><p><strong>扩展：那么方法/函数如何调用？</strong></p><p><strong>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</strong></p><p><strong>Java 方法有两种返回方式：</strong></p><ol><li><strong>return 语句。</strong></li><li><strong>抛出异常。</strong></li></ol><p><strong>不管哪种返回方式都会导致栈帧被弹出。</strong></p><h3 id="栈帧-方法返回地址"><a href="#栈帧-方法返回地址" class="headerlink" title="栈帧-方法返回地址"></a><strong>栈帧-方法返回地址</strong></h3><p><strong>方法返回地址有两种情况，</strong></p><p><strong>正常返回：当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口(<code>Normal Method Invocation Completion</code>)，一般来说，调用者的<code>PC</code>计数器可以作为返回地址。</strong></p><p><strong>异常返回：当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口(<code>Abrupt Method Invocation Completion</code>)，返回地址要通过异常处理器表来确定。</strong></p><p><img src="image-20210628170246978.png" alt="image-20210628170246978"></p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a><strong>1.3 本地方法栈</strong></h2><p><strong>和虚拟机栈所发挥的作用非常相似。</strong></p><p><strong>区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</strong></p><p><strong>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</strong></p><p><strong>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</strong></p><h3 id="Native关键字（加分项）"><a href="#Native关键字（加分项）" class="headerlink" title="Native关键字（加分项）"></a><strong>Native关键字</strong>（加分项）</h3><ol><li><strong>native是调用底层C语言编写的库</strong></li><li><strong>会进入本地方法栈（有一个Java栈、本地方法栈）并调用本地接口JNI</strong></li><li><strong>JNI的作用：扩展Java的使用，融合不同的变成语言为Java所用。（C、C++，Java诞生的时候C、C++横行，Java必须融入这种语言生态环境中）</strong></li></ol><p>它在内存区域中，开辟一块标记区域：native method stack ，登记native 方法</p><p>在最终执行的时候，加载本地方法库中的方法通过JNI</p><h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器（PC寄存器）</strong></h2><blockquote><p><strong>Q：程序计数器？</strong></p><p><strong>A：程序计数器中存储着指向下一条字节码指令的地址，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，同时多线程情况下，CPU需要不停的切换线程，程序计数器可以记录当前线程执行到的位置，当CPU切换回来当前线程时，可以知道当前线程执行到哪儿了。同时呢，程序计数器是唯一不会发生内存溢出的地方，因为它之改变值，而不会随着程序的运行需要更大的空间。</strong></p><p><strong>Q：当线程切换到native上的时候，程序计数器是怎样的？</strong></p><p><strong>线程切换以后，由于方法是native修饰，那说明是底层的c/c++来写的方法，这种情况下就直接使用当前OS的PC寄存器和CPU，相当于用当前操作系统的CPU和PC寄存器来运行这个native方法。</strong></p></blockquote><blockquote><p><strong>1、为什么要使用PC寄存器存储当前线程的执行地址呢？（使用PC寄存器存储字节码指令地址有什么用呢？）</strong></p><p><strong>因为CUP需要不停地切换各个线程，这时候切换回来以后，就得知道从哪开始继续执行。</strong></p></blockquote><p><strong>每一个线程都有一个程序计数器，是线程私有的，指向方法区的字节码，在执行引擎读取下一条指令。</strong></p><p><strong>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p><strong>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li><strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</strong></li><li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li></ol><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><p><strong>JVM的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p><p><strong><code>程序计数器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</code></strong></p><p><strong><figure class="image-box">                <img src="image-20210227152516914.png" alt="image-20210227152516914" title class>                <p>image-20210227152516914</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227162230226.png" alt="image-20210227162230226" title class>                <p>image-20210227162230226</p>            </figure></strong></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区<a name="方法区"></a></strong></h2><p><strong>Q：方法区主要存放？</strong></p><blockquote><p><strong>主要存储存储类的信息、字面量信息、运行时常量池、方法数据、方法代码、JIT代码缓存等。</strong></p></blockquote><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单地说，所有定义的方法的信息都 保存在该区域，此区域属于共享区间。</p><p>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是，实例变量存在堆内存中，和方法无关。</p><p>static，final，Class模板，常量池；</p><p><strong>Q：方法区在jdk 1.7以及之前的实现是永久代，1.8以后变成了元空间。</strong></p><p><strong>why？</strong></p><blockquote><p><strong>因为永久代是一个内存固定的区域，会发生oom错误，但是变成元空间以后，内存就是物理内存，通俗的讲，你的机器磁盘有多大，元空间就有多大，大大降低了oom发生。永久代使用的并不是物理内存，所以更容易发生OOM</strong></p></blockquote><p><strong>运行时常量池</strong></p><p><strong>在常量池中，可以看到都是用#1 #2 #3这些临时符号来表示。当运行某个程序时候，JVM会把所有的字节码文件加入到内存当中，在经过链接、验证后，将#1 #2 #3这些符号全部转换成内存中的实际地址，放入到运行时常量池运行。运行时常量池是放在方法区中的，全局只有一份，是一个被所有的class共享的区域。</strong></p><p><strong>字符串常量池：</strong></p><p>　　<strong>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<string>。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容</string></strong></p><p><strong>-XX:MetaSpaceSize=100m -XX:MaxMetaspaceSize=100m</strong></p><p><strong>1.8的元空间大小默认值为21M，最大值为-1，即没有限制。</strong></p><p><strong>默认值为GC触发的水位线，一旦触发到，FULL GC将被触发并卸载没用的类（类对应的加载器不在存活），然后这个水位线将会被重置，如果GC后空间依然不足，则将适当地提高值，反之则降低值。</strong></p><p><strong>方法区GC：</strong></p><p><strong><figure class="image-box">                <img src="image-20210305001251584.png" alt="image-20210305001251584" title class>                <p>image-20210305001251584</p>            </figure></strong></p><p><strong>方法区是被所有线程共享，所有定义的方法都存在该区域，此区域属于共享区间。</strong></p><p><strong><figure class="image-box">                <img src="1111824-20190418173802066-4603036.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210303145007956.png" alt="image-20210303145007956" title class>                <p>image-20210303145007956</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183716879.png" alt="image-20210304183716879" title class>                <p>image-20210304183716879</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183744672.png" alt="image-20210304183744672" title class>                <p>image-20210304183744672</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183812607.png" alt="image-20210304183812607" title class>                <p>image-20210304183812607</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183425558.png" alt="image-20210304183425558" title class>                <p>image-20210304183425558</p>            </figure></strong></p><blockquote></blockquote><h2 id="常量池、运行时常量池、字符串常量池"><a href="#常量池、运行时常量池、字符串常量池" class="headerlink" title="常量池、运行时常量池、字符串常量池"></a><strong>常量池、运行时常量池、字符串常量池</strong></h2><p><strong>常量池中储存的数据类型包括数量值、字符串值、类引用、字段引用、方法引用。</strong></p><p><strong><figure class="image-box">                <img src="5d58f2e0fc2f47ac9d9e2e2797e7a47c~tplv-k3u1fbpfcp-watermark.image" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304034638632.png" alt="image-20210304034638632" title class>                <p>image-20210304034638632</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304034152726.png" alt="image-20210304034152726" title class>                <p>image-20210304034152726</p>            </figure></strong></p><p><strong>字符串常量池：</strong></p><p>　　<strong>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<string>。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容</string></strong></p><hr><p><strong>jdk 1.7后，移除了方法区间，运行时常量池和字符串常量池都在堆中。</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><strong>对象头</strong></h2><p><strong><figure class="image-box">                <img src="image-20210311223140615.png" alt="image-20210311223140615" title class>                <p>image-20210311223140615</p>            </figure></strong></p><h2 id="访问对象的方式"><a href="#访问对象的方式" class="headerlink" title="访问对象的方式"></a><strong>访问对象的方式</strong></h2><p><strong>句柄访问</strong></p><p><strong>栈帧中的本地变量表中的reference类型记录指针指向堆中句柄池的，句柄中又有到对象示例数据的指针（堆）和对象类型数据的指针（方法区）</strong></p><p><strong>缺点：需要在堆里开辟一个句柄池空间，并且需要经过三次寻址。在占用空间的同时效率也不高。</strong></p><p><strong><figure class="image-box">                <img src="image-20210307002846067.png" alt="image-20210307002846067" title class>                <p>image-20210307002846067</p>            </figure></strong></p><p><strong>直接指针（hotspot采用）：</strong></p><p><strong>Java栈中直接reference的指针</strong></p><p><strong><figure class="image-box">                <img src="image-20210307003002082.png" alt="image-20210307003002082" title class>                <p>image-20210307003002082</p>            </figure></strong></p><h1 id="JVM垃圾回收（GC）"><a href="#JVM垃圾回收（GC）" class="headerlink" title="JVM垃圾回收（GC）"></a><strong>JVM垃圾回收（GC）</strong></h1><blockquote><p><strong>JVM垃圾回收主要发生在新生代，因为新生代的对象存活率低，运行时会产生很多死亡的对象，需要JVM进行垃圾回收。</strong></p></blockquote><h2 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a><strong>垃圾收集有哪些算法，各自的特点？</strong></h2><p><strong>-XX:MaxTenuringThreshold：晋升到老年代临界值设定。</strong></p><p><strong>-XX:PretenureSizeThreshold 即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对 Serial 及 ParNew 两款收集器有效。</strong></p><p><strong>如果在 Survivor 区中相同年龄（设年龄为 age ）的对象的所有大小之和超过 Survivor 空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</strong></p><p><strong>复制算法：</strong></p><blockquote><p><strong>复制算法主要针对堆中的新生代，因为新生代是有产生的对象98%都无法存活，复制算法正是应用在这种对象村落率比较低的区域，该算法会把每次幸存的对象从Eden区和From区复制到To区，此时To区会变成From区，因为在每次GC使用复制算法的时候哦From区和To区会交换位置，To区始终是空的，同时这样造成了一个To区空间的浪费，但是优点就是对象是规整的，没有内存的碎片。</strong></p></blockquote><p><strong>在一次GC中，将伊甸园区幸存下来的对象和幸存From区的对象复制到幸存To区。</strong></p><p><strong>好处：没有内存的碎片，所有的对象都复制到了幸存From区</strong></p><p><strong>坏处：总有一个幸存To区是空的，存在空间浪费。</strong></p><p><strong>复制算法最佳适用场景：对象存活率较低情况下使用，因为极端情况下（假设对象100%存活），成本太高。即一般在新生区使用</strong></p><p>​                                    <strong>GC前                                                                                GC后</strong></p><p><strong><figure class="image-box">                <img src="image-20210223211344746.png" alt="image-20210223211344746" title class>                <p>image-20210223211344746</p>            </figure></strong></p><p><strong>标记清除算法：</strong></p><blockquote><p><strong>标记清除算法，扫描所有对象，对需要回收的对象进行标记，被标记的对象将在GC的过程中被清除，这是最基础的垃圾收集算法，但是容易产生内存的碎片，对有些需要连续内存空间的对象不友好，所以这种算法效率也比较低。</strong></p></blockquote><p><strong>第一次-扫描：扫描所有对象，对需要回收的对象进行标记</strong></p><p><strong>第二次-清除：清除在第一次扫描中被标记的对象</strong></p><p><strong><figure class="image-box">                <img src="image-20210223212338753.png" alt="image-20210223212338753" title class>                <p>image-20210223212338753</p>            </figure></strong></p><p><strong>优点：不需要额外的空间。</strong></p><p><strong>缺点：标记和清除即两次扫描，时间成本较高。对象四处散落，产生内存碎片。</strong></p><p><strong>标记压缩清除算法：</strong></p><p><strong>在标记清除算法的基础上，加多一步整理，对存活的对象向内存的一端进行移动，整理出连续的内存的空间，</strong></p><p><strong><figure class="image-box">                <img src="image-20210223212828566.png" alt="image-20210223212828566" title class>                <p>image-20210223212828566</p>            </figure></strong></p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a><strong>空间分配担保</strong></h2><blockquote><p><strong>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果大于，则此次Minor GC是安全的。</strong></p><p><strong>如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</strong></p></blockquote><p><strong>3.为什么要进行空间担保？</strong></p><p><strong>是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</strong></p><h2 id="堆-JVM优化"><a href="#堆-JVM优化" class="headerlink" title="堆/JVM优化"></a><strong>堆/JVM优化</strong></h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析<a name="逃逸分析"></a></strong></h3><blockquote><p><strong>如果这个对象的作用域仅仅是方法内，不会被其他方法进行调用修改的话，就判断这个对象没有逃逸出去，虚拟机就可能将他直接在栈上分配，因为在栈上分配的话就不存在GC，对象随着方法运行结束被弹出栈而销毁，提高程序的运行性能。同时，也表明了能使用局部变量就尽量不要在方法内定义。</strong></p></blockquote><p><strong>细节</strong></p><p><strong>逃逸分析并不成熟</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000344240.png" alt="image-20210305000344240" title class>                <p>image-20210305000344240</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210305000413629.png" alt="image-20210305000413629" title class>                <p>image-20210305000413629</p>            </figure></strong></p><p><strong>同步省略（锁消除）</strong></p><p><strong>经过逃逸分析以后，如果作用域是在方法内的话，会省略掉同步操作。</strong></p><p><strong>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</strong></p><p><strong>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000150535.png" alt="image-20210305000150535" title class>                <p>image-20210305000150535</p>            </figure></strong></p><p><strong>标量替换</strong></p><p><strong>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000143737.png" alt="image-20210305000143737" title class>                <p>image-20210305000143737</p>            </figure></strong></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h2><p><strong>我所了解的垃圾回收器有serial和parNew这两种</strong></p><p><strong>Serial / Serial Old 收集器：</strong></p><p><strong>单线程收集器，只使用一个 CPU 和一个收集线程，垃圾回收时暂停其他所有的工作线程，直到收集结束。</strong></p><p><strong>新生代采用复制算法，老年代采用标记整理算法。</strong></p><p><strong>ParNew 收集器：</strong></p><p><strong>Serial 的多线程版本，能与 CMS 收集器配置工作，所以是许多运行在 Server 模式下的首选新生代收集器。</strong></p><p><strong>在垃圾收集器的上下文中，先明确两个概念：</strong></p><blockquote><p><strong>并行：多条垃圾线程并行工作，用户线程仍然处于等待状态</strong></p><p><strong>并发：用户线程和垃圾回收线程同时执行（不一定并行，可能会交替执行）</strong></p></blockquote><p><strong>G1 收集器：</strong></p><p><strong>Garbge-First 面向服务端应用，具有并发并行、分代收集、空间整合、可预测停顿等特点。</strong></p><p><strong>使用 G1 时，Java 堆的内存分为多个大小相等的独立区域，虽然保留新生代和老年代的概念，但不再是物理隔离。G1 跟踪各个 Region 里垃圾堆积的价值，在后台维护一个优先列表，优先回收价值最大的 Region。</strong></p><p><strong>G1 的运作大致分为初始标记、并发标记、最终标记和筛选回收。</strong></p><p><strong>CMS 收集器：</strong></p><p><strong>Concurrnt Mark Sweep 以获取最短收回停顿时间为目标，使用标记清除算法。收集过程分为 4 部：初始标记、并发标记、重新标记和并发清理。初始标记和重新标记耗时很少，并发标记和并发清理两部耗时较长，但都可以与用户线程一起并发执行。</strong></p><p><strong>CMS 收集器有 3 个明显缺点：</strong></p><ol><li><strong>对 CPU 资源敏感，并发阶段占用一部分 CPU 资源导致应用程序变慢。</strong></li><li><strong>无法收集浮动垃圾，即并发清理阶段由于程序还在运行产生的垃圾，可能导致另一次 Full GC。</strong></li><li><strong>标记清除算法导致收集结束后存在大量空间碎片，可配置 Full GC 执行多少次时伴随一次空间压缩。</strong></li></ol><h2 id="如何判断对象是否死亡-两种方法"><a href="#如何判断对象是否死亡-两种方法" class="headerlink" title="如何判断对象是否死亡?(两种方法)"></a><strong>如何判断对象是否死亡?(两种方法)</strong></h2><p><strong>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</strong></p><p><strong>引用计数法：</strong></p><p><strong>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</strong></p><p><strong>问题：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是【它很难解决对象之间相互循环引用的问题】。</strong></p><p><strong>可达性分析算法：<a name="标记"></a></strong></p><p>　 <strong>通过一系列称为GC Roots的根对象作为起始节点集，根据引用关系向下搜索，搜索走过的路径叫做引用链，如果某个对象到GC Roots节点集没有任何的引用链也被称为不可达，则证明这个对象不可能再被使用。</strong></p><p>　<strong>可作为GC Roots根节点的：</strong></p><ul><li><strong>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</strong></li><li><strong>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</strong></li><li><strong>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</strong></li><li><strong>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</strong></li><li><strong>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</strong></li><li><strong>所有被同步锁（synchronized关键字）持有的对象</strong></li><li><strong>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></li><li><strong>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合</strong></li></ul><p><strong>引用</strong></p><p><strong>强引用 ： 是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong></p><p><strong>软引用：是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用</strong></p><p><strong>弱引用 ：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用</strong></p><p><strong>虚引用：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</strong></p><p><strong><figure class="image-box">                <img src="227c2ddb38278e2c42a40def9484aa44.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>方法区垃圾回收</strong></p><ul><li><strong>方法区的回收主要包括废弃常量和无用的类。</strong></li><li><strong>废弃常量和堆中的对象类似，当发生垃圾回收时，如果常量池中的常量不存在任何引用，必要情况下回被清理。</strong></li><li><strong>判断一个类无用的条件很苛刻，需要所有实例都已经被回收、加载该类的 ClassLoader 已经被回收，并且该类对应的 java.lang.Class 对象没有在任何地方被引用，无法通过反射访问该类的方法，满足以上条件的无用类才能被回收。</strong></li></ul><p>1.</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a><strong>树</strong></h2><p><strong>前序遍历：对于当前节点，先输出该节点，然后输出他的左孩子，最后输出他的右孩子（中左右）。</strong></p><p><strong>中序遍历：对于当前结点，先输出它的左孩子，然后输出该结点，最后输出它的右孩子（左中右）。</strong></p><p><strong>后续遍历：对于当前结点，先输出它的左孩子，然后输出它的右孩子，最后输出该结点（左右中）。</strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><p><strong><figure class="image-box">                <img src="image-20210221225916916.png" alt="image-20210221225916916" title class>                <p>image-20210221225916916</p>            </figure></strong></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h1><p><img src="1655bd71cc1bbbf5" alt="img"></p><p><strong>冒泡排序：</strong></p><p>冒泡排序，每次冒泡都比较相邻两个数的大小，大小关系不对，则交换。如下图，第一躺冒泡下来，最大的值都会被排到正确的位置，也有可能有其他数字处于正确位置。所以一趟下来至少有一个最大的处于正确位置（如下图的9）。</p><p><img src="166aa856d3308e96" alt="img" style="zoom: 80%;"></p><p><strong>选择排序</strong></p><p>选择排序如下图，每次都找出剩余中最小的值，将该最小值放到正确位置</p><figure class="image-box">                <img src="166adfaa33b75103" alt="img" title class>                <p>img</p>            </figure><h1 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a><strong>ArrayList和LinkedList</strong></h1><blockquote><p><strong>ArrayList的底层是基于一个动态数组实现的，LinkedList的底层是基于一个双向链表实现的，</strong></p><p><strong>ArrayList对象创建时有一个空参构造器还有一个给定数组容量的构造器，如果不规定数组容量，则默认是0。</strong></p><p><strong>当往数组里添加元素，数组容量将会变为10，数组元素数量超过了10，将会自动扩容，通过一个位运算将现在的容量右移一位再加上现在的容量，变成原数组的1.5倍，JDK1.7之前是1.5+1，然后创建一个新的数组，将原数组的复制进新数组，从而实现了动态扩容。</strong></p><p><strong>有一个细节是他的底层源码定义了两个空数组，一个是默认空数组，一个人创建对象时主动传0，也是空数组。</strong></p></blockquote><p>-</p><p><strong>区别</strong></p><ol><li><strong>底层原理：Arraylist底层是基于动态数组的，而LinkedList底层是基于双向链表的。</strong></li><li><strong>ArrayList必须是连续内存的，而LinkedList不要求是连续内存。</strong></li><li><p><strong>优缺点：ArrayList查询快，增删慢；LinkedList增删块，查慢。</strong></p></li><li><p><strong>ArrayList必须是连续内存的，而LinkedList不要求是连续内存。<br>ArrayList查询快，增删慢；Linked增删快，查慢。</strong></p></li></ol><p><strong>也就是arraylist底层是动态数组，所以查询时直接通过访问下标，查效率高，而增加和删除某一个位置后，后方元素都得向前移动一位。</strong><br><strong>当然最坏情况就是删除第一个元素，而后面的第2到第n个元素都得往前移动一位，所以增删慢。</strong></p><p><strong>例：当数组元素数已满时调用了add方法向尾部添加一个元素，则此时会进行扩容，arraylist会 Arrays.copyOf 复制一个更大的数组 1.5倍，而原数组会被抛弃，被GC回收。</strong></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p> <strong>@Autowired</strong></p><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p><p><strong>@Component,@Repository,@Service, @Controller</strong></p><p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：</p><p>1、@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。<br> 2、@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br> 3、@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。<br> 4、@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</p><p><strong>@Configuration</strong></p><p>一般用来声明配置类，可以使用 @Component注解替代，不过使用Configuration注解声明配置类更加语义化。</p><p>读取配置信息：</p><p><strong>@value(常用)</strong></p><p>使用 @Value(“${property}”) 读取比较简单的配置信息：</p><p><strong>@ConfigurationProperties(常用)</strong></p><p>通过@ConfigurationProperties读取配置信息并与 bean 绑定。</p><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><p>SpringBoot自动装配原理主要涉及到@SpringBootApplication这个注释，而这个注释又可拆分为@EnableAutoConfiguration和@ComponentScan，@EnableAutoConfiguration由@AutoConfigurationPackage（作用是扫描启动类目录下所有包，加载启动类目录下所有的类），还有一个@Import(AutoConfigurationImportSelector.class)将会加载jar包META-INF下spring.factories中带有autoconfiguration尾缀的自动配置类</p><p><img src="image-20210318185345974.png" alt="image-20210318185345974"></p><p><strong>先来分析@AutoConfigurationPackage</strong></p><p>观察其内部实现，内部是采用了@Import，来给容器导入一个Registrar组件</p><figure class="image-box">                <img src="v2-f4fc91431709815748f4743160bf626a_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>所以，我们继续往下跟踪，来看Registrar内部是什么情况？</p><figure class="image-box">                <img src="v2-a93f83f34cd21c13701ad55ea8b7212e_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>我们可以跟踪源码看看这段是什么信息</p><figure class="image-box">                <img src="v2-260515784d191c4e149a0b8e87151025_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>结论：</strong></p><p>通过源码跟踪，我们知道，程序运行到这里，会去加载启动类所在包下面的所有类</p><p>这就是为什么，默认情况下，我们要求定义的类，比如controller，service必须在启动类的同级目录或子级目录的原因</p><p><strong>再来分析@Import(AutoConfigurationImportSelector.class)</strong></p><p>这个的关键是来看AutoConfigurationImportSelector.class内部的细节</p><p>在这个类的内部，有一个关键的方法，我们可以调试来看看结果</p><figure class="image-box">                <img src="v2-37063c2b7b7e2666841eaef6ca79b4b0_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>发现默认加载了好多的自动配置类，这些自动配置类，会自动给我们加载每个场景所需的所有组件，并配置好这些组件，这样就省去了很多的配置</p><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步</strong>:</p><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><p><strong>第 2 步</strong> ：</p><p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p><p><strong>第 3 步</strong></p><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p><p><img src="58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p><p><img src="94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 <strong>Spring Boot Starter</strong> 下的<strong><code>META-INF/spring.factories</code></strong>都会被读取到。</p><p><strong>第 4 步</strong> ：</p><p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p><p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p><figure class="image-box">                <img src="267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image" alt="img" title class>                <p>img</p>            </figure><p>因为，这一步有经历了一遍筛选，<strong><code>@ConditionalOnXXX</code></strong> 中的所有条件都满足，该类才会生效。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; RabbitTemplate<span class="class">.<span class="keyword">class</span>, <span class="title">Channel</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RabbitProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(<span class="title">RabbitAnnotationDrivenConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试官：你说下什么是spring？</strong></p><p><strong>我：spring是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。我们一般说的spring框架指的是Spring Framework，它是很多模块的集合，使用这些模块可以很方便的协助我们开发。这些模块是：核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container中的Core组件是Spring所有组件的核心，Beans组件和Context组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</strong></p><p><strong>面试官：使用Spring框架有什么好处呢？</strong></p><p><strong>我：框架能更让我们高效的编程以及更方便的维护我们的系统。</strong></p><ol><li><strong>轻量：Spring是轻量的，相对其他框架来说。</strong></li><li><strong>控制反转：Spring通过控制反转实现了松散耦合，对象给出他们的依赖，而不是创建或查找依赖的对象们。</strong></li><li><strong>面向切面编程（AOP）：Spring支持面向切面编程，并且把业务逻辑和系统服务分开。</strong></li><li><strong>容器：Spring包含并管理应用中对象的生命周期和配置。</strong></li><li><strong>MVC框架：Spring的WEB框架是个精心设计的框架，是WEB框架的一个很好的替代品。</strong></li><li><strong>事务管理：Spring提供一个持续的事务管理接口，提供声明式事务和编程式事务。</strong></li><li><strong>异常处理:Spring提供方便的API把具体技术相关的异常转化为一致的unchecked异常。</strong></li></ol><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p><strong>Bean的自动装配：</strong></p><figure class="image-box">                <img src="image-20210321205512991.png" alt="image-20210321205512991" title class>                <p>image-20210321205512991</p>            </figure><p>1、通过ComponentScanner<strong>扫描全部@Component及其派生注解标识的类</strong>，此路径主要用于自编程代码，取代原先springboot1.* xml标记时代bean.xml内手动组装的Bean内容，体现自动装配中的“自动”，<strong>其本质就是通过Scanner扫描@Component</strong>。</p><p>2、<strong>通过ImportSelector从spring.factories文件中获取自动配置类</strong>，此路径用于解耦三方件之间的依赖，也就是我们代码从pom里引入其他模块是为什么也能够自动装配上里面的Bean。如果我们的程序写完也作外用，那么spring.factories这里面的key-value一定要仔细认真的核对。该文件里同时定义了各种上下文初始化器和事件监听器，非常重要。源码里位置放在\src\main\resources\META-INF\spring.factories</p><p>填满beanDefinitionMap后Bean定义集合获取完毕。</p><p>Bean的作用域：</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a><strong>Bean的生命周期</strong></h3><blockquote><p><strong>Bean的生命周期包括Bean的创建、存活、销毁的过程，创建就是实例化的过程，存活包括属性赋值和初始化，所以又说Bean的生命周期为：实例化、属性赋值、初始化和销毁，而这个过程单例和多例有所不同：</strong></p></blockquote><p><strong>【1】单例Bean</strong></p><ul><li><strong>实例化：容器启动的时候实例化对象</strong></li><li><strong>存活：只要容器还在，Bean对象就一直存活（和容器共存亡）</strong></li><li><strong>销毁：容器关闭的时候就销毁</strong></li></ul><p><strong>【2】多例Bean</strong></p><ul><li><strong>实例化：获取对象的时候实例化对象</strong></li><li><strong>存活：对象只要在使用过程中就一直存活</strong></li><li><strong>销毁：当对象长时间不用且没有其他对象引用时，由Java垃圾回收器回收</strong></li></ul><p>  <strong>解释Spring框架中bean的生命周期。</strong></p><ul><li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li><li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li><li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li></ul><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><p><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</p><p><strong>prototype</strong>：一个bean的定义可以有多个实例。</p><p><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><blockquote><h1 id="描述一下bean的生命周期"><a href="#描述一下bean的生命周期" class="headerlink" title="描述一下bean的生命周期"></a>描述一下bean的生命周期</h1><p>背图:记住图中的流程</p><figure class="image-box">                <img src="image-20210905114954780.png" alt="image-20210905114954780" title class>                <p>image-20210905114954780</p>            </figure><blockquote><p><code>在表述的时候不要只说图片中有的关键点，要学会扩展描述</code></p></blockquote><blockquote><p><code>设置对象这步骤 可以衍生出循环依赖的问题</code></p></blockquote><p>1.实例化Bean，反射的方式生成对象</p><p>2.填充bena的属性：populateBean(), 循环依赖的问题(三级缓存)</p><p>3.调用aware接口相关的方法：invokeAwareMethod(完成BeanName可以获取容器bean的名称，BeanFactory获取当前bean factory这也可以调用容器的服务，BeanClassLoader对象的属性设置)</p><p>4.调用     </p><p>5.调用initmethod方法:invokeInitmethod(),判断是否实现了InitializingBean接口，如果有，调用afterPropertiesSet方法，</p><p>6.调用BeanPostProcessor的后置处理方法：spring的aop就是在此处实现的，AbstractAutoProxyCreator</p><p>​        注册Destuction相关的回调接口</p><p>7.获取到完整的对象，可以通过getBean的方式来进行对象的获取</p><p>8.销毁流程 ①判断是否实现了DispoableBean接口②调用destroyMethod方法</p></blockquote><blockquote><h1 id="Bean-Factory与FactoryBean有什么区别？"><a href="#Bean-Factory与FactoryBean有什么区别？" class="headerlink" title="Bean Factory与FactoryBean有什么区别？"></a>Bean Factory与FactoryBean有什么区别？</h1><p>相同点：都是用来创建bean对象的，是接口</p><p>不同点：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了，如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactoryBean接口了它的方法</p><pre><code>isSingleton：是否是单例对象getObjectType：获取返回对象的类型getObject：自定义创建对象的过程(new,反射,动态代理)</code></pre></blockquote><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h2><p>从哪里开始聊， aop 是ioc的一个拓展功能，先有ioc，再有aop。是ioc整个流程新增的功能点 ：BeanPostProcessor</p><p>总：aop概念，应用场景，动态代理</p><p><strong>Aop（面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和可维护性。这里聚个日志处理的栗子：</strong></p><p>分：bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现</p><p>​        1.代理对象的创建过程（advice，切面，切点）</p><p>​         2.<strong>通过jdk或者cglib的方式来生成代理对象 </strong>  （拓展点）</p><p>​        3.在执行方法调用的时候，会调用到生成的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的intercept方法，从此方法开始执行</p><p>​        4.根据之前定义好的通知来生成拦截器链</p><p>​        5.从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个CglibMethodInvocation的对象，找的时候是从-1的位置依次开始查找并且执行的。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a><strong>JDK动态代理</strong></h3><p>运用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法，同时代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理了</p><p><strong>基本概念</strong></p><p>首先，我们知道Spring AOP的底层实现有两种方式：一种是JDK动态代理，另一种是CGLib的方式。</p><p>自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。</p><p>JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</p><p>JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。</p><p>CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p><p><strong>JDK 和 CGLib动态代理区别</strong></p><p><strong>1、JDK动态代理具体实现原理：</strong></p><ul><li>通过实现InvocationHandlet接口创建自己的调用处理器；</li><li>通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；</li><li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；</li></ul><p>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p><p><strong>2、CGLib动态代理：</strong></p><p>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代 理的类，重写父类的方法，实现AOP面向切面编程呢。</p><p>ASM 建议不聊</p><p><strong>3、两者对比：</strong></p><ul><li>JDK动态代理是面向接口的。</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。</li></ul><p><strong>4、使用注意：</strong></p><ul><li>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</li><li>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</li></ul><p>实现InvocationHandler接口，并且实现接口中的invoke方法。仔细看<strong>invoke</strong>方法，就是在该方法中加入<strong>切面逻辑</strong>的。目标类方法的执行是由<strong>mehod.invoke(target,args)</strong>这条语句完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.java.base.springaop;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> MyInvocationHandler(Object target) &#123;</span><br><span class="line"> <span class="keyword">super</span>();</span><br><span class="line"> <span class="keyword">this</span>.target = target;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="comment">// 程序执行前加入逻辑，MethodBeforeAdviceInterceptor</span></span><br><span class="line"> System.out.println(<span class="string">"before-----------------------------"</span>);</span><br><span class="line"> <span class="comment">// 程序执行</span></span><br><span class="line"> Object result = method.invoke(target, args);</span><br><span class="line"> <span class="comment">// 程序执行后加入逻辑，MethodAfterAdviceInterceptor</span></span><br><span class="line"> System.out.println(<span class="string">"after------------------------------"</span>);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中增强的目标对象是由Proxy.newProxyInstance(aService.getClass().getClassLoader(),aService.getClass().getInterfaces(), handler);来生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Service aService = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">     MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(aService);</span><br><span class="line">     <span class="comment">// Proxy为InvocationHandler实现类动态创建一个符合某一接口的代理实例</span></span><br><span class="line">     Service aServiceProxy = (Service) Proxy.newProxyInstance(aService</span><br><span class="line">     .getClass().getClassLoader(), aService.getClass()</span><br><span class="line">     .getInterfaces(), handler);</span><br><span class="line">     <span class="comment">// 由动态生成的代理对象来aServiceProxy 代理执行程序，其中aServiceProxy 符合Service接口</span></span><br><span class="line">     aServiceProxy.add();</span><br><span class="line">     System.out.println();</span><br><span class="line">     aServiceProxy.update();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h3><p>静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。</p><ul><li><strong>cglib(Code Generation Library)是一个基于ASM(开源工具包)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。</strong>cglib 通过继承方式实现代理。它广泛的被许多AOP的框架使用，比如我们的 Spring AOP。</li><li>cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。</li><li>cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。</li></ul><p>至于CGLIB底层是如何动态的生成一个目标类的子类，它是使用动态字节码技术，我们知道我们编写的Java对象都是先编译为<code>.class</code>文件，然后由类加载器加载到内存中变为一个Java对象的，动态字节码技术就是通过转换字节码生成新的类来实现改变一个类的内部逻辑的。至于更基础的部分，我也没有深入的研究，有兴趣的可以自己研究一下。</p><figure class="image-box">                <img src="v2-f541ebdf0b2f894a6884166cb8a3dbd3_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>Coding</strong></p><p>添加 cglib 依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>1、不需要接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInternet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectTo</span><span class="params">(String serverHost)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Connecting to "</span>+ serverHost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、代理工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib 代理开始，可以添加逻辑"</span>);</span><br><span class="line">        Object obj = method.invoke(target,objects);</span><br><span class="line">        System.out.println(<span class="string">"cglib 代理结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//工具类，类似于JDK动态代理的Proxy类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        RealInternet target = <span class="keyword">new</span> RealInternet();</span><br><span class="line">        <span class="comment">//获取代理对象,并且将目标对象传递给代理对象</span></span><br><span class="line">        RealInternet internet = (RealInternet) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        internet.connectTo(<span class="string">"so.cn"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cglib 代理开始，可以添加逻辑</span><br><span class="line">Connecting to so.cn</span><br><span class="line">cglib 代理结束</span><br></pre></td></tr></table></figure><h3 id="强大的AspectJ"><a href="#强大的AspectJ" class="headerlink" title="强大的AspectJ"></a>强大的AspectJ</h3><p><strong>SpringBoot AspectJ实现AOP:<a href="https://juejin.cn/post/6844904129240760327" target="_blank" rel="noopener">https://juejin.cn/post/6844904129240760327</a></strong></p><ul><li><strong>AspectJ的织入方式及其原理概要</strong></li></ul><p>经过前面的简单介绍，我们已初步掌握了AspectJ的一些语法和概念，但这样仍然是不够的，我们仍需要了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如<strong>Java JDK的动态代理(Proxy，底层通过反射实现)</strong>或者<strong>CGLIB的动态代理(底层通过继承实现)</strong>，Spring AOP采用的就是基于运行时增强的代理技术，这点后面会分析，这里主要重点分析一下静态织入，<strong>ApectJ采用的就是静态织入</strong>的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><img src="v2-a4f70efe3e2bb0b438ea89a3ae927011_720w.png" alt="img"></p><p>关于ajc编译器，是一种能够识别aspect语法的编译器，它是采用java语言编写的，由于javac并不能识别aspect语法，便有了ajc编译器，注意ajc编译器也可编译java文件。</p><p>这里简单说明一下切点的定义语法：关键字为pointcut，定义切点，后面跟着函数名称，最后编写匹配表达式，此时函数一般使用call()或者execution()进行匹配，这里我们统一使用call()</p><blockquote><p>pointcut 函数名 : 匹配表达式</p></blockquote><p><strong>将注解设置为切点。</strong>将切点织入切面后使用环绕通知增强已经被注解标注的方法，此时就可以获得所有的注解操作，然后将日志记录入库，就可以简单实现用户的日志操作监控，当前提是在AOP中获得用户名，常见的shiro框架就有getSubject的方法获得用户名，当然根据不同的读者使用的技术不同进行获取，知识追寻者这边为了简单实现功能就没有使用一堆繁琐的方法去实现一个用户登陆认证系统；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author lsc</span><br><span class="line"> * &lt;p&gt;日志aop切面 &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAsp &#123;</span><br><span class="line"></span><br><span class="line">    /* *</span><br><span class="line">     * @Author lsc</span><br><span class="line">     * &lt;p&gt; 设置切点&lt;/p&gt;</span><br><span class="line">     * @Param []</span><br><span class="line">     * @Return void</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;@annotation(com.zszxz.annotation.MonitorLog)&quot;)</span><br><span class="line">    public void logPointCut() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 环绕通知</span><br><span class="line">    @Around(&quot;logPointCut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line">        // 开始时间</span><br><span class="line">        LocalDateTime beginTime = LocalDateTime.now();</span><br><span class="line">        // 执行方法</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        // 结束时间</span><br><span class="line">        LocalDateTime endTime = LocalDateTime.now();</span><br><span class="line">        Duration duration = Duration.between(beginTime, endTime);</span><br><span class="line">        // 操作时长</span><br><span class="line">        long seconds = duration.getSeconds();</span><br><span class="line">        // 保存日志</span><br><span class="line">        saveLog(point,seconds);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void  saveLog(ProceedingJoinPoint point, long seconds)&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        // 获得注解</span><br><span class="line">        MonitorLog monitorLog = method.getAnnotation(MonitorLog.class);</span><br><span class="line">        if (monitorLog!=null)&#123;</span><br><span class="line">            // 获得操作类型</span><br><span class="line">            LogEnum operateType = monitorLog.operateType();</span><br><span class="line">            // 获得操作内容</span><br><span class="line">            String value = monitorLog.value();</span><br><span class="line">            System.out.printf(&quot;获得操作类型: %s , 获得操作内容: %s &quot;,operateType.getCode(),value);</span><br><span class="line"></span><br><span class="line">            //请求的参数</span><br><span class="line">            Object[] args = point.getArgs();</span><br><span class="line">            try&#123;</span><br><span class="line">                List&lt;Object&gt; objects = Arrays.asList(args);</span><br><span class="line">                System.out.println(objects);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态切换数据源案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源，切面处理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将注释设置为切点@Pointcut("@annotation(com.tcl.platform.manager.origin.datasource.annotation.DataSource) " +"|| @within(com.tcl.platform.manager.origin.datasource.annotation.DataSource)")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"dataSourcePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Class targetClass = point.getTarget().getClass();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        DataSource targetDataSource = (DataSource)targetClass.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        DataSource methodDataSource = method.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(targetDataSource != <span class="keyword">null</span> || methodDataSource != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String value;</span><br><span class="line">            <span class="keyword">if</span>(methodDataSource != <span class="keyword">null</span>)&#123;</span><br><span class="line">                value = methodDataSource.value();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                value = targetDataSource.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DynamicContextHolder.push(value);</span><br><span class="line">            logger.debug(<span class="string">"set datasource is &#123;&#125;"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DynamicContextHolder.poll();</span><br><span class="line">            logger.debug(<span class="string">"clean datasource"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC⭐⭐⭐"><a href="#IOC⭐⭐⭐" class="headerlink" title="IOC⭐⭐⭐"></a><strong>IOC</strong>⭐⭐⭐</h2><figure class="image-box">                <img src="image-20210319234416409.png" alt="image-20210319234416409" title class>                <p>image-20210319234416409</p>            </figure><p>配置好XML文件，通过实体类的Set方法进行注入。</p><blockquote><h1 id="1-谈谈Spring-IOC得理解，原理与实现"><a href="#1-谈谈Spring-IOC得理解，原理与实现" class="headerlink" title="1. 谈谈Spring IOC得理解，原理与实现"></a>1. 谈谈Spring IOC得理解，原理与实现</h1><p><strong>总</strong>：</p><p><strong>控制反转</strong>：理论思想，原来的对象是由使用者来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理</p><p><strong>DI</strong>：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，populateBean完成属性值的注入</p><p><strong>容器</strong>：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjeacts存放完整的bean对象，整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理的(bean的生命周期)</p><p><strong>分</strong>：</p><p>1.一般聊ioc容器的时候涉及到容器的创建过程(<strong> <code>beanFactory</code>,<code>DefaultListableBeanFactory</code> </strong>),向bean工厂中设置一些参数(BeanPostProcessor,Aeare接口的子类)等等属性</p><p>2.加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition(xml或者注解的解析过程)</p><p>3.beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSupport，ConfigurationClassPostProcessor</p><p>4.BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p><p>5.通过反射的方式讲BeanDefinition对象实例化成具体的bean对象</p><p>6.<strong>bean对象的初始化过程(填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-mehtod方法，BeanPostProcessor的后置处理方法)</strong></p><p>7.生成完整的bean对象，通过getBean方法可以直接获取</p><p>8.销毁过程</p><p>面试官， 这是我对IOC的整体理解，包含了一些详细的整体过程，您有什么想要提问的？（作为结束语）</p><figure class="image-box">                <img src="image-20210905114954780.png" alt="image-20210905114954780" title class>                <p>image-20210905114954780</p>            </figure></blockquote><blockquote><h1 id="2-谈一下spring-IOC的底层实现"><a href="#2-谈一下spring-IOC的底层实现" class="headerlink" title="2. 谈一下spring IOC的底层实现"></a>2. 谈一下spring IOC的底层实现</h1><p>底层实现：工作原理，过程，数据结构，流程，设计模式，设计思想</p><p>你对他的理解和你了解过的实现过程</p><p><code>反射，工厂，设计模式，关键的几个方法</code>(不会的别说)</p><p>createBeanFactory , getBean ,doGetBean , createBean , doCreateBean,createBeanInstance(getDeclaredConstructor(),newinstance),populateBean</p><p>1.先通过createBeanFactory 创建一个Bean工厂(DefaultListableBeanFactory)</p><p>2.开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找，找不到的话，</p><p>3.通过createBean，doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造器(getDeclaredConstructor(),newinstance)</p><p>4.进行对象的属性填充populateBean</p><p>5.进行其他的初始化操作(initializingBean)</p></blockquote><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p><strong>18. 什么是Spring的依赖注入？</strong></p><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><h5 id="Spring是如何解决循环依赖的问题的？⭐"><a href="#Spring是如何解决循环依赖的问题的？⭐" class="headerlink" title="Spring是如何解决循环依赖的问题的？⭐"></a>Spring是如何解决循环依赖的问题的？⭐</h5><blockquote><p>三级缓存，提前暴露对象，aop</p><p><strong>总</strong>：什么是循环依赖问题，A依赖B，B依赖C，C依赖A</p><p><strong>分</strong>：先说明bean得创建过程：实例化，初始化（填充属性）</p><p>1.先创建A对象，实例化A对象，此时A对象中的b属性为空</p><p>2.从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题(不通)，找不到直接创建B对象</p><p>3.实例化B对象，此时B对象中的a属性为空，填充属性a</p><p>4.从容器中查找A对象，找不到，直接创建</p><p>此时形成了闭环，如果仔细琢磨的话，会发现A对象，是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，<br>能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于<strong>提前暴露了某个不完整对象的引用</strong>，所以解决问题的<strong> 核心在于实例化和初始化</strong>分开操作，这也是解决循环依赖问题的关键，</p><p>当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几种状态: 完成实例化但未完成初始化，完整状态，<br>因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方式来查找的。++一级缓存中放的是完整对象，二级缓存中放的是非完整对象 ++</p><p>为什么需要三级缓存？<br>三级缓存的value类型是ObjectFactory，是一个<strong> 函数式接口</strong> ，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。</p><p>如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要</p><p>普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象<strong>覆盖</strong>掉之前的普通对象，<br>在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，<br>因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()</p><p>因此，所有的bean对象在创建的时候要优先放到三级缓存中，<br>在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p></blockquote><p>细节： 缓存的放置时间和删除时间</p><p>三级缓存：createBeanInstance 之后： addSingletonFactory</p><p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候。同时删除三级缓存getInsingleton</p><p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton</p><p><strong>19. 有哪些不同类型的IOC（依赖注入）方式？</strong></p><ul><li><strong>构造器依赖注入：</strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter方法注入：</strong>Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li></ul><p><strong>20. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</strong></p><p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><p><strong>@Qualifier</strong></p><p>根据上面@Autowired的第三种情况，需要更改变量名来对应注入，这样就对程序不是很灵活，于是有了@Qualifier这个注解。@Qualifier的作用是在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用（但是在给方法参数注入时可以单独使用），因此@Qualifier注解很受限制，因此用的不是很多。<strong>@Qualifier常常组合@Autowired一起使用，用来指明具体名字的自动装配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//如果单纯一个@Autowired 注解则表示找类型为IAccuntDao的，如果有两个类型为IAccuntDao的，则接着匹配类型为IAccuntDao而且名字为accountDao的【缺点：要改变量名指定】</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"accountDao2"</span>) <span class="comment">//加上这个注解直接找类型为IAccuntDao而且名字为accountDao2的</span></span><br><span class="line"><span class="keyword">private</span> IAccuntDao accountDao;</span><br><span class="line"></span><br><span class="line">所以这段代码注解的意思就是直接找类型为IAccuntDao而且名字为accountDao的组件</span><br></pre></td></tr></table></figure><ul><li><strong>面试官：你第二点提到了spring的控制反转，能解释下吗？</strong></li><li><strong>我：首先来解释下控制反转。控制反转(Inversion Of Control，缩写为IOC)是一个重要的面向对象编程的法则来削减程序的耦合问题，也是spring框架的核心。应用控制反转，对象在被创建的时候，由一个调控系统内的所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。另外，控制反转一般分为两种类型，依赖注入（Dependency Injection，简称DI）和依赖查找(Dependency Lookup)。依赖注入应用比较广泛。</strong><br><strong>还有几个常见的问题:</strong></li></ul><ol><li><strong>谁依赖谁-当然是应用程序依赖于IOC容器。</strong></li><li><strong>为什么需要依赖-应用程序需要IOC容器来提供对象需要的外部资源。</strong></li><li><strong>谁注入谁-很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象</strong></li><li><strong>注入了什么-就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong></li></ol><hr><p><strong>面试官：那IOC与new对象有什么区别吗</strong></p><p><strong>我：这就是正转与反转的区别。传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转。而反转则是容器来帮助我们创建并注入依赖对象。</strong></p><hr><p><strong>面试官：好的，那IOC有什么优缺点吗？</strong></p><p><strong>我：优点：很明显，实现了组件之间的解耦，提高程序的灵活性和可维护性。缺点：对象生成因为是反射编程，在效率上有些损耗。但相对于IOC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。</strong></p><hr><p><strong>面试官：spring管理这么多对象，肯定需要一个容器吧。你能说下对IOC容器的理解吗？</strong></p><p><strong>我：首先来解释下容器：在每个框架中都有个容器的概念，所谓的容器就是将常用的服务封装起来，然后用户只需要遵循一定的规则就可以达到统一、灵活、安全、方便和快速的目的。</strong></p><p><strong>我：然后IOC容器是具有依赖注入功能的容器，负责实例化、定位、配置应用程序中的对象以及建立这些对象间的依赖。</strong></p><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a><strong>Spring事务隔离级别</strong></h3><p>采用默认的</p><p><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</p><p><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p><p><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p><p><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><hr><h3 id="事务传播机制（策略）"><a href="#事务传播机制（策略）" class="headerlink" title="事务传播机制（策略）"></a><strong>事务传播机制（策略）</strong></h3><p><strong>1、支持当前事务的情况:</strong></p><p><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong>TransactionDefinition.PROPAGATION_SUPPORTS:</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。b</p><p><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p><p><strong>2、不支持当前事务的情况：</strong></p><p><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong><br> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p><p><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</strong><br> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p><strong>TransactionDefinition.PROPAGATION_NEVER：</strong><br> 以非事务方式运行，如果当前存在事务，则抛出异常。</p><p><strong>3、嵌套情况：</strong></p><p><strong>TransactionDefinition.PROPAGATION_NESTED：</strong><br> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p><p>不论使用<code>REQUIRES_NEW</code>或是<code>NESTED</code>，在调用B的invoke时如果发生异常，都能正确完成业务逻辑</p><ul><li><code>REQUIRES_NEW</code>执行到B时，A事物被挂起，B会新开了一个事务进行执行，B发生异常后，B中的修改都会回滚，然后外部事物继续执行</li><li><code>NESTED</code>执行到B时，会创建一个<code>savePoint</code>，如果B中执行失败，会将数据回滚到这个<code>savePoint</code></li></ul><p>重点来了，如果B处正常执行，就会产生区别了</p><ul><li><code>REQUIRES_NEW</code>如果B正常执行，则B中的数据在A提交之前已经完成提交，其他线程已经可见其修改，这就意味着可能有脏数据的产生；同时，如果接下来A的其他逻辑发生了异常，A回滚，但是B已经完成提交，不会回滚了。当然，如果A接下来的逻辑没有相关要求，那就无所谓了</li><li><code>NESTED</code>如果B正常执行，此时B中的修改并不会立即提交，而是在A提交时一并提交，如果A下面的逻辑中发生异常，A回滚时，B中的修改也会回滚，就可以避免上述情况的发生</li></ul><p>某一个事务嵌套另外一个事务的时候怎么办？</p><blockquote><h3 id="A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？"><a href="#A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？" class="headerlink" title="A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？"></a>A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</h3></blockquote><hr><p><strong>总</strong>：事务的传播特性指的是不同方法的嵌套调用过程中，事务该如何进行处理，是同一个事务还是不同的事务，当出现异常的时候会回滚还是提交，两个方法之间相互影响，在日常工作中，使用比较多的是required，Requireds_new</p><p><strong>分</strong>：1.先说事务的不同分类，可以分为三类，支持当前事务，不支持当前事务，嵌套事务</p><p>​        2.如果外层方法是required，内层方法是：required，requireds_new,nested</p><p>​        3.如果外层方法是requireds_new，内层方法是：required，requireds_new,nested</p><p>​        4.如果外层方法是nested，内层方法是：required，requireds_new,nested</p><p>核心处理逻辑非常简单：</p><p>1.判断内外方法是否是同一事务：</p><p>​        是：异常统一在外层方法处理</p><p>​        不是：内层方法有可能影响到外层方法，但是外层方法是不会影响内层方法的</p><p>​        （大致可以这么理解，但是有个别情况不同，nested）</p><hr><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a><strong>事务超时属性</strong></h3><p>  所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p><hr><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a><strong>事务只读属性</strong></h3><p>  事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p><hr><h3 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a><strong>回滚规则</strong></h3><p>  这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><blockquote><h1 id="Spring的事务是如何回滚的？"><a href="#Spring的事务是如何回滚的？" class="headerlink" title="Spring的事务是如何回滚的？"></a>Spring的事务是如何回滚的？</h1><p>spring的事务管理是如何实现的？</p><p>总：spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知实现的，而是通过一个<strong>TransactionInterceptor</strong>来实现的，然后<strong>调用invoke</strong>来实现具体的逻辑</p><p>分：1.先做准备工作，解析各个方法上事务相关的属性，根据具体的属性来判断是否开始新事务</p><p>​        2.当需要开启的时候，获取数据库连接，关闭自动提交功能，开启事务</p><p>​        3.执行具体的sql逻辑操作</p><p>​        4.在操作过程中，如果执行失败了，那么会通过<u>completeTransactionAfterThrowing</u>看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是要先获取链接对象，通过<code>连接对象</code>来回滚。</p><p>​        5.如果执行过程中，没有任何意外情况的发生，那么通过c<u>ommitTransactionAfterReturning</u>来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实现的，实现的时候也要获取链接，通过链接对象来提交</p><p>​        6.当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo</p><p>如果想要聊的更加细致的话，需要知道TransactionInfo，TransactionsStatus</p></blockquote><h1 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a><strong>Mysql数据库</strong></h1><h2 id="sql语句解析顺序"><a href="#sql语句解析顺序" class="headerlink" title="sql语句解析顺序"></a><strong>sql语句解析顺序</strong></h2><p><strong><figure class="image-box">                <img src="image-20210305162751070.png" alt="image-20210305162751070" title class>                <p>image-20210305162751070</p>            </figure></strong></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p><strong>Q：如何解决幻读？</strong></p><blockquote><p><strong>幻读是因为在事务进行期间，有其他事务向当前表插入数据</strong></p></blockquote><p><strong>ACID原则：</strong></p><p><strong>原子性Atomicity：要么都成功，要么都失败。</strong></p><p><strong>一致性Consistency：前后数据的完整性要保持一致。</strong></p><p><strong>隔离性Isolation：多个用户并发访问的时候，数据库为每个用户都开启事务，不能被其他事务所干扰。</strong></p><p><strong>持久性Durability：事务提交后不可逆转。</strong></p><p><strong>事务的四种隔离级别</strong></p><p><strong>Read Unconnitted 读未提交：</strong></p><blockquote><p> <strong>所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。</strong></p></blockquote><p><strong>Read Connitted读已提交：</strong></p><blockquote><p><strong>这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。它满足了隔离的简单定义: 一个事务只能看见已经提交事务所做的改变。这种隔高级别也支持所谓的不可重复读</strong></p><p><strong>(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的commit,所以同一select可能返回不同结果。</strong></p></blockquote><p><strong>Repeatable Read可重复读：</strong></p><blockquote><p><strong>这是MySQL的默认事务隔离级别，它确保同- -事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上,这会导致另一个棘手的问题:幻读(Phantom Read)。简单的说，幻读指当用户读取某-范围的数据行时， 另- -个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。InnoDB和Falcon存 储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)机制解决了该问题。</strong></p></blockquote><p><strong>Serializable 串行化：</strong></p><blockquote><p><strong>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突,从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</strong></p></blockquote><p><strong>事务并发产生的问题</strong></p><p><strong>脏读：A事务读取了B事务未提交的数据，但是B如果执行回滚，则A读取的为脏数据</strong></p><p><strong>不可重复读：A事务读取了数据，B事务对该数据进行了修改并提交，A再次读取时</strong></p><p><strong>幻读：A事务两次查询的数据行数不一样，可能是由于B事务插入了新数据。</strong></p><blockquote><h1 id="ACID是靠什么保证的？"><a href="#ACID是靠什么保证的？" class="headerlink" title="ACID是靠什么保证的？"></a>ACID是靠什么保证的？</h1><p>原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><p>一致性是由其他三大特性保证，程序代码要保证业务上的一致性</p><p>隔离性是由MVCC来保证</p><p>持久性由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失</p></blockquote><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a><strong>数据库引擎</strong></h2><p><strong>MyISAM 和InnoDB区别：</strong></p><ol><li><strong>MyISAM是非事务安全的，而InnoDB是事务安全的</strong></li><li><strong>MyISAM锁的粒度是表级的，而InnoDB支持行级锁</strong></li><li><strong>MyISAM支持全文类型索引，而InnoDB不支持全文索引</strong></li><li><strong>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</strong></li><li><strong>MyISAM表保存成文件形式，跨平台使用更加方便</strong></li></ol><p><strong>应用场景：</strong></p><p><strong>1、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM</strong></p><p><strong>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</strong></p><p><strong><figure class="image-box">                <img src="image-20210305145252564.png" alt="image-20210305145252564" title class>                <p>image-20210305145252564</p>            </figure></strong></p><h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a><strong>锁</strong></h2><p><strong>show open tables:查看当前库所有表的锁使用情况。</strong></p><p><strong><figure class="image-box">                <img src="image-20210308021228997.png" alt="image-20210308021228997" title class>                <p>image-20210308021228997</p>            </figure></strong></p><p><strong>show status like ‘Table%’: 表的锁定情况。</strong></p><p><strong><figure class="image-box">                <img src="image-20210308021217218.png" alt="image-20210308021217218" title class>                <p>image-20210308021217218</p>            </figure></strong></p><p><strong>锁分类</strong></p><p><strong>从操作粒度分</strong></p><p><strong>表锁：锁定表</strong></p><p><strong>行锁：锁定指定表中的行</strong></p><p><strong>从操作类型分</strong></p><p><strong>读锁（共享锁）：</strong></p><p><strong>写锁（排他锁）：</strong></p><p><strong><figure class="image-box">                <img src="image-20210308020426981.png" alt="image-20210308020426981" title class>                <p>image-20210308020426981</p>            </figure></strong></p><p><strong>锁升级</strong></p><p><strong>当sql语句中索引失效时，行锁将会升级为表锁。</strong></p><p><strong>间隙锁</strong></p><p><strong>sql语句是作用于范围时，若1 2 3【4为间隙】  5，间隙将被锁定。</strong></p><p><strong>锁优化建议！！！！！！！！！！</strong></p><p><strong><figure class="image-box">                <img src="image-20210308030836304.png" alt="image-20210308030836304" title class>                <p>image-20210308030836304</p>            </figure></strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><strong>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是有序的数据结构。</strong></p><figure class="image-box">                <img src="image-20210901175227062.png" alt="image-20210901175227062" title class>                <p>image-20210901175227062</p>            </figure><p><strong>聚簇索引：叶子节点存放的是整行的数据。</strong></p><blockquote><p><strong>如果表设置了主键，则主键就是聚簇索引</strong></p><p><strong>如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引</strong>  </p><p><strong>以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引</strong></p></blockquote><p><strong>非聚簇索引（普通索引）：</strong></p><blockquote><p><strong>普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。</strong></p></blockquote><p><strong>回表：</strong></p><blockquote><p><strong>如果查询条件为普通索引 （非聚簇索引）where 后的条件不是索引，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。</strong></p><p><strong>需要扫描两次索引B+树， 。</strong></p></blockquote><p><strong>索引覆盖：</strong></p><blockquote><p><strong>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</strong></p></blockquote><blockquote><p><strong>常见的方法是：将被查询的字段，建立到联合索引里去。</strong></p><p><strong>1、如实现：select id,age fro m user where age = 10;</strong></p><p><strong>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引</strong></p></blockquote><p><strong><figure class="image-box">                <img src="1702e72ac250a40f" alt="MySQL 的覆盖索引与回表" title class>                <p>MySQL 的覆盖索引与回表</p>            </figure></strong></p><p><strong>索引失效条件</strong></p><ul><li><strong>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></li><li><strong>存储引擎不能使用索引范围条件右边的列</strong></li><li><strong>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</strong></li><li><strong>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</strong></li><li><strong>is null,is not null也无法使用索引</strong></li><li><strong>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操</strong></li></ul><p><strong>二叉排序树</strong></p><p><strong>在介绍B树之前，先来看另一棵神奇的树——二叉排序树（Binary Sort Tree），首先它是一棵树，“二叉”这个描述已经很明显了，就是树上的一根树枝开两个叉，于是递归下来就是二叉树了（下图所示），而这棵树上的节点是已经排好序的，具体的排序规则如下：</strong></p><ul><li><strong>若左子树不空，则左子树上所有节点的值均小于它的根节点的值</strong></li><li><strong>若右子树不空，则右字数上所有节点的值均大于它的根节点的值</strong></li><li><strong>它的左、右子树也分别为二叉排序数（递归定义）</strong></li><li><strong><figure class="image-box">                <img src="758447-20180126164904240-511277096.png" alt="img" title class>                <p>img</p>            </figure></strong></li></ul><p><strong>B树</strong></p><p><strong>B树的特点可以总结为如下：</strong></p><ol><li><strong>关键字集合分布在整颗树中。</strong></li><li><strong>任何一个关键字出现且只出现在一个节点中。</strong></li><li><strong>搜索有可能在非叶子节点结束。</strong></li><li><strong>其搜索性能等价于在关键字集合内做一次二分查找。</strong></li><li><strong>B树在插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。</strong></li></ol><p><strong><figure class="image-box">                <img src="758447-20180126165126756-1850778539.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>B+树</strong></p><p><strong>作为B树的加强版，B+树与B树的差异在于</strong></p><ul><li><strong>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。</strong></li><li><strong>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</strong></li><li><strong>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</strong></li></ul><p><strong><figure class="image-box">                <img src="758447-20180126171338850-1455023219.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</strong></p><p><strong>2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</strong></p><p><strong>3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</strong></p><p><strong>4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</strong></p><p><strong>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</strong></p><p><strong>B+树多高?</strong></p><p>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p><p><strong>InnoDB的默认一页大小是【16k】</strong>，一页即<strong>叶子节点</strong>的存储空间。</p><p>上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。</p><p>那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，<strong>而指针大小在InnoDB源码中设置为6字节</strong>，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。</p><p>根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170<em>1170</em>16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，这就能满足千万级的数据存储。在查找数据时，一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查到数据。</p><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a><strong>最左前缀法则</strong></h2><h2 id="数据库优化（重要重要！）"><a href="#数据库优化（重要重要！）" class="headerlink" title="数据库优化（重要重要！）"></a><strong>数据库优化（重要重要！）</strong></h2><p><strong>定位低效原因方式</strong></p><p>·</p><h3 id="定位低效率的SQL查询语句"><a href="#定位低效率的SQL查询语句" class="headerlink" title="定位低效率的SQL查询语句"></a><strong>定位低效率的SQL查询语句</strong></h3><p><strong>explain分析执行计划</strong></p><p><strong><figure class="image-box">                <img src="image-20210307171257288.png" alt="image-20210307171257288" title class>                <p>image-20210307171257288</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307173624838.png" alt="image-20210307173624838" title class>                <p>image-20210307173624838</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307181719755.png" alt="image-20210307181719755" title class>                <p>image-20210307181719755</p>            </figure></strong></p><p><strong>show profile：显示对应Query ID在每个阶段的耗时情况</strong></p><h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a><strong>优化手段</strong></h3><p><strong>联合索引：</strong></p><p><strong>为什么要使用联合索引？</strong></p><blockquote><ul><li><strong>减少开销。建一个联合索引 <code>(col1,col2,col3)</code>，实际相当于建了 <code>(col1)</code>，<code>(col1,col2)</code>，<code>(col1,col2,col3)</code> 三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</strong></li><li><strong>覆盖索引。对联合索引 <code>(col1,col2,col3)</code>，如果有如下的 SQL：<code>select col1,col2,col3 from test where col1=1 and col2=2;</code>。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 IO 操作。减少 IO 操作，特别的随机 IO 其实是 DBA 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</strong></li><li><strong>效率高。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 SQL：<code>select from table where col1=1 and col2=2 and col3=3</code>，假设假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 1000W10%=100w 条数据，然后再回表从 100w 条数据中找到符合 col2=2 and col3=3 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出 1000w <em> 10% </em> 10% * 10% =1w，效率提升可想而知！</strong></li></ul></blockquote><p><strong>批量插入数据</strong></p><p><strong>索引维护列数据有序导入效率比无序数据效率高。</strong></p><blockquote><p><strong>插入数据时需要维护索引树，有序数据的索引树创建的更快。</strong></p></blockquote><p><strong>关闭唯一性校验</strong></p><blockquote><p><strong>当插入时，Mysql会对主键进行唯一性校验，关闭唯一性校验以后，插入数据时不需要唯一性校验主键，效率提高。</strong></p></blockquote><p><strong>手动提交事务</strong></p><p><strong>聚合函数（常用）</strong></p><p><strong><figure class="image-box">                <img src="image-20210308031636317.png" alt="image-20210308031636317" title class>                <p>image-20210308031636317</p>            </figure></strong></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h3><p><strong><figure class="image-box">                <img src="image-20210309052439562.png" alt="image-20210309052439562" title class>                <p>image-20210309052439562</p>            </figure></strong></p><h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a><strong>应用优化</strong></h3><p><strong><figure class="image-box">                <img src="image-20210309061028463.png" alt="image-20210309061028463" title class>                <p>image-20210309061028463</p>            </figure></strong></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><p><strong>慢查询日志</strong></p><p><strong>show proceslist：查看实时的SQL语句执行情况</strong></p><p><strong><figure class="image-box">                <img src="image-20210307171113409.png" alt="image-20210307171113409" title class>                <p>image-20210307171113409</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307171134186.png" alt="image-20210307171134186" title class>                <p>image-20210307171134186</p>            </figure></strong></p><p><strong>binlog、undolog</strong></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p><strong>为了保证事务的持久性</strong>，mysql的InnoDB采用了WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。<br> 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。<br> InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><figure class="image-box">                <img src="webp.webp" alt="img" title class>                <p>img</p>            </figure><p> write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。<br> <strong>为什么会有两份日志呢？</strong>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><h2 id="DDL、DML、DCL、TCL"><a href="#DDL、DML、DCL、TCL" class="headerlink" title="DDL、DML、DCL、TCL"></a>DDL、DML、DCL、TCL</h2><p>DDL（Data Definition Languages）语句：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME。增删改表的结构</p><p>DML（Data Manipulation Language）语句：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE,包括通用性的增删改查。增删改表的数据</p><p>DCL（Data Control Language）语句：即数据控制语句，用于授权/撤销数据库及其字段的权限（DCL is short name of Data Control Language which includes commands such as GRANT and mostly concerned with rights, permissions and other controls of the database system.）。常用的语句关键字有：GRANT,REVOKE。</p><p>TCL（Transaction Control Language）语句：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION。</p><h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a><strong>主从复制的原理</strong></h2><p>首先放一张Mysql主从复制的原理图，总的来说Mysql的主从复制原理还是比较好理解的，原理非常的简单。</p><p><img src="v2-12f36a0aa2ea88020809173182e54e73_b.jpg" alt="img" style="zoom:67%;"></p><p>Mysql的主从复制中主要有三个线程：<code>master（binlog dump thread）、slave（I/O thread 、SQL thread）</code>，Master一条线程和Slave中的两条线程。</p><p><code>master（binlog dump thread）</code>主要负责Master库中有数据更新的时候，会按照<code>binlog</code>格式，将更新的事件类型写入到主库的<code>binlog</code>文件中。</p><p>并且，Master会创建<code>log dump</code>线程通知Slave主库中存在数据更新，这就是为什么主库的binlog日志一定要开启的原因。</p><p><code>I/O thread</code>线程在Slave中创建，该线程用于请求Master，Master会返回binlog的名称以及当前数据更新的位置、binlog文件位置的副本。</p><p>然后，将<code>binlog</code>保存在 <strong>「relay log（中继日志）」</strong> 中，中继日志也是记录数据更新的信息。</p><p>SQL线程也是在Slave中创建的，当Slave检测到中继日志有更新，就会将更新的内容同步到Slave数据库中，这样就保证了主从的数据的同步。</p><p>以上就是主从复制的过程，当然，主从复制的过程有不同的策略方式进行数据的同步，主要包含以下几种：</p><ol><li><strong>「同步策略」</strong>：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。</li><li><strong>「半同步策略」</strong>：Master至少会等待一个Slave回应后提交。</li><li><strong>「异步策略」</strong>：Master不用等待Slave回应就可以提交。</li><li><strong>「延迟策略」</strong>：Slave要落后于Master指定的时间。</li></ol><h1 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><p><strong>八大数据类型：</strong></p><ul><li><strong>string：最基本的数据类型，二进制安全的字符串，最大512M</strong></li><li><strong>list：按照添加顺序保持顺序的 字符串列表</strong></li><li><strong>set：无序的字符串集合，不存在重复的元素</strong></li><li><strong>sorted set：已排序的字符串集合</strong></li><li><strong>hash：key/value对的一种集合</strong></li></ul><p><strong>string（字符串）</strong></p><p><strong>二进制安全</strong></p><p><strong>可以包含任何数据，比如jpg图片或者序列化对象</strong></p><p><strong>Hash（字典）</strong></p><p><strong>键值对集合，即编程语言中的map类型</strong></p><p><strong>适合存储对象，并且可以像数据库中的update一个属性一样只修改某一项属性值</strong></p><p><strong>存储、读取、修改用户属性</strong></p><p><strong>List（列表）</strong></p><p><strong>链表（双向链表）</strong></p><p><strong>增删快，提供了操作某一元素的api</strong></p><p><strong>最新消息排行；消息队列</strong></p><p><strong>set（无重复集合）</strong></p><p><strong>hash表实现，元素不重复</strong></p><p><strong>添加、删除、查找的复杂度都是O(1)，提供了求交集、并集、差集的操作</strong></p><p><strong>共同好友；利用唯一性，统计访问网站的所有Ip</strong></p><p><strong>Zset（自动排序无重复集合）</strong></p><p><strong>ZSet可以实现有序性操作，从而实现排行榜等功能；（以访问量为分数进行排列）</strong></p><hr><hr><p><strong>Redis的优势</strong></p><ul><li><strong>速度快。因为数据存储于内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</strong></li><li><strong>支持丰富的数据类型，支持string，list，set，sorted set，hash</strong></li><li><strong>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</strong></li><li><strong>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</strong></li></ul><p><strong>Redis为什么这么快？</strong></p><p><strong>第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。第二：数据结构简单，对数据操作也简单。第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。第四：使用多路复用IO模型，非阻塞IO。</strong></p><hr><h2 id="缓存产生的问题"><a href="#缓存产生的问题" class="headerlink" title="缓存产生的问题"></a><strong>缓存产生的问题</strong></h2><p><strong>缓存穿透：</strong></p><blockquote><p><strong>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</strong></p></blockquote><p><strong>如何避免？</strong></p><ol><li><strong>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</strong></li><li><strong>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</strong></li></ol><hr><p><strong>缓存雪崩</strong></p><blockquote><p><strong>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。</strong></p><p><strong>目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</strong></p></blockquote><p><strong>如何避免？</strong></p><ol><li><strong>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</strong></li><li><strong>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong></li></ol><hr><h2 id="Redis内存回收机制"><a href="#Redis内存回收机制" class="headerlink" title="Redis内存回收机制"></a><strong>Redis内存回收机制</strong></h2><p><strong>Redis的内存回收主要围绕以下两个方面：</strong></p><ol><li><strong><a href="#1">Redis过期策略</a>：删除过期时间的key值</strong></li><li><strong><a href="#2">Redis淘汰策略</a>：内存使用到达maxmemory上限时触发内存淘汰数据</strong></li></ol><p><strong>Redis过期策略<a name="1"></a></strong></p><p><strong>Redis过期策略通常有以下三种：</strong></p><ol><li><strong>定时过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</strong></li><li><strong>惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</strong></li><li><strong>定期过期 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</strong></li></ol><p><strong>【Redis中同时使用了惰性过期和定期过期两种过期策略。】</strong></p><p><strong>Q:Redis key的过期时间和永久有效分别怎么设置？</strong></p><blockquote><p><strong><code>EXPIRE</code>和<code>PERSIST</code>命令。</strong></p></blockquote><hr><p><strong>Redis有哪几种数据淘汰策略<a name="2"></a></strong></p><p><strong>在Redis中，允许用户设置最大使用内存大小<code>server.maxmemory</code>，当Redis内存数据集大小上升到一定大小的时候，就会执行数据淘汰策略</strong></p><ul><li><strong>volatile-lru：从已设置过期的数据集中挑选最近最少使用的淘汰</strong></li><li><strong>volatile-ttl：从已设置过期的数据集中挑选将要过期的数据淘汰</strong></li><li><strong>volatile-random：从已设置过期的数据集中任意挑选数据淘汰</strong></li><li><strong>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</strong></li><li><strong>allkeys-random：从数据集中任意挑选数据淘汰</strong></li><li><strong>noenviction：禁止淘汰数据</strong></li></ul><h2 id="02-redis是单线程还是多线程"><a href="#02-redis是单线程还是多线程" class="headerlink" title="02.redis是单线程还是多线程"></a>02.redis是单线程还是多线程</h2><p>1, 无论什么版本,工作线程就是一个</p><p>2, 6.x高版本出现了IO多线程</p><p>3,使用上来说,没有变化</p><hr><p>4, [去学一下系统IO课],你要真正的理解面向IO模型编程的时候,有内核的事,从内核把数据搬运到程序里这是第一步,然后,搬运回来的数据做的计算是第二步,netty</p><p>5,单线程,满足redis的串行原子,只不过IO多线程后,把输入/输出放到更多的线程里去并行,好处如下: 1,执行时间短,更快; 2,更好的压榨系统及硬件的资源(网卡能够高效的使用);</p><p>*,客户端被读取的顺序不能被保障<br>哪个顺序是可以被保障的: 在一个连接里,socket里</p><p>6.x以前</p><figure class="image-box">                <img src="image-20210309122215735.png" alt="6.x以前" title class>                <p>6.x以前</p>            </figure>缓存不严谨,尽量去分片<br><br><br><br><br><br> 6.x以后<br><br><figure class="image-box">                <img src="image-20210309123037436.png" alt="6.x以后" title class>                <p>6.x以后</p>            </figure><h1 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h1><h1 id="redis的分布式布隆过滤器"><a href="#redis的分布式布隆过滤器" class="headerlink" title="redis的分布式布隆过滤器"></a>redis的分布式布隆过滤器</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>老顾先来举个常会问到的面试题：现有<strong>50亿个电话号码，现有10万个电话号码</strong>，如何要<strong>快速准确的判断这些电话号码是否已经存在？</strong></p><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-f078b9444162b88f79ea8cf98063ab5e_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上面的问题可以细化一下，也就是50亿个电话号码在数据库中，现在要<strong>快速、准确</strong>的判断提供的10万个电话号码是否存在。</p><p>我们小伙伴们是否脑子中会有以下方案：</p><figure class="image-box">                <img src="v2-be68dbd9576a4d485574703f606e786b_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>实际项目中也会遇到类似的问题，如垃圾邮件过滤、网络爬虫重复url检测等，<strong>本质就是判断数据存不存在一个大的集合中。</strong></p><p>那如何去解决呢？这就是我们今天老顾要介绍的布隆过滤器方案，我们继续往下看。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是<strong>一种类似set的数据结构</strong>，只是不太准确，当判断元素<strong>是否存在时返回结果存在但真实不一定存在</strong>；当<strong>返回不存在时肯定是不存在</strong>，所以判断去重时有一定的误判概率。</p><blockquote><p>当然，误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判。</p></blockquote><p><strong>特点：高效地插入和查询，占用空间少，返回的结果是不确定性的。</strong></p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>这个是由柏顿.布隆在1970年提出，<strong>用很小的空间，解决上述的类似问题。</strong></p><p>实现原理就是我们需要一个<strong>很长的二进制数组（也叫向量）</strong>；在添加数据时，使用<strong>多个hash函数对key进行hash运算得到一个索引值（即二进制数组的索引值）</strong></p><figure class="image-box">                <img src="v2-984115177dfcb0ec6c61d78360bc6c3b_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上图中，下面是很长的二进制数组，第二层就是多个hash函数，再上面就是数据。</p><figure class="image-box">                <img src="v2-43a8efe34ad3a8e72d182ed2b645af61_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上图中，每个数据经过多个hash函数计算，得到索引值，并把<strong>二进制数组对应的索引值那边设置为1，我们发现经过三次hash</strong>，<strong>就会在三个索引的地方设置为1，也就是代表此数据存在。</strong></p><h2 id="布隆过滤器误差"><a href="#布隆过滤器误差" class="headerlink" title="布隆过滤器误差"></a>布隆过滤器误差</h2><p><strong>空间占用</strong></p><p>布隆过滤器的空间占用有一个简单的计算公式，但推导比较繁琐。布隆过滤器有两个参数，<strong>预计元素数量n</strong>，错误率f，公式得到两个输出，<strong>位数组长度L（即存储空间大小bit）</strong>，hash函数的最佳数量k。</p><p>k = 0.7*(1/n)<br>f = 0.6185^(L/n)</p><figure class="image-box">                <img src="v2-d0db1392f878a2898eec29647f6ce17d_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>实际元素超出时</strong></p><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-2920bb0c45ccd76f6d1bca22ae9463e2_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>以上小伙伴们只要知道会存在误差就行了，不需要强求是怎么计算的。</p><h2 id="Redis布隆过滤器的基本使用"><a href="#Redis布隆过滤器的基本使用" class="headerlink" title="Redis布隆过滤器的基本使用"></a>Redis布隆过滤器的基本使用</h2><p>在Redis中，布隆过滤器有两个基本命令，分别是：</p><ul><li><strong>bf.add</strong>：<strong>添加元素到布隆过滤器中</strong>，类似于集合的<strong>sadd</strong>命令，不过<strong>bf.add</strong>命令只能一次添加一个元素，如果想一次添加多个元素，可以使用<strong>bf.madd</strong>命令。</li><li><strong>bf.exists</strong>：<strong>判断某个元素是否在过滤器中</strong>，类似于集合的<strong>sismember</strong>命令，不过<strong>bf.exists</strong>命令只能一次查询一个元素，如果想一次查询多个元素，可以使用<strong>bf.mexists</strong>命令。</li></ul><figure class="image-box">                <img src="v2-592b76212a0848532ad61843440bbbe7_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="布隆过滤器的高级使用"><a href="#布隆过滤器的高级使用" class="headerlink" title="布隆过滤器的高级使用"></a>布隆过滤器的高级使用</h2><p>上面的例子中使用的布隆过滤器<strong>只是默认参数的布隆过滤器</strong>，它在我们第一次使用 bf.add 命令时自动创建的。Redis还提供了<strong>自定义参数的布隆过滤器</strong>，想要尽量减少布隆过滤器的误判，就要设置合理的参数。</p><p>在使用 <strong>bf.add</strong> 命令添加元素之前，<strong>使用bf.reserve</strong> <strong>命令创建一个自定义的布隆过滤器</strong>。<strong>bf.reserve</strong>命令有三个参数，分别是：</p><ul><li><strong>key</strong>：键</li><li><strong>error_rate</strong>：期望错误率，期望错误率越低，需要的空间就越大。</li><li><strong>capacity</strong>：初始容量，当实际元素的数量超过这个初始化容量时，误判率上升。</li></ul><p>比如：</p><figure class="image-box">                <img src="v2-4e8ffdee45bb0ca9a570c617ea83a3ed_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><blockquote><p>如果对应的key已经存在时，在执行bf.reserve命令就会报错。如果不使用bf.reserve命令创建，而是使用Redis自动创建的布隆过滤器，默认的error_rate是 0.01，capacity是 100。</p></blockquote><p>布隆过滤器的<strong>error_rate</strong> 越小，需要的存储空间就越大，对于不需要过于精确的场景，<strong>error_rate</strong>设置稍大一点也可以。布隆过滤器的<strong>capacity</strong>设置的过大，会浪费存储空间，设置的过小，就会影响准确率，所以在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出设置值很多。总之，<strong>error_rate</strong>和<strong>capacity</strong>都需要设置一个合适的数值。</p><h2 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h2><p><strong>解决缓存穿透的问题</strong></p><p>一般情况下，<strong>先查询缓存是否有该条数据，缓存中没有时，再查询数据库。</strong>当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。缓存穿透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。</p><p>可以使用布隆过滤器解决缓存穿透的问题，<strong>把已存在数据的key存在布隆过滤器中。当有新的请求时，先到布隆过滤器中查询是否存在，如果不存在该条数据直接返回</strong>；如果存在该条数据再查询缓存查询数据库。</p><p><strong>黑名单校验</strong></p><p>发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。<strong>把所有黑名单都放在布隆过滤器中，再收到邮件时，判断邮件地址是否在布隆过滤器中即可。</strong></p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP四层模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层（Application）</td><td>应用层</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td>表示层（Presentation）</td><td>Telnet, Rlogin, SNMP, Gopher</td><td></td></tr><tr><td>会话层（Session）</td><td>SMTP, DNS</td><td></td></tr><tr><td>传输层（Transport）</td><td>传输层</td><td>TCP, UDP</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP, ICMP, ARP, RARP, AKP, UUCP</td></tr><tr><td>数据链路层（Data Link）</td><td>数据链路层</td><td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td></tr><tr><td>物理层（Physical）</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802.11</td></tr></tbody></table><h2 id="在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a><strong>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</strong></h2><p><strong>总体来说分为以下几个过程:</strong></p><ol><li><strong>DNS解析</strong></li><li><strong>TCP连接</strong></li><li><strong>发送HTTP请求</strong></li><li><strong>服务器处理请求并返回HTTP报文</strong></li><li><strong>浏览器解析渲染页面</strong></li><li><strong>连接结束</strong></li></ol><p><strong>具体可以参考下面这篇文章：</strong></p><p><strong>假设输入的URL是包含域名的，那肯定会涉及到DNS解析。当然，如果URL仅仅是IP，那就不会涉及到DNS的。域名的出现是为了方便记忆，因为域名比IP好记。我们这里假设URL包含域名。</strong></p><p><strong>解析的步骤大致如下图：</strong></p><p><strong><figure class="image-box">                <img src="1249-20181201164228952-1248762918.png" alt="img" title class>                <p>img</p>            </figure></strong></p><hr><p><strong>首先，在本地域名服务器中根据域名查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求。</strong></p><p><strong>如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器（TLD）发送一个请求，依次类推下去。</strong></p><p><strong>直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。</strong></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a><strong>TCP/IP协议</strong></h2><p> <img src="image-20210404234920439.png" alt="image-20210404234920439" style="zoom: 80%;"></p><p>​    </p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h3><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><table><thead><tr><th></th><th><strong>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</strong></th></tr></thead><tbody><tr><td></td><td><strong>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</strong></td></tr><tr><td></td><td><strong>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</strong></td></tr></tbody></table><p><strong>TCP三次握手的Socket过程</strong></p><hr><p><strong><figure class="image-box">                <img src="clip_image001-1605197589861-1613496648112.png" alt="640?wx_fmt=png" title class>                <p>640?wx_fmt=png</p>            </figure></strong></p><hr><ul><li><p><strong>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待；</strong></p></li><li><p><strong>客户端Socket对象调用connect()向服务器发送了一个SYN并阻塞；</strong></p></li><li><p><strong>服务器完成了第一次握手，即发送SYN和ACK应答；</strong></p></li><li><p><strong>客户端收到服务端发送的应答之后，从connect()返回，再发送一个ACK给服务器；</strong></p></li><li><p><strong>服务器Socket对象接收客户端第三次握手ACK确认，此时服务端从accept()返回，建立连接。</strong></p></li></ul><hr><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h3><table><thead><tr><th></th><th><strong>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</strong></th></tr></thead><tbody><tr><td></td><td><strong>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</strong></td></tr><tr><td></td><td><strong>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</strong></td></tr><tr><td></td><td><strong>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</strong></td></tr></tbody></table><hr><ol><li>第一次挥手，客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。</li><li>第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。</li><li>第三次挥手，服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</li><li>第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，<strong>客户端等待2MSL（指一个片段在网络中最大的存活时间）</strong>后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。四次挥手</li></ol><p><strong>四次挥手释放连接时，等待2MSL的意义？</strong></p><blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间<code>等待计时器</code>。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p><strong>为什么要三次握手</strong></p><ul><li><strong>三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主     要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。</strong></li><li><strong>第⼀次握⼿：Client     什么都不能确认；Server 确认了对⽅发送正常，⾃⼰接收正常</strong></li><li><strong>第⼆次握⼿：Client     确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：对⽅发送 正常，⾃⼰接收正常</strong></li><li><strong>第三次握⼿：Client     确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：⾃⼰发 送、接收正常，对⽅发送、接收正常</strong></li><li><strong>所以三次握⼿就能确认双发收发功能都正常，缺⼀不可。</strong></li></ul><hr><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h2><p><strong>UDP通讯协议的特点</strong></p><hr><ul><li><strong>将数据封装为数据包。面向无连接。</strong></li><li><strong>每个数据包大小限制在64K。</strong></li><li><strong>因为无连接，所以不可靠。</strong></li><li><strong>因为不需要建立连接，所以速度快。</strong></li><li><strong>UDP通讯是不分服务端和客服端的，只分发送端和接收端。</strong></li><li><strong>在UDP协议中，有一个IP地址称作为广播地址，广播地址就是主机号为255的地址。给广播地址发送消息时，在同一个网络段的机器都可以接收到信息。</strong></li><li><strong>UDP是一个不可靠（数据包可能会丢失）的协议。如一下情况：</strong></li></ul><h2 id="TCP拥塞避免算法"><a href="#TCP拥塞避免算法" class="headerlink" title="TCP拥塞避免算法"></a><strong>TCP拥塞避免算法</strong></h2><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a><strong>慢开始算法</strong></h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p><p><img src="v2-54715533f093170d50f1ff1be39006e9_720w.jpg" alt="img"></p><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a><strong>拥塞避免算法</strong></h3><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p><img src="17384f11ea6ed5fc" alt="img" style="zoom:67%;"></p><p>拥塞避免</p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p><blockquote><p>发生超时重传的拥塞发生算法</p></blockquote><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，sshresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code></li></ul><p><img src="17384f11ff07e074" alt="img" style="zoom: 50%;"></p><p><strong>拥塞发送 —— 超时重传</strong></p><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><p><strong>重传机制</strong></p><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p><img src="17384f114569c301" alt="img" style="zoom:50%;"></p><p>正常的数据传输</p><p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p><p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><p>接下来说说常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a><strong>超时重传</strong></h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><img src="17384f1143f3adb1" alt="img" style="zoom: 50%;"></p><p><strong>RTT</strong></p><p><code>RTT</code> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</p><p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p><p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p><p><img src="17384f115f970fd0" alt="img" style="zoom: 67%;"></p><p>超时时间较长与较短</p><p>上图中有两种超时时间不同的情况：</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p><p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p><p><img src="17384f1163667495" alt="img" style="zoom:50%;"></p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><strong>快速重传</strong></h3><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p><p><img src="17384f116656218a" alt="img" style="zoom:67%;"></p><p>快速重传机制</p><p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）</li><li>重传丢失的数据包</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1</li><li>如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法</li></ul><p><img src="17384f12005eb183" alt="img" style="zoom: 50%;"></p><p>快速重传和快速恢复</p><p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><strong>滑动窗口</strong></h2><blockquote><p>“ 引入窗口概念的原因<br>”</p></blockquote><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p><p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p><p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p><p><img src="v2-d388476be4c044b1f0c055ad1b61d543_720w.jpg" alt="img" style="zoom:67%;"></p><p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="v2-719ef8746c5e323e13f7e28ca8709b81_720w.jpg" alt="img" style="zoom:67%;"></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><blockquote><p>“ 窗口大小由哪一方决定？<br>”</p></blockquote><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p><p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><blockquote><p>“ 发送方的滑动窗口<br>”</p></blockquote><p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p><figure class="image-box">                <img src="v2-dab1fd117460ca012080fdb52a99f847_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p><figure class="image-box">                <img src="v2-d486cc3872e9873ab2a646cd6908f739_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p><figure class="image-box">                <img src="v2-609be3306d058eafc9a45c89adb21840_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h2><p><strong><figure class="image-box">                <img src="be714471b75a4e901581ffb719981796.jpg" alt="状态码" title class>                <p>状态码</p>            </figure></strong></p><p><strong>常见状态码</strong>：</p><ul><li>200 OK - 客户端请求成功</li><li>206 部分成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>302 - 临时跳转</li><li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>404 - 请求资源不存在，可能是输入了错误的URL</li><li>500 - 服务器内部发生了不可预期的错误</li><li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><p>转发和重定向的区别</p><p> 转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址 栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p><p> 重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动 跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><p><strong>HTTP特点</strong></p><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><p><strong>HTTP的缺点：</strong></p><ol><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报文的完整性，所以有可能已遭篡改。</li></ol><blockquote><p><strong>HTTP持久连接</strong><br>如果有大量的连接，每次在连接，关闭都要经历三次握手，四次挥手，这显然会造成性能低下。因此。Http 有一种叫做 长连接（keepalive connections） 的机制。它可以在传输数据后仍保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次握手。</p></blockquote><figure class="image-box">                <img src="v2-e051b1ebaa5217a4e902a754523650d0_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>HTTPS</strong></p><p>​</p><p><img src="v2-a994fbf3094d737814fe01c2b919477b_720w.jpg" alt="img"></p><p><img src="v2-169338067adce8c5da0aeca08a04db1c_720w.jpg" alt="img"></p><p><strong>服务端证书通过CA机构签名认证的过程如下</strong></p><figure class="image-box">                <img src="v2-f6dc4107ba6149196895eb55ad210333_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p><strong>对称加密</strong></p><blockquote><p>简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。</p></blockquote><figure class="image-box">                <img src="v2-1252526c263ee50c47b7b49bd1c2ef44_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>用对称加密可行吗？</strong></p><p><strong>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</strong></p><p>然而最大的问题就是<strong>这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。</p><p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行了！这么做显然不现实。<br>怎么办？所以我们就需要<strong><code>非对称加密</code></strong> 。</p><p><strong>什么是非对称加密？</strong></p><p>简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p><figure class="image-box">                <img src="v2-1589bbfab027eb9f52da03c02a837fd4_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步?何为阻塞与非阻塞?二者的区别在哪里?阻塞在何处?为什么会有多种IO模型，分别用来解决问题?常用的框架采用的是何种I/O模型?各种IO模型的优劣势在哪里，适用于何种应用场景?</p><p>简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。</p><h2 id="I-O-的定义"><a href="#I-O-的定义" class="headerlink" title="I/O 的定义"></a>I/O 的定义</h2><p>I/O 的全称是Input/Output。虽常谈及I/O，但想必你也一时不能给出一个完整的定义。搜索了谷歌，发现也尽是些冗长的论述。要想理清I/O这个概念，我们需要从不同的视角去理解它。</p><p><strong>计算机视角</strong></p><p>冯•诺伊曼计算机的基本思想中有提到计算机硬件组成应为五大部分：控制器，运算器，存储器，输入和输出。其中输入是指将数据输入到计算机的设备，比如键盘鼠标;输出是指从计算机中获取数据的设备，比如显示器;以及既是输入又是输出设备，硬盘，网卡等。</p><p>用户通过操作系统才能完成对计算机的操作。计算机启动时，第一个启动的程序是操作系统的内核，它将负责计算机的资源管理和进程的调度。换句话说：操作系统负责从输入设备读取数据并将数据写入到输出设备。</p><p>所以I/O之于计算机，有两层意思：</p><ol><li>I/O设备</li><li>对I/O设备的数据读写</li></ol><p>对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为磁盘I/O，网络I/O(一次网络的请求响应，网卡)等。</p><p><strong>程序视角</strong></p><p>应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程API等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。</p><p>因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为内核空间(内核对应进程所在内存空间)和用户空间，进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。</p><p>但操作系统向外提供API，其由各种类型的系统调用(System Call)组成，以提供安全的访问控制。所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的系统调用(system call)进行间接访问。</p><p>所以I/O之于应用程序来说，强调的通过向内核发起系统调用完成对I/O的间接访问。换句话说应用程序发起的一次IO操作实际包含两个阶段：</p><ol><li>IO调用阶段：应用程序进程向内核发起系统调用</li><li>IO执行阶段：内核执行IO操作并返回</li></ol><p>准备数据阶段：内核等待I/O设备准备好数据</p><p>拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</p><p>怎么理解准备数据阶段呢?对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区;对于读请求：等待系统调用的完整请求数据;(若请求数据不存在于内核缓冲区)则将外围设备的数据读入到内核缓冲区。</p><p><img src="v2-0fe981d52109a6eec954a4f19813ecb7_1440w.jpg" alt="img"></p><p>而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题阻塞IO与非阻塞IO。</p><h2 id="IO-模型之阻塞I-O-BIO"><a href="#IO-模型之阻塞I-O-BIO" class="headerlink" title="IO 模型之阻塞I/O(BIO)"></a>IO 模型之阻塞I/O(BIO)</h2><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。阻塞IO简称BIO，Blocking IO。其处理流程如下图所示：</p><p><img src="v2-0f788eddca6f6fe20841bf8544e2ec62_1440w.jpg" alt="  "></p><p>从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间用户调用线程选择阻塞等待数据返回。</p><p>因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是阻塞二字。</p><h2 id="IO-模型之非阻塞I-O-NIO"><a href="#IO-模型之非阻塞I-O-NIO" class="headerlink" title="IO 模型之非阻塞I/O(NIO)"></a>IO 模型之非阻塞I/O(NIO)</h2><p>那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：</p><p><strong>内核select轮询套接字</strong></p><p><img src="v2-707bb073ca8a4bbdbba9ccd0a5e58645_1440w.jpg" alt="img"></p><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。</p><p><strong>缺陷：</strong></p><p>然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那NIO问题的本质就是频繁轮询导致的无效系统调用。</p><ol><li>空循环，无意义循环</li><li>JAVA–JVM–OS</li></ol><h2 id="IO模型之IO多路复用"><a href="#IO模型之IO多路复用" class="headerlink" title="IO模型之IO多路复用"></a>IO模型之IO多路复用</h2><p>解决NIO的思路就是降解无效的系统调用，如何降解呢?我们一起来看看以下几种IO多路复用的解决思路。</p><p>IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符(如socket)，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核kernel能够通知程序进行相应的IO系统调用。</p><p>目前支持IO多路复用的系统调用，有 select，epoll等等。select系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll是在linux 2.6内核中提出的，是select系统调用的linux增强版本。而Java NIO库中的 <strong>selector</strong> 底层就是IO多用复用技术。</p><p><strong>IO多路复用之select/poll</strong></p><p>Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态，当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。其IO流程如下所示：</p><p><img src="v2-80a46760bcf7751b65c52c174513fec9_1440w.jpg" alt="img"></p><p>但是，select有一个限制，就是存在连接数限制，针对于此，又提出了poll。其与select相比，主要是解决了连接限制。</p><p>select/epoll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：</p><p>用户空间和内核空间之间，大量的数据拷贝</p><p>内核循环遍历IO状态，浪费CPU时间</p><p>换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：内核存在无效的循环遍历。</p><p><strong>IO多路复用之epoll</strong></p><p>针对select/pool引入的问题，我们把解决问题的思路转回到内核上，如何减少内核重复无效的循环遍历呢?变主动为被动，基于事件驱动来实现。其流程图如下所示：</p><p><img src="v2-cd3810718115195b6b0948ec30bf33e0_1440w.jpg" alt="img"></p><p>epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。</p><p><img src="v2-989c77a28bae71276916fc4ec20638b1_1440w.jpg" alt="img"></p><p>epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：数据准备阶段都还是被阻塞的。所以这是一个可以继续优化的点。</p><p>“多路”是指：服务器端同时监听多个“端口”的情况。每个端口都要监听多个客户端的连接。<br>服务器端的非多路复用效果</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzQyMA==,size_16,color_FFFFFF,t_70.png" alt="img" title class>                <p>img</p>            </figure><p>服务器端的多路复用效果</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzQyMA==,size_16,color_FFFFFF,t_70.png" alt="img" title class>                <p>img</p>            </figure><p>选择器Selector<br>Selector被称为：选择器，也被称为：多路复用器，它可以注册到很多个Channel上，监听各个 Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个 Channel，就可以处理大量网络连接了。 有了Selector，我们就可以利用一个线程来处理所有的Channels。线程之间的切换对操作系统来说代价 是很高的，并且每个线程也会占用一定的系统资源。所以，对系统来说使用的线程越少越好。</p><h2 id="IO-模型之信号驱动IO-SIGIO"><a href="#IO-模型之信号驱动IO-SIGIO" class="headerlink" title="IO 模型之信号驱动IO(SIGIO)"></a>IO 模型之信号驱动IO(SIGIO)</h2><p>信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信的号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。</p><p><img src="v2-ea392e66039a354515f63863c5f36e25_1440w.jpg" alt="img"></p><p>乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的。</p><p>综上，你会发现，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。那如果能将IO执行的第二阶段变成非阻塞，那就完美了。</p><h2 id="IO-模型之异步IO-AIO"><a href="#IO-模型之异步IO-AIO" class="headerlink" title="IO 模型之异步IO(AIO)"></a>IO 模型之异步IO(AIO)</h2><p>异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程IO操作执行完毕(与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕)。其流程如下：</p><p><img src="v2-230080fe14c7d68630a96bbbf36aca99_1440w.jpg" alt="img"></p><p>所以，之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO。</p><p><img src="v2-3984144fcdb6a880a6512bcf2b29396d_1440w.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理完这些IO模型后，之前一直处于懵懂状态的阻塞，非阻塞，同步异步IO，终于算是有个概念了。同时也纠正了自己一直以来的误解，所以一路走来，愈发觉得返璞归真的重要性，只有如此，才能在快速更迭的技术演进中，以不变应万变。</p><p>回顾 BIO，NIO，多路复用器</p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#1__4" target="_blank" rel="noopener">1. 计组知识</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#2_BIO_10" target="_blank" rel="noopener">2. BIO</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#3_NIO_49" target="_blank" rel="noopener">3. NIO</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#4__112" target="_blank" rel="noopener">4. 多路复用器</a></p><blockquote><p><strong>回顾一下BIO，NIO，多路复用器</strong></p><p>————————————————————————————————————</p><figure class="image-box">                <img src="20200612204735300.png" alt="img" title class>                <p>img</p>            </figure></blockquote><h1 id="1-计组知识"><a href="#1-计组知识" class="headerlink" title="1. 计组知识"></a>1. 计组知识</h1><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70" alt="img" title class>                <p>img</p>            </figure><p><strong>cpu</strong></p><p>首先计算机的组成肯定有<strong>cpu</strong>，他是核心的处理器，然后有内存，你的所有程序都需要加载到内存中，才能和cpu进行交互，比如Java就是通过ClassLoader将字节码.class文件加载到内存中再执行的。</p><p><strong>计算机内核</strong></p><p>他也是一个程序，属于操作系统的核心程序，<strong>是基于硬件的第一层软件扩充，提供操作系统的最基本的功能</strong>，我们在操作系统上启动的程序最终都要调用cpu执行操作，而为了系统安全和效率，不能让机器上的程序自己去直接随意操作底层硬件，必须都通过内核来完成对系统底层硬件的使用调度，简称<strong>系统调用</strong>。内核在内存中有独立安全的地址空间，使用保护模式和用户空间隔离开来，保护和统一管理系统调用。</p><p><strong>中断</strong></p><p>假如我们只有一颗cpu，则同时只能运行一个程序(application)，但是由于程序间切换很快，感觉起来就像多个程序属于并行状态，而何时停止当前程序，去调用其它程序，就依靠着<strong>中断</strong>，中断有外部中断，例如电子电路中的<strong>晶振</strong>带来的时钟中断，也有内部中断，例如<strong>程序回调中断</strong>。附上一个比较详细的中断说明链接，这里不再阐述：<a href="https://blog.csdn.net/jadeshu/article/details/100176917" target="_blank" rel="noopener">CPU中断</a></p><h1 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2. BIO"></a>2. BIO</h1><p><strong><em>\</em>BIO (blocking I/O)： 同步阻塞I/O模型**</strong></p><p>我们主要来看一下Java代码中BIO的实现(底层实现是依靠内核提供的<strong>阻塞IO系统调用</strong>)，上代码(这些都是在<strong>Java IO</strong>包中的，基于<strong>ServerSocket</strong>和<strong>Socket</strong>)</p><figure class="image-box">                <img src="20200612215259479.png" alt="img" title class>                <p>img</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">*// 这里是服务端的程序实现，主线程接收客户端连接，将每一个客户端连接放入clone的一个子线程中(这里的clone是底层的系统调用)*</span><br><span class="line"></span><br><span class="line">*// 绑定端口7777并监听 bind→listen*</span><br><span class="line"></span><br><span class="line">ServerSocket serverSocket = new ServerSocket(7777);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;服务端启动...&quot;);</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">*// serverSocket.accept()方法是阻塞等待客户端连接，*</span><br><span class="line"></span><br><span class="line">*// 没有客户端连接就一直等待，直到有客户端接入*</span><br><span class="line"></span><br><span class="line">*// 有接入后返回接入的客户端socket*</span><br><span class="line"></span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;客户端连接...&quot;);</span><br><span class="line"></span><br><span class="line">*// 客户端接入之后需要将其连接放入到一个线程中去处理后续的数据读取操作，*</span><br><span class="line"></span><br><span class="line">*// 因为读取操作也是一个阻塞的等待状态，客户端可能一会给你发消息，一会不发，*</span><br><span class="line"></span><br><span class="line">*// 如果不开启子线程，则此时服务器就只能阻塞等待客户端发信息，无法接入其他客户端*</span><br><span class="line"></span><br><span class="line">*// 相当于这个一个服务器只能接入一个客户端，这显然是不符合常理的*</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">*// 获取客户端输入流*</span><br><span class="line"></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">*// is.read() 也是阻塞方法，子线程在此等待客户端输入...*</span><br><span class="line"></span><br><span class="line">​      int clientData = is.read(b);</span><br><span class="line"></span><br><span class="line">*// ...*</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>我们说BIO是<strong>同步阻塞I/O模型</strong>，这里同步的意思就是指，客户发来的IO信息，需要我自己线程去同步读取，客户端发送一点我接收一点，两端数据是同步的。</p><p>在这里边有<strong>两个阻塞</strong>，第一个是服务端等待客户端接入的阻塞，另一个是子线程中等待客户端发送消息的阻塞。上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B1%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>图中**</strong>recv<strong>**是指读取信息的系统调用</strong>，你可以把他理解为Java中的InputStream .read()，以上就是Java最古老的基于<strong>BIO</strong>的<strong>每线程每连接</strong>，而这里BIO的问题主要是两个：</p><p><strong>第一</strong>，创建线程是要分配给每个线程对应独立的内存空间的，很占资源，而且如果这个连接不做任何事情会造成不必要的开销。</p><p><strong>第二</strong>，多个线程cpu在执行时会给每个线程分配时间去调度执行他们，如果线程很多，则cpu会有很多时间都浪费在了线程之间调度切换，切换也不是很简单的操作，其中包含了当前线程挂起，线程的执行场景保留和下一个线程的执行状态恢复等操作。所以引出了我们的新IO模型，<strong>NIO</strong> ↓</p><h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h1><p><strong><em>\</em>NIO (non-blocking I/O)： 同步非阻塞I/O模型**</strong></p><figure class="image-box">                <img src="20200613082503702.png" alt="img" title class>                <p>img</p>            </figure><p>NIO默认是指操作系统提供的NIO，而在Java中，NIO也可以叫做<strong>new IO</strong>，因为是全新的IO包，新的一套体系，是<strong>NIO包</strong>下的内容，基于<strong>ServerSocketChannel</strong>和<strong>SocketChannel</strong>，虽然底层也还是依靠新的非阻塞的系统调用。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B2%5D" alt="img" title class>                <p>img</p>            </figure><p>NIO是随着内核系统调用发展的产物，其非阻塞的方法也是依靠内核提供的，如图为Linux的内核实现的非阻塞IO方法参数</p><figure class="image-box">                <img src="2020061308333075.png" alt="img" title class>                <p>img</p>            </figure><p>图上是<strong>服务端</strong>的非阻塞参数<strong>SOCK_NONBLOCK</strong>，同时也可以通过<strong>fcntl(2)**</strong>这个系统调用来设置<strong>**客户端</strong>非阻塞。(如BIO中说明的两个阻塞分别有对应的两个解决)</p><p>我们还是来看Java中对NIO的实现，上代码(服务端代码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">*// 创建serverSocketChannel，监听8888端口，类似于BIO中的ServerSocket*</span><br><span class="line"></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()；</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(8888));</span><br><span class="line"></span><br><span class="line">*// 重点：设置为非阻塞参数 → 内核提供的NIO*</span><br><span class="line"></span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*// 创建一个放置客户端连接的集合*</span><br><span class="line"></span><br><span class="line">LinkedList&lt;SocketChannel&gt; clients = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">*// 循环是在一个主线程中，期间没有开启任何其他子线程*</span><br><span class="line"></span><br><span class="line">*// 循环中有两大步，第一步接收客户端连接，第二步遍历客户端查看是否有数据需要接收*</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">  *// ① ******接收客户端连接*******</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *// 接收客户端连接，一秒去接一次(也可以不设定)，非阻塞，一直会有返回值*</span><br><span class="line"></span><br><span class="line">  Thread.currentThread().sleep(1000);</span><br><span class="line"></span><br><span class="line">  SocketChannel client = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *// 那接收的结果就是两种情况，接到和没接到*</span><br><span class="line"></span><br><span class="line">  *// 内核系统调用时没接收到返回-1，Java中为null*</span><br><span class="line"></span><br><span class="line">  if (channel == null)&#123;</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;服务端监听中...暂无接入...&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;客户端接入...&quot;);</span><br><span class="line"></span><br><span class="line">​    *// 设置客户端非阻塞，比方说*</span><br><span class="line"></span><br><span class="line">​    *// 客户端有数据发来就接受到了，没有就返回-1，也是非阻塞的*</span><br><span class="line"></span><br><span class="line">​    client.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;客户端端口：&quot; + client.socket().getPort());</span><br><span class="line"></span><br><span class="line">​    clients.add(client);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *// ② ******遍历客户端集合查看是否有数据需要接收*******</span><br><span class="line"></span><br><span class="line">  ByteBuffer buffer = ByteBuffer.allocateDirect(4096);</span><br><span class="line"></span><br><span class="line">  for (SocketChannel c : clients) &#123;</span><br><span class="line"></span><br><span class="line">​    *// 此时读取不会阻塞，返回 &gt;0，0，-1*</span><br><span class="line"></span><br><span class="line">​    int num = c.read(buffer);</span><br><span class="line"></span><br><span class="line">​    if (num &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">​      buffer.flip();</span><br><span class="line"></span><br><span class="line">​      byte[] bytes = new byte[buffer.limit()];</span><br><span class="line"></span><br><span class="line">​      buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​      String message = new String(bytes);</span><br><span class="line"></span><br><span class="line">​      System.out.println(c.socket().getPort() + &quot;: &quot; + message);</span><br><span class="line"></span><br><span class="line">​      buffer.clear();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里NIO一个线程就干了<strong>接受客户端连接</strong>和<strong>读取客户端数据</strong>的工作，解决了BIO中的<strong>线程内存浪费</strong>和<strong>cpu调度消耗</strong>的问题。NIO的优势就是解决了客户端连接多线程的问题，那么NIO有哪些弊端呢，<strong>C10K问题(client 有10K个)</strong>，假如你有一万个客户端连接，每次你去读取客户端数据都要向内核进行recv(读数据)的系统调用，但是假如此时此刻发来数据的客户端只有一个，那剩下9999次的调用都将会是无效的，没有意义的浪费资源，上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B3%5D" alt="img" title class>                <p>img</p>            </figure><p>那如何解决C10K问题呢，C10K的主要问题在于for循环调用了一万次系统调用，如果我们可以降低循环的次数，减少对应的系统调用，那性能将大大提升，好比说我们在一万次的循环之前，访问<strong>某一个系统调用</strong>，将一万个客户端连接描述传递给内核，让他给我们返回到底有几个客户端发来了数据，在这之后我们就可以只遍历内核返回回来的真正有数据传达了的客户端，假如有三个客户端传来了数据，加上我们循环之前访问内核的<strong>某一个系统调用</strong>，总共有只四次系统调用，而只循环了三次，是不是大大提高了效率。</p><p>我们可以将这一万个客户端理解为一万个数据通路，这多个数据通路都同时使用了<strong>某一个系统调用</strong>完成了数据传输状态的确认，我们将这个过程称之为<strong>多路复用</strong>，使用到的<strong>某一个系统调用</strong>称之为<strong>多路复用器</strong>。</p><p>可以把多路复用器理解为是基于NIO模型来使用的。</p><h1 id="4-多路复用器"><a href="#4-多路复用器" class="headerlink" title="4. 多路复用器"></a>4. 多路复用器</h1><p><strong><em>\</em>多路复用器： select，poll，epoll**</strong></p><p>多路复用器也是随着内核系统调用发展的产物，是内核为我们提供的可以管理多个数据通路的系统调用方法。上边三个版本多路复用器大致又可以分为两类：</p><p><strong>一类：select，poll</strong></p><p><strong>二类：epoll</strong></p><p>先来聊一下<strong>一类</strong>，select和poll，以select为例，看一下linux内核提供的系统调用，调用方法名就是select，这里是C语言实现的。</p><figure class="image-box">                <img src="2020061310565648.png" alt="img" title class>                <p>img</p>            </figure><p>首先，select是同步I/O多路复用器。(multiplexing：多路复用)</p><figure class="image-box">                <img src="20200613103518120.png" alt="img" title class>                <p>img</p>            </figure><p>再来看系统调用提供的方法，其中int类型的参数nfds就表示的是<strong>文件描述符</strong>的个数，这里具体表示的就是多少个客户端连接需要询问内核(C10K)，后边三个参数是三个文件描述符的集合，可读集合，可写集合和异常集合，最后参数是请求时间超时的限制，为什么使用文件描述符呢，因为Linux中一切皆文件，而什么是文件描述符？这里的使用可以暂时理解为你每个客户端的连接信息，这里补上一个比较详细的文件描述符说明链接，这里不再阐述：<a href="https://blog.csdn.net/wan13141/article/details/89433379" target="_blank" rel="noopener">Linux文件描述符到底是什么？</a></p><p>关于select的系统调用是有如下描述：<strong>允许一个程序监视多个文件描述符。</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B4%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>直到一个或多个文件描述符达到一个准备好的状态。</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B5%5D" alt="img" title class>                <p>img</p>            </figure><p>这里select多路复用器的作用就是替代了之前循环遍历客户端的过程，用户端时间复杂度从一万减少到了一，但是其实在将一万个文件描述符传递给内核后，内核还是要遍历，不过内核内部的自行遍历相比于用户循环一万次做系统调用，要快的多(因为用户态到内核态有保护模式，系统调用执行间还有好长的一段路要走)。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B6%5D" alt="img" title class>                <p>img</p>            </figure><p>这里需要明确的一点是，<strong>多路复用器返回的只是对应客户端的状态</strong>，多路复用器不会帮你去读数据，读取数据的工作都是在代码中实现的，都在自己的线程中(比如上边图中最后都调用了recv)，无论是BIO还是NIO。</p><p>这里再补充一下 <strong>IO模型的**</strong>同步<strong><strong>与</strong></strong>异步**：</p><p>如果是程序自己读取IO(类似于上边的代码获取客户端输入流，系统调用recv)，那么这个IO类型，无论是BIO，还是NIO(使用和不使用多路复用器)，他们都是<strong>同步的IO模型</strong>。只不过BIO是同步阻塞，NIO是同步<strong>非</strong>阻塞，而多路复用器只是NIO的帮手，不属于IO模型。</p><p>那<strong>异步IO模型</strong>呢，windows中有IOCP实现，Linux也有Proactor模式，做法都是在内核中启动线程(不是在程序中启动线程)，内核线程把数据拷贝到程序的内存空间中去，当内核线程完成IO操作之后，发送一个通知，告知程序操作已完成，此时程序就可以直接进行获取，程序不用自己开线程去调读取方法(recv)来读取数据，这就叫做异步IO模型。如图(kernel就是内核)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B7%5D" alt="img" title class>                <p>img</p>            </figure><p>这里简单的提一下，就是NIO 2.0引入了新的异步通道的概念，就是图中的AIO。</p><p>附上一个Linux异步IO模型的详细说明，这里不再阐述：</p><p><a href="https://www.cnblogs.com/schips/p/12575933.html" target="_blank" rel="noopener">Linux 网络编程的5种IO模型：异步IO模型</a></p><p>这里差不多了解完了多路复用器select，再提一下多路复用器poll，select和poll是一类的，区别在于select有一个源代码的1024限制(不同版本代码可能限制数不一样)，一个select最多同时监视1024个文件描述符(可以理解为一个select同时最多管理1024个客户端连接)，而poll是没有显示的限制的，是随着操作系统底层配置来实现限制的。</p><p>那么一类的多路复用器select和poll有哪些问题呢，也可以总结为两个</p><p><strong>第一个</strong>：每次会重复传递文件描述符，每次系统调用都传一万个过去，循环多了，资源空间上也很浪费</p><p><strong>第二个</strong>：多路复用器select和poll都要全量遍历文件描述符，有没有什么方法可以减少遍历次数呢？或者说可不可以不用再主动遍历文件描述符了呢(无论是程序遍历还是内核遍历)？</p><p>EPOLL可以解决，这也是为什么现在用的比较多的同步IO模型的多路复用器是epoll，那么如何解决上边两个问题呢，</p><p><strong>第一个</strong>：让内核开辟一块内存空间，来保留文件描述符，不用重复传递了</p><p><strong>第二个</strong>：属于计组的知识，使用中断，callback回调等来实现被动获取文件描述符的状态，不再主动遍历所有文件描述符(连接信息)。</p><p>上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B8%5D" alt="img" title class>                <p>img</p>            </figure><p>下来我们主要说一下二类多路复用器：EPOLL</p><p>在讲原理之前这里先对NIO内容进行一个小补充：</p><p>Java Nio主要由三个核心部分组成：</p><p><strong>1.通道 Channel</strong></p><p>所有的io的Nio都是从一个channel开始的，Channel有点类似于流，但是和流不同的是，channel是可以双向读写的，<strong>可以把一个channel理解为一个客户端连接</strong>，Channel主要分两大类：</p><p>SelectableChannel：网络IO读写</p><p><strong>ServerSocketChannel</strong>和<strong>SocketChannel</strong>都是SelectableChannel的子类</p><p>FileChannel：本地文件IO读写</p><p><strong>2.缓冲区 Buffer</strong></p><p>在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。（<strong>用于读入和读出channel的数据</strong>）</p><p>缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。</p><p>具体的缓存区有这些：ByteBuffer、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。</p><p><strong>3.多路复用器 Selector</strong></p><p>Selector是Java NIO 编程的基础。</p><p>Java中的Selector类位于NIO包下，名字叫Selector，是一个多路复用器的统称，可以理解为适配器模式，<strong>Selector类代码运行不同的服务器上可以是不同的多路复用器实现</strong>，主要看底层服务器内核是如何提供系统调用的，可以是select，可以是poll，也可以是epoll，还可以是unix系统下实现的kqueue等等等等。</p><p>最后上个图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B9%5D" alt="img" title class>                <p>img</p>            </figure><hr><p><strong>现在我们看一下epoll解决一类多路复用器两个问题的原理：</strong></p><p>（最后会有代码的演示）</p><p><strong>第一个问题解决方案</strong>：让内核开辟一块内存空间，来保留文件描述符，不用重复传递了</p><p><strong>原理</strong>：在客户端接入时，将对应的文件描述符写入到内核开辟的内存空间保存，其实内核开辟的内存空间有两个部分，A部分用来存放全部已经连接的客户端文件描述符，B部分存放有了对应读取状态的客户端文件描述符。我们的程序现在不用循环遍历客户端连接了，只需要从B部分获取对应的客户端就可以了，内核负责监视A部分的客户端，当有输入到达时，就将客户端文件描述符从A部分拷贝到B部分，再由程序轮询获得。此时就是通过内核牺牲部分内存空间来换取时间。</p><p><strong>select和poll的多路复用器，在多cpu的时候无法发挥出多核的优势</strong>，因为内存没有开辟内存空间，每次需要程序进行系统调用，等待cpu返回结果，因为cpu处理和程序获得结果这两个顺序是不能颠倒的，所以别的cpu也帮不上忙，但是在epoll的情况下，因为内核内存空间的存在，可以让cpu1去接受客户端信息，做A部分拷贝到B部分的工作，而cpu2去运行程序，并且轮询(轮流循环询问)内存空间B部分的状态，这样就可以充分发挥多核的优势。</p><p><strong>下来看一下这个操作的系统调用级实现(Linux)：</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B10%5D" alt="img" title class>                <p>img</p>            </figure><p>分别有三个系统调用方法：</p><p><strong>epoll_create</strong> → epoll创建</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B11%5D" alt="img" title class>                <p>img</p>            </figure><figure class="image-box">                <img src="20200613160434656.png" alt="img" title class>                <p>img</p>            </figure><p>epoll_create方法返回了一个文件描述符，这个文件描述符会在后续的epoll_ctl中作为参数传递过去并且使用。</p><p><strong>epoll_ctl</strong> → epoll控制</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B12%5D" alt="img" title class>                <p>img</p>            </figure><p>这里第一个参数epfd就是刚才返回的文件描述符，第二个参数op是option的意思，有如下几个表示值，【添加，修改还有删除】<figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B13%5D" alt="img" title class>                <p>img</p>            </figure></p><p>如果op是add，那么添加什么呢，就是添加第三个参数fd，也是一个文件描述符，就是我们的客户端连接的文件描述符，最后一个参数是event集合，表示监听哪些事件，比如客户端的读事件，写事件。</p><p><strong>epoll_wait</strong> → epoll等待</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B14%5D" alt="img" title class>                <p>img</p>            </figure><p>这里第一个参数还是epfd，后边是对应的事件(指针)，以及最大事件数和响应过期时间。事件指针是为了更快的访问到对应的事件。</p><p><strong>下来用这三个系统调用来说明如何实现第一个问题的解决：</strong></p><p>首先在你的服务端程序启动时，调用且只调用一次<strong>epoll_create</strong>，使得内核创建内存空间，方法返回一个文件描述符epfd，假如等于7，这个文件描述符就是<strong>内核开辟内存空间的描述</strong>，包含地址啊，大小啊，等等，为什么内存空间也是由文件描述符来描述，因为Linux一切皆文件嘛</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B15%5D" alt="img" title class>                <p>img</p>            </figure><p>有了fd7之后，表明内核已经开辟了一块内存空间了，我们程序在启动后，会绑定并监听一个端口，返回我们<strong>程序的第一个文件描述符</strong>，也就是程序服务端(server)的文件描述符，假如是3，接下来就是把次文件描述符拷贝到内核开辟的内存空间中去，这里还是用上边的代称，就是拷贝到内核内存的A部分去，此时调用的方法是<strong>epoll_ctl</strong>，op参数为add，监听服务端的accept事件↓</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B16%5D" alt="img" title class>                <p>img</p>            </figure><p>这里内核空间fd7其实使用<strong>红黑树</strong>来存放这些添加进来的文件描述符的，使得对文件描述符的获取和使用更加便捷效率。</p><figure class="image-box">                <img src="20200613164358546.png" alt="img" title class>                <p>img</p>            </figure><p>此时已经拷贝完毕，内核负责监听拷贝到A部分的文件描述符的事件，假如此时又客户端接入，则将fd3从A部分拷贝到B部分，当我程序随时想要获取状态时，只需要调用<strong>epoll_wait</strong>即可，就是之前提到的轮询，程序会时不时的过来查看一下最新的状态，有变化的话就读取对应信息到程序内存中去执行，epoll_wait的意思就可以理解为等待内核监听事件直到有事件发生。epoll_wait是阻塞的方法，但是可以设置一个timeout时间，超过时间则直接返回-1。最优情况下epoll_wait可以到达O(1)的复杂度，一次获取多个连接信息。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B17%5D" alt="img" title class>                <p>img</p>            </figure><p>再下来无非是服务端fd3接收到客户端，假如是fd8，再次调用epoll_ctl来add到A部分，内核再监听对应的可读事件，有读事件发生了，再拷贝到B部分，等待程序调用epoll_wait来获取。这一部分的解决方法大概就是这样。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B18%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>总结一下，epoll其实相比于select和poll，就是多了epoll_create和epoll_ctl方法，这两个方法分别以在【内核中开辟空间】并【操作文件描述符】。</strong></p><p><strong>第二个问题解决方案</strong>：属于计组的知识，使用中断，callback回调等来实现被动获取文件描述符的状态，不再主动遍历所有文件描述符(连接信息)。</p><p><strong>原理</strong>：简单说明一下，内核在开辟的A部分内存空间里，监听了所有文件描述符对应的事件，何时把A部分的文件描述符拷贝到B部分，上边已经说过了，是对应监听的事件发生的时候，比如读事件，那为什么文件描述符对应监听的事件发生时，会接着发生A，B部分的拷贝事件呢，这两者明显没有直接的关联关系，结果就是，内核使用回调机制，比如callback事件回调，在读事件发生之后回调了拷贝事件完成了这一操作。</p><hr><p><strong>最后看一下多路复用器在Java中的封装：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">*// 服务端代码依旧是绑定端口和监听端口，设置非阻塞*</span><br><span class="line"></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(8888));</span><br><span class="line"></span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*// 多路复用器：select poll epoll都有可能，优先选择epoll，可以通过传参 -D修改*</span><br><span class="line"></span><br><span class="line">*// 在epoll的模型下 open() -&gt; epoll_create -&gt; fd7 让内核开辟内存空间*</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">*// 为服务端register(注册) selector*</span><br><span class="line"></span><br><span class="line">*// select,poll -&gt; 在jvm里开辟一个数组，把fd3放进去(进程空间)*</span><br><span class="line"></span><br><span class="line">*// epoll -&gt; epoll_ctl(fd7,add,fd3,EPOLLIN) 把fd3放到内核内存空间A部分(内核空间)*</span><br><span class="line"></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;服务端开始工作：&quot;);</span><br><span class="line"></span><br><span class="line">*// 下来开始执行*</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line"></span><br><span class="line">  *// 查看多路复用器中当前监视了多少了文件描述符*</span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; keys = selector.Keys();</span><br><span class="line"></span><br><span class="line">  System.out.println(keys.size() + &quot; size&quot;);</span><br><span class="line"></span><br><span class="line">  *//创建消息处理器*</span><br><span class="line"></span><br><span class="line">ServerHandlerBs handler = new ServerHandlerImpl(1024);</span><br><span class="line"></span><br><span class="line">  *// select()方法就是调用多路复用器(select，poll 或者 epoll)*</span><br><span class="line"></span><br><span class="line">  *// 语义就是去查询一下那些IO可以读写了*</span><br><span class="line"></span><br><span class="line">  *// select，poll -&gt; 调用内核的 select(fd3)，poll(fd3)*</span><br><span class="line"></span><br><span class="line">  *// epoll -&gt; 调用内核的 epoll_wait()*</span><br><span class="line"></span><br><span class="line">  *// 超时时间500毫秒 -&gt; selector.wakeup() 返回0*</span><br><span class="line"></span><br><span class="line">  while(selector.select(timeout: 500) &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">​    *// selectedKeys()方法返回有状态的fd集合*</span><br><span class="line"></span><br><span class="line">​    Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">​    *// 这里遍历的就是有真正IO需求的连接*</span><br><span class="line"></span><br><span class="line">​    while (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">*// 连接请求*</span><br><span class="line"></span><br><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">   *// select，poll -&gt; 在jvm里开辟的数组中存储新客户端*</span><br><span class="line"></span><br><span class="line">   *// epoll -&gt; epoll_ctl(...add...) 新客户端注册到内核内存空间*</span><br><span class="line"></span><br><span class="line">handler.handleAccept(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*// 读请求*</span><br><span class="line"></span><br><span class="line">if (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(handler.handleRead(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*// 处理完后移除当前使用的key，不移除下次循环会重复处理*</span><br><span class="line"></span><br><span class="line">keyIterator.remove();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/***</span><br><span class="line"></span><br><span class="line">** description:对selectionKey事件的处理接口*</span><br><span class="line"></span><br><span class="line">**/*</span><br><span class="line"></span><br><span class="line">interface ServerHandlerBs &#123;</span><br><span class="line"></span><br><span class="line">void handleAccept(SelectionKey selectionKey) throws IOException;</span><br><span class="line"></span><br><span class="line">String handleRead(SelectionKey selectionKey) throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/***</span><br><span class="line"></span><br><span class="line">** description:用来处理有需求的连接*</span><br><span class="line"></span><br><span class="line">**/*</span><br><span class="line"></span><br><span class="line">public class ServerHandlerImpl implements ServerHandlerBs &#123;</span><br><span class="line"></span><br><span class="line">private int bufferSize = 1024;</span><br><span class="line"></span><br><span class="line">private String localCharset = &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(int bufferSize) &#123;</span><br><span class="line"></span><br><span class="line">this(bufferSize, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(String localCharset) &#123;</span><br><span class="line"></span><br><span class="line">this(-1, localCharset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(int bufferSize, String localCharset) &#123;</span><br><span class="line"></span><br><span class="line">this.bufferSize = bufferSize &gt; 0 ? bufferSize : this.bufferSize;</span><br><span class="line"></span><br><span class="line">this.localCharset = localCharset == null ? this.localCharset : localCharset;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  *// 当连接是客户接入的时候*</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void handleAccept(SelectionKey selectionKey) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">*//获取channel*</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line"></span><br><span class="line">*//非阻塞*</span><br><span class="line"></span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*//注册selector*</span><br><span class="line"></span><br><span class="line">socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;建立请求......&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  *// 当连接是客户发送数据的时候*</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public String handleRead(SelectionKey selectionKey) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line"></span><br><span class="line">String receivedStr = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if (socketChannel.read(buffer) == -1) &#123;</span><br><span class="line"></span><br><span class="line">*//没读到内容关闭*</span><br><span class="line"></span><br><span class="line">socketChannel.shutdownOutput();</span><br><span class="line"></span><br><span class="line">socketChannel.shutdownInput();</span><br><span class="line"></span><br><span class="line">socketChannel.close();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;连接断开......&quot;);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">*//将channel改为读取状态*</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">*//按照编码读取数据*</span><br><span class="line"></span><br><span class="line">receivedStr = Charset.forName(localCharset).newDecoder().decode(buffer).toString();</span><br><span class="line"></span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line">*//返回数据给客户端*</span><br><span class="line"></span><br><span class="line">buffer = buffer.put((&quot;received string : &quot; + receivedStr).getBytes(localCharset));</span><br><span class="line"></span><br><span class="line">*//读取模式*</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">*//注册selector 继续读取数据*</span><br><span class="line"></span><br><span class="line">socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return receivedStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码是参照此博客的，我懒得写了，基本只是加了点关于底层系统调用的注释：</p><p><a href="https://blog.csdn.net/qq_36666651/article/details/80955398" target="_blank" rel="noopener">java Nio 使用 NioSocket 客户端与服务端交互实现</a></p><p>最后附上一张图，是在Linux中验证epoll调用顺序的(注意一下左边写的监听的是3，右边是4，没有本质上的区别)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B19%5D" alt="img" title class>                <p>img</p>            </figure>————————————————————————<br><br>最后再补充一下，类似于netty的实现：<br><br>上边代码是单线程的，代码中的Selector既要负责建立连接，又要负责确认客户端状态，还是假如现在有十万个连接都有数据不断在发送过来，那么每次epoll_wait的时间就会变长，两个epoll_wait的间隔就越来越大，这意味着什么，意味着程序每次响应会<strong>一次处理大量并发</strong>，会导致用户端感觉程序反应很慢，用户体验降低，原理就是在你执行第一个epoll_wait之后，所有的连接再进来就得等第一个epoll_wait处理完才能再接入，然后在第二次epoll_wait的时候再由程序处理，所以解决方案很简单，可以建立多个Selector复用器，在多个线程中，将数据量分开，符合了负载均衡的理念，提升处理的响应速度。<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B20%5D" alt="img" title class>                <p>img</p>            </figure><p>多线程多Selector：</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B21%5D" alt="img" title class>                <p>img</p>            </figure><p>可以让多个多路复用器去做不同的事情，比如Selector1是大管家，负责找到需要接入客户端并分发出去，Selector2和Selector3接受Selector1的任务来真正的处理客户端接入，这样就使用了两个多路复用器在不同的线程中处理了客户端接入，速度肯定比单个线程单个多路复用器快。(多核操作系统这三个线程就可以跑在不同的核心上，并行效率更高)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B22%5D" alt="img" title class>                <p>img</p>            </figure>线程的构造方法如下，Selector1分发任务的多路复用器使用第一种，selectors就是处理任务的子多路复用器有多少，剩下Selector2和Selector3使用第二种，单纯负责任务完成。线程内部都包含任务队列queue。<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B23%5D" alt="img" title class>                <p>img</p>            </figure><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B24%5D" alt="img" title class>                <p>img</p>            </figure>下来开始执行，只有第一个线程中所在的多路复用器Selector1被注册到了server上了可以获取监听状态，在接受到客户端之后走acceptHandler方法<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B25%5D)acceptHandler方法中就包含了任务的分配，分配给Selector2和Selector3，一人一个这样分配(给对应线程的queue中分配" alt="img" title class>                <p>img</p>            </figure>，下来看一下Selector2和Selector3的任务实现<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B26%5D" alt="img" title class>                <p>img</p>            </figure><h1 id="牛客面经总结"><a href="#牛客面经总结" class="headerlink" title="牛客面经总结"></a><strong>牛客面经总结</strong></h1><h2 id="new一个对象的所有过程"><a href="#new一个对象的所有过程" class="headerlink" title="new一个对象的所有过程"></a><strong>new一个对象的所有过程</strong></h2><h2 id="spring⭐⭐⭐"><a href="#spring⭐⭐⭐" class="headerlink" title="spring⭐⭐⭐"></a><strong>spring⭐⭐⭐</strong></h2><p><strong>AOP</strong></p><p><strong>IOC</strong></p><h1 id="Spring中用到的设计模式"><a href="#Spring中用到的设计模式" class="headerlink" title="Spring中用到的设计模式"></a>Spring中用到的设计模式</h1><p>  准备几个则够了</p><p><strong>单例模式：bean默认都是单例的</strong></p><p><strong>原型模式：指定作用域为prototype</strong></p><p><strong>工厂模式：BeanFactory</strong></p><p>模板模式：postProcessBeanFactory，onRefresh，initPropertyValue</p><p>策略模式：XmlBeanDefinitionReader，PropertiesBeanDefinitionReader</p><p>观察者模式：listener，event，multicast</p><p>适配器模式：Adapter （AOP）</p><p>装饰者模式：BeanWrapper</p><p><strong>责任链模式：使用aop的时候会生成一个拦截器</strong></p><p><strong>代理模式：动态代理 </strong></p><p><strong>委托者模式：delegate</strong></p><p>proxy与delegete语义（也即使用场景）的区别：<br>     proxy :译为代理， 被代理方（B）与代理方（A）的接口完全一致。 主要使用场景（语义）应该是：为简化编程（或无法操作B），不直接把请求交给被代理方（B），而把请求交给代码方（A），由代理方与被代理方进行通信，以完成请求。<br>     delegete : 译为委托，主要语义是：一件事情（或一个请求）对象本身不知道怎样处理，对象把请求交给其它对象来做。</p><p>门面模式又称为外观模式，实际开发中，屏蔽了子模块内部的实现细节，只是将客户端需要的接口提供给客户。</p><p>如： spring ApplicationContext;<br>它实现了Factory、ResourceLoader等接口，并通过引用这些接口的实例，对外统一提供：加载配置、解析资源、创建Bean、提供环境、启动流程等功能；</p><p>客户代码只需要操作context就可以获取spring的提供的功能，而无需关心内部的细节；</p><h2 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a><strong>springboot自动装配原理</strong></h2><h2 id="hashcode-和equals⭐⭐⭐"><a href="#hashcode-和equals⭐⭐⭐" class="headerlink" title="hashcode 和equals⭐⭐⭐"></a><strong>hashcode 和equals⭐⭐⭐</strong></h2><h2 id="HashMap和TreeMap区别-⭐⭐"><a href="#HashMap和TreeMap区别-⭐⭐" class="headerlink" title="HashMap和TreeMap区别 ⭐⭐"></a><strong>HashMap和TreeMap区别 ⭐⭐</strong></h2><h2 id="HashMap如何遍历，TreeMap如何排序的"><a href="#HashMap如何遍历，TreeMap如何排序的" class="headerlink" title="HashMap如何遍历，TreeMap如何排序的"></a><strong>HashMap如何遍历，TreeMap如何排序的</strong></h2><h2 id="hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐"><a href="#hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐" class="headerlink" title="hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐"></a><strong>hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐</strong></h2><h2 id="MVCC详细说说"><a href="#MVCC详细说说" class="headerlink" title="MVCC详细说说"></a><strong>MVCC详细说说</strong></h2><h2 id="springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析"><a href="#springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析" class="headerlink" title="springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析"></a><strong>springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析</strong></h2><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a><strong>如何确定垃圾</strong></h2><h2 id="类加载器种类，双亲委派和打破"><a href="#类加载器种类，双亲委派和打破" class="headerlink" title="类加载器种类，双亲委派和打破"></a><strong>类加载器种类，双亲委派和打破</strong></h2><h2 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a><strong>TCP如何实现可靠传输</strong></h2><h2 id="如何实现UDP可靠传输"><a href="#如何实现UDP可靠传输" class="headerlink" title="如何实现UDP可靠传输"></a><strong>如何实现UDP可靠传输</strong></h2><h2 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a><strong>TCP和UDP的使用场景</strong></h2><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><strong>cookie和session的区别</strong></h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;首先感谢龙哥，向博主整理并提供资料，爱了~&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h1&gt;&lt;p&gt;互联网的快速发展</summary>
      
    
    
    
    <category term="技术" scheme="https://github.com/missionOdd/categories/技术/"/>
    
    
    <category term="java" scheme="https://github.com/missionOdd/tags/java/"/>
    
    <category term="面试" scheme="https://github.com/missionOdd/tags/面试/"/>
    
    <category term="复习" scheme="https://github.com/missionOdd/tags/复习/"/>
    
  </entry>
  
  <entry>
    <title>大学创业的结束随笔</title>
    <link href="https://github.com/missionOdd/2021/11/03/chuangye-end/"/>
    <id>https://github.com/missionOdd/2021/11/03/chuangye-end/</id>
    <published>2021-11-02T19:15:14.000Z</published>
    <updated>2022-01-12T12:14:06.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 如果让博主盘点自己的大学生涯，说实话挺单调的，就是 – <code>All In 创业</code></p></blockquote><p>博主，只不过是一个有两年创业经历的互联网年轻人。读的是双非重本的学校，在校期间开家小型软件公司，开展经营活动数次，这就是博主过往大学的基本情况。提到校园创业者，按我理解，是要分两种，一种为了参加创业比赛赢奖而在台上进行创业路演的学生，一种是为了挣钱在校期间有真实创办运作公司经历的学生。博主属于后者，业务活跃地点<strong>Base广州&amp;广州湾</strong>。博主参与的都是要求落地的商业案例，与多个公司合作，更多追求的是项目的健壮性与快速迭代，没有其他科技园团队成员那样，做创新型或包装型项目打比赛，正是博主的团队没有花心思在参赛上，即使自己技能足够也没去争取拿奖。之前在经历添彩这方面看得过于淡泊，没去好好渡金。不过博主私心里还是个想被认可的人，目前在马不停蹄地学习新东西和沉淀自己。</p><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><p>编程是我的爱好，很高兴选了计算机科学与技术专业，进入了科班行列。<br>刚入大学时，博主马上搜罗学校的科技团队，看中了当时院内评分最好的科技团队，名字叫网维创业工作室。了解后发现，工作室的创始人是一家千人体量公司CEO，十多年间，给工作室投资和合作机会，提供校园外界的资源和项目，扶持学生创业。目前工作室已创立了十多家互联网企业，当时博主蛮渴望成为其中一员。</p><p>博主的大一是创业准备阶段，从成功考核进入学校科技园网维创业团队开始，与同届伙伴携手，做创业准备。作为技术骨干，博主去学习网页软件开发，掌握了java写后端的技能；</p><p>大二则是一边学习一边接业务，找机会拓展渠道；</p><p>到大三才创办公司，有了公司资质，便有了广泛的客户群，有了各种签约订单，工作忙得没有了生活，疫情期间日均工作13小时；</p><p>大四达成网维团队初始设定的创业目标–可持续性经营， 也是承接了团队的十几年创业传统。</p><p>在一番折腾后，博主于刚毕业的六月末决定直接退出股权离开公司，退出了创业赛道。</p><p>博主在大学走了一条不同寻常稍坎坷的路，路上挑战重重，但感受到每一步是渐进式，人在不断成长。过程细讲怕涉及太多个人信息，总体有得有失吧。</p><h3 id="创业动机"><a href="#创业动机" class="headerlink" title="创业动机"></a>创业动机</h3><ol><li>当初就是对互联网方面有想法、有兴趣、也觉得自己有实力且合适就选择创业了，没有想得很复杂，分析很细致。</li><li>想过让自己创作的产品能在市场上得到认可反馈，有一个亲手打造的成就感满满的长线产品，自己顺势往复合式人才方向发展。</li><li>选择大学创业，是因为年轻有试错的资本，追梦也是年轻人的权利，大学是适合去积累创业经验的时间点，失败也无畏，真到上岁数很怕失去了这份激情。</li><li>现实有资源支撑，具备可行性，博主选择创业，能够得到机遇、人脉、客户、资金，还有创业前辈成熟的商业模式，加上一同上道的创业伙伴，博主具备足够的执行力，顺势而为了。</li><li>并非创业不可，博主做事也会权衡，考研，找工作，考公，创业在大一的时候都想过，这是个选赛道问题，早选择则不迷茫。机缘巧合接触了多位创业者，了解其人生轨迹后，博主内心挺愿意创业。</li></ol><h3 id="离开原因"><a href="#离开原因" class="headerlink" title="离开原因"></a>离开原因</h3><blockquote><p>根本原因是个人达到瓶颈上限，在公司里对个人发展失去信心。<br>博主主要负责项目技术，也参与团队管理，还会与客户对接，前期分析需求协助产品设计，后期对开发成品做验收测试，全流程打怪属于是。<br>什么都做，意味着什么都不精通。创业期间，博主的时间被繁杂重复的劳动工作占据，自己苦了自己，却发现一切都距离个人目标越来越遥远，得不到自身的价值追求。</p></blockquote><blockquote><p>博主想开了，博主的创业其实是在通过简单重复的方式赚取利润，旧的业务如此，不断探索的新业务也是如此，若是不精进自己，不赋能自身，就一眼看到尽头。<br>博主已经决定要成为专一的技术人员，要摆脱现状，跳出小公司氛围，离开自己的公司，裸辞去挤出时间精力去研究学习沉淀，势必把深层代码逻辑了解通透，学好算法与数据结构，深入操作系统与虚拟机，熟悉网络，数据库和分布式，跑好技术赛道。<br>不留恋过往，在设定目标后，参与到云上自习室，通过衡水模式的坚持+努力，最后希望找一个符合双方利益、有共同价值观的企业。11月了，博主还在坚持~</p></blockquote><h3 id="离开后感悟"><a href="#离开后感悟" class="headerlink" title="离开后感悟"></a>离开后感悟</h3><blockquote><p>总觉得，人生一定给自己一个plan B。博主也是个憨憨，当时决定创业后，主动舍弃了很多有用的机会，说不后悔是假的。首当其冲是错过校招机会，结合身边进入大厂的同学来看，<br>博主加入了科技园团队，若是不选择创业，按自己的学习情况，有希望进入一个不错的厂，可惜博主没有走好这一步棋。事到如今，过往就让他随风而去，走好当下才有更好的未来，博主也不放弃，有机会也去争取。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 如果让博主盘点自己的大学生涯，说实话挺单调的，就是 – &lt;code&gt;All In 创业&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;博主，只不过是一个有两年创业经历的互联网年轻人。读的是双非重本的学校，在校期间开家小型软件公司，开展经</summary>
      
    
    
    
    <category term="生活" scheme="https://github.com/missionOdd/categories/生活/"/>
    
    
    <category term="生活" scheme="https://github.com/missionOdd/tags/生活/"/>
    
  </entry>
  
  <entry>
    <title>会计学|复式记账法</title>
    <link href="https://github.com/missionOdd/2020/02/01/debit-creditbookkeeping/"/>
    <id>https://github.com/missionOdd/2020/02/01/debit-creditbookkeeping/</id>
    <published>2020-02-01T05:40:32.000Z</published>
    <updated>2022-02-08T01:44:12.611Z</updated>
    
    <content type="html"><![CDATA[<p>借贷记账法</p><p>泛金融类企业的账务或者财务系统常常使用“借贷”记账法，又称<strong>复式记账法</strong>。</p><p>看一下财务系统的一条分录信息：</p><blockquote><p>借（D）：xx账号 1000元</p><p>贷（C）：xx账号 1000元</p></blockquote><p>什么是贷？什么是借？千万别被字面意思误导，忘记什么“贷”就是减少，“借”是“增加”等的错误印象。</p><p>在学习复式记账法，会计学的几个基础需要先弄明白。</p><h2 id="第一点：“借”、“贷”-只是一个符号"><a href="#第一点：“借”、“贷”-只是一个符号" class="headerlink" title="第一点：“借”、“贷” 只是一个符号"></a>第一点：“借”、“贷” 只是一个符号</h2><p>“借”“贷”二字，由于借贷记账法是从国外引入的，所以他们讲的“借”“贷”和我们日常所说的借贷（你以为的借款啊借钱呢 贷款啊）有比较大的差距，这一点特别会给我们理解借贷记账法增加一道障碍。</p><p>实际上，“借贷记账法”里的“借贷”与借钱、贷款没有半毛钱关系，它们仅仅是<strong>用来记账的符号而已</strong>。</p><p>“借”这一符号记为D（Debit）或D；</p><p>“贷”这一符号记为C（Credit）或C。</p><p>所以在这里，我们关键的一点是有一个心智：<strong>借（Debit）贷（Credit）二字理解成记录方向的符号就行，如同 左/右，买/卖，上/下，东/西等一类相反的符号。</strong>程序员可理解为<strong>布尔类型</strong>。</p><h2 id="第二点：两个会计基础公式"><a href="#第二点：两个会计基础公式" class="headerlink" title="第二点：两个会计基础公式"></a>第二点：两个会计基础公式</h2><p>前置内容《财务系统入门“三张表”》</p><blockquote><p>以一个包子铺的例子来进行串联三张表。</p><p>小明同学以前是后厂村路F4的一家做过账务清算系统的程序员，年底不幸被优化，但是也不能闲着呢，毕竟需要每个月还一万多的房贷呢，怎么办？</p><p>于是，他想在后厂村路开个包子铺赚钱。</p><p>说干就干，也是做过账务清算系统的，记账自然不能忘，从开始投资就要把帐记录好，看看自己究竟能挣多少钱，做生意嘛，挣钱才是最关键的，不能免俗，赚钱才是最终的目的。</p><p>为了记录赚多少钱这个事，引入了第一个重要公式：</p><p><strong>利润 = 收入 - 成本。</strong></p><p>举例来讲，包子铺一个月收入两万，成本是一万，那么小学生也能算清楚了，利润是1万。</p><p>这个记录收入、成本、利润的东西，换个高大上的名词，就是我包子铺这家企业的“利润表”。</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>回过头来讲，包子不可能直接new出来呢，需要找店铺付租金，购置面粉，还得找人，这一切的东西都需要实打实的现金投入呢，想想自己N+1的赔偿金也是不够呢。</p><p>粗略的算下来，至少30万，赔偿金只有20万，这差的10万怎么办呢？想起来在后厂村工作收到的“XX银行”、“XX”有钱花，为了自己的包子铺开起来，借一笔吧，利润好的话很快就能还上了。</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>该记账了，为了赚取利润，比如投入资源也就是钱，这也资源是产生收入的基础和来源，将它换个高大上的名字就是包子铺的资产了。</p><p><strong>资产的意思，就是包子铺用来产生收入的资源总和</strong>。按照来源，可以划分成自己的，和别人的。或者简单来讲，一部分是自己所有的，剩下的是借来的。</p><p>记录一下这个资产过程：</p><p><strong>资源总和 = 自己的 + 借来的。</strong></p><p>包子铺总投入30万 = 自己20万+ 借10万。</p><p>在财务上，换了一些装逼的名字：</p><p>自己的 = <strong>所有者权益</strong></p><p>别人的 = 一个债务或者负债；于是有：</p><p><strong>资产 = 所有者权益 + 负债</strong></p><p>这个公式耳熟能详的，这就是财务系统重要的<strong>资产负债表</strong>。</p><p>如下图，总结一下资产负债表的推导过程：</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>到了包子铺的日常经营中，有一些特例，小明不知道这笔钱该怎么记录，放在利润表不合适，放在资产负债表感觉也不对劲，一直困挠着小明，到底是什么事呢？</p><p>第一件事：由于在后厂村路，程序员同行颇多，熟人自然是避免不了的，比如小王，每天都会光顾小明的包子铺，可是从来不给钱，一个月下来，欠了300多，可是架不住时间长了，一年下来也是3000元，这笔钱小明该怎么记录呢？收入？但是钱没收到自己的手里呢。</p><p>有一天遇到了原公司的会计小丽，小明问小丽该怎么处理小王的这笔钱，小丽这么回答的：“这笔钱小王有义务未来偿还，你对他有追偿权，这笔算是包子铺的收入只是暂时未到账，需要一个中间账户来记录，过渡一下，等小王还了 就划掉”。</p><p>小明于是新建了一个中间账户，记录着像小王这种吃包子不给钱的情况，这笔钱叫做应收款项，等小王年底年终奖发了就还给我 应收款项就没了。</p><p>第一件事刚解决，第二件事又来了。</p><p>既然是新兴的程序员卖包子，当然就要与众不同了，为次小明花了10万元进口了一个AI机器人帮自己包包子，10万啊，不是小数目，一下子公司的现金就见底了，当然得上帐了，这笔钱又该怎么算呢？投资资产？还是今年的成本？不过这个机器人可以用很多年的，如果算成本也应该平均一下呢。</p><p>小明又拿免费的包子请教了一下会计同学小丽，小丽又给他上了一课：</p><blockquote><p>按照经济和商业的本质来处理每笔商业交易，和按照现金在收银台里流进流出，在很多时候是有差异的，有时差异需要长达十年才能弥补，有时永远也不能消除。前者在会计上叫暂时性差异，而后者叫永久性差异，它们的存在，对公司的利润表，纳税等，都会有广泛深入的影响。</p><p>为了处理现金流入流出和利润表及资产负债表表达的经济本质之间的差异，于是就出现了单独的一张报表：<strong>现金流量表</strong>。它的含义很简单，就是<strong>把企业的每笔交易，按照现金流入流出的角度记录下来。</strong></p></blockquote><p>得了，小明又get一个点，现金流量表。</p><p>这样，小王同学这种赊账行为，以及自己投资未来的钱都找到了记录地方。</p><p>复盘一下，小明的现金流量表的产生过程：</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>总结：</p><p>利润表来表达该记账主体到底赚钱不赚钱或者赚多少的问题；</p><p>资产负债表记录的是为了实现赚钱的目的，能用到的资源以及它的来源（这个很重要，后面讲贷借记账大法的时候专门会提到这个）;</p><p>现金流表是一些特殊情况或者说是对前两者的一个补充。</p></blockquote><p>其中，有三条会计等式</p><p><strong>资产 = 负债 + 所有者权益</strong>，这是最基本的会计等式，通常被称为第一会计等式。</p><p><strong>利润 = 收入 - 费用</strong>，被称为第二会计等式。</p><p><strong>资产 = 负债 + 所有者权益 + 利润</strong>，这是将第一会计等式和第二会计等式相结合的第三会计等式，是利润分配前的会计等式。</p><p>将第二等式和第三等式连接起来，就形成了我们一般记账时最常用的等式：</p><p><strong>资产 + 费用 = 负债 + 所有者权益 + 收入</strong></p><p>以上公式的元素称为会计的五要素。</p><h2 id="第三点，账户分类"><a href="#第三点，账户分类" class="headerlink" title="第三点，账户分类"></a>第三点，账户分类</h2><p>为什么要讲会计的五大要素呢，为了后面我们的账户进行分类，大概我们的账户类别是围绕着这五个要素展开的。</p><blockquote><p><strong>资产</strong></p><p>是企业过去的交易或者事项形成的、由企业拥有或者控制、预期会给企业<strong>带来</strong>利润的资源</p><p>要点包括：</p><ol><li>资产必须是显示的资产</li><li>企业对于资产必须拥有所有权。从经济实质来看，企业以融资租赁方式租入的固定资产虽然在法律层面上不具有其所有权，但是由于占有时间长，也可以被看做是企业的资产</li><li>资产预期要给企业带来收益</li></ol><p>资产的确认条件：</p><ul><li>与该资源有关的经济利益很有可能<strong>流入</strong>企业</li><li>该资源的成本或者价值能够被可靠地计量</li></ul><p>资产的分类：</p><ul><li>流动资产，预计在一个正常经营周期内变现、出售或耗用，或者以交易为目的持有，或者预期在一年内变现的资产<ul><li>货币资产</li><li>交易性金融资产</li><li>应收或者预付款项</li><li>存货</li></ul></li><li>非流动资产，流动资产以外的资产<ul><li>可供出售金融资产</li><li>持有至到期投资</li><li>长期股权投资</li><li>投资性房地产</li><li>固定资产</li><li>无形资产</li><li>其他资产</li></ul></li></ul><p><strong>负债</strong></p><p>是指企业过去的交易或者事项形成的，预期会导致经济利益<strong>流出</strong>企业的现时义务</p><p>负债的确认条件：</p><ol><li>与该义务有关的经济利益很有可能流出企业</li><li>未来流出的经济利益的金额能够可靠地量化</li></ol><p>负债的分类：</p><ul><li>流动负债<ul><li>短期借款</li><li>应付票据</li><li>应付账款</li><li>预收账款</li><li>应付职工薪酬</li><li>应交税费</li><li>应付股利</li><li>应付利息</li><li>其他应付款项</li></ul></li><li>非流动负债<ul><li>长期借款</li><li>应付债权</li><li>长期应付款</li></ul></li></ul><p><strong>所有者权益</strong></p><p>企业资产扣除负债后由所有者享有的剩余权益。公司的所有者权益又称为股东权益。由于资产减去负债后的余额为<strong>净资产</strong>，所以所有者权益也就是所有者对于企业净资产的所有权</p><ul><li>所有者权益表明了企业的产权关系。但是，所有者权益并不与企业任何具体的资产项目发生对应关系</li><li>所有者权益与负债共同构成企业全部资产的来源，但是两者有着本质的区别<ul><li>所有者参与企业的经营管理，债权人无权参与</li><li>所有者根据资额比例以股利或者利润的刑事参与企业利润分配，债权人不参与利润分配，知识按规定得到偿付并获得利息收入</li><li>一般除按照法律程序减资外，一般不能提前撤回投资。而债权一般有规定的偿还期限</li><li>企业进行清算时，资产在支付了破产、清算费用后优先用于偿还负债，如果有剩余资产，才能进行所有权再分配</li></ul></li></ul><p>所有者权益的确认条件：</p><p>所有者权益的确认、计量主要取决于资产、负债、收入、费用等其他会计要素的确认和计量</p><p>所有者权益的来源包括：</p><ul><li>所有者投入的资本，既包括构成企业注册资本或者股本部分的金额，也包括超过注册资本或者股本部分的金额，即资本溢价或者股本溢价。</li><li>直接计入所有者权益的利得和损失，不计入档期损益、会导致所有者权益发生变动的、与所有者投入或者向所有者分配利润无关的利得或者损失。</li><li>留存收益。盈余公积和未分配利润的统称。</li></ul><p>所有者权益的具体表现为：</p><ol><li>实收资本</li><li>资本公积，包含资本溢价或者股本溢价、其他资本公积</li><li>盈余公积</li><li>未分配利润</li></ol><p><strong>收入</strong></p><p>企业在日常活动中形成的、会导致所有者权益增加的、与所有者投入资本无关的经济利益的总流入</p><p>收入的增加极可能表现为<strong>资产的增加</strong>，如增加银行存款、应收账款等；也可能表现为<strong>负债的减少</strong>，如减少预收账款；也可能表现为两者的结合</p><p>收入的确认条件：</p><ol><li>与收入相关的经济利益应当很有可能流入企业</li><li>经济利益流入企业的结果会导致资产的增加或者负债的减少</li><li>经济利益的流入额能够可靠计量</li></ol><p>收入的分类：</p><p>按照经营业务，分为主营业务收入和其他业务收入</p><p>按照性质不同，分为销售商品；提供劳务；让渡资产使用权</p><p><strong>费用</strong></p><p>企业在日常活动中发生的、会导致所有者权益减少的、与所有者分配利润无关的经济利益的总流出</p><p>费用既可以表现为<strong>资产的减少</strong>，如减少银行存款、应收账款等；也可能表现为<strong>负债的增加</strong>，如增加预收账款；也可能表现为两者的结合</p><p>费用的确认条件：</p><ol><li>与费用相关的经济利益应当很可能流出企业</li><li>经济利益流出企业的结果会导致资产的减少或者负债的增加</li><li>经济利益的流出额能够可靠计量</li></ol><p>费用的分类</p><p>费用包括生产费用和期间费用</p><p>生产费用指与企业日常生产经营活动有关的费用。直接材料、直接人工和制造费用。期间费用指企业本期发生的、不能直接或者间接归入产品生产成本，而应当直接计入当期损益的各项费用，包括管理费用，销售费用和财物费用</p><p><strong>利润</strong></p><p>企业在一定会计期间的经营成果，是评价企业管理层业绩的指标之一</p><p>利润 = 收入 - 费用</p><p>利润反映收入减去费用、直接计入当期利润的利得减去损失后的<strong>净值</strong></p></blockquote><p>有个规则：</p><p><strong>资产 + 费用 = 负债 + 所有者权益 + 收入</strong>，如果账户属于公式左边的我们成为资产类账户，相应的，右边的称为负债类。</p><p>一个账户是资产还是负债时，是看你的屁股坐在哪里，它是相对于一个记账主体的基础上的。</p><p>比如对于小明去某银行存了一笔钱，这笔钱对于银行这个主体来说，是客户放在银行的存款，但对银行实际上是银行的<code>负债</code>，相反，如果小明向银行借了一遍钱，银行发放给客户的贷款实际上是<code>资产</code>。</p><p><img src="v2-d2da03dc925b5c484da9a06031a4f3e4_720w.jpg" alt="img"></p><p>上面这段话多看几遍，彻底的理解它。</p><h2 id="最核心：借贷记账三步流程"><a href="#最核心：借贷记账三步流程" class="headerlink" title="最核心：借贷记账三步流程"></a>最核心：借贷记账三步流程</h2><h3 id="第一步：明确记账主体"><a href="#第一步：明确记账主体" class="headerlink" title="第一步：明确记账主体"></a>第一步：明确记账主体</h3><p>类比在讨论任何问题的时候我们先确定好边界，借贷记帐法目的是为了记账，记流水，但最关键的是我们要为谁记账。</p><p>比如“小明通过招商银行向支付宝充值了100元”这个情况，我们怎么记账？我们首先要做的就是要明确，是为小明记账，还是为招商银行还是支付宝记账，不同的记账主体记账内容肯定是不同的。</p><h3 id="第二步：明确账户属性"><a href="#第二步：明确账户属性" class="headerlink" title="第二步：明确账户属性"></a>第二步：明确账户属性</h3><p>这点在前面强调了，我们明确了记账主体后，需要明确记账主体下的账号类别，是“资产类”还是“负债类”，因为根据账户属性不同，记账方式也不同，后面举例来讲。</p><h3 id="第三步：按照会计理论进行加减。"><a href="#第三步：按照会计理论进行加减。" class="headerlink" title="第三步：按照会计理论进行加减。"></a>第三步：按照会计理论进行加减。</h3><p>资金像流水一样，是运动的，记账就是为了记录这种运用的过程，无非就是某个账户加，某些账户减，但是每个行业都有自己的术语，要不怎么体现出入门门槛呢，会计也不例外，加减多俗，我们换个高大上的名词“借”和“贷”。</p><p>从会计账本的格式来看，会计账户分成左右两个部分，一个部分表示记录增加，一个部分表示记录减少，账户左边的部分叫做借方，账户右边的部分叫做贷方。</p><p>如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-10cc0b3ee99435f1998ef57e18de2201_720w.jpg" alt="img"></p><p><strong>借贷记账法的结构</strong></p><p>账户的左方为借方，右方为贷方。</p><p>所有账户的借方和贷方按相反的方向记录增加数和减少数，即一方登记增加额，另一方就登记减少额。</p><p><strong>借贷记账法的记账规则</strong></p><p>有借必有贷，借贷必相等</p><p>同借同贷则相加，互异借贷则相减。</p><ul><li><p>资产 、费用:   增加用“借”表示，减少用“贷”表示；</p></li><li><p>负债 、所有者权益、收入:  增加用“贷”表示，减少用“借”表示。</p></li></ul><p><strong>会计分录</strong></p><p>简称分录，是对没想经济业务列出应借、应贷的账目民称以及其金额的一种记录</p><p>会计分录由应借应贷方向、互相对应的科目及其金额三个要素构成</p><p>会计分录的书写格式为：</p><ol><li>先借后贷，借方在前，贷方在后</li><li>贷方的文字和数字都要比借方后退两格书写</li><li>一借多贷或一贷多借和多贷多借的情况下，借方和贷方的文字要对齐，金额也要对齐</li></ol><p><strong><em>不能将没有互相联系的简单分录合并相加成多贷多借的会计分录，否则无法反应账户的对应关系</em></strong></p><p><strong>借贷记账法下的试算平衡</strong></p><ol><li>发生额试算平衡<ul><li>全部账户本期借方发生额 = 全部账户本期贷方发生额</li></ul></li><li>余额试算平衡<ul><li>全部账户借方期初余额合计 = 全部账户贷方期初余额合计</li><li>全部账户借方期末余额合计 = 全部账户贷方期末余额合计</li></ul></li></ol><p><strong>试算平衡的作用和局限</strong></p><p><strong><em>如果所有账户在一定时期内借、贷方发生余额合计不平衡，肯定本期内几张和结账有错误</em></strong></p><p>但是，如果试算平衡，只能说明记账和结账可能正确。即它不能发现全部几张过程中的错误和遗漏</p><p><strong>来个实例体验借贷记帐</strong></p><p><strong>场景：小明同学通过招商银行向自己的支付宝充值了100元。</strong></p><p>还记得刚刚提到的三步走吗？</p><p><strong>第一步：明确记账主体</strong></p><p>该场景中出现三个主体，小明、银行、支付宝。</p><p>我们先以小明这个主体来操作。</p><p><strong>第二步：明确账户类型</strong></p><p>该场景中小明有两个账户：银行存款账户、支付宝余额账户</p><p>对于这两个账户，都是小明的资产。</p><p>完成前两步，形成了如下关系：</p><p><img src="https://pic2.zhimg.com/80/v2-d18b8508a5bb2a430dc3211c09f26aa1_720w.jpg" alt="img"></p><p>在专业一点，画出会计版本：</p><p><img src="https://pic1.zhimg.com/80/v2-dd64ee369548bc652dab8c896823a508_720w.jpg" alt="img"></p><p><strong>第三步：按照会计理论进行加加减减。</strong></p><p>对于小明来讲，是把银行的钱，放到了支付宝里，银行存款账户减少，支付宝账户增加。</p><p>换成会计的语言：小明银行资产类账户减少，小明支付宝资产类账户增加，资产类增加记为“借”，所以在小明资产类-支付宝账户-左面（借方）记录一笔“增加了100元”。如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d8fe8d6515c4f79d07701e46396ba919_720w.jpg" alt="img"></p><p>小明银行资产类账户减少，资产类增加记为“借””，相对应的资产类减少记为“贷”，如下，小明银行存款-右面（贷方）记录一笔：减少100元。</p><p><img src="https://pic2.zhimg.com/80/v2-f3454d59a8ff9ba42be3f1fd748e247d_720w.jpg" alt="img"></p><p>一直没有提到我们的10字口诀：“有“借”必有“贷”， 借贷必相等”，我们再看一下，是不是这样的。</p><p><img src="https://pic1.zhimg.com/80/v2-36c3e46f881c16f017e174ea530ba18c_720w.jpg" alt="img"></p><p>隐含的操作行为：</p><p><img src="https://pic2.zhimg.com/80/v2-896672ca6d54ce464026a240742b3a39_720w.jpg" alt="img"></p><p>看完了这个例子还没看懂？我们再以该场景中的其他两个主体来看：</p><p>如果以支付宝为记账主体，记账后的结果如下：</p><p><img src="https://pic3.zhimg.com/80/v2-4dac94c5e11d3e26d07d705a76d2af8e_720w.jpg" alt="img"></p><p>第一步：记账主体为“支付宝”。</p><p>第二步：支付宝有个银行存款账户记录着自己在银行的备付金有多少，第二个，自己体系类的，为小明记账的小明余额户。一个是我的资产，一个是我的负债。</p><p>第三步：小明通过招商银行先我的支付宝备付金转移了100元，是增加，前面说过资产类增加记为“借”，所以在左边记录。</p><p>小明的余额增加，负债类增加记为“贷”，记载右面，这样“有借必有贷，借贷必相等。</p><p>隐含的记录规则：</p><p><img src="https://pic3.zhimg.com/80/v2-fc70e9ce5330bba60e3df134c34b8b3e_720w.jpg" alt="img"></p><p>还不明白？我在把以“银行”为主体的记账也写出来，自己在体会一下：</p><p><img src="https://pic4.zhimg.com/80/v2-35692cc30683fc38f63359ec03c09dc3_720w.jpg" alt="img"></p><p>再回过头总结一下：</p><p>复式借贷记账法：对每一笔资金操作所引起的会计要素（账户）的增减变动，都以相等的金额同时在两个或两个以上的相互联系的账户中进行记录的一种科学方法。</p><p><strong>“借”“贷”概念</strong><br>借贷仅仅是记账方法所使用的记账的符号，没有其它特殊的含义，与资金的借出、借入和贷款都没有任何关系。</p><p>如果将来你看到这样一条记录，你能看明白了吗？</p><blockquote><p>D：XXX存款额户 500<br>C：XXXXXXXXX 500</p></blockquote><p>这就是一条会计分录。</p><p>基于复式借贷记账方法，对每一笔经济业务所涉及应借应贷的账户及其金额的记录，简称分录。</p><pre><code>多级科目的会计分录如下：    平台侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-被授权人           贷：5401损益-主营业务成本    平台侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-企业           贷：5401损益-主营业务成本           贷：2202负债-应付账款-平台           借：5401损益-主营业务成本    企业侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-员工           贷：5401损益-主营业务成本           贷：2202负债-应付账款-被授权人           借：5401损益-主营业务成本    员工侧        摘要：（快递单号）个人现结退款           贷：2202负债-应付账款-企业           借：3001所有者权益-实收资本</code></pre><p><img src="image-20220208092534699.png" alt="image-20220208092534699"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>数据库</p><ul><li>科目类别表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`subject_index`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`num`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编码'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`typename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'类别'</span>,</span><br><span class="line">  <span class="string">`rootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`rootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`parentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`parentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`parentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`parentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`parenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220208083033398.png" alt="image-20220208083033398" title class>                <p>image-20220208083033398</p>            </figure><ul><li>科目余额表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`subject_balance`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'科目余额编号'</span>,</span><br><span class="line">  <span class="string">`subjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目名'</span>,</span><br><span class="line">  <span class="string">`subjectbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjecttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目类别'</span>,</span><br><span class="line">  <span class="string">`subjectrootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectrootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectparentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectparentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjectparenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  <span class="string">`financesubjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主体编号'</span>,</span><br><span class="line">  <span class="string">`ending`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'余额'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><ul><li>凭证单表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`voucher_index`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'凭证编号'</span>,</span><br><span class="line">  <span class="string">`vouchernum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证号'</span>,</span><br><span class="line">  <span class="string">`financesubjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主体编号'</span>,</span><br><span class="line">  <span class="string">`biztype`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型'</span>,</span><br><span class="line">  <span class="string">`bizid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型相关编号'</span>,</span><br><span class="line">  <span class="string">`originatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'制单人编号'</span>,</span><br><span class="line">  <span class="string">`auditorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'审核人编号'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`creatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`editorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'修改人'</span>,</span><br><span class="line">  <span class="string">`is_deleted`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否删除'</span>,</span><br><span class="line">  <span class="string">`is_locked`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否冻结'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><ul><li>凭证信息表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`voucher_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'凭证信息编号'</span>,</span><br><span class="line">  <span class="string">`voucherid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证编号'</span>,</span><br><span class="line">  <span class="string">`vouchernum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证号'</span>,</span><br><span class="line">  <span class="string">`summary`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证摘要'</span>,</span><br><span class="line">  <span class="string">`subjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目名'</span>,</span><br><span class="line">  <span class="string">`subjectbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjecttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目类别'</span>,</span><br><span class="line">  <span class="string">`subjectrootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectrootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectparentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectparentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjectparenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证余额方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`beginning`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'初始金额'</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">  <span class="string">`ending`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'余额'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`creatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`editorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'修改人'</span>,</span><br><span class="line">  <span class="string">`is_deleted`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否删除'</span>,</span><br><span class="line">  <span class="string">`is_locked`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否冻结'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220208085053670.png" alt="image-20220208085053670" title class>                <p>image-20220208085053670</p>            </figure><figure class="image-box">                <img src="image-20220208090551866.png" alt="image-20220208090551866" title class>                <p>image-20220208090551866</p>            </figure><p>会计分录练习题及答案</p><p>东方公司为增值税一般纳税人工业企业，2001年月12月份发生下列业务：</p><p> 1、 开出现金支票从银行提取现金2000元备用;</p><p>借：现金 2000</p><p>贷：银行存款 2000</p><p>2、 用现金支付生产车间办公用品费440元;</p><p>借：制造费用 440</p><p>贷：现金 440</p><p>3、 收到盛达公司前欠货款80000元，存入银行;</p><p>借：银行存款 80000</p><p>贷：应收账款—盛达公司 80000</p><p>4、 向前进工厂销售A产品一批，不含增值税的售价为100000元，增值税17000元，款项尚未收到;</p><p>借：应收账款—前进工厂 117000</p><p>贷：主营业务收入 100000</p><p>​    应交税金应交增值税(销项税) 17000</p><p> 5、 接到开户银行的通知，收到光明公司前欠货款150000元;</p><p> 借：银行存款 150000</p><p>贷：应收账款—光明工厂 150000</p><p>6、 向大华公司销售B产品一批，不含增值税的售价为200000元，增值税为34000元，合计234000元，当即收到大华公司签发并承兑 的面值为234000元，期限为三个月的商业汇票一张;</p><p>借：应收票据–大华公司 234000</p><p>贷：主营业务收入 200000</p><p>​    应交税金应交增值税(销项税额) 34000</p><p>7、 接到开户银行的通知，胜利工厂签发并承兑的商业汇票已到期，收到胜利工厂支付的票据款120000元;</p><p> 借：银行存款 120000</p><p> 贷：应收票据–胜利工厂 120000</p><p>8、 向宏达公司购买一批甲材料，按合同规定，东方公司用银行存款预付购货款50000元;</p><p>借：预付账款–宏达公司 50000 贷：银行存款 50000</p><p>9、 收到宏达公司发来的甲材料一批，增值税专用发票上注明的买价为80000元，增值税为13600元，合计93600元。扣除预付款 50000元，余额43600元东方公司用银行存款支付，甲材料已验收入库;</p><p>借：原材料甲材料 80000</p><p>​    应交税金应交增值税(进项税额) 13600</p><p>贷：预付账款–宏达公司 50000</p><p>​    银行存款 43600</p><p>10、厂部办公室张强因公出差，预借差旅费800元，付以现金;</p><p>借：其他应收款–张强 800</p><p>贷：现金 800</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;借贷记账法&lt;/p&gt;
&lt;p&gt;泛金融类企业的账务或者财务系统常常使用“借贷”记账法，又称&lt;strong&gt;复式记账法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看一下财务系统的一条分录信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;借（D）：xx账号 1000元&lt;/p&gt;
&lt;p&gt;贷（C）：</summary>
      
    
    
    
    <category term="会计学" scheme="https://github.com/missionOdd/categories/会计学/"/>
    
    
    <category term="思维" scheme="https://github.com/missionOdd/tags/思维/"/>
    
    <category term="会计学" scheme="https://github.com/missionOdd/tags/会计学/"/>
    
  </entry>
  
</feed>

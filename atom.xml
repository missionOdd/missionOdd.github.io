<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>🎉 Missionary&#39;s Blog 😆</title>
  
  <subtitle>Missionary 中国 👋</subtitle>
  <link href="https://missionodd.github.io/atom.xml" rel="self"/>
  
  <link href="https://missionodd.github.io/"/>
  <updated>2022-03-24T08:15:41.557Z</updated>
  <id>https://missionodd.github.io/</id>
  
  <author>
    <name>Missionary</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程| 深理解volatile+锁升级+DCL单例+线程池调优</title>
    <link href="https://missionodd.github.io/2022/03/23/concurrent-programming/"/>
    <id>https://missionodd.github.io/2022/03/23/concurrent-programming/</id>
    <published>2022-03-23T04:50:37.000Z</published>
    <updated>2022-03-24T08:15:41.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>一是保证可见性。<br>二是禁止指令重排序。<br>可见性，是让其他线程可见，一般我们是多核CPU，一旦volatile修饰的变量被一个CPU修改，修改完的值需要立即推送到主存，推送过程要经过一个总线。那么，我们说的可见性就是体现在总线这一层上。因为，我们其他的CPU一直在嗅探总线的数据流通，在缓存一致性的保障下， 能够嗅探到数据的修改，然后，如果自己的缓存行有这条数据，就置为失效。<br>如果下次有线程对该数据读或写，那么它会先从主存拉取数据保存到CPU自己的缓存行里边，然后再做进一步处理。<br>就是嗅探和MESI缓存一致性协议共同保证了CPU层的可见性。<br>总线如何知道volatile修饰呢？关键用了lock 前缀的指令，有两层含义。一个是将数据的修改推送到主存，一个是lock指令过控制总线的时候，其他CPU会嗅探lock指令，然后置缓存行失效。</p><p>禁止指令重排序<br>首先，它是禁止在编译阶段，Class结构中方法表的属性表的Code属性，存放着JVM指令，在编译期时，volatile就完成了一个内存屏障的编译。<br>对于volatile的写，写前加入storeStore屏障，保证写写顺序，写后加入storeLoad，保证先写后读顺序；对于volatile的读，在第一个读后加入loadLoad屏障，保证读读顺序，读后loadStore，保证先读后写顺序，StoreLoad这是个全能型屏障，开销很大，同时具有其他3个屏障的效果。执行该屏障的花销比较昂贵，因为处理器通常要把当前的写缓冲区的内容全部刷新到[内存]中（Buffer Fully Flush，一般不会单独使用。</p><blockquote><p>引申：<br>final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。<br>在 初次读 final 域操作的前面插入一个 LoadLoad 屏障</p></blockquote><p>特殊情况下，可以保证原子性。<br>如果是单条JVM指令字节码，可以保证原子性；如果是多条JVM指令字节码，不能保证原子性；（建议别深入，怕深问到指令出入栈）<br>如果是对 flag = true的读写，可保证，因为读和写都是1条指令字节码。<br>如果a++，不保证，这里涉及了3条JVM指令字节码，iload 读取a，iadd 进行a+1，istore 写a。</p><p>下面这个其他人的答案，有点含糊不理解：<br>read load use 作为一种读原子操作<br>assign store write 作为一种写原子操作<br>主存值read到执行引擎，执行引擎值load到一个栈存副本变量，栈存值use 到执行引擎，以便计算处理；<br>执行引擎值 assign到栈存副本变量，栈存副本值store到主存，主存值write 到主存的变量，以便共享；</p><p>原子操作避免 读过程 或 写过程 在中间操作被打断。<br>虽然use 和assign存在 被打断的可能，但工作内存和主内存，可以依旧相等。<br>    因此在多线程内，适合flag赋值，不适合a++等非原子操作，运算结果a会对中间加数a产生依赖。</p><blockquote><p><strong>Java内存模型即Java Memory Model，简称JMM。</strong><br><strong>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 是隶属于 JVM 的。</strong><br>一、JVM构成：<br><strong>1、类加载器（ClassLoader）</strong>:在 JVM 启动时或者在类运行将需要的 class 加载到JVM 中。<br><strong>2、执行引擎</strong>：负责执行 class 文件中包含的字节码指令.<br><strong>3、内存区（也叫运行时数据区）</strong>：是在 JVM 运行的时候操作所分配的内存区。<br><strong>（1）、方法区(MethodArea)</strong>：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。<br><strong>（2）、java 堆(Heap)</strong>：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。<br><strong>（3）、java 栈(Stack)</strong>：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个<br>方法从调用直至执行完成的过程，就对应一栈帧在 java 栈中入栈到出栈的过程。所以 java 栈是线程有的。<br><strong>（4）、程序计数器(PCRegister)</strong>：用于保存当前线程执行的内存地址。由于 JVM 程序是多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程私有的。<br><strong>（5）、本地方法栈(Native MethodStack)</strong>：和 java 栈的作用差不多，只不过是为 JVM 使用到 native 方法服务的。<br><strong>4、本地方法接口</strong>：主要是调用 C 或 C++实现的本地方法及回调结果。<br><strong>开线程影响哪块内存？</strong><br>每当有线程被创建的时候，JVM 就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。<br>Java 线程之间的通信总是隐式进行，并且采用的是共享内存模型。这里提到的共享内存模型指的就是 Java 内存模型(简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。总之，JMM 就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。</p></blockquote><p>比较：<br>synchronized  一定条件是重量级+可重用锁<br>作用到普通方法上，静态方法上，代码块。<br>普通方法是对象锁，静态方法是当前class锁，代码块看它的指定；</p><p>对单个值读写，<br>读多写少，用volatile，缓存行直接读；<br>读少写多，用sychronized作用到读写方法。<br>volatile锁总线，CPU嗅探，伪共享问题，总线风暴问题；<br>sychronized只会线程的block状态，有用户态和内核态的上下文切换，有一个线程执行的记忆，这个过程耗资源耗时间，所以提出CAS。如果写过程短，CPU执行非常快，线程blocked会非常短。</p><p>总结<br>重量级锁能提高程序的吞吐量。</p><p>volatile挖到操作系统的内存管理，可以看：<br><a href="https://missionodd.github.io/2022/01/26/distributed-volatile-series/">https://missionodd.github.io/2022/01/26/distributed-volatile-series/</a><br>Class文件结构可以看：<br><a href="https://missionodd.github.io/2022/02/01/jvm-notes/">https://missionodd.github.io/2022/02/01/jvm-notes/</a></p><hr><h2 id="Q：synchronized-和-lock-的区别？"><a href="#Q：synchronized-和-lock-的区别？" class="headerlink" title="Q：synchronized 和 lock 的区别？"></a>Q：synchronized 和 lock 的区别？</h2><p>1，基本使用，关键字；接口<br>    lock接口有6个方法：lock，unlock，trylock非阻塞加锁，trylock(time)非阻塞可超时加锁，lockInterruptibly可中断加锁；<br>    Rentrantlock 实现<br>2，隐式加锁，显式加锁<br>    lock在try里，unlock在finally里<br>3，作用方法上多种方式，lock只能作用到代码块<br>对于synchronized<br>    普通方法，静态方法，方法块上有什么不同。<br>    代码块反编译同步指令，monitorenter，monitorexit；<br>    一定有两个出口，正常和异常。<br>    方法上会有ACC_SYNCHRONIZED访问标志。</p><p>4，lock 支持非阻塞式加锁（信号量），支持可超时加锁，支持可中断加锁；<br>不阻塞，少一次上下文切换。可超时可中断，更灵活；</p><p>5，从底层原理，synchronized一定条件下 采用对象监视器monitor，lock采用AQS；<br>Object 的monitor，线程竞争失败，调用wait方法释放锁，会放到等待队列，等待唤醒，再进行锁竞争，会放到同步队列。</p><p>6，synchronized在进行加锁解锁或通知等待时，只有一个同步队列Entry Set 一个等待队列Wait Set；<br>lock有一个同步队列Entry Set，多个等待队列Wait Set；<br>创建一个condition就多一个等待队列<br>7，锁竞争，synchronized只支持非公平锁，lock支持公平锁和非公平锁；<br>对于在排队的A线程，新来的线程B，AB竞争机会相同，对A不公平；如果A总是被插队，A总是在排队，A就是饥饿线程。<br>对于在排队的A线程，新来的线程B，B在队列末端排队，对A公平。</p><p>8，等待唤醒机制，sychronized与Object进行配合，使用notifyAll方法操作；lock需要用contdition接口配合，也是wait/notify机制，只是方法名不同await/signalAll。<br>如果线程获取锁，并condition的await方法，线程去哪？<br>在await方法前，线程加入condition的等待队列，不需要CAS，直接加，此时持有当前锁，说明自己竞争成功。当调用await后，它会进行锁释放。<br>场景：线程A获取锁后，调用wait，A被唤醒，继续执行释放了，A经历了什么？<br>wait前，A提前加入condition的等待队列尾部，不需CAS；当A在队列头部，就是被唤醒，就会进行一轮线程竞争，如果竞争失败，会加入到锁的同步队列尾部，需要CAS；A排队到头部，被唤醒，看公平锁还是非公平锁，如果是非公平锁，可能还会保持一段时间饥饿，如果是公平锁，直接获取锁，直接跳转wait方法释放，直到把锁释放。</p><figure class="image-box">                <img src="image-20220305082139330.png" alt="image-20220305082139330" title class>                <p>image-20220305082139330</p>            </figure><p>9，个性化定制方面，AQS是使用模板方法模式，可以自定义lock。<br>lock下的读写锁ReentrantReadWriteLock，能支持并发读，是共享排他锁。<br><del>AQS的可重写方法：tryacquireShared /tryreleaseshared，tryacquire/tryrelease等，不展开了</del></p><blockquote><p>每个对象都与一个<strong>monitor</strong> 相关联。当且仅当拥有所有者时（被拥有），monitor才会被锁定。执行到monitorenter指令的线程，会尝试去获得对应的monitor，如下：</p><blockquote><p>每个对象维护着一个记录着被锁次数的计数器, 对象未被锁定时，该计数器为0。线程进入monitor（执行monitorenter指令）时，会把计数器设置为1.</p><p>当同一个线程再次获得该对象的锁的时候，计数器再次自增.</p><p>当其他线程想获得该monitor的时候，就会阻塞，直到计数器为0才能成功。</p></blockquote></blockquote><h2 id="锁升级详解"><a href="#锁升级详解" class="headerlink" title="锁升级详解"></a>锁升级详解</h2><blockquote><p><strong>synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁</strong></p></blockquote><blockquote><p><strong>无锁，偏向锁，轻量级锁（CAS）都是在用户空间完成</strong><br><strong>重量级锁是需要向内核申请的</strong></p></blockquote><p>简单的讲（简单概括这里可忽略不用看）：<br><strong>当线程A启动后，获得了对象的锁，此时线程A的线程ID将保存到对象的对象头中，对象头中的偏向锁标志位变为1。此时如果第二个线程B想访问这个对象，线程A、B之间就存在一个竞争的关系，但是此时偏向锁是偏向于线程A的，即A是优先的，偏向锁将会升级为轻量级锁，以此来保证持有对象锁的的线程A运行。此时线程B将会进行CAS，CAS也叫做自旋锁，B会去检查对象的锁是否还是属于A的，如果是，那B将会继续自选，直到对象锁被释放，B马上就会获取对象的锁。但是假如长时间无法获取到对象的锁，CAS是会消耗CPU的性能的，尤其当许多个线程竞争同一个对象的锁时，CPU资源占用会大大提高，此时锁将会再次升级，对象锁将升级为重量级锁。此时，所有竞争的线程将进入阻塞队列，等待cpu的调度。</strong><br><figure class="image-box">                <img src="200B5CB0-C1CD-4BAB-B6D0-0F9571CA6BE7_20220306170653.png?v=1&type=image&token=V1:3a9aOLmt56Y9r0-FQjdOX46UTQordIh0AVMM9wUpw3I" alt="32位" title class>                <p>32位</p>            </figure></p><figure class="image-box">                <img src="7D5886D5-B82C-4991-BB30-A941167F9C49_20220306165657.png?v=1&type=image&token=V1:-L4TERytUf4m7oc5qmaAP0u8qsvL9-ami3kxpq7ZVYc" alt="64位" title class>                <p>64位</p>            </figure><p>看图，具体展开：<br>32位系统下，<br>当我们创建对象的时候，它对象头里Markword有25位hashcode，4位分代年龄，1位偏向锁标记，2位锁标记位。</p><p><del>对象头的其他，32位的指向元空间的类指针，不一定存在的32位对象数组长度，这里不展开。</del></p><p>如果对象进行new关键字，对象头有无25位hashcode？<br>仅仅new对象，如果没有显式或隐式调用hashcode方法，该标记位并没有真实标记hashcode。就是说，只有调用Object类hashcode，才会有标记，比如存入Hashmap，否则是0。</p><p>分代年龄，没有经过minorgc，就是0。</p><p>偏向锁位：<br>无锁状态，偏向锁位 0<br>偏向锁态，偏向锁位 1</p><p>无锁状态升级为偏向锁状态<br>想要成为偏向锁态，markword中无hashcode记录，这是一个前提。<br>让23位线程ID+2位epoch 占据了无锁态的所谓25位hashcode位。</p><p>锁标志位：<br>标记是什么锁状态。具体看图</p><p><strong>偏向锁：</strong><br>单线程操作环境，不存在锁竞争，偏向锁有一个非常好的性能，<code>偏向锁</code>会直接往markword里贴上线程ID，表示锁住了，<strong>每次只需检查线程ID是否偏向自己，好处是：没有CAS自旋和操作系统调用这些耗时的锁竞争机制</strong>。<br><strong>如果出现其他线程竞争，也不一定升级锁</strong>。比如线程A在对象已贴上线程ID，线程B发现被贴上A线程ID，就会检查线程A的存活状态，如果线程A已在临界区外，线程B先把对象置为匿名偏向锁状态，<code>‘宁为玉碎，不为瓦全’</code>，再准备CAS无锁竞争，如果竞争成功，线程B把对象置为偏向自己。如果竞争失败，比如线程C进来并且CAS抢到(截胡)，C正在执行同步代码，此时B仍不放弃，还要做一个更高级的争取操作，线程B会进行<code>偏向锁撤销</code>的stw复杂操作：B线程挂起，等待线程C到达全局安全点后就把C暂停，线程C的栈会被遍历，找里边的偏向锁对象记录Lock Record，看看线程C是否还锁着。如果找到Lock Record则说明线程C还在临界区，否则线程C不存活。接下来，<br>简化地说：线程B撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。<br>具体而言：<br>如果线程C还存活且线程正在执行同步代码块中的代码，则直接升级为轻量级锁<br>如果线程C未存活，或者未执行同步代码块中的代码，则进行校验是否触发过批量重偏向：<br>1 没触发<strong>重偏向</strong>，则撤销偏向锁，将markword升级为轻量级锁（无锁状态），再进行CAS竞争真正成为轻量级锁<br>2 触发了<strong>重偏向</strong>，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程。</p><p>那么，最后就会导致3种情况：</p><p>一是对象升级为轻量级锁，但起初只是锁位标记00，前30位置为00，没有指向锁记录栈帧，此时算是无锁状态；后续再CAS自旋竞争锁处理真正成为轻量级锁。</p><p>二是对象重新偏向到线程B。</p><p>涉及到<strong>批量重偏向</strong>和<strong>批量撤销</strong>的操作。<br>除了对象markword有epoch计数器，class信息中也有epoch值，class的epoch维护两个阈值，批量重偏向阈值是20，批量撤销阈值40。</p><p>比如：同一个类创建40对象，线程1对40对象进行同步块的初始的加锁并保持执行，线程2对40个对象操作而引起了偏向锁撤销，首先会把前19个对象进行偏向锁撤销为匿名偏向锁，每次撤销class的epoch会+1，之后达到class批量重偏向阈值20，JVM认为class偏向锁有倾错问题，触发批量重偏向，后20到40对象通过CAS直接偏向线程B，这就是批量重偏向的过程，这里class计数器没有增长。线程3，执行20-40做锁撤销，撤销class计数器继续增长，达到class批量撤销阈值40，JVM这个类的竞争激烈，标记该class为偏向不可用，在之后创建41个对象时，会直接把锁标记置00膨胀为轻量级锁，这就是批量撤销过程。</p><p>此外，触发批量重偏向阈值20后，还配合一个time超时阈值25s，如果超时未达40的批量撤销阈值，重置class的epoch，下次重新计数20-39的范围。</p><p>三是直接将该类置为不可使用偏向锁。<br>这个就是批量撤销开启之后。</p><p>偏向锁升级为轻量级锁：<br>先把偏向锁标记置00，线程ID+Epoch置为00，是无所状态。由下一次争抢完成升级。</p><p>下面是流程图和代码，跟文字描述会有出入<br><figure class="image-box">                <img src="image-20220324153550084.png" alt="偏向锁" title class>                <p>偏向锁</p>            </figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BiasedLocking::<span class="function">Condition <span class="title">revoke_bias</span><span class="params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  <span class="comment">// 如果对象不是偏向锁，直接返回 NOT_BIASED</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  <span class="comment">// 构建两个 mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span></span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == NULL) &#123;</span><br><span class="line">     <span class="comment">// 匿名偏向。当调用锁对象原始的 hashcode() 方法会走到这个逻辑</span></span><br><span class="line">     <span class="comment">// 如果不允许重偏向，则将对象的 mark word 设置为无锁模式</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断偏向线程是否还存活</span></span><br><span class="line">  bool thread_is_alive = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 如果当前线程就是偏向线程</span></span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 遍历当前 jvm 的所有线程，如果能找到，则说明偏向的线程还存活</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果偏向的线程已经不存活了</span></span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="comment">// 如果允许重偏向，则将对象 mark word 设置为匿名偏向状态，否则设置为无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程还存活则遍历线程栈中所有的 lock record</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = NULL;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    <span class="comment">// 如果能找到对应的 lock record，说明偏向所有者正在持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;owner() == obj) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 升级为轻量级锁，修改栈中所有关联该锁的 lock record</span></span><br><span class="line">      <span class="comment">// 先处理所有锁重入的情况，轻量级锁的 displaced mark word 为 NULL，表示锁重入</span></span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) NULL);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != NULL) &#123; <span class="comment">// highest_lock 如果非空，则它是最早关联该锁的 lock record</span></span><br><span class="line">    <span class="comment">// 这个 lock record 是线程彻底退出该锁的最后一个 lock record</span></span><br><span class="line">    <span class="comment">// 所以要，设置 lock record 的 displaced mark word 为无锁状态的 mark word</span></span><br><span class="line">    <span class="comment">// 并让锁对象的 mark word 指向当前 lock record</span></span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 走到这里说明偏向所有者没有正在持有锁</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">       <span class="comment">// 设置为匿名偏向状态</span></span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 mark word 设置为无锁状态</span></span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br></pre></td></tr></table></figure><blockquote><p>注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</p></blockquote><blockquote><p><strong>批量重偏向</strong>和<strong>批量撤销</strong>如何理解，我用转岗问题举例：<br>有40个员工（对象锁），3个部门（线程）。<br>1) 线程1: 1-40都入职部门1了（有偏向的线程1了）<br>2) 线程2：1-19都离职（锁撤销）后又跳槽到部门2，HR们看转岗一出一进麻烦，改为以后想活水就直接在员工档案上改部门吧，一年内一次活水机会，结果，20-40都快速活水了（可重偏向）（Thread Id直接换了） // 到达BiasedLockingBulkRebiasThreshold（20）次数后。<br>3) 线程3：不到一年，20-40又都离职（锁撤销）后又跳槽到部门3，HR们觉得转岗频率太高了，滚蛋，以后都玩完，转岗门槛拉高（设置为不可偏向状态，正在运行的锁对象会被撤销）// 到达BiasedLockingBulkRevokeThreshold（40）次数<br>4) 以后新入职的员工41，就规定了较高的转岗门槛（new出来就是轻量级锁）。只能等待各部门主动去要你。</p><p>PS: 活水是指依靠公司内部的转岗机制，实现跳槽换部门。</p></blockquote><p><strong>轻量锁</strong>：<br>多线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 MarkWord 中的线程 ID 不是自己的线程 ID，会CAS尝试获得锁，如果持有锁的线程在全局安全点检查时，不需要再使用该锁了则获取成功，程序继续执行，反之则获取锁失败，撤销偏向状态01变为无锁00，升级为轻量级锁，即自旋锁。</p><p>此时，将锁对象markWord中32位修改成指向自己线程栈中Lock Record的指针（CAS抢）执行在用户态，消耗CPU的资源。此时，锁标记位00.<br>JDK1.6引入了聪明的<strong>自适应自旋锁</strong>。能减少长任务的自旋次数。<br>他的自旋次数是会变的，我用大白话来讲一下，就是线程如果上次自旋成功了，那么这次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么这次自旋也很有可能会再次成功。反之，如果某个锁很少有自旋成功，那么以后的自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>轻量级锁的加锁过程：<br>线程A进入同步块，如果同步对象偏向锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，里边存储锁对象目前的Mark Word的拷贝，存放拷贝的地方称之为 Displaced Mark Word。然后轻量级加锁时，拷贝对象头中的Mark Word复制到锁记录中；<br>之后，虚拟机将使用CAS操作尝试将object的Mark Word中的32位更新为指向线程A的Lock Record的指针，并将线程A的Lock record里的owner指针指向object的markWord，意在完成线程A与object的绑锁。此时，线程A持有锁。<br>此时线程B进来尝试CAS更新，<br>如果更新成功，那么线程B就拥有了该对象的锁，并且对象Mark Word的锁标志位置为“00”，即表示此对象处于轻量级锁定状态。<br>如果这个更新操作失败了，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。<br>此时为了提高获取锁的效率，线程B会不断地循环去获取锁，尝试CAS, 这个循环是有次数限制的，比如10次，如果在循环结束之前CAS操作成功，那么线程B就获取到锁；<br>如果循环结束依然获取不到锁, 则线程B获取锁失败, 对象的MarkWord中的记录会被修改为指向互斥量（重量级锁）的指针。之后，锁标志的状态值变为10，然后线程B被挂起，后面来的线程也会直接被挂起。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。</p><p>此时，线程A的displaced mark word和原来对象的markword不一样了。</p><p>解锁<br>也是通过CAS操作来进行的，如果对象的Mark Word仍然<code>指向着线程A</code>的<code>锁记录</code>，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word<code>替换回来</code>。</p><p>因为线程B把对象 markword改成重量级锁，那么线程A<code>替换失败</code>，那么就把自己栈桢的Displaced Mark Word拷贝到对象头的<strong>Monitor</strong>对象的header变量，并且<strong>Monitor</strong>对象的owner变量指向自己。保证displaced mark word不丢失。</p><p><strong>重量级锁</strong>：<br>CAS发生10次后，轻量级锁升级为重量级锁，把锁指针指向重量级锁Object的monitor。</p><p>在Java虚拟机(HotSpot)中，Monitor对象其实就是ObjectMonitor对象，这个对象是一个C++对象，定义在虚拟机源码中。</p><p>回顾Monitor机制。<br>场景：线程A获取锁后，调用wait，A被唤醒，继续执行释放了，A经历了什么？<br>wait前，A提前加入等待队列WaitSet尾部，不需CAS；当A在队列头部，就是被唤醒，就会进行一轮线程竞争，如果竞争失败，会加入到锁的同步队列EntrySet尾部，需要CAS；当A排队到同步队列头部，被唤醒，看公平锁还是非公平锁，如果是非公平锁，可能还会保持一段时间饥饿，如果是公平锁，直接获取锁，直接跳转wait方法释放，直到把锁释放。当然，synchronized是非公平锁，公平锁情况并没有出现。</p><figure class="image-box">                <img src="image-20220305082139330.png" alt="image-20220305082139330" title class>                <p>image-20220305082139330</p>            </figure><figure class="image-box">                <img src="image-20220324082854210.png" alt="image-20220324082854210" title class>                <p>image-20220324082854210</p>            </figure><h3 id="synchronized可重入"><a href="#synchronized可重入" class="headerlink" title="synchronized可重入"></a>synchronized可重入</h3><p>synchronized是可重入锁，那么它是如何实现可重入的呢？其实上面详细的过程已经说过了，这里再总结一下（之前的判断逻辑就省略掉了）：</p><p>偏向锁：检查markWord中的线程ID是否是当前线程，如果是的话就获取锁，继续执行代码；<br>轻量级锁：检查markWord中指向lockRecord的指针是否是指向当前线程的lockRecord，是的话继续执行代码；<br>重量级锁：检查_owner属性，如果该属性指向了本线程，_count属性+1，并继续执行代码。</p><p>总结<br>synchronized的执行过程：</p><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><p>上面几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p><p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p><p>synchronized锁升级实际上是把本来的悲观锁变成了 在一定条件下 使用无锁(同样线程获取相同资源的偏向锁)，以及使用乐观(自旋锁 cas)和一定条件下悲观(重量级锁)的形式。</p><p>偏向锁:适用于单线程适用锁的情况，如果线程争用激烈，那么应该禁用偏向锁。</p><p>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)</p><p>重量级锁：适用于竞争激烈的情况</p><p><strong>锁优化</strong></p><p>以上介绍的锁不是我们代码中能够控制的，但是借鉴上面的思想，我们可以优化我们自己线程的加锁操作；</p><p><strong>锁消除</strong></p><p>锁消除用大白话来讲，就是在一段程序里你用了锁，但是jvm检测到这段程序里不存在共享数据竞争问题，也就是变量没有逃逸出方法外，这个时候jvm就会把这个锁消除掉</p><p>我们程序员写代码的时候自然是知道哪里需要上锁，哪里不需要，但是有时候我们虽然没有显示使用锁，但是我们不小心使了一些线程安全的API时，如StringBuffer、Vector、HashTable等，这个时候会隐形的加锁。比如下段代码：</p><pre><code>public void sbTest(){    StringBuffer sb= new StringBuffer();    for(int i = 0 ; i &lt; 10 ; i++){        sb.append(i);    }    System.out.println(sb.toString());}</code></pre><p>上面这段代码，JVM可以明显检测到变量sb没有逃逸出方法sbTest()之外，所以JVM可以大胆地将sbTest内部的加锁操作消除。</p><p><strong>减少锁的时间</strong></p><p>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p><strong>减小锁的粒度</strong></p><p>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间（如ConcurrentHashMap、LinkedBlockingQueue、LongAdder）；</p><p><strong>锁粗化</strong></p><p>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; 在以下场景下需要粗化锁的粒度：<br>假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p><strong>使用读写锁</strong></p><p>ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写。</p><h2 id="单例模式的原因"><a href="#单例模式的原因" class="headerlink" title="单例模式的原因"></a>单例模式的原因</h2><p>双重校验锁DCL ——double check lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.懒汉实现惰性加载资源。</p><ol start="2"><li>volatile修饰，设置内存屏障。错误说法：<del>强制指令执行顺序，先分配内存空间，再创建对象，最后引用指向该对象。</del><br>正确：在这行代码的new指令前加入StoreStore屏障，在new指令后加入StoreLoad屏障，保证new指令内部的三步：分配内存空间，创建对象，引用指向该对象的完成，才有外部读操作，也就是if空判断的读取。<br>总体效果就是一个线程对volatile的读，优先于其他线程对volatile的写。<br>挖重点，StoreLoad是全能屏障，总线会有Lock前缀指令，确保写操作的主存刷新以及CPU缓存失效。</li><li>static修饰，定义属于类变量，保证单例</li><li>第一个判断null，过滤synchronized锁的性能消耗</li><li>同步块，设置临界区，同时间只允许一个线程完成对象的创建。</li><li>第二个判断null，防止多线程进入第一个判断null，而导致多对象的创建。</li></ol><blockquote><p>Q: 过去DCL不安全的原因？<br>JVM1.4前，允许指令混乱情况。final：一个线程构造函数为final修饰变量赋值，另一个线程可能获取final的初始化0值；volatile：只保证读可见性，不保证写的顺序</p></blockquote><blockquote><p>Q: 不用volatile，先临时变量，再赋值到单例变量，是否能解决指令重排？<br> 不能，JVM只是潜在的reorder推手之一，CPU和缓存也会导致重排</p></blockquote><blockquote><p>Q: 新版本volatile如何保证DCL安全？<br>设置内存屏障，防止指令重拍，其中store-load屏障是保证读写顺序，实现volatile上的happens-before语义，即一个线程对volatile变量的写，先于其他线程对该变量的同时读。屏障的结果就是原来只保证volatile字段本身的可见性，现在保证本身以及所有相关字段的可见性，代价就是造成访问volatile字段的更大性能开销。</p></blockquote><blockquote><p>Q：是否可以用final实现DCL？<br>能。<br>a.对final字段的写必然先于其它线程装载该final字段的共享引用。（final字段必须被正确地赋值后其它线程才能读取到它）<br>b. 构造函数执行完毕后，对 final 字段的所有写以及通过这些 final 字段间接可及的变量变为“冻结”，所有在冻结之后获得对这个对象的引用的线程都会保证看到所有冻结字段的冻结值。（所有线程对final及其间接字段有一致的可见性）<br>c. 初始化 final 字段的写将不会与构造函数关联的冻结后面的操作一起重排序。（构造函数内部，对某个final字段而言，它的冻结点之前的操作必然先于冻结点之后的操作）</p></blockquote><blockquote><p> 再来说一下final域的重排规则：</p><ol><li>写final的重排规则：<br>JMM禁止编译器把final域的写重排序到构造函数之外。<br>在final域的写之后，插入一个StoreStore屏障。<br>也就是说确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</li><li>读final的重排规则：<br>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。<br>在读final域操作的前面插入一个LoadLoad屏障。<br>也就是说确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</li><li>如果final域是引用类型，那么增加如下约束：<br>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>就是确保在构造函数外把这个被构造对象的引用赋值给一个引用变量之前，final域已经完全初始化并且赋值给了当前构造对象的成员域，至于初始化和赋值这两个操作则不确保先后顺序。）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: DCL是否是实现单例的最佳方案？是否有代替？<br>不是。DCL的目的是懒加载和提高性能，但现代JMM加强volatile保证可靠，但副作用是性能开销变大，且加上了同步块的开销。</p></blockquote><p>完美方案：<br>推荐通过内部类实现惰性加载：<br>有一个大前提，JVM保证类的加载过程是线程互斥。<br>第一个调用getInstance，instance只被创建1次，且赋值给instance的内存已初始化完毕，避免reorder，此外，该方法第一次使用互斥机制，解决同步块带来的性能问题；<br>当然，只有第一次调用getInstance时才让instance加载，所以是惰性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;      </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             …          </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonContainer</span></span>&#123;</span><br><span class="line">             <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> SingletonContainer.instance;          </span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/doraeimo/article/details/5714239" target="_blank" rel="noopener">https://blog.csdn.net/doraeimo/article/details/5714239</a></p><h2 id="线程池参数调优—雨露均沾，保绩效"><a href="#线程池参数调优—雨露均沾，保绩效" class="headerlink" title="线程池参数调优—雨露均沾，保绩效"></a>线程池参数调优—雨露均沾，保绩效</h2><p>通过压测，符合最终场景，调整参数。<br>如何进行初次压测时，线程池参数配置？<br>分两种场景：<br>一当前服务器，只为当前线程池服务。也就是说，线程池能够占用服务器的所有资源，比如Tomcat的IO池，并行Steam流。依据处理逻辑，是CPU密集还是IO密集。CPU密集就选CPU数+1，IO密集就选CPU数的2N+1，N越大，可以加2加3。根据一轮压测结果，做一个参数的合理调整。<br>二是存在微服务和多接口，比如一个场景：5个接口：2个重要，3个降级，高并发压力下就会对3个接口进行降级，保障2个重要尽可能分配到更多服务器资源。在一个重要接口里，需要创建线程池，提高单接口处理速度，这个时候，不能只看CPU核数，线程池设置参数需要具体一个依据：<br>首先，一个真正高并发项目，它的监控是非常完备的，首先拿到线上高并发压力下该服务所有接口的访问比例。比如刚提到5个接口，2000条请求打到服务里边，5个接口分别<strong>承载着不同比例的访问量</strong>，比如2:3:1:1:1。比如，在比3这一块，它有资格至少占用服务资源的3/8。它不能太大，否则占用过多而让其他线程无路可走。<br>那么此时，基本可确定maxPool<strong>最大线程数参数</strong>，占服务器线程资源的3/8。<br>至于整体服务器峰值最大承载多少线程，参照CPU核数以及QPS来说。比如QPS100，相当于1s内服务器内当前几个CPU线程能承载起100个请求线程，因为处理速度够快。所以，要衡量整体服务器最大QPS，即当前服务器的<strong>同一时刻活跃的线程数</strong>。当前活跃线程数可粗略理解为这是基于业务需求场景的资源数最大值。再根据3/8，可以确定接口最大分配线程参数的值，100*3/8约等于40。</p><p>接下来，考虑<strong>核心线程数</strong>。初次压测时，设置为与最大线程数一般大，看能否撑住。撑住就尝试调小到资源不浪费，否则撑不住，要对任务排队队列Q设置，Q是存储排队的任务。Q不推荐无界队列，这相当于最大线程数失效，违背设计线程池的初衷，而且高并发导致Q的无限积压而OOM。<strong>Q设置为有界队列</strong>，这个界的依据又是什么呢？在生产上，像抢购秒杀都会有<strong>一个高峰访问时段</strong>，那么在压测的时候，需要模拟一个生产上的高峰访问时段。比如1小时抢购活动，就要至少持续1小时的压测。在无Q等待情况压测，大概算一下在分布式环境下的一个节点1小时该接口能够承载的最大值，如进来10w，只处理8w，失败2w，2w适当上调50%作为有界队列上限，为了访问节点倾斜的问题，如果均匀可改为10%，如果有节点<strong>访问尖刺</strong>就要调到尖刺最高位左右。要知道，实际的队列上界一般很大。</p><p>这几个初次调整后，<strong>开始多轮压测</strong>，看是否达到性能需求目的。可适当调小线程数，避免浪费无用的线程资源，因为，后续要涉及接口降级和线程池导致高可用问题。一步步调到最好，这是最理想的。<br>但往往可能，没有达到预期，刚刚已经给3/8最大资源量，还不够。第一点，<strong>再次调高队列存储上限</strong>，前提是业务能够接受这种等待慢，先不要想增加同时线程数，而是通过任务空间缓冲，保持当前接口稳定运行，且不影响其他接口。第二点，不接受Q过大，想尽快处理任务，那么，要从单机单接口的<strong>代码的并发性调高</strong>，从吞吐量和RT入手，比如，DB访问是瓶颈，使用缓存；第三方接口是瓶颈，使用异步MQ处理；秒杀业务，开Gzip压缩和做静态页面。第三点，已竭尽所有，<strong>只能线程数适当调大一点</strong>。但不能太大，如果以当前接口利益为中心，而毁坏其他接口持有服务器资源的权利，这是比较糟糕的。所以，在对重要接口的线程数调大的同时，要对其他接口做<strong>降级处理</strong>，相当于降级接口去牺牲它的服务器资源，分摊给重要接口。<br>但其实，这做法不要做，应该向上级<strong>申请加节点</strong>，通过集群分摊。<br>因为，调大线程数，是让其他接口冒着风险。其他的接口设置线程数小了，很有可能走到抛异常的饱和策略，这样，它抛出异常比例升高，造成接口的熔断或降级。<br>这本来够用的服务资源，由于设置线程池参数不合理而导致异常熔断或降级，AC，年终绩效没有了，必背锅。线程数调得过大，这事更大，你占用了额外的资源，导致别的接口的请求积压。</p><p>至于，keepAlive空闲线程存活时间，只是复用性的优化，根据测试，看有无触及阻塞队列阈值，如果频繁触及，说明业务总需要非核心线程，适当调大存活时间。一般默认即可，因为我已经确定当前最大线程数绝不会影响到服务的其他接口资源，它的调整优化作用非常有限。</p><p>饱和策略，大多数业务抛异常，记录日志，熔断或降级处理，做重试机制。</p><p>最后，理解以上这些，那么我们可以合理配置hystrix或sentinel。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;volatile&quot;&gt;&lt;a href=&quot;#volatile&quot; class=&quot;headerlink&quot; title=&quot;volatile&quot;&gt;&lt;/a&gt;volatile&lt;/h2&gt;&lt;p&gt;一是保证可见性。&lt;br&gt;二是禁止指令重排序。&lt;br&gt;可见性，是让其他线程可见，一般我们是多核</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="高并发" scheme="https://missionodd.github.io/categories/技术/高并发/"/>
    
    <category term="并发编程" scheme="https://missionodd.github.io/categories/技术/高并发/并发编程/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="高并发" scheme="https://missionodd.github.io/tags/高并发/"/>
    
  </entry>
  
  <entry>
    <title>面经 | 基础面+调优经验，高P7开发一面摘录笔记</title>
    <link href="https://missionodd.github.io/2022/02/15/p7-interview-skills-1/"/>
    <id>https://missionodd.github.io/2022/02/15/p7-interview-skills-1/</id>
    <published>2022-02-15T07:50:37.000Z</published>
    <updated>2022-02-28T02:22:02.318Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8e81d129e67d7343713e3638802cb414e2ad220c263a1fe7852eaa9fd8019f6d">4c4fd9e09482e311844f0584b2bdee0d161fcfef30e9a8b92a83c9a32f76ed99a2bd1ac35892d3b01fad95391022b7f8c49854b431a7e21c3a9092d9729291ace0ae2cc5dd095c2ebe575ae870d4c6012b88730018f3ff09d93dfcdcd3ef1a226ed49cf9a99927f4ed5d420af3d8bc3a436d0e736b2df3c1395ca1fd324cc4f567c8a49d8a12e4b48f121cd842cce9a5ea2c8dd2d80efcd94038be1e7c71d65cdb27138fe09c0dc6f64237e253bde394a1ee4145bb30b6919a2b0096eb4b9159a2fc2fe2478dad9c5b1c433573b21e4643bb3de19c76a5a6529386c849d401c74fca4f3b71f3ec502e2bf609dddf688fed2c30881bdce0e6b39bde1b0dc2b43b19e7fec665fd4f7e4cb35a1aedef7689beb27d6ae4c4ce76389e1e2ea6724610332496be121961456392676b1593174d0a754ed824334f3b405b9d1b8f41d9a96291b7045bfbc8fc9f0f271d123a4791c5ce514582380b631b62eca92679b7e669bea9f6da582f2584cd6f03d8d2e2032a6696fd83698c5a6b29269dd0c1daa652a2fda7b3bfc8bbef2682585d352b34abda47f01ad97ccf2c81d1d53553bdb1e8e832e4b7a54716fc824b44d649e26d0037faaf12883e36ee4f33c5c1e09c372ae3f5d3c9595dc4cf10466b35fa1e60b1d5752c7ce9cdd463904cc84a59b65fd53828ae95d6042b7b946858d8c8424587be88003f051ee7c15f2f1863a253f1219214b5837a507c060ee1a7f5bd4f5d43371b6c10617a89be8f6dccd9f1d963518d52e9ed6001ad985f07242e31d3ccc238f2cffc775f75c6392fec48d163f0e52a91dac59889a487844dacdb0ab0966f3db551ee4a870a28a610ca292b40d1f35630f446e44cd721084de26f84237d1f7ecd21d459f06c3f5825d134f12d3ec77cd133e4982a6086ad601f0a58a769070dd2eee9140a80fa93484dac6e3d5de5e9be4690ee697323f500b3ec9ea13ace3dbe2cf09b6161a72e2f9b0d6f72da7f17a8cdd485ec22edec651db46a739314e2a7d1a3ec204921ddb65fbce8850db2b9d255e938b0d611f7f99dfcfda7dae4217d0e22bf72f1817c71b4120803fce0f7698501f278c7467b27f708b9c7533012e226d86058479e372cae9a7576d024b5920a6b5b41c3a194847c950c3f0044052bf187e204f8fce2d8643e3ce7ec7c7b2e59f6b89b6788406d4c5114bd3dc0f268f47425786b512f585104bd761cddc456a8432ab5ccdaccd1a5c49b0ed5cbe0a82fa24179befbc8689fce88183fab05c377b62306bbd4de78571528ecaba9aba12b621d39a70c1ffff7ac179c012d002c236feeb6500df598a23d220691e0285451a7ad14d4ce1546266709a6340904ef611c8a99729b189499a93329ab4ba8a1340f0e6b406d81a70f0af1986c3345a20f0c2dc0c4daf42331a24b484cc339cb9d528872f86239eb3f478fbb8f6aa3ff3d21b558ac87b1974675cd048dc931e9ad1b318237b1068e433cca654ebcf1cf3015ea221848f433b3b8d2e78d7125d381d402ed4f6ff4c6091cc638ba4c61917e3ae743bef6f5d7d8485f3084fbeb655758cd655c7d6aeb82599c8b8f39a250aae148f60a1cb76474936f5c178c9c15487412913bb90aa49b2cd66daa348d8f5821252041c1ef7462244fb84fb4597df227be73518b25b9efe7005d9d8f3d83f893e53cfdfbe943c25620da58415c472b12bd70b611991ce88bed1c56ce9158cc2518223fc44bd8fe70c35f23b6caafd908514fcabb4b5734bf770f36b9b9d8888548fff572eeca2931b4a9cd8eb059857d7a7574317e674e71244fd0849530ffac7736642332cd63db439346581500562fa7c98f73d035d54b6c5e5498fa821c70171220c8588ae6f2b0aac450cb88946fca2ff246d08ccd93c97d05f220ada15ad0946cb29bad0e92bc14ca14ae3af232c05ef81d2c25b0a7e176628b1cdb9a6e71cf83abaed949eca68606674bba225f0d01804fce1a15f8e603c990d5e56b6fa7ad01cd0a7a9240d026603b02736d65ee64d8111739005cb5c80399559f9cc94daa5d40e4cf7490b2fba5b9c170dd8248a5862734bfca629f441676c1ca7ea18ea31d7bd400f87b7435c42abbcb47b896241edea6a94a7e49897168775b223f867ff18f1cc0a781fc282b3f19bc83f5cac9896b57f35c0b0da24fcf12da1a4ef2c79643b836eb000f14942d97fc34d0e27fac8aae2379ba007e2618b4a54b3daabeef6a67309a909fdce8e7170423dfc0f1ef0f42a3909636aadc817d86e81c2726a027debb1f441dafdfc54035372e58f21e0c9ca27b5965ab5a90f96874ebdb617514bbdbca97f70a1d0a367f0e34cb6c9263ae66b39bf617e884353927fc03f6857a0f259339b6e134a1c4f5664b814b13dcc17145a81ea5345b912a22521afa022a9cb862a1ec4141a4a77255d1ac32a93ae5962074da28205a70b9d44d03a033734a0ca6c8b5908ec9bfb74569463b1a1c640d0039c540a0034dedcb30cc37b76aaf6c208364f5f9f659414aafe7a48c6a07c89d86324cbb1bf0dcfb08a2b6b3b61a14ccffc53caf9938322a8c4fdfc07c6b704380a362d6d50c80b176440130ec49480d6ef64a4b968ca9f448a5c1bee71e640f92501c282ef1bb017ac994d22a6d36a099d34f97733d2751a0bf7c51da050a01847609d3ae9f8328ab2bc3004fb5caa516aa0f8a5e321d215d30a0d98de6d2183272a9762acf74ea4988a194bd62c3ef486dbdc68f151f488deb9c401b0397091a57ab116b59ef815d50104efaf0ba6992c0a40787c8019222263cb87406b0e6df011bd803eebfe00264f153e69295133abc699fc51c5e34dddded65d4300e189b5e93e25f6aac9ff1f73d433015b086340741db27828d3fe42c69821307112cf1dd0ce44a623bb0bb6c00564db5e3d3740bdbc9a6e6dc358f3aba682124a39fa87b09e85e3da632aba76e72646467b0f78d73bad1693c829759ab4a707e0ec3b1592f4b02b184649245154226dab4176c62b359fa09f2ae2f1e6176050fb29651932e4b2bb046c8065a8592b9d5ac05cdb469788fefec4ffa78a277ea01f95586d8af156f3c37c48d1d5c505e0373552d8f5cbcc85e1901413d10517b663363e72de0693fd4e04e5c129f831381ecb2df28fb165435bf5fb40bfbe70d98fea833b775864e966d8a47dfebaaf815448fa4249af2a75a8c6bece5d1bd66a7686340437715d0c3c91d7e7ca78e39cd770aef4bf713a8e3c2e7edb4a0ea113ae3ef6fcad5fab977590af3621a425ff112e207adba2ed5e6d9c79fa57f214996f084021ef0ad2cd7516d06806a4e021702ca37b3469fd3c921551a4808eed55bce6bc58d31a3d34ed3d9e5678e8e20d792a53bbda4ddaf506e92b166ef77e57fbc4c8b819fb3eb2b15c95a118003eecfc14bee2fd899c187488c5982cd4499bb4b1d8533a2d58d53ced9824f85f965b889b9172b1a73293552aa936264037d8a7133f1c3bd42e08c50df5c7bf91fea919c984bdf70cac5d84382c48ea8f4b7cdbd551f24a4c44689cb875ed299d28b6b0911120b6e17dccfd5b3ae7a1b1616cd887b2750d695691c63fd86074aa8587e349d5b39ad8ea90824b58923fbe05035bd5f44a5ab4428d8cee237f08951b28e1bea740553e7fc8529845a79a394e4e86b220edccf2c77d789d30828d1244c110374a2a36d55d6e2a74ac196f6813d8b3d7503bb5aca44c0da42e8c6e7ae89ca3206916959ff89a639de1a621e3fd7b787b72b1def32149c2c2341efe355cb3190ae5670e892cce23b78b206cbee94ea3f131a9e476108a31115f0a70a3d711fd371639986de32309c21e9640233f7dfe22199873d4946d04ce661e93f3861be5ad915b592b4f94ad0b83f27ea2aebb4544c3b0c1da5183b98d9d0a589714a3182dfe880f24c50a32e840a28f7a00d45967a108a48f4f51c568aa125d4116898bb3492a3c4aec179c55389920c97e6b32cf5dd614589ded670c230016fe386d61322f424f98acb08e8240a6d4eae0e6c5ce4bbe77a34475c117b13e019b8e2e59c245ad1a92baa44379228b968f22b5a471c9ba9a2d889ca290497bf0f05fb648871f77c6b0d1a74859beb4f2ca490372ed04b6607b5dc1228f46ad4ae8abf6cc86a1a706303c73be292249d2da01860cc504736902a5975b575e0c90455c0eecae8ed2166517f9e432954d4a0acadf9c4b11f5339b27608b5fe1702b064484552382cb010b6fa48008d75edfe0f707d117f1b051bad0407ca7e73a772c44c5a8b2a62464a1e33f51764639e9df331ce233133df2c8a08e0cc5006f629f0f68b79b5e75f23255e1900155e687505728d15e118210594978208d128db6d9e7bc80a1ee8521dcebd5ff1fc971bd465312024ad0013f75ba4bfbebf559ad0b82f49893a329c0fcac219d33891bdd746881e4ef968c084f155d90bdce3d49e90c4e8af3aea11f40cf0e31d2ae9ad6ec817689b3f3a7d1f5484b4cd8d0b4a0b08c8c09d39de7b5e0159baeb2d4a9aea52bbb19b66b914802e9c7a728f1ad6a2a4fa36c424f9fc6e5055703da61318717fc6d82ada04c76d011b620f2ab403f2e08e125cae53b49bd659e6619d0ccf8b1081e9e88773542a4ef3ee99042ad80aa396ffe0dc7add28c013c95f3988f3fb305c1220cc384b9c8fac2f8a854e8472ba0813b89e15981876b0dfc7c52c6a420eb5ff2d454fdb47b9dfe63025817f1e876bdae78b0d7764d3ef28c4e98296179a23763d8c18fd4af57920ce2deedc1a0cd8121fcc697d5f86da31d02fe9b50a2469f43db384dbc7d3363c7d2a73c9aeacc4d115a0feebf2bed24f45767ec2952135c38dfe703e615e6284579febff4c68e0795b9fd8034d2c2d9453c4408296ead907e2b38759c06e29f0f764ca537357963bababd0a9752fba6c481522c79c73ef180e83b810f3bb1e5c220742a52072eadf29ff863498e6fc2d71db9c0987207757d96d2b253ca41df2235d06198e6f1782fd91b9a05104b6e5f80a693d74781532a210863012376053b37b0e547ccedc68b13be29cb44b7d15587a43fe024283c12a4a70dd227464490df955f2368111ea2517bff5a8f6e59bf05b482e5f291d2bc8af3f650774781e6122115431d98f9c6d2dec69210db48a2492fc4a43954eff52e438333d3fe947ef9d4882bd278b6249e2a878564b3f6ed19302bc83a70d5cef136c778d2da6fe542775cdf95c09a273302703e13b9a989725a45f74eab9fe5f2457fe7c947be543542baf8e051ea8dafb46b3e45e6286261dd1f2b9b71ee05245708394cd5763ec1fee4e6147f30ef593794230519cca8dd1c6211636d23f9b806ec5cad37ee23e067cad2a3357c9bacaa9982b5f3c347dcfe274fce5117261e767dab30ad3dafd6f01b2a69a89f8794c39c58b7ee657b4ee34fb8d8e56c1f36d106cd5478d99f82549f105a38ba9449f94460bf4b8e83f66ceb15f54807e6faeb0487e0d60911f1dd7fd45d7bf8de895d929a0c619f6add8a6cbda34ff3f645d497ecebc180ff5cf524ae36ddb6460d216e5230e486fa82aa897ae2ab2b52835baa4fa19412f598c9f8591bf0491ae9becad733b10547e28f69d099c100180b70f36b726bc71cba0c3edbf5929da27634f47036557229e7a534e352adc13a5d8465a765add155f7d040fd7d2f98164d3639e713f694269f077f4753ad9f029e77dfaad4fcd2cfe9260e777ca3f7e6d63f73cb72a91549fb8d9b7c75c0cfcd78cbdb543fec934f8b92de57b307ada9b52ff3dc24cb302ddc3e87273113077bfbde89be4a0645853423afe813c386de977cfd25433e6ebe231ce844f77d04e32e3b1603cfbef4636c359127a4ace550d9e99fbf02a552dcced6aa339e6db38bec7f8250298248506c87a2b8e30ac6391b1912f35b7d56ae2dd7eacdcbaba76be9274a4634f6eccfdf10575e308b3676912cbb337710d43cae6674333eeaed0fb7b0ee970dc161f866b9133700cf9fe08e67069f72e2b6077b24c6e27acf1e199d274dead127f1943e9e7ac1fee142e7eabc0d7d1d8382a73ccf4f4d514fce9200724ff3fc641ad4f078aca4b6e4b1840416bca5ed192ca1af02906a0fd878b4da16f17e9966f32c308cfd76150bccc92e3d44fc657d142e7d59c33ad478842d85b868b1623242a04d365d7c5ac36a037b422282501e625599deb47ee65e0bec9c0d45318b06ade3735a7feacded8831b109ef4698f2314672d4f648cf68e695fa6338a9cb9c99aa6999963d83e602fb2a133117ef0f680d0433b5176192fa3730b19b23b9693d17567c47e02a2957b61c56f2b02cae4b30103d6ecad95b49717a2df7c916b844651807bee0ef4c6994f324b629cf897716f3551fd158b44ffdc10dbba60ea70b085993c42d51d13a77053abdc4bbb6a9a8795c8faed7aaf4b3cba074b230879125c8ec2c96e0ca38882764347a9aae79774fae6be9bb2191589a2fe65840ad621ba4949e341f5c4711033aff7c1c88e5907affbe394f3aec44ee99c2694a6f4bfa5130dd9a05f68d1feb3dc6bf103abcc09ac61f4f70147eb41c4192562592561b71bf202b8944746558500ed006fd7ef2ceb1b7e8b389bc0d2f2caa594637cfb9f188ce00433f15baa8e339a248452376fdc30583b3848a88c6ce406e9430a04941837396f98a92b625983d5bc7f8b62a7a4c69677faf46174e9ddee7b3a4cfd198923a6a7c2c8ee450981821f2a41c0371494618c7e370a161accb2a48ce1481e9109243bdc47bbb3eed430f26328954381ae4f61efbb470373cbd9395c501e19c21a1987c3e121c0d0241db580a9ae7ea478d3a65ea719103e2fa3294a86e53c47d5b27d0b9a7f7fd3fc18377a752dd02b6cc11690d9893e7731e0ff99f5431e136fed63bdc24d07e1c09fab36f4b8b83ce17dd95fe0016c10fcc6783c224bc1269d94ffe8cc2d6bd249a851350a391af680968c503eb9215016cb08d58afa38c5d0adf81636862386e64829bc5afbb30c3d5b780d6f9cf3d21fdc36ea44426b9c1797a31a2d2c910ca71a48aa90c3b83d2d497202c6300cac816136432711700f5d9e11d92d65235208dce121db45c62ff72eac974f0617cd7934fc10b21fe046634fe9ae4b476c5bd26c51a380b74684f0e86a7f986123c8ff2844fb14c6d48e2c4fef6ffdf07e5bccb60593a8a40e9fbfbe1593b7a24841e2131c43bd700a2f8a334c1d5741e73cbded33fb695b2c02f4c17edd7e0dd64b5d63641b482fc0429868962d806310d54e66571fb6d9c3b35f0f8d3c1b42075fc6c018e3fcab43e56727a86a44f2a9307f66f4ee834cc68e4159149fe0675dbbaae140f62958188228f04ec16ef93326c2c236f834b8f716daeb7cd7a99f181e8b4be38bc2740a53fee5a2eec633f96bb99d5100bcc4cc036ef0094aa53516e084ddd3c13f4fc8d2a73b5fa945f0f078218624599a4b268a47e6e859c3466318409aed83b01aff096559c47dd0c4e887fda5e073d684ce9e07d7a8625ea5ac518d67bb4c946b1adac0dcb3e1f6c20a72839d22b39e0dc0a0a34afde8b280838f14abf30dc49a6bda3765b868593941d50a052e47726aa00ef053e5f5d50b2d158f4746d4ad3c3fe082283ff6991dedcd67aca129a8e0e04d0c4bf4ea3832606307ee377922ce2f20e99a8db000a55ba739981dc6d3737dcb1ce862d1ba73a9667c203c3e741cb77b44ba2eed76c45197d75edc73e444fc4b892df2034babdc73fce9cd029073a68372ee02aec1421afe4803c75bfc813bfb8a0c74ede3f65e4adf2312c4d81c521f45250d5ac82571dd0c5c55cacc40f0e508f92d5e0b00782db09a0b633e1ee66624aa1ee7f277de87cecd21eb3697f09d7da9b3224aaa86f99e48bdbccedab405a38e5d36a4b6a4771fda54b050aff6b02a876f1cc6f6a95525890b80ca1c402b9ad3fe182559a8ed170269b81d4f01d466a262f3af3a05dc905f60b1e5b4aafa35c5981ff9e19267142364d7a81df63d4ccb1b6762d564dbdfae0ed87f71030e581cfb91e09855aae84c00eb36a1167ccb7e268ae38ccb52e3817198c9ddd6cb3d128a8070ee77c7ba9f32e4e2155336c496de4b1140a0d751917a5bb85eeb4c606d93045a66681722d5371652c6e3efdae8a5f562c4b465357d3c93138b7fe6858acae9e16b51a761b4ec00e63a0b35638c45fedb3cf30fece7f744d81d9c6b40935827aa6d2671226eeb7219e68d64563aed9a0639f2fc1197add9702f674aa9d167c5373f1c9242f50e32c60d0a659041780f31c8d371914ce7cddb8f4ec0e1a209465939a1ad032f7deedde5d61bfbc1aa71822c705bc99ead6795bdfd2812b94cd8bcae7a433432ef22906712a14efa29eedebfea96569e32780fa84bdd852fc03e7c869bd9f2280655a84e31b5ee81ff67632c4ec741b34fed810c5ddb4b403e5eb676ce16f27913a041f31b1a16c5c1002e44c22b86602838222f6f36bc249a7192b1b285b3a424d2aae46f984cf31b75ee7a659ab6f5de9b09c12c6f450ff7db0cc09b33d26c22d1840d0f1cf12e04854919cf525536c1f0ecf2fb13039f1e9b8bd91a56ed97fe4424a23a5e64abbba8a69ad4e00ff6e90e7d64ddded8a71e85d4fd4cb1531b0a2c2a0daefa10a748c0241478fb1a4e87898bcd704cc5c561d5a3de50a16a4f0c30ac94ac76382111948c640257f202469328eccf256326b40b1fec752b5bc8417e245a742f63024fe8a21388be2803396938b4b0ab2dca0a1dc711e19719dbdb3be23252a6a948d6624921855f47bdd51df2d2be4a5dcfc3c9be992616512479d07d6ecaf3b2d1cb68b87e341e3e1876065a1b27e235e18daab13a6f20f88883aaa3fb50c0fd31c95f883d3b02e99b0441ff83200ba402b961fab991d1455d493f96e71d554f17f3472bacc9af2f26160acc1fce8ba620140938d3242f2e767544c1bf83a4caf7ae0771a3fd6d577ec6e29baaf4f3c656ec1990e48349a0b578913c5100bcde704b8257494fddbb5d364907ade8d51753d679cb4207efc41a38ffee1592a185f1b79897ed0012f9a0de6318408b181d064e75b5a46cfbe8929642f5591fa1c697c53597ebe46282887dffb9b425a27b84a2e0121f001e73c5af879b40e3037908a946dd1471415b0e8fd6b811b468b0c1b84999ce47a6fa5c6c044227d9e2c5e205b8e9bb6ba58283119422f82f63d9f5af6ca2ea6ec83464a14a7d0de773ae7bdfc170df43b9b65b1b21e6d251e991ebf632dbac64913b1aa483bf468dabc9b009cba7fbf780cac808cdb4ddff68b5613307bbb556f1c1650572a9e91b4e0ee64e1fc01d5a276ca8d3820768a4d92b8f7e68d494ea8e195760d3192e6d08fb6a552372c28b130fa0a7383d8d5e6a571ec8f2c06b995d3b97bac7b5e9ce4fe37a7a71a0576c84f2b94178836db0de35cee0db2f602a706c602b69d9150c0d8749dfeda93c0ae8467a9f9871d9451649dba5d9b1e63e1faa7a67cd2f9a237368e6a01dd7d1b2fd1a46fb2a5749790b01f14308dcd8d47fefb3966a2b8489ad335746240bc8e2005c5c5f67b5761af1ec9aab44a64932c7a6d071387445760b28318f04bdd922a92dc3d83b7ab8676b89551f26780a61994465999c2d57ef611da063b03675813e0476d2d651e226f30cdf1a2d69413e7a4a3425593892be202a0d57f052f3134180d952564ef67851defd740b5c78cde6d8868ffb31ffc632bef68290d298edd7b3d427c8b19e00af6053b4c6717ef5b5acfc2f3a869b7bf5d9729704682c99c954f8ebf3436869e33e8d3fd5a93571063f57012492f4a3da0be65b7459060738e6cde8391570359ba560d4aa2025a1816923c975d931564f253e9395ec7ec0ff42c2e901f926c426d6d101e815e38bce52c0a6b1228e1e148a03cfb0429c784a6168ca1ab5f9758eddf9657a0941a69b26347e6b562728cb8f745d95d93ef93a9f65568963a8d305cc225098c2a8d6e440f3564299076a90d2f1bbac21e2b51ac418d615777219a83022e320a28bbe93bdb17f109cd6764001a9e99d1da41c7aa5dde675be4ec4a41956fda82aa481b1a21737da50d6c256cdbb2de1a86c7faa4eb8caa0151be616a64b820ed41c123818ca0c46291129ce9e31a66f63c9247a61f1d8f7569e9bdb7d42bc1fd402d684d3b6ff47c24a5a338366ec272d251df397bba354638f82f2ced2d99f2d090d0e8ab93a2bb64ae059e1319bb36029be2786cf33d5634b3ef990a8229119d92def9ead09f3ef67efa13d201587215a3d0703c3f56c4a1c55f22aca7474c69dee782f0b12140b01b21590e6bfc6fba54abc373728ae8f076fc8285c2485c38f57e37f70e7eb81ea7f3d56510ebcfe039e5e51b38e7f1deed024cb37a18ce5ea89d18260d6a7fb9f705eefbf7e3ee25f9848b5c63cb67e9bc482933268cc361a19c33a4796c1a5030869dac7a149754bcbbc58f03b9d2e576a0984d4e9c07ea648fff2a884779ee4c30c80234a7b8c1760b562f528e13f8c7e7157c2ceb86c1d500546de340695b0219322107d919693c751e84e3a82c6b8e58e97223df76e41832adbe8419e9a64a1b7297b366c4bc5d4fb7b15e43dab62d8291e168c6a4e54cc3307cbe9eb283ed0e8af86098efed4e8e4013ce4a16d3bd7668a1884be3ebee6de338e5727e1de425ad04efb17f00f939132750d1781597c38ce1510988d8efe2729bde026c6289c67d77e361e579b9122e65490b162ffe6f3e2d777516c891faf2eb747c454f8e362cea562ab7b82879ad4129c93c40110a11be8f00510287cc3974b046ed5c73482ad03e6cc497584c15486f1d08b0fee8daf463eda07a224e3cf2ddbe1b74f2b566b06d25fbbe0a4bd9cf378ecc092c70c47fb36d626e522ce5c69dd968c05ae6a2c491d26673a8537b724f611add529872598375e6f52411fd85b2e460aab8f0e580fdf5a4a745ff7a3aa507eb8ea88acaa19f7e51a3e424dc49385557aaf41a41a215aa4f9d0bf430193f845c631a8ca4a51801873d0a527c88e658dfc54923aaedfc175ecec763bb28ecfb663d5e644b2838aaad503c261a5b87d5a6b7c766a2eb6ff203527bb08239b2b28f69ac0b2a947148e6d8fa778194d56cb41e3e4841c3b63b4f05d3bcfe80ecfb2e0a7405c3e3a054fb791bb0ab4fb602f1f4b50a74246299697cce078859939bdd088ce5a0adc4076c4fcc9bd6ab6e88b2c176e7ee0d6e4ee22d385dc7ce177ccf0c812e761ee783b6b9e63748ba7daa81b19ceff3fb13b434b000a240b248ef506b2864d8f98d0b829dbaa4ac713460125a1ce900bf07ef57c4bf718150e054145086c923c3777ee039e4016494e13addfbf2e419180afeee0ad420dca7b86b26ff6c2fd5d61cb241b77fdd33a2b77760653f58c2bee8184792ec16fb02448aa459487e4c5b1d4fa9237aded1dded62a40d3cee08e79b60a3c3de46196e3ec53223ca2ec0f19d5ef3ec2cfdfa56753b960532dff7dcc54c39983ae93b67fbd82d91be1bbb15a9847922b44255fe47046086f6ad3455803139f2ca4a13cbf23dd2b0feaecd3c169d1cd6e8b286366408574545573724b476e2dd85fc8d73ef3d316b744d1fd8feb216583fa85ee6b1e8721000bad3e5482d792fabae096662678702388da27efcfa0384c6a4d4b4cea33367d3b17ca36f18f4f311eeec135569b1d2898fb3670f55f37e7f948151d1d119b109743c36cf756059af46718d9e11f48d53c8c9cf3387bcd8617b248ff67462b2088132cf24273fc8b041e10079cf5e87995527af17048d31736f68f6fa58a4597d137f3ec802c02540f26dfb42ad5fb332a3915f01a01d34a7f5df5b4d95ff79c1555a9f60d4150aea1de4827c7eded82cd9e4138982415b3c3f70f38bebc46fef432257f1af50919b322ba4344926775ffce6333e33bf340f829007ed20477d0d9c00b67501b456e22eddcea996817ff904710ea53b552e39ae4ab5f956eb2e51e86673e471fd1e7d9451331386f307d9b0b52c39ca6f3aca973d1020855534ce7d79e2a7b00f8f36d47e823693634d36eb0cc232e02d4ec1d72c253b4f5fe6a2d67bc28b855b1b330d117f901517d9e8e51587dfefdf65a271416ec02c88d4d0137d14c87dbd49f9c16db25aa92119ae74bcb3dc954b719f6f39609ab84b032e285341e52a3c23d7929ab11af54755f919f2a27431e172ca8fc2c882ade2dbcf55d1292db2fc97a88874f25ea7e26e2eba6795be8333a691b3d071956a68d84a7fe7eec350e09bee6b4a80364f9febcebfd63835b80ae11094ec363c9cf13c7de8d3b2cb5fc4e603b9fbf0fd6818bdfbba1fab1a0f8fc8359545acbf46d09e7d0b51c1e4357b7683ff4506a9c478036f50928bf07ccf741e39d3f20493bf8a38db2a783b7db39ae580d7a1a34271654453f1eedb87841158f2dbfdcbd8881e2521ea7c640d6337bfb0b9f625ad4bd4752046b83df3593ace14446960e0800d2c04e8def5a4388be538c804f0ddf8b7f90137e40ad7665dc6fef6ec3ca9c792ad2da7fa7409a368f9d871aea3c1927589e7865eedd96bc3ccd8b387a64fccef2514e90e1c14cdc3137d8a7b940266fd890ad6f60092a5f564dcf530ecde78ce33a4f790587adfce0959cf18b6d3212b6a6f58b659e106d547e7c81c5dcaa64d2da0a2aa38e35bad6629613ac60eb41df0ea2083728b0afbec19c9fa51acf96c75813c34f5a5b820f2994f2417dd0de0527a803483b76ab8089b4557092ef5d4935cc65f6b4c3e28a6e6b8109558d8eb7485922d741718d6f637fb7c9ed3e364d8ab00bf52d1c4e512ae50a7e9bb870377145f04243fac6ff20a717e7cc666988764f2570bb9245a95985e559bb1769212f099a1a8d4996fde1eeb0307a675b0ff2eb51fe574faefcd4bd961265d7b5c1f33ab3dfbf4b0f0b919544ad24c3e28ba40730fe6c9f8e8785ec81fe4962e9b4557f646ae3b38fe72fec049dca199b7521dfbadb0cb8a9f8c795049d05a89e4799d6d14043c9a77e89494c013a54d449590a5523739145bc605801d745e28386a36e0cd3abf2bd360bfbf4484aae2912c7d357f399261b900c7e3fa12a064f812ccb919ee3dddc75397862d56dc4902ea1487a92856946a7dfcc56dc267ece0486423a9ddaa973ed1ca527a4c857804b50f51cf3c40ab4b5d66b16094844cd4c2f116337f74976b61cd8fe1bf951c3e761724cf4e4ffde813bd212011749207a47a629b1b07262d4584e51e19b1fd1be25b1246d7f984b11203b464442d1a99cdf23be9e5aba35acc1ca12e360a689fa9dd780227595cecc07ba98f1bb0e040cfb4c1daaaaf705d72fe1cce70848722efc697c9c6593cae3d895e00e27c5b0342da700d11b56a9a3b210ec62558f879bcefd8d32cc13ffa6b2426a8cea4825457436aaecfdb38e5774bad4696c5609be4412b0da374c768a6a2560bb3d141648e2df8f2d17b31006490726b1257616d44d5c384345ccc1fe17c3b9575bcca0b45a89dd7488269e2d5f50fa258f76000d3d5f684df71758419d0d9d58ffb257904b60fc3225e3a0b883f64ed407478df3879f2d87198fdcc26e4d8f2879267a34eb553e43d40e5afc70c4c6f36f4746153d64019ee1426e98a592b7e1773448110e8fccc4225d3dfe40d9b8f80dab76f825e7a9f90c31c3f01b9284848a1e414fb5a107796750f1900327311362be8890bac3ad360dc9cec9cf3c885ddeffb6ef5de8c5f3b545751f41260929b56b01e55b4644fae97c730389627b6b1e7a561a5cab041ee8cf1fe22a61d8cc978c1d46e083a1c9106c5a51609e0c418361e8bea9cde866007c2d55e5d710d0351092dada0400da9fa8147f8e1f6a657acfb4523ca02b8ebe81c17f80274409a5c5e75a6f859366b877b30bc1fcbc4b643251679025a5c9ee566257b245b7c9603e217fdd36e6fcf4833ae6fa9965c5febd8433f1a6fd901bd5d8ce04179732724ac06a9bedf080f60d3c19f813463a5d8ef4e22cbec990498cfe15c1b3104aefaeafe3e36e0be990f9257b8305d4fc5a30312a57dddc83b4d5a4e763188e2d3176e08556fc448484ce7c7ff946c094dd00147d22b0f51de4a4f4ed708866318368a60d06237d35776603476eb9d740f07a246b5e2295d8996947900686f98a51c9ac2863461ac0b9b22c9fbdf167aa7aa4c3a333db89a4519d8c135815bb1e7c8327c028800a67e1909ce42b92dfb706c3e96787205d84558f0ce85113d2a2cae9b0eaa62747a42b28c6e1901986510406dc8ed7d753e8ba2bda7c4711d8775c6d8771644e576b9db3a4abe833218799fdae257192f49bd3dfc71b6d0e202e1335015ff9173609be01eda0d1423d34348747f8536f6910e81b413386f1b7cb4bfa5bf34b8bfbc5665e90b312456303244fadf8b5a98115e1591d3b095cf86bccfd49d85df3d74743b7a5e39357ba6cb702482e912fd81ce32bc4111154c0a9f6f8ab0633120a9224fd67d54f7670b0740d2f4250642f1bb37770ad300b73431ca90275cbbdbe4866114fb688e5cee79bf9d8360a7ea935196c777afe3f91679dc6524daa764544473d706fb315bc2b69cffbab03ae4548c83ead607cdbd357e40ca05ef5f04dd0fdc6742e27667b05e364321a869b7dc1c69381aa9f228650ddc9dab47a43c43bb6a3d6096eb3bc75f375666959721a95e4255e1a99951d3d6977ae4a14ddcad949ae590bd1f27d395e357763987d9459fb50545f44f95f219b7e94ae84d9d5781032f57d88d90ff126ee19cd027d81b537cb1da880f9ae2387c8fee42ba769587f6fae531bd845439da2ae2b0cd5b4b5f71111d2895abd85fb80a1ab6ad0f9f00947e5e7ea354789bf0c6d153bf3b1418cd624b2e3fb488a5f8de60dab25964724c6819d18ec7087e545db35a9b6b87c622ff6f055f315efba6335f564cad8af5d6e132a5421f7796cd9c944ffb2e452987cbcc03f297d9184c36bb2b1cc89070ec9056b5c0b4d7c216f06754d2aadf85f228bdf468d482ef51cbc9f1ceb7d03486e44becc69f51e0d994dcf35e45914b09a2b8b458d5fa45ddc4ad9f7073dec5f7902cdf93ec1d27b4958a72f9f9438f26368abc539f7fa30b3b2b950f936b42bcb9ad0eeadee7c8f29044f88444627af3a1b74876df4a422637de28fdffb4a6e0190cb5c71f57bc23b157aa905f409aeebe45d8c304c6b5123a5d8d7520b77057176fec6f3568f5248484246891928bad08b4507f989c0b3e9c3b76a2fb34683be96d19cf6d0aae7346aab7c2845f0bd3f1a748df07db6a44e440759a9b4323aa53de8eda337d546592f75b4569905a79b22a9204954fd40b33b3908e067b56bff8e9649054a9c834100860eec60fb3f145047d8f03d70e0b22ba4765d154d83840da24da56ec28366ef3d8545c314904d1b8ae0178b51aa4a902f55889552c337bd9932c89391fdf1d545b85c1443faa850a3d9637da358c656acf6b46473281757b6979f7add1eb5fb3bd41f07df0497268adc5e9881b1a50faf132b2df369248f63e64e8f085ef498d3e8c0ecbee5135b84d12a7e6e8cf70e2366c5c6fcaa115725ea3014ce91f0e103769e75b2d881e50956b203171f9b66337f87fe9b0a83a1d6f4acdb559f080b2c6848d9635199cfa92e2ad73cf72cb28161ca6e5eea8f9bb77fd5e11907de533f598aeebb94d55162abb8f8d8478031e4b14b81d4d8d6a751271250723e63563ef46e2b9acb40b6f5f2a7001b042d945f21b38609f27aa7bd687ea9aaff8f79e33c9df5d1d1b4ade614c7953b90a98f7572d7059c36c0f1fe1e4b55c3ef9ad4d0bb48124afc85d60097ce13473ce85981da0b49fc47cf1d0d69b835dbbba338343b67923e5392395044f9190cb9ec8bcfea771debf9a14a3547211910d1d925a4cf3996961f16dd77d190b3e6704ae469720b88d44708651b797f09e90dc7628fc5a0cd9a5bdf34d2d8e0745baaed1c5924a0003d0e0463dd291003e67a9e2368f18fb47c6753dacc8860ecfa66451f77bb8fc843c6acce5196d3193cd56ca246e4acadc5496249329ea6ebf7a47891e0aeee128275d42d1ca823d89320abfb2a622d6d7d392a3c18aa9720e76653ee1a3afb6ee9bc266565f93bd28ef54e6ed719ce4518ac4ad515a3cc0d189b31e79fdceff0b0f8cbc4bc6f76e1c209cf5d4f9eaf0b017958babb475711f4fce4e5b3407ddec917e94c053bc003a10f1ce7300a06b3bde6312ca5368d6633f7322f6baa67114a4f3bc52cfc3574cf1c1061a53dc9b0fd3c06e106842f945f127cbd2c1e08eb57c14721f0b964b686bed6a271e9513aad3a8d82c4eff700b33943a6214a499265667facaad4b5fb6624db9d2c52cae30ba27b70c2809eed8270adb673ceda907344cac33dbea72c7e5e9b3710851ed28cc6a159abff562b36bbfce5f0517b4a047dafb63883bf6ba62783ec9be31995977c4a069ed62cbe6481396f546cb775cd766ae755c9372e070c244755f95cec9efa67107dead305ee30eeef49e5c5065187756b66fff93bf076b01a26e1f48a41496dc287ebf64b3e314ed5e216ca276b0608cbf506490df4dfd7660b108210e19806ae014466382630690cb24ec7932525d3d3f99d27fc2f95f20197ad2b951736342ed470d56ff8d536273cf49ff64aa7ee75b63b95b7a881da050825aa27401b9e1df0ee8dbded4457c958db50fb8cc212038a08a161aaa81909f414e9989c511ef0195efd425df06d5a392c6b804fd2a3e1122bbac50e02b3679adcfac9913f75e05905425d010b395bb0cea1a9599353201cb980e37d6cc1028bd1682233e974835bf5fdca8e0be48d9b1890f00242cc540ad012a682fe52d856d7d6c4a5b182f3a7f043bf189b7fa165933a30bd7b59dbf54c31a584894883dd222fc7d3aef3bcaf3bf3bbb3b35e70e45514677248b1a3e38ef75c38e1b75a2721737c6b6aef21d67def93c8b03a85581a163bd033307e0285477b085548989220abb2b727afea6392def0427a94bd04d739cea1b9158008bc7f1f01f0395cc4bedacda0eafe2a8dd0dd1651e2e8859c1cc1a43e3010802fb83a7eb6a9ef3ba7b01a98788cf67d51e85790c2648b551e9ae16dd60d41c97fbbeb75c4f1b03517d25e51772a1f5ba4bcba4cf6bc2f17dd7dd71fd36d84e13ab72abb46ca4061789ca5df8a68801872551c64a0ed4ba49b4e610cb3fd718d3e19491aeaf04f490421cdc5488afa4c17d8b8f7b19a227e0463c815d54ee8d040ab6655bdf0e36d61f0cbb374bb7c8458eeed42c9f9bb025b1e4e5052e5a6004034fd994e1e6e2805acc57986965acec1cee04135ed0ab4c3a529b662dcc98a7f90d60e2fb3de5534237563b828eb647918255646b798196c06c4538a4d5c1660fd23b3b012dc1620e1e4eb2a7956e7891557c287cf522756d4dbe1f5fc167814c8c420c64be93cb7f7879e6fb14c4ee53ed7fe3510d003604190884d4e8197166043c0e83effd3e9d3d43d50fbe1427bbf8ede1e23f40c7dd430f175800ccfd791342edf83cbdfcfdb66de76f68c2666254e8e88a9f8ffb82c50c51f2d171dcf92159ff69674415e2cbe565ba3d9c6f6295aa22d9a6eb0a0eaa579ea16c14523b7b762da908eec1c61deda2b675aa70a6dc019622e700e9a7aa02d1bcec769225dcea645b61804e0a3a41cc4fd19fd6d33ef8cfdf7611bd96ad59233ba79196e7e0055e81d01c684cf18e546b1da4487cccd7a0a12ec9c25eab76279c4cf539a1f623d50f1e4f770bce62439bc45e91ef0c6e8a8dcd1ed360ef6c8bae6a95df4f3a37a652c9fb18b2c5fac55ca7ea22c40f80c8507ed8ca7e61b9e3b4760cd7850df791eb8c97d9683760141f383aafcf1571dd7ad023d8edf1ef4091a3888e25b0a8482f989a1fe3b7c359f191a84da80faec5f7334cec2f5f65b04e50abfa0910e7588ccd9873b4c41ff56e8b27e630dd9df0b9b3f41a7583c9d435f538506ea6d18a57ff189c2220d372c8a00adf9ed09ae1970f0783ae04989067078b634cb4e77474d5f1916df1acb53cd023a1f82ab233fa188711c2974c01ca2097e16cbd854b1f3cce61963d014d1d2ab6859e4bafe3778876d9b1d0371a7df7b4ef1d98c53517b9eab7dfb0dafae3e1aa60fc574c38c7ab4dfd07810e56b61ec070e8807c0165768975d7f303b1143de0264f71fe49a4636d9412a96fac2a0ba71c1ff4827dabc302776ec5cd80fca4e8bf35fbdeb94bb1dfa399663a54720fffc5b685032c2793c0b1b201b3202777b20b132f386d59b8cbbeb51cec6adc1950e1991f6b9496469d81d9876b3d3c0ae924c6840d4ebf58819302d74541e4184656bc57b613bc9944b79fc9c43d9eba805e63158ff58d3235a0321264bd3dbd10f9007e6780ae9fac9acf15505a4771dd6e8b0d9a78b31a5ce39b8e072a29a228f54358cfd2a27b8b9e4fd638e2e51aba27de87a9ea13d020a7d3e52ff232f714024e4e6416fd51486b3a0e7b3e594b39ac29ba7660ebb86372669758b87e9a28ff8bd4630acb957e8e85e68c2860b6b3b6669e51b7e1910b53545600b8758b43a3173a423ab55956bf1f7e61bc133d38a374ed4a965f53e3f6bfb1e2556befad27d5205a9204524884aee73ceb567fb43a235d2d213d53840d92409a6a058f82321602afdc74c5bbdbe47c7d5c4997c5cc5cdb48957c401fa018e5cfb8508c69a6a75333bb982821d4a92becb161f8acc50adb7d48b4a5843837d45f221111c82f4d47aee252970580db60b4bdd5f43886a2dc44be8997f5fc18595f2579fe8baef5efe6b280b3493c3e2863a16f69887dcbe0e158a907e2b17414547045ba7fadf9674b2f226463dae82f9e459b1f2b8e08455a43df968ac56785b534164f0f7cb990d14ac79bbba8a58315a4b87f3ef79d6bc550e4cf1fa97b6996f705d3333c3899ee921cd0c990761a8c2447d4deb582a55cd3413c0cadea5a3490f9b1097ab246fad356f7bcc1896ac28c7b425a17db2e6db832ee4b6029dd34ebd0339a054e7bc6eb43dd18c695f256793a3191875a13b33d2896a44d2c01f081fb4ece96d61db268a1c6bdceaea3cad04efe44e1ef57c08e86a47801cdd05fbf3b5826aa2dbc723dfc63ab48c76e005af8a6a2473ff93f79d86f1270a12b3607a6362f2adb568942e420f8576f54f1068aa29cc3754e15a4af76eb0fd2238eb6cb2068fb90f36e2b928ddcf6be80c2533e4b1cf637d3bb4a005215d0500bac86bb574a82feb7a85cb15aca9a05be92dd04c71ca355797570f5bdba224dfe6f2198647d870450cb9d657fb0442c9de7a23dc50f6b29e30985ee9501e99092e728887d50d899e5efd2191c96596720432e743f6d84a81e45ec0e4cda8aa01acd498fce96da2a5cb4763cc00eabc6ad1bde4a556c2bb61da66d2ec74458f81fbb6f5de6ea168457c84779c915a7f40dedfd62b516760676caad2b7d48e8b48ff69e08abb91ecfbc06528f4896478dcc1f54c57fb7fddb5ae1a1bb82b27e62fcab5922d99a81ce59e4c74fbcca226501e24ba955a70103b5af8fbd1b34ed4893cbb5e1f819a6f7043b65477aabae6c6b27b05907fd7b876a82e53dede636bbbc2fab3bc32b3f1dd04f7ada92471df6036d6bc8b4f77595709b085d929f264573e1975a2ea4c9e3063adcd4af6b7551a062807e89328e3a89908070a9dcc658fbbb4f177d33b303030fb7db5b050202bd7d89d77756c0384659bbadd43156dac7b62ac07aab7ad0d6164e165194527edfb207be1c3ceeb739ebb48289d8154c3b4b55bafe52454823c0a24f9e1126d27325e9a3c72b1c25b29c16239232dd5f6b26f6a526d6ead09cf8196da37780368582879ca5c19f8406db3b7db19d3e0e7f68517b1a8dee74b3f90c2712fb582506956ee7c8b341e757d1056680bc29a9ba6815e918d6e642c2bfd6adee717f782ee79df4b0d1877a9257644660debdcdb50d56364ed8d402820005b13821e59b35f67382bccfb880636ab998790f814d93b7b23020f350f45dece5a365bd8da8e9e87f0cfe19956d8ec23da5929111eece0cbd3d1a8ebace520949922d99a08318e5f4e20c258624bde028b8fc7f9d7a93f3ab0f26a4edf559057449e9d2b9979c4af84a9b31f93fe1d90e5e9bfb9502fb2982993ed5f5c07662d5ceb5eeca282dfa0390805332d008f20aaabf31a0d69cb650031f1aa87bc415eca88ef8998d22d5457c1d659410278687526c014a6db7d45ac898c633a459edc945e83b4a1a587fa912ae9417dc3ac7e0ee0490e03c4c834f09e39fda74e5345087a3ebbb8e95a480a88a174b5ec61e7b4e57bf3cb5249a80ef2dad1696aff8bcf63bc25de30f10ec387a84df6f05862942f149865347860527ebd5461cc7fa552bc3bfd33382884351452ddfb3de4e49460f3c29087924d11364e0a0226fad77c7ca2db5bd98277595dd1c58ec94ded126d49de61791a5509028c97b0eb0f6e4b05e0a586bde25be8fd1055be368b4a20923ec631eaaa972571c8e44f280e787738e183d90f87c0ebb35b55bebf6364aa2acea3f4c2d1f8804963e80f0d35659618ead089f4d308b8e0e1ccd6983e2db54a9a46ec183ab2d8ba9c585697f7cc5f18ec2f534e7747bdd705ee37a216d1bc5e8265aeb4c617df5b2a18b8d372388212f7ff35e914c49b48f1e749b82e0d980608dd6337f058e5ebd8f48fdab704469f116372c6fd5bb2b57561b116a2c9e2d279aac54a6dcdb76caec79ef121ea52324d8df8956827d98b4e49eb2b98dbd4debd4b39c2fb2f1fdfa311d5c3a7088f4f665c05b074c6da688640448a66f08b7bae283abfe41d16d3744bf398b4f1493d3990401dff199768f67c16a454d7653d1a2eab54d279d1b1be69e7f3e3e553a08f24e59870caaabb7fb0a790fb4e4dbe092e4c83bd63d8ba1363f1ef4d3ebd8576fc8eadf7073159f70ec5dfd06862eba4ce1dac5528177053176ab059c38623b855f95cc460a4fee433c2979a954f3f795625b9c71c2bc42aa8f9c32066bd580c7f9b31fbcf0239ae4ce54502d17c36b226b3cd1da47a174f10981b6cea63368cd68925c5361648082c48cc32b7f6313f9795c3d83b894247e1786034549504330a501a4c9b126bbf9b33e365e2f46a60faaea70901e0f945da28dd4bd356ac2c32cb130d6c4384b0f7f0e7ecd09455482cf6769c2d92c3d31a7400e62a0c51a6a09a344378442b9047e3f59f040fa07d0ea8047b9dc1526efea76cf44f5d8c7bf0b913cfcbe95221b283b83480424b301d02bcef400ce26ca282950aa8cb5f7675dcb9956ebaab7b04eefa932edb1b0a9492b1b7e49ec8c39a1a0b73d6e798b68d0180d6989d73de58ad2a1c34a89f198cfb75ef0c1e23edf40cf6b72254ba9ac30de6d71968687e1caec49779adf19c087b960cf289ea666a3fd3363f78cd0f819a570966fdda1cd4ff6bc5d372d4869ec74a5c9be26c43dee578b4eba8ea7f47265ecf0f2e61e57be1556968bf57d7e15ca8ec2640bdbf312668d2a281beeb55f08d797ec695e79b68058c6cf3dada5fc139d9810bdbd2afecbd6ad0aeb6e5c208696fb1f938cc6029ceb5bd292e57e839acb637584b6d796d88bf2eecf0ec32ea20c48cbf9c022fcb86adc76004dec255ecfc62bd7c2a7a174002873e31587620d23a9668d20693a1d7c4378e9eee37e8ba610069aebf31bfa72900f01d98f6aec2a3ac28f8e31f2240135ecad7c6180b3325b3cd23c93d4a242b3f0c0ac52b9691231f5c12acf05eb0eabe2a9cc5149791e246ab05ae5088fd8525a73cdb922f445a75f794d4fdcd70e2f0993217a3877d35bef109a9a40153b98ed1799f249c32d6c20ae109911e225a0bf298200d0a7ad7b668ef1a802f4adb0e0917c1aac969495f38eb7b2dde8f7a400b3b77af55c4d805862129ef386cd1313e0e8ca5135d1a6424db307d6ac35eb693c1e8ece3863f8e530328a5d5bcb21216b10b2d3a946b7fc2a2e753df1174256f6581ba8f1fb940d237c673697dd6e3d17d7dc7784b431ad150a9119fd3141755fc68c4eca55546d9e71d5f75020383d020e01ea4abe532f7f9776aeaabb9793cbfb0cd85f30bd2c6d132b01bb64a88311cf7e3e619dc8acd350fff59282d4852f7637554c5e3d2149c23e19659ea3698d349c700580abde989b83807a7059701709e49bc39c33429957eba6bf0d53a8e3cd7e45bb2a4dc7b4b3df8021bb17afdee435e32d3f90e666661d49f1cba35c969d9e6e3c3a3c03834b13888bbf38850d2c13bc6a1e004518b17a9ec80f378a59894207fe117b002053e7d51f208631779b8c81a811ca46698ebfe1ee7e643371c9efe6e339dd4fdbd98e609f22a0501282cf511b39d520162159ea444a8c64f9e3ed04652dd70c51c660fc9537fbed3a39578fa169934d1856eb6cd6bec2053779821ba7d00a6f2eb1265c0cc3c013bfb721345f7f9f27a81c10fc725b5a0be615cd80861987c42fe71028cc2ab048e455d15e0ff742b608dc288be6686d685bc2bc6e2e7d68257739ff35425152e92b48fd98eae6c494c4f6eda18e7e7a9e75932144db853503308e0929c9898a1b66f5e71c05c5bfe61596ca65cd07a3d064fffcb7e068616d3bf342b9a9cc2e2610c16bb6e6e8a763bc03a2dfbb9d3d1944902e4a6a6e40dae88b4cd7585b2cc5114fb372963706a20a1604e554fc9c2278da1d03cac96324c144c4dc94ec9dd1a55623b367d47f368bd49b5a5d52526118beac45a4af59b73b4b3e6d85d9005deaccd7fd3e8a5653c6ab2830527cc4d6334a9e3b21a4274a2d93d2e6e96c9a4e550a06ff93643c8d10c2210af51b8d9f4dada3b8908c1853b758fb780e3f2017fe9cfabc4694a5e34da35d3a22e064055fe38b96076eeb6222b91766bd311521416bab2bda8f336b2d960e4c8279416676f67352bdc7c30ea371e14ba586d57cc06e1919989a8f9e3e158f7fc7756c4119c3949ed19d2792a0ad87e3881196c43dc9990f3a4dee28042bb7736d3c9f8f5428cc9bf0cd1691a12e40ce8b198071334265f06f92b718b68c2547427c2bc856c417f4c424158faae3d1ad2acda94f5e75b042b9ea2b285e66636ae74ffb4e7e32725c28e3d8734cd37a385c6550fd0028ffef333f3c504ee95db021bf2c199496aea04ffe96451c30a26d9dbef733b8a0e0afac133678fd5dcf42200f924bb59e4706fa02698c4a2ea6bf8dab0a73a606ce7e894d65f9226b6df96c06e44f1e9fb08e4c77cbec384cd9aeb2e7041cce456050408241a4face12ed03fcbe90de0f0671c0c4edb1b0f7ace0ff0746c9ba7eb307caec21a1591bb58fe90179ab8490fff5e992517110cc10255c3e000b0d7b6741fbee69a79556d4629b9b339296e91efe6435cafdfd08110b37c457420a0662032600163de5ee583173be1bee1fa15e12533975dd8c401a19d17b5da7e2f017c8b3c1fd8533e97d33b9f9b785858f80e16dcc12eae7f4e9a96510d72c17b3931731d47ce69fa9c8e1bdeefba6e58856c1566a2ea9c8d00225ec65f6796e058b85cb8f6bc5fc60fabdd535788013f5ef97c7148b89dfd244c1dace7652702ed0fabbaee63bcc4be394a9315ac9a73387e643602c53a44d800ada528828f9deb43fb3a8846d61d612c299e7d4eea0ce7a344a13b418675c5214de2a50dbf9254ad7422fdab1c1f9372953ad841e76078f9071fc6639df8ecca57cbb0839acbc451bfed176ced5b54f7253c4ee46e70358676cafe97cd8767d7e602989b30b045e002541ca8ce0ace1e5e968627144a93fdcfeeb1806f6045c3bdc7f56246cda91082f945112ba65a7439e9a41235082903a623e8f578f9e0aa0816b92afd64d71d27fa5930a7e1ac38936461121a2b3a39d8e97838fc97dd9c92d8fa7603d580079e8c229da2ca9e99064de7215d4b29a9ef6e97ca8804902ce2291ade63bb4c5f71c122f3b883fbcfd99247c12248af09b458001b544efb1c5180d9bb93ac474ed4f40c95c7551cc1b7b1ce162e77545e98c665430672ee59c692138202bdf9174713c6e538971133bc8173336ad70017fbb8966577993621bdcc1791caa6e18c90edc23d150390224fd8de51668b4832183a3d67234409bf71b1ad3d9c855b17144fe49577fd6ad72f20c39ef38a0f3bbd41d89c13304c3b15886a49f29e20b2f9566da46bf595df12f0123e3dd039f5fea4955c282aefec1d34400e0e9b9905ff0d367114491f47090dad54e73b6a04d3388e11223c3f7c9e9515ad82c6348d6f1cb9cece116475c1a6e98d44065843d78d93fd533422c11e8c633524c6261c63b350c58e667c55a899893e87d599fafd2bb21d7ea3936f2aa1f9473c023c7d971c4aa347f1bb787be400a448c567a4d08118eed69adc7a26a6a8999593092dab9e39192ccb2a71fb06432c90644dcd7c1d98e44d590320d57c80b3bd7d7185af4f970e9b98286c08a391392f7fcdeb7f5c8a3d356c2d4bd806e192aada0836b8274c9ab5d07692d679e78bca7661fafd4a59420dd0c0cb61e8062eea7f20770b55238332a7082cb736582a9f3b7ef05a91ddf24bd362930b1e0ddb5e377da53048168ba657ff3c1aafd34fac9b350eef2c37bb62df976bb3967fb8db1a62c533e39451d75c7ddb0ad25e08836a7330831b8fd5cf0f9d65f91a9452bd1b44d91655a952c8959ea8ee68860c1d6e7c80e9ad7cb8f13eadcbdb7d09e4a390a510aaec2c8ffb84272448089721fc9e8b6baa18c827fe06ba9860e9dff3b29bf5ef910923964868db4b3a5f33a0b16a0fd83597b54e4c4705b46d516832b114dd9d86f1938f18eaa00874b0f9be7424559af24da01fe078c4435546b3097ab66bc61689226cabfaa84301330df4268ab5a92a4b65e6e74be184d4da322bcf29259ab07c0b34b7cf5dffb720b40a51906cfaf1f88b727f9c996a332da1d90dde5c7acdc63acecd76cea199b74bcd44727488c026f4556e7ef153a84f2d0c60b23d97bfe46ffb53c908a3625daef2e9da01f3bbbe08a618805b7feff402003866d3bfdca827342708d42bef4528405f6dad2aedf4dde22f95c9793d152fa96bc65e81aa5e0fa90d9383df591b78ddfb3a7bb3d1bcc10a035bb8ee346eebd2e120e2888d7a0c0e9d25083022c506ae5bd460e996ffb8503f974ed592cf4f0fd0c3f0251e17203f6ecc745ccbf029c4e75e31e4b676d69bbd7db1f12a6c54964d194cfdd49632bab6c88d78694f7b9e200f04abc6281c7c619311cca1408a7b0397fdb8ebf4561509627d0ea2ee2429f79d528506a1aa05d3d4bb4402794c31bbd53e8e3c512a65da09b3a7314ae72488cc30564de1d9ae1b8110aab40bc56778b6a022ccbe204f66470672e2a44cf04285404187b33d9cd11fdfa7688ed6a2d8a3951df2aa420ee0a339f1055ffaaa2c9eb8ecdf65bd9a34eb3e32be458b26bc7125a4c1bea15a0055ce840de33ccf5539716a7906615b115598a894dc269eb6f8b04a883a13ea44851062c0871082d1dc210275ed913c8b858a295c4902ff0b66d4f817a5c133f5f1dccdff10d9def562d59e970f1ffc2a49b624969ff51956239d782a393d19594098151625540d2f03fdd2fc25d3d218bfb11d51523dc6e37089ae9d3fddeaff0942165d561c93bf74ae41a7f6e4afec8536e7febb2d0e550923ef9a5f9611639990b2bc91edfeafc29b30e3dbd04fe9bf2b8e9dac9b5154aba3b97487b3fbf64d5a98bdb05c562388cd128b38bbf10a721cd86f532e362122daf0ca2157d17bc4ce439b31151839116d985459d43b260c7f8a483caf5bb4575cf78a9c711395fa73192f50dac766d949286f601614dff305e63ee39f82c27a65a7019c78e25b9929d6ed2d016ec536369f6df3c75a16cd3c091313c221cf756960a47db35218ce54ed5cb58d5237d092c33f7d32e6e7e4830bfb271b417c781002dae0157a5aacfc20f5e6c671fa6cc426992aa70a548667c25e4549ad0e769d27d46bb70687c4ff6a37a44ca2c0da55f84d6d22ec5bc4669693e3bd2520eba129f8c03ad8aeac3e231f06335f94266c980c1cb6925db4c5c00a608fe1cfc4f3b48614014f793f087ea76b37f4f75fcdfd7720fe2734d1d70eb235f0ae43ff67d575baf1785b0890895cc5155db31ddc4a82c590b8eaeb5029610a36a8c56821e4d9d0451960052caf472af18050744eba6ecd7c3115c9182195173b125f8df754601b6139c143f90ff46eb2d21c84e2a6c671a3ef8918d03489d59f31269b6c8580ffe7de396a8d76dc8808ff2b9ba50b89f8bf07570b426969c3badebf4472d764bfa43828bebfd837412b0dd6e80f30c0379206f9a79caa955f8d1e6ec52b4db23cc4034f542f8d0d93c0a30910419f423911ec57610073c3f849236ba977f2341007a489d9385595e25bf1b8cf17bfef218a385c337ec7968cc432afc101e6aad7091f6c2cdac08f5e1ba5b516d3d6500efeff1166515ad53bd87d6be71e14ba9c4e9b1475d36a187aa8ea14a0225b440dfa1f857fe6090d6a32e018453d1f6f5e5750a4235bc6e227feab1e37e04632f0dd3d24fad864749bde9821f2f96a36bf95033fdd120d5b74e94d9b1a89cde67e6c20c87150a914def94e02b7fe210a0df177cf48a4f97607aff370f9550d18b9900c32e4b481db388ba2e6d83c328c75a9cc4fd1bcae580c1a067b83abd3d336bf272b2c8ee78cbe2d7da008269b86fec335fa2a3e380c8c37badeca508a2456626da5b6d0cd70e53c5e26311e2b0ca2f1b6594d1fbbf07c0aad90f67c32c5faf2500447761535aeebc45bf0c9e12d21783485fdc4ad6d8a046a931d93a0f72e14662686ca2663c517a3ed827f0497c2ceecb329f087b003108aa207f70483b727d475c68ecccc3fc97bb21d9174e0a9abde06cba13aceb396653e448c9562b9d1b0632549ff21d3ec1659174b441caa7d8d2698a6a1e169e4f01fcd197f65316486e91e69aded2815518f3d60a1d6865e0f4bcdea0be7186d64348712b7dd07d9cc95681a8e7c33c0d4a0d00324f84a37f1b0865a8186df31736a3ea874cff44298292ffd927159b4b5bed852a98b1983d21bc6c853e428d41a0f9ccd42cd78bd83b55609aa1d282995fcfac6abbf417ce66628452b1bdbf776a9b18a7ca08260623683c5374da16edb9d99a3a5283c6f87911cd2fbbb3d8fcf8b659a062da40232148447794f1c068081aad323a339db2fc86397320fd4852cf053df2a932006d432d828a1e11f6a6718da70be3d153eee8e317419c45a5787d8684064fd0219b4de53253f2878a16b678ab8ed650cdf2a5d9ba73f0ac0f4499998b22ef62296dab14d820631205035df5caa60bd016deaf9b7a6cbf295be276ae227e8012acf6e306ca4628caa7dc6262cacf61c7f44faa2f86929448213541aee0e541b8894527403335c0d1ccdd8169eb3bd563ad99e229f22e4c5876a4cf035955d1ac4d7f4f1560195d1b63f318419bead511dac8f557f33b9dddb14f1c1428299aabfd4f7a9bf4a4bd8d13fb8acebb2269c3cbef28c433553eecfdfae82ebda8c38c26b40cfbff328ef8f9094cf0bbb51d1b1561c1dbd158d7d7e0ab1fee44d923a7e7e243e7329a2221571bbadcdaed1e47e9ad60dbde6043ab24b8bc957d569efca2baa11c9c70f102db6e8ea4142dd9338c708195fb033ea14eb58469d78bdf57bd00b70747e03bb6c6108bde2e006d02583f108c3af6f82c511e161da5b41887915fb3339a504ec6bb573b534e01fe3e9b08991527a9b7e8568cdf229a02e62b13a6c9fc2dde2ded233330331bb8bb00602fd2aceee1e629ef091d32b93c37e34758ba0f1fb1a7998e75dc7c8fa5be235b9d0075675f8945a608ea317a6c29445a0fa85f2694bcf7b4e118836f6203d82e5f0b6b0193e0adb5f5f4454258e388937c554f16aab99d224688e84aeb1cd9befea1be744904dc327885690a158814673ff872f742b052c33057b1473fd1fad87ee7ff98003753a6206f6495e2ce86e8d7c9eb363a9456a40abcf91b81fed254c3c413b1781c872c999cd618902d2053fa8b40a94d0a0fe48169d6ce74f3ef439aa0f1b0179703cf47374840c5c427d96f0b384edf3db1ce4b550128fac9927a5d5740ef2d9bd887f1dafe9c4ef62b2b5af0aab214443a8fe3af2a619ba5952b1e0ee76d1c8923c17c2377977fa115bbaa54ff0677dc9cf6200ee241a5ae3e0cb0315c4bf0572c79ff3a9d9840ea8543b08d1b8d668b4afef560ed0c4e6691126fa5f2f576690728c502f7a79ef7c1d3e8c221228e1105daa07222175164d1cfd74fab68fbaff47a1329256f4feb845ee1e4ae3d30ebe547d306f27c2ddebf58a670a79fa4db0150496ca94d5268e124763b52a9b38131c8e95c990bc284427bb5d76ed395366af8780c0d67ee9315515f800e1f1e63b0d57fc1c274150b51c8fb5aff41c04e21c72e53c189ec66eee1a6711ce1a95a12e5ac386c4c3130ad7c24fdd7c38c66edf584bb24f954c56eaa9ca0fc5fb7c68986749338511d2d5320a01203e2694a3abe9c5bd7388cda0416243eed561e62d1056ac08a856e149e014c32cdfe0f788a2298adc61758211f5544eff9654947539a73042ab5959f0dff24c04e7f7d6b458fd1438f5dbbe2f1dbe4ffc4ea6605866599e5c4ce71fb8061ff3fd2d82273df7a2ea92afdcb124b2841cb7e7d2a88c15e4eb0032df08a0d6877c7f8a4adc8e838ad79b0f1f8a4de7fd6e2b7725eee14ffa66530fee28878e46a969fe5f17a42fbbd52787de0f8801873fbb82c3805513dd885a80beb1aedc0cb914a12dbf1a9c600274004e95c94379b22f23a3734e986eeb3846a4e7970134ab262f864348af1841a996e9872806d48a617237d7abbd55aec78df9096e41ac6c275919f4ef6e553caaa7f43e19ebd4680d8628f4a49f1074068a69cee7808be8e2f8721adc03dfe356edfd772e7ad3f0aceec5792cc4e95a1ea0857ab552782e4a6edf06c98b29026ea8b42019afb71aa64acd22ff0184bc4a4666c58a8bff243757f873691c2318c30bca4816621ea5010124f625e1ec491ea7cbbeec292c80e3abccc8bfa0aa2a349976cd604123d51c8a12579da608ed1f11bea3286b38f11dc29fe4375c3c8aaa7a51779eaad3f7207bf8bd43b28d426d1156601a4930d262990375a0bf42a48fde3f5a790588f74e13ded19acb7ba009d879651792e3bc314f6ec21adb83b2d1f9e3d9b5ad330fb648d7f5d32fa4a8a1d751d60c6912673bef5158d81b476d9fde9bfb736aaea4c959e516fd1793e0dd051d6c60b29128451129216262e3a5c4a65383b36834743f75882a9f85c77474ed8aaa9a2d5b0ef2b36b4ae0f21055fb60c0bb1336ebd2c1108de4e065a23f2110f6f80ac138750223e302efbebcb3fc50cc88bc910a87ebb7ca71ab377243ff9f3870a438e0b03972b51e47ce4ae801fe78296f16740aa92d5f75a042fe621e89e04ad49221a850e85c4dcb29e9fc71c81554b98397039ad7df13064778b3b446e3a1167fc9f95296a0c5d63642a325a1448eb91dcb93b94b8f7a9493d4508c3c82db11faad2f1b67fedab1fe1023586990f14dfea6d997f9af4eb54f9e816c5afe7b9907f304981e601fd670933280aeec31e96273170356d824433aaefd8415fcbc8e567a4bfea7a7eaf63938c4629dd28b2bf2bcf6bc9fd49a63b2f6abee1909c03ece1c1d9f46674c5f71784c569401b5e7a41dd9bea9e00ed39e9061bc2550742ff28e15dd9c9cb5efd9809c1be77626dc7ec2daeadcb5da69d11863be2d758e0bbf4dcfb549e844bbdb345f552320a56aeca819306a9b2877ec395f7fa7576119afe136b8f940c5a83654b4c3025ccfc49c1a7eb9295043726a1c62af0068bcf75be03c8a1998bab715987a775ea8573caef8994299ff78b8c216fdad74fe39e2acf6fed60af04aeea57c94e37f3c6de7d1b4b4c24d9773e555cda82b4b3f6ce78a222ffa71a8b3f32922140427d53b68d8d8b44e510bbe3b3ca04f953a85571c0b5a953a246f5f0c44a8e6ddccf22acd1845b388f292d6cb47f5d0cd5e31ccf6969ae7d955dc2336bc8394fb73857295014bd15dc61b59a0c3d9898942aed7e8c2914977ea991c9d2421e0de499746303deb13c43640cff3c3aebe475e5282ca94253c67d37596ce51aee6d6fde52b82b04350960e4d8f5860aeb63dd4d98a0d2f8ef6a1e11d679a0798cb012a6b760898a464417d9701b525d372e9be326e5a90e1784a93a4bfff8cb02673aaafd5877d674b8efe00e75a0f83841af9fb5e1bc28fb423ffec69cd3c643cfb036eca0bee8b4743db988c2aefa59aaf1a1ed580d9b95a2a39e1cf4807dab91e8a27965694cf8b59240242fbb7b11733a9de6693cc0de24ae461021cd0067f02fa07fc93cf08fc87aad840deaba968b718762d4f544a9b980057df473588232c5ec9c9dff67eaf242bfcfce8cde9a5bb05f51eb43fa44893752ea725dc0db02c0dccf0b917075380fbf9cf853a88b0e6695a31f700bc28bc672e5c0bd3d9fe5087c8e19f5fa043f14f224130b32818e6c1d1dc92c37189da28b1de40f17b7e910b4b7f52d87bf6528f6bc6e6b8d9aac6561c8eaeb43baaa63b106de522d6ce6581ad9b7159467fffd35cfed2e8b5fd17805d30b8268bf09d49b9fa28dbfd857be113ccd236893d484db919538ea1be6c9065756d973da3a48aa2ea8d967513e13ee51f7072b9de39a8c6f2bdd1d1dbbd3f9c220b483eb8a679062c12433707ea0b8294168fd518e0dbc79fb7c1715dc6f4e9a52b7b5a1b3abac8204b2edf34e4de21063623c8a9c37e38b65b77fc038f95b959825c9fa46e3c904a61e78b2f67796adf4e172485ae0f56dc4b64e8a0414bac17220b63c76d573f275fea2421ef8385f9a160238e77a7b2d29e4725770ee054cbd23ac505067dbb0cd7f798ef60c841dc344eb3a9be83c76c818aea98e9c1df1059d5a9d54e196906f5c93de64cfaa3c29b6cc6bc0c1489f895d4646910d884319f7d60e9693f4e4868f4c0ed0287fba6b015cc5a9e6c98231ef72eceae8919106fcf72dee91f2662c682a29926d35ec0a0ca559ee42d009ff32c76f4640df49bd65dcfe64762a845826316965def91b2c23e36a7881a23d01c29c26a8edb2b8e54095d8579b6b86003c1bb54355a87201a3a13ac8cc7d9014426bfcb5e50bbdbf0d47ea4fa555da53af9d421b5fa5290e0fe6bb6a9dc647c0ec9d4fdf16dcfec8c9b9281ee85004ddce5c900b49ba84bacd08fd11cac86c486fbc42e5de2435973ec2cab4693a910e75d5e88803c5dcfd21551f0f272a2be2d2d312f7f919ac191ac9bf892d05523f7fcf45e6374123de1ef2fa938198d4241074abc1e5f7404c7a80a0c4acf594646f9de0154db9b68ad3a214c63caf42e56ca8ed1e8de7e11b0ec619ccaae146fa67a438930c56f5383e4542ee6cf08c53611771c079dc3ae995d9bdde1bdd063312d6e1151cd77a71c32ee5940ee25125c26fbbba0d711e29f981b6488f3ff6f0e08b94ba9755be455dfac425d94fdfd43250dfe3b1d94ac57577a90f5b839f30d774d11d6b034a2ece798eceb320ed6fb80762b974ec28643938131ec4490905c910b78caa714b1af0d48e0c4245f601e650e2fe20e83d94cf46663c0dec39788532d0567544fdf6d0beb617c8f230933ca4cfa9ac6c9c231680006eb7eb9adc82e0b98a465b47eb113918643ad2389b8fa3437b3a8fbdf4125c757930e3b59e141b3fe340c8cd8651ce34b8ac719c32553b9a5eb9224b6b1e2694b79a2b97050a9ac5932246c64f9f434ba14760e5ff04a2c707412865fc1f8974c6e162047030938c4876904b374851428598f133f32ca295bdeb4d9c40f9e7b7df492334a0bbdf7022982536eb75e80eff137605dd0ffb88c917fbce121cfb7bd99872c6ae17e9f2516309da6de6538ce6652e3b8218fd4a1f7d6a4cf2886b9afdfc74534ad9e66d306f0a36dedd4151e40eed8e435351f4b3ff93055745157f6867635e2b775b8421cf9724de12a0074033fff33b6943284aceb08e7ad7ff89b9f2286c387e07eee2f6585f538117e1fcfe703f2af6c5eba3faae01187ab690f7efde034cc541d0f498beefa11c6d5489cb04b500a46a5f000a3cf441253a75d2fb6e2a67485989be050f44afad9cbc0ba2006853551ed67b1c74ac95e68ea47c1de11ab510e633150d1349dc07d998eb0bc7fe4ed0093cb6a94bcb769712f13cf1d1d485ad1eec8d1be342d771be3f4d98732ea44eea521960f80e47f1bdb4940a890bf0e5de2967cc81a165715c3c217ae45a4b4aa5b84e3313404a577021dafd72eca14fccc5efa677e22932283e01b7680b17ce864ec3ef8b56979ea55bfd3219a28a573aaabfd7f9576fca7d932a74b6bd5ee1bb47dc38dfa7ccf01d3bfd1da67b7a0ce4eb7b02506a6ada462d69616d72507bcce16c89c841e0a92750b7bc5040f45f07566bca4745bc152b746075ac8fd49c0d6e0fe0aeb187293439a3ffd3d2ca95e5176954071f0caa3ca9eb9c401872a9ac16dea194590e88677a79f3fa14eeded65d03e360aebdfc36f3b09d8d35b1f0942b3be389dd338bdd0212994d7cf52239eb2cedeaf7cd1c1c5722d2fa4f6fb14a3af651cb666fd8ca98181d0a82b929d4f33d3571a90340a86f63bd5f0639633882e3962351df59a9fac222702cfdf9596f738478425dc548a6fc7f44bb146c4e1e0bf5728e849b291d7986ddfe99eee0c1bcddafaf75fe93bdafe7c28988ed497ea64886b539f839d0af18a60056b5477fa0b0fe79f760cdcbe6a8d0dcfe514afde1b65f41ded707eb2f57b0798b7f682d48b0e92a9c70b61e3199217703181b94cf6c719cd230bd923bb415ab48d2b90c50b15bbe467155332e169163ec2f4447957a32aed4bfdd0b2084d41d327829e1e6a2388d38b1d12de4a5ddbf688d92d2e79f398a572c4332975b2d9f9709908b9dbe70d14963a930eed38726cbf23eda102edbc70ee42a131f83376d5b167469985b418027d86dc706b9ca8ccc1d69a385c9bf6e0535905032e8ac8160b253cc421083da43825d00913b5c09b2f84518af535a58ad7c8e3bafd33e1ad1537888fa84367dbdeb17bd2b6719ecfd05ee57ea3716161409cece09ae7356feeba542b0af5f00a9bed01e765039576177d90a2645aade4feaa2c5eb881f10a04791413b50c714dab52ca4f8c357e7ba138c1358230c5c179ab847cfd8743f96ee0fa1d2888d01cc0dbc48480a5d3944c91c5cde479c159d92c53919783fa5cf3bb5d59d7a301bd302d04e63f90913053b9ed5e63f7036cee35cec4c6e76d3e0036cace9c49d7e1907173baf630eacb52fc3de0ccb1cc0509e0ed52ccbaf646aeb244f33cd50ad0f6d0722fc908e4f1fbc9f32055e6ed463a97eaa36dc435034a053cf457f1ab86fcecc47780cac3390e8b789ef6bef6225ec0405b606505d7ee4717c57e6126a2fb1707f904503c06ccf62861c9c2517447b9aa70a47cbaad9cdf4a28c581c63a82c483eddfb5a725ea749d33bdf869effcf3ba39613ecc3e114cb198b62a2ff1383f9277f2d5b90b82d377991c55b417511e8c15384cb592e06174bae889f58afbe2bc8fbc146458999b81ea4fbbc709e74ebf9bb964f99804da7e9db9b687d4cc5a3a79dcafaa4014b94626ac9fb2de8f78e2e619f1d994bc788ef9996d0d3b213bd0d8c1c6b654264979069f58c79852a28612db8d0310ff4220bc3ce76fd1ca970db524b58a0e5cd785e8f3a1cda83cc51460b2b2775412717232437efc37a3e2f0c414f4bdbf612096488861a6cd720ce47fd1acd8e36b042fa437733d8717bf43ee6388441b9ded409113be536f89ca9dd860ccbc3e3593849b0653a863f74e32b2be89f0f5238a727d51ec7142a58f4db63b24edebecf3e2bc4e2f77cd36bfc2b8ed5ccb649368edb81cbf5ee9ad97449d902ded77e22ad9c22b0b4a462c52774b0dc6ed7e070b513be202ae12359de0ef1555e00dd07ccd7ba564f4946b5f742bfc0653420a897c51b51a4967bef52ac2447c7fa9ee3f1e90c97695326c7dd573d2fd98f6a49ebf89af33a6427560576d4223f8e005534e0d8836c0c6b3fbc573ac30ccb90ddd15d207ccb5d7b77faab07285626c92559e5aa058a510292b035666bb9811c551b958af5d14d4edb363eb74363df8b6249e489c98f8f230ee30f201c0d514b89e523ceb2faf3ae3ccacae7d56c6e8fd9f6c90d95720b161944ef00dae03a86db56b5c4c6f0ca0951eb32997dfc26501f41daad8463a879d848fda91ddac4e9d07568e304559365734ce6d1841a841307feadfb098ac5eb8cf1eec8bf33b5128b3f12484ea398eefd5d85b85bb621b7c5d36d7ff16552834fe9a108c4db07c665017b7c1a0685f7a7ab72c2de58c7310943e61bb93fd1786770c39ae97a4bf4aaef1114f3b6310ea60fe04dce02a515ae62039e0253f0f445d7b1d980ba1326035696800cc6652ca4fe7fd9cfa9232f1a9e6c38b5925bf1b7e1372d51f7a2986fcdfffa0c46a0e69084e7ab04d3346c91776c6e9acd8f82195310af43c68b9bcb91c0fb7251e020e749ed1e43ff027b8b8878d1c410c9b6d845b40fbbe372b24e77428622aa555370f116d2acfbb9bb107cf49500834be1ccd444b9f3c5393129ca237b03ce682eabdaba89cfb58eb4431b02356990d4c2ba637d5636351ee5706a1dcabbee51e98030e65f2362181982b6ec2aaac835e49aecbee8ad16c25bf13cf84c2be73daf8a5288f35727bf096273dcedd9572f173e71365c8763bd1ef295ade4da1dcf7c5c9e1ebdee0bbd09123c578d43655a98268a8c9417ab9f03f8d36ca5331f63028db293ddc1a9fef447b4693d14014f6a6e74c0821237b778630c10e1bb75cb8d94d46c488f540407f3f534527cba2b3f093e11ea1b764e7947e24f02592e180d8833a50b623316b4a6ae84d778be0cc3d66b31b5a70b965d4b44f5d2b6cdebf6890f79a33283b2ee111081d30429f2bf1a18e6f3243edd3103ca4ef6f415d1a726e428d33ba114cee2022e55a8395e560fdec90e230b5cd1af1e214151b89cc28c943b5c8bbf7ac03d446cbd3b385ec6b2b9f997786057843e1f046e5b78c9d72547560b81fcf2b48d528a0aef57a9718d23bdd0be7795c619358e12b8ddf7dc0bdee004017ba4376e8e8176a0a4c9323fd17bbc4feb763aa5ab30babed96f789f9fe18bcdcc1ec1a1d4b752d07f7b9122f1d8e3614d4e4f7bf2ac3e3417dbebbbc22f6a848a2c9d2ad28563a68128dbac32525f54b3e79f5ea8d54547097b5acf1b21da2098d8a1386129dae6b85b4a7d131748ee39e03dfc5102f12628f523544b9d1d85eeb5252869ab9f9e27a90fc10a29b6f6b572bc121636327d45044bec17d7324092b9352de29ec2ff0be24cf11c27629467af6b6d7ce4aaf7cc8fc10a8184bd3bb8b0a89c0b6a23b104a21971af89fd39c4a26d41e2eb515b9bd282eb9bc50c1b2238a3b7e7f708eabb2947cc6a45f61b42f0de40178ab093f1cb897f201429cce7824471f493e12929a6abc820a7a71654f4f2d105377ce7044f1c8fd87f7a1e3e14300449020564c1bf770e73866d2a8fd7356325dc006a43ef07b1276d5556d5cb32bcdad3651e94c0ca95ea0ddb65598bc5d8a404faae456411f002bf2837872405dc567088f7f626f2edf59a635718e0e5bd545a8b8f9d763ded4946e5cad1a7c48775c37474ca97ed3a8166a1cbdd584736f18c7ac978324a8e832b0d5c3d0556b15e35b17e815adc42f371305c6a13430853ba1824533df8655ebd98163f8ff6a35ce5b33a651768f755e898a2d7282157f1e20f6653b387b67905fb9ab87bd378faefe6baf0c819da592a2e0f310a4891b68b1a0dfa5a835f1b57ab290c98317766f0d0b522962f2732f99f62322bb3f340cc373495e8b08b5dad09ba744f4e0a32e500df78122a9d74bbcdbe2fcc7bcad517729233eac408de2def1bb7bd46770248c18493a8eb0707c4a5277dc0c60e275616600e8fb258cfb947d6017d271aee0199ffefa8562d6464dad14017311d2aee42c855f6410fc8c06c23c0cc2342b4a32404ed81ec09e7a9447c4d806419ad0c1d7157f8298217f089f47919463929ea9c4cdbbe53ee2233485aa0d2302392771db800e34edbd4e86118a2669387adc908995c56c7981a1cbf3eed3a0836dc49df677773bd6439b459bde17d17e6f90c9041bed17bc043267c1ffec7095119f32a6426afdbc44a5889ac7f55dd3ac40d6a2c4076a2e42b43b2c5143c41835a6a067c098f1e9bf8185059833f55fffb719988cb1047088b064699230e8e8731a0b01a8f1bed436bcfcd2bfa7c41354c7687298f059b8a5cf77379873f3fdc62cdb97f54ca6b5fe59b3fc84e23ec1c242922ce8eefcd72f510f169b47c847a2256140fbb97fdc98a265fdce9e03e90232bd5d1782b2bf2d0ef6e884697d0f5a7085f4888339647a36aa4a4c694321fa7e13e19ab8f642543df028e1766d0d394df2f58e8028ec6b5b2a126e4805e69af3149a709e737ef27efacbc32328d1716a7ff5c3a88fc4a974e9e3d0031306aff7ba0e51e823150acc654455b557049b6e1657716ee7d991a70166d0a69d257d212382bdc9547c2e5b69b7fc65c4e31f51575bafeedb776b12e34e3a107dd94e8caa126978f5b94ea9de281b102574233d5ea7f9b3b3106820205010295e3018c5c2fac2f0da733c7dac0e8b9251b8afa15cce04afedb7f53a8926f2eca1c3138d4372805b2e6f187f22b0a4cb3f88bd540fe729d328530ed98d448de8f317831a1c14a08652daa0f7f65dcc90e2def639fc69f3d88931ca6889b8bca9233918b884b89069e9123a3edf5b598d8eb125ec9831de59ff8e8dbaa51c1ddab24fdbd5a3b03e27a51cb8be26bfb2184c0f56fb956e86c3e9a5b9a3ca3428dfc334a1b30ce689d74736f15d9f2f7a4647ddf4f9635222a7fdcfa7b890d376d3e2c1e97440b7885625cf88beb89416828d1436d5a461391379636fb75511a63ea089181de59b273ebb1dacb0cabad7f140f224fc9a700e3a233f62b089e03918ced7b061faf71eb69480df6c956b57e7bd0bd5b0e51f2e0f5ecfa6628f5609c6d95aed1daf722facb28bb841e9376d853750c138a970cb4e864877996339e542d35ec46d5467f4e90dfb139cba4414239e42e6efb511ccbfcfcd1efddd624d4f2a7ebd155cd2a5da55a6c45fee90df399f1e4835b1d0dc36286ec7fe876e65aea00bab4ee1941e5bb1e3cd2a0ddbaad81a2ee785adccd7a939dd47b2e51d4ef97956880843be71df3912570484ddd7d936f98eb406a4e18c8b33918fa9d2b0dfcbd8558a8abd0f88b8adc99ebbd47d2359f9a37265fe8e9e5bc58ff5065274dc06c24c33658bd17232730552a82080abf6116f87c00580cecb928805eac72aab11402e96e904077130d2f4a50cc019ff3731bf2fa89c086c2a1bd092adb914d99b6e36b6cd5323863f1b115a97d4a2c64c2fa3925ddda7697dc9018d08a56fd61a3a7e7e37099664896253e47431471339e55d622a55254e2968cb50656ad801a41d0acc910a60578332dae4b31360b1188ae43c834543c99b84ffeb4f833a0d7a89eba8ec8ca438d9dd3922b7f12a247b23517cc862f60b1aafd5e00fdd64bac641ec0479c38bf2e2f6186ee5d6133b965798aaff1112f1d7ea38b94154eb561e0295e448e7da311d38d3646bb2432d75d0acf1f4176a70b567a6a4d514d97a00e70fa63f6d627cbc5416d567cf2b41a2f2a20c7792bf5dd1341df228d0a8850258efa86818f7374d163c501ef5dfea8fbdf72c0c3b9f62c8c1f0ef316b8cfa9b9b22040e14fb3c2c610781741478dce5cf5053e469995033e7644cfafebb6b2a322ba81add179452ca98fc0d6d3f8ed60743f5d2eebd9bfc3bf57303b6a7fdf0d72269dc40a97fe29b13fe745957fb5c8f7958e6db9b8da8112d5b4c88c2ce3f4c1a3b7880e5e04dabfd5fbc1ce6bb10bf3ed07d2b819f4ae3d12c2d0fb3b368c3933f5f8a5e7d120fdd2f2a27c4de7deb8523f6f12024d5ef854e42c48ff5bafabf12c1c7eccce7b9a04ccd10d8d9bfc02011c45f4bb495cb95fc17f0834ca0ee7bf1878fa9794fdd0dd8341641a2c90978c8cf6de6f4af710b9955940e5a1a2ab8bba7431dd21aec37e342f6327d665a9a33b232f1a0975e06f1cca79eccce5b19105c6e688c35ddf43f73d992f26bc010e90902fd7e0caf74ff979b1e7f179ebf1264d23a7e56a03ada3a6e5facda44978e6a616303d0449548ad5d7303876fe6ef3a34ad6e145d2a120a14b79a05aee82cdb092bf1638388c8a16b01dd0278336d71f2dae9dff830f58fb57c9c3ecbdc7e778064c5891f8866b52fa9b393355274e0ad7eda992719fc09d98f158a490a20b02c6f4651316e022db265b3584223f8eb9201bb1e6d4354e6aad567d400eb5610d1ed031a898be756d6de5a0f4aab7ffd7324eb390265c62c23c9861b10974d437a9883318fcb7acd7f9c6355270b05cd921c6bfd6cb0bb434a2cb20f1c04696e0fa97f4cc7a35ac04ef6217562a862cf6bee6d91fed97b1236e4613203f13247c33870bf80dd160d0a59480ce008077e921d9c4fa125b96a450aeafc7bbdfe09b21db0e381b7877fab7d84ee91b1c74e4e703f40bcc653ff7eee3688f2584558ca117eb4f260d928db848dacee827788f9f306452892e080a46398dd2654316e0339acac435a2b5578b4dc30c92ddbe03c82b71a4254d7569737e1961182a3bbd3eee185b07307c2874e99a3c7120637169a4957cbe06d16efbcb757bf99d916c0cc4bed5c357f39a1639f08bf7d2443a4b6f77fa156e17119d50de5f33f29a83239a7015cd56e3c594d93a43005e9cf829f09ba31c93928c853d1913a98a814df8761a5be817f33a1cc459f3b09cef6759bab18dee019920c4e60ed62a5bbc8956bb87cd474d1db6284a07b37c690e6fa67aac9fe65dc54a9ae42a71f7c8bc06a5c83909dc3c5737f3d11d8244d2eee6f57f48db3a91189df84247b295666a3ee47764a51bbbbb2c0fe7098c1b970655cbbbd6f56db52186311f24866462fd1a2d1f0c5f34fee56c7f5a2d847e7009b611dfb3845e02f78cd28d1c5c2b5a0342f829a57821c7c4f94dcc7774356a2e9f644c88ba8e09c974c1a5f2500e803f63c410555800dd0f54d560711d4b68c1cf530de4cc96ca7772427b269e233c08056a7bf8883e08251ad5bf109dacd962b3828c25246a04b8c59c32028f68cf2781ac2fcce239cf42f9644c5b3465f8ce49163729f647a3bfa926af08c4a83d2a44ac5a2b41e245ec5d74ce839af9847003cd5270264e480ad39ca78477ddbf48514cb72b4a8360c3273eec3aff16dfdc6ebaee8d3af06b77cb355b90d6675ca53b1aedf5ef661a9db2007e0d77d4a0722fadc16b6f774168a860eeb464fb2d7a38b009fb7934875e971d115af2fa1b48c8f8ed1e1dea5e504f2d0a075e22fcd88b8301e3889d1226dc4a73ccd9ed35c93b1566e52323bf152c9281e05a31aa27b004dd8373cdcdd1669813030391012de0e77db85be6c0a0467e31268bb3c7dadb23a2519a620994a419a86fce8357b308c637c1233837da5e640b403c34eea669bcbd54fdf5f421914304796ab6365543b9f223431f7f7ac65b1fa542aef1688a2ca9c93f6723c79ade645a0fd10efeb355099c535a21ae47daf80bb140da0169ccadca868562e6d46f9b99d46691e619d92e7fbb8e4e2dfd8ba18c8299bcdf6c982504959e6f7f3be69f66273cb8293f5ff2589272bf26313de7322a6b3659f153a5ec18605b2fdb7438c01012faaeb61c0599a76f3b9acbf1c80229b3e32340e5b10073ef31df52331350eaec9d8dc5bc7ecfa71612ed5dd0503f73c08daf2e47509faa0e4243197d49381a9ef532509f21454c93b01de1ef40ddc3710d7bd20b149f3b5ab455c9af719552c620d4ceea0062e662ae612a777f7f9d5cf1ad3a774b0dd067d2eca858592a53ba8977bcf6cc954aea1a211eb5417879fdd661be26ef9ebac7b2d3accaa9914a213cf2b2c7db3f7bd549b7f1934562f4365f72fb7b97b91a5f66a40706560432789fe61e685c9cd70cdfdd7a0148e948a36e1311335f19a6a3c1d10c3b2cada61c3294d71f6b0902ca13958b71d1e69bf468988dfd9d8d1aa677d88adb6009f5515fdb8318a129e4bc6d10df57f7b0f4684b339c3a0b81f3b7cad6af7964ec2b34dedae4deacb1d2b21159ad23c4d336c4a1b878867e20af70e0c90e32d95d294967cb1d57d8ca2836edddf232da6917fe528e1a5282057f3bf7be369c55a3848fd5f79e47f960f3d69737e124e2cb24f83afbc3d548ee198a7169a8df42681d52b544839313e18df383b43941332955a5f9e2f59031a1128b366518554b12752a636f051b2bc64dc4735ad2c7caa9aa0394b38265d7ffc48f4eb46c859e95269f7c61274862db52e832e8c2d2fd0687461ce627f017065f9fb9e3ebe75a760fa84c2266ba1d4612ced5eda0267477b883cab72c35a21af482017ff3e651331577628fb892291c05a28566945c7e8f83964194bbd88791424dea3edc7e0e6d66c7af2e016604d07ade38009e94c00ec778f0e0093b3f611963dbbe58b46ed9ca606422b84f6c6c853a95f27c2cc244399fe89306a5e588a4ed30fcf03c21b3add59bc66500dfac51b074f8122e97469fc78ce11187e07d664359e8ea343b7302b2c5f8cc6f419fea83c9da988dff7927b76ae38ac102b099295017672cf49d788d8bdbbca906a381077b816e979e0bfb9342a4ae1a58698230070aa32cabff464207e101d441473406ada3232dc19184988d88d38c151e96b850d43e83ee0a2db7d7416501d3e48ef1ea50e226b5bd096431f8b3a425805ade814688648d1ad4be4777e9bfa0f3f70257261d3da27fb5a0745f24d847467c6acecdca1f1f616405729c49ed4beeb41d89e71eeece74eee5d5964bb26bb6f7918e35e7de470ce690539726cdebf2cedcfc653408de2eb24d3d03e97b63843a36b072ea40efe96f896af832c0cd944ad4207ad694e53ef946a09d1099805969b7a1cdb1896676a102f9ac325ebb8100ad4aab14fe7c5bc6ae81906b97d1798df9a729ebc822e7d73acfef0ebc5b4d861d8278bd45017d64e01efeac73d3c6b712a1daccd328e0f48eec7258d583e389da8b67520c94cce8cc1949baccd611a6a2394b3b439fe74d9f19e862843eb2a3dbeacc4640dd83bfdfc5f9bf340ea1a7396d0b7e74eb5a6578124d2de03bc3e605d7f86bd91871d0c96cc2786d43be8efc79de4cdc2490de41f94c4cdf7983b39c1d36f3adf6a5abfd0da711f12642bb6fffd08a70e18a3c9532028846b228430a789d04d1a0b441560c8e9e311eaa8f6532edd36a2bb63b9e97b202929716095745c7a57f52e6dd935080e263053808a948d06804dc0c8b702ec9f2f485a058f24ab9cacf56a3df8e3f8a942f7a153a5020a878d121567dd77384323fd2e5bc1a4f58717981962623d86887223f4f1082a54f117d80622e5837627e37b3618730ef8490c4960834410685b2d3fafe8f50efb9979eb4b1e05a77bfa50fdd18c7e911d9afd2255a7b0dcb6a1dcc0ad32c3f90d7fe5df2f12777a03209fecdb4593a387c276b3b2eb3a1083bf9aa01204e6c6a44d16cc0a12b5e85e599186395720798471654c6ff88275c676b90d0850c8e6b9288360eac99886c349e66891eeaa5d279fe39258676d13efb1139625dbc68e4d3f6fc0276d0a296803c6ac33ee8b8210243b901bc5b9b33f53edeb84aa9c272796401e701d1fd346ef2c8323f68f044c2950f3ca99f9cacc9d9763975deee437963357c35cf2e1987537cdecdd767c1a79aaf71fb3841188a4b4a1ed36250ff2a8969489313561f2d768ae3194f3ed4aacca17365bb3d94de021e2a8bcaad912fe84cff0b0695d896b8ff08572386d825b692466f6f5f990ec7468e376405fdab5dbfa017b1202c0117957a4147ba31a931d3a4cda2c28b02088c4102efb367fa42c0ab58e275c27da405fe4b6a57bdd9959b997e47c7e710419fbb18d611ec197aeaa7e55c6e8ed8c0124ef32d226064ac587f0b8ae688fe3e294925ccdc252cf6424a655d3ce5c6c7f53929cd2ca7a29d49a5edd09dad421e6fb514f578c1901f74366805b9e2b829dad0e0edc6a8d81485e66dacf6565eea5999a4650d9ccb525c52d8750dafd288f7af616be3a4b39041de350c2445b43c982a820b88b2c7adaf8c9f24c997c0557b0c6c4707d74b9fb5bd2869081eacc4a2de061df9ff58e4a9d36b15ee4bd2683dbbe97bc2ba18efb1a26c6035ba2e36cb007120fd905e109fe5b0b2dddb3ba84d60929c22d6d2e5436b49a84bc44ddf13cd85421c515711078e08491427f290f4e68cad47c1e60de4ea867e2f5bb7b5ed937ca46d6eb5c6a325abfbbe4294f93d2f417331754a22dd252afb9a3dd3a1d6b8ecf99964367ee08c25adc0d57c19bf6ad608c58a4879946d8b8a7a88b03ed487cc47cb673fdb492635f947df3e88d9809166afd3cb92393355cc15652dced1171a4832d0c1e68282f7bd675d0192c673e72caf7b897ada4df005541e6e1cc3bf0c9ef141ac74e5e6420161b26963058f43c6f8178b06c0cfde46702a2bcb1904fc25acfb9e5db3f6b099f2d35657d72bf7d0376529acb191b5d142f899e5f402d93ff3c3927d0f402d8902793649b15a0415812eae8a5d387b467d31a18d4c3aaf09a2d401f12f2402a47436d2d4d00edc8f0690bf117265f135c6fdf0d5f0ef27f03fb5a59a7ccb4996c8aea460a8b2f249c4cbd44052ca352c3fa0301a9e0e6bb107b6e055d5c48bcc78a3ce6dec78c2b6adaec5d4f855e9292975c1da66bfd8ebd3d91e297110220b69440215d65b574c69ab611af45865f0647e9721fda25778b2e31a2a214e6cf653670c8b179ffab49661386eced490a76690df3b1c060da94988da965a9ca45d83a5c3a2458c90ebcb2e968d99e73d53a7948e1f67b11346abb4d02947539e271fabae9ccd42a77ea0a61194a3e67bdf0a1b6b816f7a77d2c7fdbab57f25bf3cec54136457d327bc2544876b9823889d542410ffa81c9c07c601e54db8c39cfb412da08f6f9ed9af4b8a009f845a5075c46b8aed401dc1bcfa7050668eb9a9c9208cf64df58dc182e779608af99e41c914151cf59422ba9a8eeedb59fb16a49ec3cc054acfc631630578d0cfb33967c39579d2696056dbe0f9d8fe84bbd82c26249bf0b167b240344fa8788a7755f3f2e8d1c2879f411e8e8f4b643dc190d7fbf86d23f5f3ec8df5e9b4215ce79831d79aa88c3072c3b82a564bed3051a613511907f08439c3784a405311060ac48496f014a283ec5d5e1199e00251121f98d84fcafee8cd38679b21f1a9f74af9d89be20511373409c45c60194198c6c8b22ad00f58fcc8a8c95d10522e381a4f5bf34175c5fa31107b082175f7f216518b401eff5f18b528db5f3b8161641e2aea6bd46b29574a40d52bd178977fd012107b369c93c17803f3ef237ead8238083e1986557715a82b144125a13037b254da6fc16f02e89d7c5ef6ae1761e2c960867a2d8ddb2fda470f340eb2b61753928dd9a5f95081d10dfb94b256d5e5b8e5136f24469bfa09a62a8f51cd7d8e9d0a6f90dcaa83dda2258440980fe0d296c1fb80e702e7c2536559cfe1fd2cc0d099125fe11ea9800369e813e8a1154c4bad4befd4b3491acbb6336a4e1ca98079cc13cfb9f02da5c061f7c74f8fee48a568b125c7a0d54b77767af00a2f2083f120239b60c21c32633b36021b186aa4fa6bc11f31beec8ee7233e5f40e5d301a013d32b43f91496693b58d2ef248f8b7592b922e3d67b54b0526a3a8a6fd933caf712121873647d61d04f15ddad32d645af4f3298d808c824e9298f756db318eaa8d1cedbcc30488ada55a8a34edc246ffdb129d648f3bc97bb7248ed1d13b42cbca78758488fb03ffe9b813fe6c403fdf6bd9c3b88562bd9ed0438cf4bd96ed9503331a7bdf52239b85dbebda11f3fa891d820175a9c27aa129e4ab86aa1ecb5dd7b30ac445463994b6c236f388e8d9f9b25616d350b1f0b82cd115273df797e1aa7ab5b595e2a514268c8c1d24058c18e0427423c84aa93c7ecfc03a13d5cb7fc2e4b7ee588d2ed0ccad42180a1b2da95ae039ddc4948631e9435b9ffbb0b7605dc7e151d3bbfa12c074a73884d05958b3229bd94b82acad361425a1d6295303af2201d61f92070632237ebbf55c92ed0da4090b57fb746bd92ac3c3cab0399e95b08ce5450139c063d963c26921aae79ea8b51a3820678fd5f5d153ee623a1cf26738b1453011e24098adf61235fe883ca286d3fddec4b18742af46bbad08031bbca4815aaec1c1f0230119facb11f2f667d0b665344f71db0168ec62a1e08ca701d432a7f89eac502b471edac5c93a9a78716775544b99cb382c0e35ba7b29d5fcb6844f1b63daf1ae3d9b02832f482ba017f982a7f3ee6ee941d341bb114f706b0652ab009b4e4c909a8189f7a97c4a8c637061c317a4cbd856fe73dd6b530ad62b132c85a3db802bb48ea88df41daa7ad4c072ea6749a1124c88c2bad5551629b0f20d04d28122237601d73979f7a203a2fa4bfac69fd5779f8b80953cc96e29f092820659e8f976522333fd7376af927c8ecd6c7ea01c696d9ada2844a5ba3e688ccca042e51d0c2fa833b84616c50cf04c0e5267b2fd58b275f588a2a46bc98eb68c0ea9185f143b52c6c2d2fa762bd775797997bcb8b7b2334dd638367b8856f958f525862d85f6c0e2c3b58fd00b3cecd2244585ca28c25afdf6d11dd10c163e8cc474b62fc46fa3a56a40b7fbe5cce8f05c658129bdbb2b84458e42ddc1eece0fe09d3c3d49d5725f25acdca965c2d2cd7948d4bed2e4c6cd48f2b6fac0ce9783bae2acae6a08b17ba1e8a922a1812cc64c716b03b6a3ddee4415624b26bc54868507e6e4bd663e9695d7d3c71ecfadf3947b871e4fbecbbb1350968ca2e696f38ba6a155402ceb3d93e62bea878f9ba474c1b567978cfee1c1d067d24b66bc3c5d74d27efb0f086c031186346c990e06f54281c6bd41797bfc87a0fb6ee1771caf8badc128a6ee8a7de0c43e5a4cd241c24f9b43665bfd1577e218142b5e906d678cb379f5fbc290f457fb5daa443251b1001b063622e572d5dc94415ee0b0f24cb327a6b7d406d119b644d46982906248d187710992deed678af77a8428727cf176ccd0ccdfc5b9c99cb154303759680353e43b248e1ec0841bcb0dded76225c3e9c591554df037c3f05a04b03a9dd5b44d742acfeeeaf75e8f6d1927337e38a421bcbe67daaa302f3b8652caa05b5b9ff84380ffc9bf6ee4cba69bd72fa5704e610e53e821efe9954085ec99b6d39057e68351f70c1841b67798a58031979124dfb411ff2f7297c75ef81bf2b583c1cf959000fbfc92f1f7089e9e2928142c0b3dd3d73c11aef158f2b403ebe02dabc30a1efafbefbc4bd44f0df15ebb3b123f5fa76d63ef1059fe149a06d3ce45878466f70441021233e323fb843e7bba9e168af6fc9e57abddb5efc944ab5d2a8583e5234281de19b3c1710ddf7b178e758ea5d45cd5adbb3bde28ac11772a0cc829a3264749c2f1dcc1de8e0fddc90561a8c8085d387462855d11b7d74ac0a83c84e398c945cdfe00a0fc4fd3d3bec6fd85b7a4c8b39d82152a1214bd19e0f6f278e1ec5140a509dd1fbdf7986cf684e499b259af0eeba598f5ea0c3f68da667599fb51164916e524a1979ee035b7ba2397bcab40a7c3e944f7d14aa801202dd7fc4bacdffe11bdeabf26dd21607ad755c44f5795eff4b2d5dbd790f9958e5f1edda9ab2926d2ee693f86293378f3f31be3077064e471066f5d502d2f52b9dc0f8cc457d4d5eba5461dffd98125d4c10b24748a12a1d054677a75d378d0a4b80bcb316988d291f55a10e2d9877e7db4f6ab2e6d7c632ae72b241c4114dde9b9224682253c537f41bfefb9cbc0f4f6bc8bf592df01f2304d61f83659b6a48baf8875bbd4f54b3e1f848af9e6c06ebd74eeaf9d2abd615624b9d5248e5359b244b0aaa2603aedd72cc43673c052337b513f5f7505f5b84805b0116800a262b728838ed6214cd2c65cbb20ad435720e311c007e678c6ba959fb12d1bd713a97f3cfb50bfcb7f3c54c95052c06bc0b813130854a8545214e6058e5fa4ca3093b302d176c8a22d9e0fff2d3df1cbc01b9488fa91be8fcbfeec6a69138d252d9d78485c5b6f21aaba58fd3cbded2721bdce4987f0010630579ceea11f212a30bd6bd332b248bd10254aeb2d2b10dad43d69da14f87c65b411f6a89299fcdfb65a3e81e171e21d2f7f2d6237ffab99d9a6a0758e9d56bd98ae9ace4d948c39d55c900adbc7052ca2c7be3944916d5a22d5249ceb305fcf469cabb3db679b0c70225f79c62ee90cc23c26b40011a2fc31e9121d11c463ead90488cdebdd4862508cd4ef654d07c2e46088d4d96c0bc54cb2d131aae6e4a9a567df8bb2295e8417f3f7b6ecb4b8adbf53bc229d9ee97403716311d38ab02bf30415246d76de8cdd4c0719c13be9ab773402315b8d20634f636d80a209f6d4ec4d0f7a00b6fad2e2bebc1407dddd183b25819a75f592e2e91ada69b83c824ce57170409524ae0e313808592d0fe49955479e1c011aa3664f70748ee2ce1e38ce834b50211028aecab27bba0e07dc9f01cf96e6e9e9ecf3e7030b96a413673c719472670f4a766707dd2122badf6dec8b9a4957a3bcc98c4a336104815b328253cd0248698ce8c2595ebba0e6e075e9daab8d85ecd1398d09faae9c0669eb65ccecd93361a70c8aea56dd317a26910829a3ec260140433af5d2d306e4f644294344310e84f8c80443b4f4fa36db1a87192cdeaa35d6d866c06e8405908f3730bc8c6dcf44c08672049ecd067d8d3da86444594b6b4360ac2fd5b460568d8c85ce77f1cafceeab82ffd681c0e3b4dbd9b251110adbcd74218446a04ba3fc91ed154345d3c3662642141086b82d888fcb051e2ae9839da579ac86becd2e2f850dabcf8ca2135ed27bfa39a16d6194322485de1260e0b1b0ac553797430630b8893b9bc740571fd4fc58cccc840319a8ed80420290dca37509fda4b50dd37ea3e4398f9860a66668e04e3c201cff8b065ce81e2aace5559388642c4483ae660e35bb25ea85544638e54699d9c9a015e4673fbd6798e5639c411b3911d3745d0c46be84fcc4d1c784fab242c36e065d949164cc8da9e8bfef9104269a30691c56b99586d26636b788e1f98f77394ac725ba8fed8eec56fc6b639896926da05c6e91751118af3c069b78544e56ae580649edf782991064b9738811b5b7ce9c98f1690ccb674f6359611d20d64b80b0ba92d4a51926edff14a5e32ec576551df8e96f18bab011b26eb3af2e410afb36872bad83958a8fa8b2ee3b094e4d62e2dd24f454e663a8c8e2c849e1998f3261c6aa5b8aac74019eea5be1ebcdcfca9dd043d8382fac79eb1c973dfb5e2929f65c6838659fd3ca6e55ba8d61a604e843a609ef5a4fa4d1a4f83b83e6019879107fefc5a9bdf23f0593a00161e1bfa77a913a04ce969fe7422c47fce2d4d0f19887cbf4538ca9b87fdf5024b1a31c97460b1014696ae7330763f652d24c7c450ca6e21e5546728955763b071a3b1d60b6f4517439a85011036feb2702b85ad2076f2030ffe9a375c2be8ebd6b121e421fcbbdb63dc2cdf47915a4b6a9fc960b3f1acdee4c866e978eba9ee75db611498442340662f45bcb829bd6126f23b9dd331a267c86f6330983dc5fba90b94077c3eb516f9bcc060e8caac3385baafb07873c9c165a5ebd29d6bf21a3d9da3da5e77c5c8582276c0f14c23e070ad45bbd9a8e93e1d9036dfc4b702005afb2f1955c96fa2d4aad42924b471da739ed58793e3e3f942751cef35472e99207fba4e43997865c0e834fd7855eb9f07431527192cbb12370bc5f5ec7a7200562fac680a4b611bcbd1caa2ab8a7f2155d4335d781573a07c499045cd78ffdfa6c495a5d6af8ec60f17c4ecbf79d2390c260603d293a79c4db7beeaed16791066dd623f1b807d19ff465e4bbca25566206450c72d9bcde8803522cfc34c70b8820db748b941130055d06f749a9198f114da673416ce9ed6c1b8c71bb189a7972c4030d77d720c00ee167d8dc191ffe20a3107310aa0ab0e0fc095374990b16205d01d0f591d0d6d16f6d86ecf14cd1a6e59c2ec1b0c5a5bcd713400e1ac161c88e2f8d41bea4e8f91e60def44cf298f8923db86a95ccf27b3477450564b6f7aa1bcdc9cc7f1f1209927d07ee1f5edc0160ab91350dec91fedef209d04b1b48a4df41c87f912e8042695e9ff08833a5788667071984c907f47123a24f2156c20c2507d99ba1ba1519bda31b14307a7fde5c5272ff41fb95862ce29cf851abd52831692c41063827764878f8db7e97b73f4c86b7380321b5e140cb322f026ea97b7757b689f1f76078f3acdea1f53f7fffe46542896a90d8953b55b3bb3d9ba526de65c7f6fc1cd73c5ff8f288b1ec137b714a44f51eca50e31e1b80046faddeabce0f336de14376d9288e4b49910d7d0118289891298ddef208c2e9fffc50c107ef1e59262f344d761f62b6a5904ab199baca1cbbe448b091d6927f745bf4e71fcbe0bdd428a1cb409a2d595045e2e24ebe53ba66584b7db9c6657d5e1a09a4469289ad7febaa1778c3fa1fec19b7120f7d3f23ef7a0aec0e2c0fe7bfd773c9d5a0f5eed6befdb933bcd6ec9727033eed9c9d0ed6fc839ad9592642a45b400f71cefaa296ff8904287ff75230633636f03b6ca4322aea3e26b17723dc28a982ad386c4e2974ff470cac616dd2e33fd1fd6cb3e8706f94f0a66a26df30f91f5b4272012f2d37e14c84c57d5d9740b893d055085931832305c375522bf0e06e82d23c3d3653ceebebaaf60bb3fe234be57b86b55e11240df487935baae3f6a52f6dd83786c019c42f47d2d4c96c137eacd5b3fc2284a0fb0dba6969df4fa592ceb2f4cb770e898d50170fb9a4bceb7756f797d6fda0c090105920410d8a6a4d0ff0b32f423f79ec17e62b641eb0b2143e6384b19322398894eda53cb8021df703cacfac6741fa67a04eb08a5f69cdb0f406d2f80a08c74477665f65a21631a3ddd732274549c6765662c29ca6e325096e5224dcd9b838e028526088b4927391f6f313ad7c4c00abed1e6d8d42df95543f32adc60d82c27c52b4aa464b9b0355a291ac5888d1af158fd085efa1fe1a82f0d5ad4c0ea6cf0182697c15a6f3f0093ff8c416c1bd24607e4fd9086d3e4295ecaf5d4206a79e333f8fde95c95bf96c9f74061b059b9c58adc9de872aa07c95cd79bd3996f24b57aa57199eeff322b25f0cc2ce03d86cf946abae1b7714214d180a5c2f743333c85eb8ea7a793a765af85b2b21a41aa683cd1ee9f12c5b3cca565d9d60758b8378b007195992eb431cb615a7711718e3b51122a1b626928611c8a4563a5819c11f1af2d68460a09899c24b3d3330b9a44af403363ee32a1e9a10546a5e8fdf94b4d8cb60386d161bcdda8638bde967139d2450141a7b70f3f1fd7deacf3b20d172da8f53dc619dc0cfbe6c2074bb72fc589da35365afce121e35f54b87335f0f800cc893df6e11a4a57741b3bc22fd00fb6e29a6ffb1944bca608d40f5edb6e2f9e20622da15c6609f7ca440802d69b7653f3753f83d6dea97b6c9498079afcee344647d1b2e9a6240a9c665121cd894f79bc15d576a56a27863575c71a36be64a29250a8f1c8b3368afa585ab4a275d6a38a73ffd290d65f5171f016c000687e11261046be23ba559e60ca804b3fc5c88c176bac35338aaed7cf99152976e73f74daabe1c1463b163639ebb95c355d4e2105f9a5d48843dcd29d823d02c430c83fd87c6dde67328c4db9e76cc57a1bca8ef1ae6282b1306eb5eb809347aa23bf0237a34b0e6c40c003f7874b43c640fd669894a1b3b739f79b12c93025e85255c77fb5439d9a3079e4c176f939aa4879a1029444e833e7cceea0fe50352e51fec531c51fdfd0e19042783882e483666a3fab623bc7e0460e6990ead6d015bad1d2b0ff9fc7db5a49b1c09295e3bb1270fd47ca820aff02dff9bf92a438deb62c8d13299921ce284418dac5c393ade27e1202e874e23631787d6c07733bb128c0f63468749577b2e74dafaedca4516660a272d1a1b79089f403dc9518bf5108938e2542311f25d3312ff0a079f24df0a63bc39a9d3e2b662978127c7b87ef1fc18c459e3d78eec2f21e3ef8efeb7b6d36758d633b71b3f8fe929b2b9bdc949bc39038b39c43835a10de124e8191e24a42378f6490401c48233a8bfc859d783c4645d36ba4e50b4e4d0a01df86c99e98846313eda0aa564f44982d85f52ff1a6ded2ca867efb0dde71abfde7ce8271b1badf938f56678d1d5826bea6d993fa4e8093bdd5fa767e63ba6de281691b7b2afac86b9880f0b62110f92a72d9128442b84ef00e6fbacd555b9738c6b2ce8d405df195392e110783f060ba565a4d7c3702d076ffabedd88b3014d69d51c8d479c9f02fe575654b6bdbaa002d1eccf7133b8ec8aaa3a3df9efc655dcd26f7e5ee9b75eec26a0500a9e3b48403e188a24823eb3dd1a299c113ae70a37ed80b48c77d1a5f84c04b341c0f0058a6579dbecb08434c7b4e5228c625a3c4f4e20a8b1a5177da313f9cc4d726154a10728bc7d1b7a406e35bf16126d29f0761cb43afd3e4031512214a7db4b9319602a873ebae9183019f1621822927cb371c91a11c23e4c33da4aac207f74365ae1e238a4ef04efa8554b6c939200d4905371186e8af8e436d3e35990384a3f3679143a85c4626d69a3a871d787bcc1d7dc57dcdbfb24ce94da17908a740b6c75fb943e5271d7c6a7e2b884b60eb094fa166f54d4e518d578b8db3c80eb07682f30bdd1161e1a15e1ff4eb0da3c8980367c4ae2a4d8576769211b0a324ab55dab75820badd7d55d6526e544d280d3bca90d7d9a13427b8739b72a80f17606ea2135db3b6d64a65b360b25bc6fcc1aa58cf38f05bc4bb4d4fa8142f9aa7361231a5e9dec359b0a39682e5e13ec5d9d9fd1aa8ddc8d72deee43bc4b007ddd3c11bfbebd2dcda19d415cdc14c5c57b8af2a9fe9166b70adc2d70b6053cdeff4ba0c8f8c7454eeae7f873d0aef1fc7ed11fdedaca618f648dd97a7791074e5aab4209a12dcc86954e1c68a20e0856ab05be32dd931257a460edd5d8bef99d2daf04bee52db1288bbc5e02e90ff2bea165dccb964beac91f69763539c56f6a2d7a318901cdfcd0400201ce997a5a68451a91d3de174addb663a9063f050129bda5f4f7dfccce24b97a2e3f0a639fb2811652fe7420b91144257bd8ccf8173ae99f59652f256ea0de87fbce549bcf6f226ea91d1012356d489dc333bf4d5b1710a5ab86be08a81fc59f89c24cde04076bfd5bc9f8c7ee79ce9462824d01f1fffa212f782090a3224d17b2729b7e2498bde7864eaeb4993065496893eb767ca20cde851db7d4f4a0bb1ba423cda61e79ac529569709c47073921bef2cf80a0ba6fff94bdfa7dcafdeed00b360d45533565e9d0911590f6489ca7d54d27c695c9e1f1ee794bc35b20487fbd11c2057b1ff5e83420fdee677c5cbdae09650e4a716d49bb96e2439706fe22ca83be3b4f03dd31c34b0580fa82cbabe7f014f6185129c9028b4cd4cf664f6145ec4624c61c9fb1da867eb9295ad391943fec1ee3225ed1abc807da743104f07c0a71d831fb8de38b193c87891648e99bfdfde83130e0b0a4087088cb832387e024db70a970aac4f5168eb5840715cb3579d554b1c73e1a0d8c036128d0e939909f7a239ca57b562680092c83c1478a8feb6765aa101c961101eccc134d016183e650d61814f9161754a7747f8b57d8ce644b13e3157ec62606b238960038483b17d7b2de8169a06f36cf783173cc16e3383afc608b38ad4651599754bc0fa4a9368fcec8e87be5c7c2e4fbf61688ff9de458a019ed501687be74d121a72cc8a51cdd306f4b95c24699d309ec4f813cb8afa7fd6d228e51da459f52f79bbaf600a529d72a0741ca52e4c22fc2a1c0bf86d006627621cad67487c22eaf820bf3efade74f392c1fe67ce6cd053f8ac8124b8702ff3bdf18e1342ee357f075ccc8c52b3a13281d2e83f217298ab8592f8ee6549ce61cfb8ee4e475d69371a7742064ca3c3205eb85a18a636ecf6b9f39450c08d7c63bb969779e451d4ab782cebcf85ad0895c7a55f662d4cf538b356302504bf6161dc09e1b3c441da4fe2147cf7b14c9120c799699f56f485270ba6f2c079ca456a6960e9f10fc81992e042f31df3c9a9d224c96cfd54c7d09d37fe05cd6d061c5090a2f0be6b08b171ce7955e1ad13e6a7362ad2c7e361a100f5b7b2a5354293a1b5679c907eb4ebec91265c24ec6f58a6a12644ea8c3eddf83891bd54355ab45714bb176cd41be8dd683193eee824707d00ae0a31c786df9d2347b6fcd838f9e2ef7ca32cbaaed74f98db412aee1b18e771b1785f5117458574e324c0285fda13ad82b457dc3634ee0f7d83bfc8b3d375c2616a95656566bfefad459796e7702b371bfca29c744369f9bad4e6073736255e7d2cbef38f768baf705a7a6a6b451aff4c5bcb8660cab9bf24a15978f8b8150239837e8003d48e1c24899d7f1025f78417aea23eb7386e042fc28786df663e4904ba4dab6b85c74b72f2d04d6cb90ec232cb539f483fb9c1405313303ba349b7bc75890d152038f599e384f68de1a370aa793d7aa778bdfa29fc837b41cc657e1a24421a5e94e913b5cb1f175bc43b1d4c3fcc3c627693f1db931dcf0b5f17efc2fe48bcfa3555fbfbcb76cc8a2ce077b00e942ca2af52b1a638e6c5b29694a9a145f6c2abcefe4e4b606b8348b4d08c8343c9734674c3bffb61c0528e08350d2fbd94bf0a87634d0dd5ba1db0a23302fc8585b16be696358541800fd8b2e88e9bc88c3831e132e81979583191a23efed99bd1f68f84e748de05317e42cb3fc933d545b63530e9682cadd171b759cfce69eca5cf534c0ee2de7ff6db4c2ba814feb79d12888eb7a87aed6d274998c2e4a214930e5d161869565ada46937b8b9d33a52eedd2a073690e07286cb10d254d00bf060f03ad69e7587377046ee40e485121419b9d5e2faf1333f3d3322a00553da968bb9df891f5806e387fb94ef5f9950fbd2441fa2384c170e37779861f79fa7d47a48a53dc58da335ace24b24d0f6d4a25d413228e0f2aebfc4c5107396eec57420118aeebd867c478cf7f2e9020bbb860802e5e74b552a44e2a4a16dff9ed5578a70d3415070bedc648781584834a0f1932b3281822c8631ff154a5c7e7e0ab204cc4439a58e2154491b7b26c25ebdefed55a8c6c96b3aa60009696e24d5a9f27c3c3e6ff263f425f83b55830c521155599e004e432adb0c4880f6a94e85989fda2bfaafdd7ba91ee8b876ef823da023a5b4afad9202764b40a1ed5cad3322e32d550a0315849c9d2fcc57d078e319e9b497242f1a8699f234b9bb0c9542b020a23152b909729c1c95b289aea48376e2f0082ee39a809be1a50aaa32a0b3b854536436550e988dfee3500c1ea019c30ec048dd6eefa39e554d19a4fd6a17f7321957486efe16eb1fb7ed37c12fdd5096118b3e26f298a2f3d09134857ee4d8251dfbd092724f8e06e47f0ff64bdffddcdac3e202e397f8df1198247b7f1e9ebe6e3e7e0c0cd0657eac653ede11f11282c8896032fe3077ba62aaa1c7886e4ef787429e739873aba357b1c91bb9116d0268f2bba44f293c5547780ede70cc5bc7605baf6825448268bef1a98c8c7893925083a98a181db294f7c63137887630ff7ae06a182a0694ba10372f93bbc4190299220a69ca2ad0ba1e98240608df251dc003cbe20a4ecf6030ae02ba77ef9d411f0cf295982a8243b40b323a616089981eedc557efac773df807e022373921308e6a1d7a9876d2489367f699a7d0d3b06f945c8f05d12c28337d56d22c1544f1bc8746d330cbee37d95fe3d92713a1b778ac921cd4f721ad11af374448092e3a58a1fb4e116a1af6005fbc65867c9d0276ff3cf3c812cc920f745b4d9d68ff84d143840748340c049f68f01d0b6af81db1520687224b98fbfd10163b90808bdf6df10bc6870b0bccdf944866bdfaf2b51ef31ce575ab3d5917482bbfa617284467d8582ed34f6ded5df6fc85647ddacfb75bc3561a982c9d99f595e4f9e5870c66009c763027e3203edc761d4024147d64f604a4da64996aedbb645470f89ca4fcf68df3d02150f95be9fa21a09743c98a3eaaae945193ebc08d73a356fd41066dfe564bcb3a387321b667cfcaa8f591d24ae455b51ffdb0a3941c0ae9821932415aa33d28cfd06b8cd297f00888493246a8ddf86ec533d6b93f09cede1d72a91b6171f877043574d0b4374da0a7665e223422930a9c33ad04eb6980f87f8d1a75367b820b93a43318660800e443c68c4a6993738f5c6bc894f05f2c8e908ff48b23d1fb00d31b2dbf5c3dfcab3546dddde00d3296a8cda3556b2f0683706c08e99df789cda9843c9b056681daf240336af6aedb69e0b8ca80354c054ef41fce93ded86c7cb9077c33852e27871fb6048c51753fafd84663d3dc245671cd73c197cc5d55d4a58ad1ec411f52ff1e9920d8871161cb679ec81c8dac4755b1d312f3f6df55417f9406d4ecc9435105a1489ef0e4dbd70bcaddc4bfdbcb4cc11eb2c463a49b4fcae560920dd266b14a8ef108a01ffa15ebfafb71dcc4d82453b8db9a8018a460924ab9fe14b1820133a1f7874d2c65a23d58d8942682e3d0a7f273b01395c9e907423be22115fb3767df4fd5703c6c79133dc14b6429d6692ab4adc0ad74df5211455517b4c2af0aa357d264d1a189f381f1476bb3f79309e46139b27747502d8c7c7e056a27b2e497f1b9404dd5ed577e779cd7909d7ec2785bccea88842af3a5da3dd386b3b5afb6d01a78471575fd5a34499c11183f364ee9dd6ee75031e55091e1d2a395f9f50ecdfbab63860ed5d71a9095728a10d12ff7b251ec839d20ad1127b9b9e85e98d4b3e66b85a6cec4c0fec168d7bfc8159db3e2203b35e013befbc97833f91084ec0f3e60941a979118d6cce898a6bcc20e2a98c0debf29b38697f94cec8d9c990b81904743d52db48730722471d0f6d5d3b9126b09ff3d126547b88d11c8082b7d5e122a9ce8b0c813de2bd67a6ffd3e2a956e0338e9d97941ac2d5a296d06050d9da300f30db9f17bf60439a7e8082ac3cff4df7eab1d8f867b00d6e34e9d469f45aef9a09a67ca91c2a3601dbbe500e6f48edfb2074224fe3e71527cad5499b934c2ed78fc19a13994519288d65e694b73b648bf740d988ec00b246840d7a0c5cf30f0a42a36396fae4cdb712510d090107a5405de33edc8ba16039f08058b2e44df0369ae074503a7fdc0ca790c941a1cc4b6dce2613d943967d9e85f34ee26fef0dce1e89f13161e289387d84f8ec8758f17a6104cf3243e00353e8bbfd2e52c5f51749f36428c83627f93b56d007ce83a2abde54a32fe8d1934cb084dfa776d531a93474efeafa2f390a4bdeabce7be10e0309a7ef062e5a794c0855dcdc15571c9809f4690bafcb6814c234cdff913fb2512aa8e6895ad26ef24ad8b77c98eb51edeee7350ccb5ee0b59e7b1965da3be222d210365e87b6089a21c282edc4ef37c2a03d8436df1c8bb7e3b2d3c938ce3c6d912e8461973e5130b5352b92ac4585c1f56665bea1f40fc6199d339145a5dd325258e86254a6434888828d8146f55ebdbe479fabd698c147b54fad218940593f95688eae1cb464f0048b1367a159eff742d5cf2f2ee93f4aab288e5ce791b02d71bb9b99c3aac6e71036432b819b60dee499d8b20a049f24c0dc1eb7a141345efc87ea3c9e413c795721217734e3ed62b086012bd5f53c17513f0f454e149c148b50d2c38ffe22a2914571ce7b4089bae5af60f2d379c113f8a6deee45886d457ea642280ec6e2ddbb6123ddb78b8357b38a5b3b8b46f2f6773e4eb07efacbcaeca65696ee100736cc1611216ee180606cd0a23f69a6c15c5afe44096ccc8cad6a4f2f12d890a1c499b68c6b15e8b429b63a95d8a93f61f1d837036d5a3608d602b33ed69ec8b7fc17d4af6fb22d24e042e21a8d99043f44051a3a41546ddcece7fb56569017b3abde768b2bd28b5769ea7aa30f144d302177ca565d0b3a9b8f348ddd5ca314b7e63af33307f4b95a593367b85d8f6c895baae7e3751ed811b73cdfd3872490cb2487d78e5d684f27304c206dc24d203140f172bb293c93b1ab61d4255349f751e8eb3de37763aa4ee2c18b6c469af04dcd8f1eacfeb2f915e2b8f4d84c0e950be0ec0e7926c8719c5f9cc3e367029d9b3335c07f4ca80a759293361db48e9f88e13606c557185441e269d1a1b428bec9afae2e8c5a7fcd96a534bf68581565fd32a00c94b289423523d375dd7fc7edd20c97b6a7b4fb675e04d91d6b5a3075ddb99e05d7b7b042ff24776f78a4cab9fa74a84686f85ac2e8dcb3ea370a8ae665545f8353887573816773f423adddd00f407cd81f1f3f43987cc8b507166c7c4bde4424ebeaf4f5b2d482410a75a6e6bcf87c1f3d2e3ea49a56cb6895879d632b2e72c41d9738c08cb99ee455e7cd03e424873911c17969b866f752fa991e485d98abee302f2d38e15ab76a013cbc42e0d6ae97f601f76a2b27f5751807260341e36a20431071a969ab9fe9ca59d13131e2e15ef9b7cf7123f4e92fc1f3e4f2d4ede9ed0bedcb67adb945ff0aebc0051d8e934101659f9c7a195021095f35334be6b718f1260e10a7060ce35c3c943b7aa087c6543ed4a4258e00c5391eac2f4587f53239f035699e225e7a2e2f9ebd957b5355f49343d433c115825f024e32d2d0b7cb74107785d6ae2acd19200a1099699a12431d4f846425b319d159b5cd0d4035673b710c9728a1489cfd02d0bda53400e9cfaed9672797322e6379c479e342abf636e187ef9de4bd11206af5d9d87d74abc79e2118813f99e8183e19ea9ca618888be7dfa52ce907a1e91161a372d2d082e0da1b52341c46257c5e9e217ff0da9cac4c4de478380ad690eac150f5545fc303ea2fe76d8aa12e98fe4e175a09998181f2d6d8083b85e6c1514bf86abe44235c1d89979dd16847c51a81d7c1fec4f6b7f6e3e9997b06aee2c85356d7c9c646593b8d31b3bbacfb122c85610668d5d19ad4943127ea2039970021cc62b199f9b11b360ba75987d2f9bf952b706b62ef14dd46c15cecc5b179b691ccc5223cfa4a62ab9b64cc78799b03468ab850e3068b9ef9aa395740c6ad6afe45e0dfef2b5c51ec808c2e302ed51304a35c6ac67fd2d5edce6910b9c641078e2c55fdf643f9ae481de8c9bc58722070c25ecfc5bd5fdba7d07bcd72e92bfd704fcf51916681b8d0cd7c3ffc3f3e8dd538c1b33d28180b696050db2c292b8f801b70b73d5989fa8a2fb6ed6e4034d5b39611ea7308a9fc7e9efc25a7c87a5f82ff64d9739b13e67c8b935c18c3416d1d59eb9fad59d085e053d2c3af814d19b32b15d68aed59a50a27573d2c0eface98742aace101905530168b469da9b46abbee5cdcc7ee76b041a2da772cbb0e56b4563117f14a35c2cce05842cd1848adf84f90872a5f6705c73adcab1802c1ad419f23362a713c27182e8085147a7653083504d2ed62634c1df8ab44d0b385bf58b6670ff893b88b21dddde3dd4a25dd33f99b8081d101913c417d602ce0903a287fd63cf54564c8b3e8048affe61baf2346f80a108e1652c2a4fa4aa5eef343db8dd2b7c2b23d564f394fa16bbfd73a8e99994d704a2402c1a8678ee11cca470d4f085f5b6e1188173d56fb876ca170af6c2385c1f169f08191a64f4fbcfb3487361237418649b882a64a8218acb45fa2bbd255a49a72ff1655744bb9a91287b87a2836dad9cd72c424b98b2b15544a6dda2c3c21a4cb20d0722e00dc431ff13a06e62449118ab93d7c1091f4fe62419007e69b2dd21e68c680dce1f9ce3ebc00dcbdd93f9753dd1e384ecba1c302a24fbff13584b3f9c74bf56394cbbb724edb78c41ea2cf48406fe46fda33bca7de8a97816ea9ff8bc6ab1fd284a2a7832920448e075da232341830494ae7cde09f55b1e76e40eb8255f2eb637e6d71d1c349e81ff393ed67bcc02b4dd2e5f2c8e2a33c8aa3a3261310c3827c4eb9139b1e10c0b6cfcd6742c28ea304241aec152c5a60ab14a6977dbc2bb7818307b1531fb597f328ea4d0144fee6f533f9b052e92f5ff58b6da5a9ef681e53edb5aa65b5231daa677da39fa81106d7cc7477359d60b0e03615a73c7a7bb21fca16071d67284f1b091fc7e28fe449997e103c16716182618017c6bf3e8f619a11d68fe24f6554bac7e62ffcfce90e8f6ffd634fd1cb9bdfd2d1f018b50c91be9d3a244e4f4738c9676e6334262727440a840623dce266ab513c7cee93eedfdbe999b752edcf78f912370b0174d9991611826a504164ab4c12af564b549c637ae7cff61891fea2db5175be26e37eb7588393422d7d93075557d02ce5816b43cf50aa8ebcd7f85b2f83784a3561a01fa44165baca50ec16d4af4475ef0be799b6237c123f09164b76538cb375dd3d7f06da33c07aa7301e1b07f4543294353dbea2c4cf21d9812f794c30bc9d5cb2fac7bcffaf130fb39270d91b1525a5579c0a9cf03998486a8897f75e3545938e00e3dc13d4f870f19ecf4c222f5c1259a338b7e0dda043b723059805dc912f9bf663f7f4fdf78dcc560a9361035972625e93abf09a2c003ff3333c6a57dbdb383c4054ee09e098fc6b8889469371b4d92c32647a5536f83b13b0fe369371ccf231c1e4095b5be045db330d7d38994b8841247d7bfc2bc8fd5a477550c539f910cff0669cbf92999006d4153765d2c104d3998d3d86aff4ecd73deed397390dae84a1771377c896ad2cd9d748bf77048c4d2157ded516334dd77be85d024d85cb5bc2ec009ff9f79d6967ae735f78c969b43fbd2c68128bfed47bcd17d4bddcb398f85e5eb772fc2b7fef3fb61f9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密的文章,请联系博主获得阅读权限.&lt;/br&gt;</summary>
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="面经" scheme="https://missionodd.github.io/categories/技术/面经/"/>
    
    
    <category term="面经" scheme="https://missionodd.github.io/tags/面经/"/>
    
    <category term="java" scheme="https://missionodd.github.io/tags/java/"/>
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL| MYSQL优化思路+知识点梳理</title>
    <link href="https://missionodd.github.io/2022/02/14/mysql-notes/"/>
    <id>https://missionodd.github.io/2022/02/14/mysql-notes/</id>
    <published>2022-02-14T05:50:37.000Z</published>
    <updated>2022-03-17T15:44:12.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>多数来自王校长MYSQL系列<br>笔记优点：从调优角度去挖知识</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>调优为主线，进行贯穿，再引申。<br>从mysql初期设计表开始考虑调优，<strong>控制单行数据的大小</strong>。<br>不能像初学者，直接来一个varchar(255)，过于浪费空间。<br>varchar不像char定长，它首先额外存储1或2字节的长度，再存储一个变长的数据。<br>存储就不得不讲B+树。</p><p><strong>B+树是mysql索引数据的存储数据结构</strong>。<br>先以<strong>聚簇索引</strong>为例，以主键进行索引树，非叶子存储索引，叶子存储整行的数据，比如bigint类型自增，除了存储本身8字节整型，还加上一个6字节的向下指针，对于bigint类型主键，非叶子节点的每一条数据需要至少占用14字节，（tips：B-是开区间）比如，ID 1，真正的节点存储格式80 00 00 01，ID 3 为80 00 00 03，这是8字节，指针来说，是6字节。根节点是16kb的内存页，16kb*1024/14约等于1170索引数据，第二层有1170节点，每个节点有1170个ID+指针，那么，第三层就是1170^2，大概1百万叶子节点，叶子节点存储的是所有数据。<br>那么，如果1条mysql数据，没有好好规划它的大小。如果1行有16kb，那么mysql只能存储1百万条数据，就是1个内存页只有1行数据，这是非常恐怖。如果是1行1kb ，那么，1个内存页存储16行，那么，1百多万乘16，可以存储1千6百万，差不多2千万条数据。</p><p>这里，3层B+树出现一个3次IO索引。每次IO索引时间复杂度O(logn)其实就是用了二分查找，这是B+树查询快的原因之一。刚刚讲到，有一个内存页1行数据的IO，这查效率是相对慢，这就涉及到加载内存页的问题，16kb内存页加载出来，这算1次IO。首先，一层16kb内存页加载完成后，再进行二分查找，定位ID范围，然后指向二层，此时，又要加载16kb内存页，在这里边，又要定位ID范围去加载第三层，三层又要加载16kb内存页，再二分查找最终定位数据。当然，1和2层一般回缓存预热，减少查询IO。但是，如果1行16kb，查询多行，IO次数依然较大。<br>控制1行数据大小，这就是B+树的<strong>高扇出性</strong>。</p><p>为什么不用二叉树？不用hash表？B树也不怎么用？<br>B树，<strong>每一个节点都要存储数据</strong>。从根节点开始存储数据，这时候，如果1kb数据，最多15条，再加上16指针，指向16个二层节点，二层节点又16个指针，三层就大概是16的平方，369个叶子。三层B树，撑死就这么多。如果2千万条数据，那么mysql一直IO内存页，再二分查找，非常要命。<br>二叉树呢，原因一样。B树起码是个多叉树，还不如B树。<br>那HashMap呢，在不冲突情况是O(1)，而树的索引，查询是O(logn)。为什么不用hash表？<br>第一点，<strong>不支持模糊查询</strong>，也没有最左匹配原则<br>第二点，<strong>不支持范围查询</strong>，一个个离散hash，太恐怖了。<br>第三点，hash冲突不可避免。</p><p>为什么不用跳表？<br>跳表是一种链表的优化，查询O(logn)。<br>主要是mysql的存储介质是磁盘，链式结构是存放内存。<br>mysql数据是块形式，是16kb内存页，在内存页定位数据。链表是一个个node节点，节点只有1条数据，磁盘IO更多，而且磁盘无法对链表预读。<br>B+树数据分布更均匀，每一条查询速度一样，更平衡稳定。<br>跳表数据分布不均匀，查询数据经过路径长度是不一样的。</p><p>B+树有一个最左前缀原则<br>能够支持模糊查询，比如查找同姓的，王1，王2，王3直接遍历叶子内存页；<br>能够支持范围查询，比如查找ID范围，从1到100直接遍历叶子内存页；</p><p><strong>聚簇索引</strong>，是每一张表都有的主键ID<br><strong>辅助索引</strong>，是自己设的索引，每个辅助索引都有一棵叶子是索引值+主键的树  </p><p><strong>联合索引</strong>，多个字段连起来的索引，如果没有主键ID，可以是辅助索引；</p><p>如何在表里边定义索引？<br>要看字段的随机度，随机度越高，定义为索引的索引效率越高。<br>举个反例，如果存储1000万人，性别只有男女，也就是只有01两种情况，这个字段定位性太差，一下子定位到差不多500万的范围，建议不加，因为加索引优化不大，而且还会增加插入数据时的一个索引负担。<br>如果是日期，随机性很高了，怎么看离散呢，命令show index，然后看cardinality（扣低内了体）的值，接近1，说明离散越高，就适合索引。当然，这最终还是对应我们的业务 来说。</p><p>cardinality的值，多说一下，它是通过采样算法，会实时变化的。</p><p><strong>覆盖索引</strong>，它其实不是索引，它是一种效果，没有树，指查询无需回表的索引。关键在于select的字段，是否都在辅助索引的叶子中。如果是select * ，那它回经历辅助索引三层，然后聚簇索引三层<br>，这个过程就是回表，发送了6次IO，差距就上来了。</p><p>索引前缀：把文本前缀作为索引，增加长文本查询效率。</p><h3 id="Q：什么情况索引失效？"><a href="#Q：什么情况索引失效？" class="headerlink" title="Q：什么情况索引失效？"></a>Q：什么情况索引失效？</h3><p>记忆：LOL+-*/ not null  function convert join<br>Like  不匹配最左前缀的模糊查询，比如，以%开头<br>Or    不匹配最左前缀的Or，or作为condition的连接符，当前后两个条件都是索引不失效，但凡有一个不为索引就会失效。</p><p>Lian联合查询，不匹配最左前缀的and联合查询，ab联合索引，如果不以a为首部作为查询，就会索引失效。</p><p>+-*/ 条件字段加减乘除计算，索引失效，比如，age年龄-1=10，失效。</p><p>not 非不等于，!=，&lt;&gt;，is not，取反集就会失效。</p><p>null 字段is null 和 is not null，不一定失效，索引允许null，但是B+树索引不会存有bull值，比如 age is not null，可以走索引，而且还有优化器可优化。为避免失效，字段尽可能设置not null，如果需表示null，尽量设默认值，使索引完全能够构建到B+树。</p><p>function 对字段使用内置函数，比如dateadd(propName, -1) =2022.1.28，失效。</p><p>convert 字段转换，比如：员工ID是varchar类型，查询用了 id = 12345，这就发生varchar转int，因此，要加上单引号。</p><p>join 连表看情况，如果id类型不一样，那就会失效。</p><p>我是就是我，不一样的版本不一样的我。</p><p>select * from table where A&gt;3。A是辅助索引。<br>mysql5.5，一般是全表扫描，不会用A辅助索引，三次IO。这里考虑了离散读的问题，从辅助索引三次IO，拿到所有ID，再从聚簇索引发生超过三次IO拿数据，至少6次IO，有特别离散的5个ID，就有3 + 1+5+5=11次IO。<br>它有一个阈值衡量，比如小于20w数据或小于总量一半，辅助索引失效，聚集索引进行一次三次IO之后，从叶子全表扫描。大于20W数据，利用辅助索引进行离散读。</p><p>mysql5.6+，引入<strong>MRR优化</strong>，解决离散读。立马辅助索引3次IO找ID，存入缓存后排序，再进入聚集索引。如果ID间隔不大，就进行叶子顺序扫描，如果ID间隔大，就二分查找。<br>顺序磁盘IO，比随机IO，可能提高10倍。</p><p>在计算机中，随机io的速度比顺序的io的速度慢很多，因为在一个柱面中，随机io必然会造成磁头的随机旋转，从而产生一定量的磁盘io，而顺序io则可降低到最低。</p><figure class="image-box">                <img src="6E93E449-CEDB-431F-9F78-ADB219D3FC91_20220303211957.png?v=1&type=image&token=V1:geO33iNjY-_a2JB32jzPvAkcUhKneA_8zPt3utACWRg" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>索引下推：先在辅助索引过滤掉所有能够过滤的，再一次回表。</p><h2 id="Mysql锁"><a href="#Mysql锁" class="headerlink" title="Mysql锁"></a>Mysql锁</h2><h3 id="MVCC概念"><a href="#MVCC概念" class="headerlink" title="MVCC概念"></a>MVCC概念</h3><p>一致性非锁定读，也叫多版本并发控制。<br>一句话，基于自己的回滚机制，为并发场景读的优化，为了达到读操作不需要被锁定的效果，加快mysql读取。<br>底层基于undo log回滚日志和一致性视图。<br>接下来，讲一下mysql不同隔离级别的MVCC表现。<br>从低到高分别是 read uncommitted读未提交，read committed 读已提交，repeatable read可重复读，串行化读。<br>默认是可重复读。<br>已三条线程来举例子，A，B修改线程，C读线程。</p><p>A，C同时对1条数据读写，C开启事务，A去修改，A在修改前生成一版快照，就是undo log，A修改完成，并且提交。目前又两个版本，B又对数据改，又对生成一版快照提交，此时有三个版本。<br>C线程再读，C线程访问哪部分？<br>在可重复读情况：<br>C读的是最原始版本。</p><p>在读已提交情况：<br>C读的是最新B提交的版本。</p><p>在读未提交情况：<br>A线程改，生成版本undo log 后，未提交。<br>C读的是未提交的A中间状态的数据。<br>这是无所谓版本控制了，是一种即时读取。<br>读取没有持久化的脏数据，是脏读。</p><p>在串行化情况：<br>理解为无论读写操作，都会锁表，操作是严格串行，无所谓版本控制。</p><p>读已提交，事务隔离了吗？<br>没有隔离，AB的修改，影响了C的读取，违背了事务隔离性。</p><p>那么，可重复读，C的读不会收到其他事务影响，实现事务的隔离性。</p><p>对于读未提交，没有持久化的中间状态的脏数据也能读取，这就是脏读。<br>现在我们几乎不会碰到脏读，除非，隔离级别改为读未提交。</p><p>对于读已提交，如果C一个事务中在A修改前后读取两次，发现两次读取结果不一样，这就是不可重复读。<br>如果A改为删除，C一个事务中在A删除前后的读取两次，发现第二次读不了，这就幻读。</p><p>我认为，不可重复和幻读本质相邻。</p><p>对于重复读，通过行锁解决不可重读，再配合间隙锁解决幻读。</p><p>对于串行化，用表锁，不会出现以上问题。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>一种是锁本条记录，一种是锁范围。<br>共享锁：事务共享读。<br>排他锁：限制一个事务改<br>多个事务能同时获得某一行的共享税，这叫锁兼容。<br>若事务需要获得某一行的排他锁，就要等待所有共享锁及排他锁的释放，这是锁不兼容。</p><p>InnoDB有三种行锁的算法：<br>Record Lock：普通的单个行锁，总会锁住索引记录，如果没有索引，就会锁隐式主。</p><p>Gap Lock 间隙锁，锁一个范围，不包括记录本身。<br>next-key lock：左右两边的GAP Lock + Record Lock，锁一个包括本身的范围，对于行查询都采用这种方式。</p><p>InnoDB的[next-key lock]本身的设计方案就是左开右闭的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c2 = 10 for update;</span><br></pre></td></tr></table></figure><p>next-key lock则锁定的是 c2=10 这条记录本身，以及其[索引节点]上 c2=10 前面的那个gap。</p><p>但在RR隔离级别中，为了避免发生幻读，需要把所有可能插入 c2=10 这个值的位置都加上锁，所以对 c2 =10 后面的gap也会加锁。</p><p>当查询的索引含有唯一标识属时，Next key Lock 会降级为Record Lock，仅锁本身。</p><p>索引上的等值查询，未命中，所在的Net-Key Lock，退化为GAP Lock 。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p> 从插入场景开始讲，<br> mysql 插入会 记录持久化日志redolog，如果mysql非常高并发插入，会有什么性能瓶颈？<br> 首先，面临最大的性能瓶颈，就是ID自增长。ID不重复，就是数据安全，说明有锁，就涉及到block阻塞。<br> 5.1.22之前，所有插入有个auto increase locking，它是一个轻量级锁，innodb提供了是自增长计数器，它是保证计数器线程安全。插入sql提交前进行锁的释放，他不需要等事务提交后才锁释放，这算提高mysql性能：事务提交涉及到mysql持久化的问题，一旦持久化，就要消耗磁盘写入的时间，如果提交后才释放，就是要等待加上持久化时间。5.1.22之后，把id子增长，调整为三种模式。一种是原始的轻量级锁，二是默认策略，分两种情况：如果已知插入数据数量，比如10条，采用了更轻量的互斥量，如果自增长计数器是0，可知最终是10，只需要把1-10分配给10条数据，中间无需block阻塞。对于未知的插入数量，则采用原始的一插入一block的方式；三是无论如何都用互斥量，这会导致ID不连续，将威胁到mysql主从同步问题，不同节点ID不一样了。如果不考虑主从同步，可以用。</p><p>主从同步，有两个策略 ：一是rbr，row形式，记录每一行最后更变样子的语句，二是sbr，statement形式。如果用statement，会记录插入语句，那么在从服务器，执行未知插入数量的语句，互斥量形式插入，ID不连续，可能ID不一致。</p><p>在持久化redo log之前，会存入redobuff log 一个缓冲型日志，在commit时才会fsync磁盘刷新，flush同步到磁盘，然后最终到磁盘。</p><p>问题来了，1000万条每一commit一次造成刷盘，有性能问题，也会影响磁盘寿命。这个盘刷其实做了3种策略：一是每次提交刷盘，这是最好的，二是每一秒定期刷盘，是执行sql语句的线程在做，相当于1000万条只有一次刷盘，有一定延迟，可能存在数据丢失；<br>三是从不刷新，没有redo log，宕机就无法恢复。</p><p>redo log 记录的是内存页的实际数据，bin log 只是语句层面的数据，它不是用于恢复逻辑。</p><p>我们最好是在代码层面，将多条数据变成同一条语句进行插入，一次性提交。如果数据过大，可以分批batch每2000条插入。这样commit的量小，性能提升可达10倍以上，因为盘刷有性能瓶颈，磁盘1秒撑不住1千次刷。</p><p>binlog，用于主从数据同步，包括pit同步。</p><p>undo log，有两个功能，一个是回滚，有个undo段，理解为有几个阶段的回滚快照，以实现MVCC。</p><p>总结<br>MVCC结合undo来说，以及不同事物级别的表现，提到redo log，结合mysql插入性能，就要联系ID自增和提交刷盘。</p><hr><h2 id="其他的问题"><a href="#其他的问题" class="headerlink" title="其他的问题"></a>其他的问题</h2><h3 id="Q：执行计划？"><a href="#Q：执行计划？" class="headerlink" title="Q：执行计划？"></a>Q：执行计划？</h3><p>我们一一来介绍,并说明每个属性有哪些可选值,以及每个可选值的意思。</p><ul><li><p>id: 表示查询中select操作表的顺序,按顺序从大到依次执行</p></li><li><p>select_type :<br>该表示选择的类型,常见可选值有: SIMPLE(简单的), PRIMARY(最外层) ，SUBQUERY(子查询中的第一个select查询)</p></li><li><p>type :<br>该属性表示访问类型,有很多种访问类型。<br>最常见的其中包括以下几种: ALL(全表扫描), index(索引扫描),range(范围扫描),ref (非唯一索引扫描),eq_ref(唯一索引扫描,),(const)常数引用, 访问速度依次由慢到快。</p><p>其中 : range(范围)常见与 between and …, 大于 and 小于这种情况。<br>提示 : 慢SQL是否走索引,走了什么索引,也就可以通过该属性查看了。</p></li><li><p>table :<br>表示输出行数据所在表</p></li><li><p>possible_keys :<br>顾名思义,该属性给出了,该查询语句,可能走的索引,(如某些字段上索引的名字)这里提供的只是参考,而不是实际走的索引,也就导致会有possible_Keys不为null,key为空的现象。</p></li><li><p>key : 显示MySQL实际使用的索引,其中就包括主键索引(PRIMARY),或者自建索引的名字。</p></li><li><p>key_len : 表示索引所使用的字节数，</p></li><li><p>ref :<br>连接匹配条件,如果走主键索引的话,该值为: const, 全表扫描的话,为null值</p></li><li><p>rows :<br>扫描行数,也就是说，需要扫描多少行,采能获取目标行数,一般情况下会大于返回行数。通常情况下,rows越小,效率越高, 大部分SQL优化，都是在减少这个值的大小。</p><p>注意: 理想情况下扫描的行数与实际返回行数理论上是一致的,但这种情况及其少,如关联查询,扫描的行数就会比返回行数大大增加)</p></li><li><p>Extra 这个属性非常重要,该属性中包括执行SQL时的真实情况信息,如上面所属,使用到的是”using where”，表示使用where筛选得到的值,常用的有: “Using temporary”: 使用临时表 “using filesort”: 使用文件排序</p></li></ul><p>Q：为什么要做主从同步？</p><ol><li>读写分离，使数据库能支撑更大的并发。</li><li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li><li>数据备份，保证数据的安全。</li></ol><p>Q: 用过processlist吗？<br>show processlist 或 show full processlist 可以查看当前 MySQL 是否有压力，正在运行的 sql，有没有慢 SQL 正在执行。</p><p>Q: 讲一下MySQL架构？<br>MySQL主要分为 Server 层和存储引擎层：<br> <strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都 在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模 块。<br> <strong>存储引擎</strong>： 主要负责数据的存储和读取。 server 层通过api与存储引擎进行通信。<br> Server 层基本组件<br> <strong>连接器</strong>：<br>当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。<br> <strong>查询缓存</strong>:<br> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。<br> <strong>分析器</strong>:<br> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先 看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。<br> <strong>优化器</strong>：<br>   优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成 执行计划。<br>  <strong>执行器</strong>：<br>   首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限， 就会根据执行计划去调用引擎的接口，返回结果。</p><h3 id="Q：大表怎么优化？"><a href="#Q：大表怎么优化？" class="headerlink" title="Q：大表怎么优化？"></a>Q：大表怎么优化？</h3><p> 某个表有近千万数据，查询比较慢，如何优化？<br> 当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下： <strong>限定数据的范围</strong>。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内； <strong>读写分离</strong>： 经典的数据库拆分方案，主库负责写，从库负责读； 通过分库分表的方式进行优化，主要有<strong>垂直拆分</strong>和<strong>水平拆分</strong>。</p><h3 id="Q-一条语句的执行过程？"><a href="#Q-一条语句的执行过程？" class="headerlink" title="Q:一条语句的执行过程？"></a><strong>Q:一条语句的执行过程？</strong></h3><p><strong>查询语句：</strong></p><ul><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p><p><code>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是</code> <code>18`</code>。`</p><p><code>b.先找出学生中年龄</code> <code>18</code> <code>岁的学生，然后再查询姓名为“张三”的学生。</code></p><p>那么优化器根据自己的优化[算法]进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li><li><p>更新语句执行过程</p></li><li><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、redo log(prepare 状态)、binlog、redo log(commit状态)</p><p>更新语句：</p><p>update user set name=’大彬’whereid = 1;</p><ol><li>先查询到 id 为1的记录，有缓存会使用缓存</li><li>拿到查询结果，将 name 更新为 大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ol></li></ul><h3 id="Q-：重做日志刷新到磁盘的策略有几种，有什么优劣？"><a href="#Q-：重做日志刷新到磁盘的策略有几种，有什么优劣？" class="headerlink" title="Q ：重做日志刷新到磁盘的策略有几种，有什么优劣？"></a>Q ：重做日志刷新到磁盘的策略有几种，有什么优劣？</h3><p>innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。 n 该参数的默认值为1，表示事务提交时必须调用一次fsync操作。还可以设置该参数的值为0和2。 n 0表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中每1秒会进行 一次重做日志文件的fsync操作。 n 2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。在这个设置下， 当MySQL数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。而当操作系统宕机时，重启数据库后 会丢失未从文件系统缓存刷新到重做日志文件那部分事务</p><p>举例： 插入50万条数。正确方法：innodb_flush_log_at_trx_commit = 1，将50万条数据在一个事务或者多个事务中分派提交，减少fsync次 数</p><h3 id="Q：purge-操作有什么作用-MySQL-篇-delete和update操作可能并不直接删除原有的数据。"><a href="#Q：purge-操作有什么作用-MySQL-篇-delete和update操作可能并不直接删除原有的数据。" class="headerlink" title="Q：purge 操作有什么作用 MySQL 篇 delete和update操作可能并不直接删除原有的数据。"></a>Q：purge 操作有什么作用 MySQL 篇 delete和update操作可能并不直接删除原有的数据。</h3><p>delete和update操作可能并不直接删除原有的数据。</p><p>例如， DELETE FROM t WHERE a=1; 表t上列a有聚集索引，列b上有辅助索引。对于上述的delete操作，仅是将主键列等于1的记录delete flag设 置为1，记录并没有被删除，即记录还是存在于B+树中。其次，对辅助索引上a等于1，b等于1的记录同样 没有做任何处理。而真正删除这行记录的操作其实被“延时”了，最终在purge操作中完成。 purge用于最终完成delete和update操作。这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事 务提交时立即进行处理。这时其他事物可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。 而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真 正的delete操作。可见，purge操作是清理之前的delete和update操作，将上述操作“最终”完成。而实际执行 的操作为delete操作，清理之前行记录的版本。</p><h3 id="Q：说说主从复制的工作原理"><a href="#Q：说说主从复制的工作原理" class="headerlink" title="Q：说说主从复制的工作原理"></a>Q：说说主从复制的工作原理</h3><p>1）主服务器（master）把数据更改记录到二进制日志（binlog）中。</p><p> 2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p><p> 3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性</p><p>复制的工作原理并不复杂，其 实就是一个完全备份加上二进 制日志备份的还原。不同的是 这个二进制日志的还原操作基 本上实时在进行中。这里特别 需要注意的是，复制不是完全 实时地进行同步，而是异步实 时。这中间存在主从服务器之 间的执行延时，如果主服务器 的压力很大，则可能导致主从 服务器延时较大。</p><p>从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL 线程，复制执行中继日志。</p><h3 id="Q：主从复制bin-log-日志有几种记录方式"><a href="#Q：主从复制bin-log-日志有几种记录方式" class="headerlink" title="Q：主从复制bin log 日志有几种记录方式"></a>Q：主从复制bin log 日志有几种记录方式</h3><p>变更操作将根据选定的格式类型写入 binlog 文 件，目前支持三种 format：</p><p> statement-based Replication（SBR） ：master将SQL statements语句写入binlog，slave 也将 statements 复制到本地执行；简单 而言，就是在 master 上执行的 SQL 变更语句，也同样在 slaves 上执行。SBR 模式是 MySQL 最早支持的类型，也是 Replication 默 认类型。</p><p>row-based Replication（RBR）： master将每行数据的变更信息写入binlog，每条 binlog 信息表示一行（row）数据的变更内容， 对于 slaves 而言将会复制 binlog 信息，然后单条或者批量执行变更操作；</p><p> mix-format Replication：混合模式，在这种模式下，master将根据根据存储引擎、变更操作类型等，从SBR、RBR中来选择更合 适的日志格式，默认为 SBR；具体选择那种格式，这取决于变更操作发生的存储引擎、statement 的类型以及特征，优先选择 “数 据一致性” 最好的方式（RBR），然后才兼顾性能，比如 statement 中含有 “不确定性” 方法或者批量变更，那么将选择 RBR 方式， 其他的将选择 SBR 以减少 binlog 的大小。我们建议使用 mix 方式。</p><p>SBR 和 RBR 都有各自的优缺点，对于大部分用而言，mix 方式在兼顾数据完整性和性能方面是最佳的选择</p><h3 id="Q：-主从复制有几种方式？"><a href="#Q：-主从复制有几种方式？" class="headerlink" title="Q： 主从复制有几种方式？"></a>Q： 主从复制有几种方式？</h3><p>异步复制</p><p>MySQL 默认的复制策 略，Master 处理事务过 程中，将其写入 Binlog 就会通知 Dump thread 线程处理，然后完成事 务的提交，不会关心是 否成功发送到任意一个 slave 中。</p><p>半同步复制</p><p>Master处理事务过程中，提交完事务后，必须 等至少一个 Slave 将收到的 binlog 写入 relay log 返回 ack 才能继续执行处理用户的事务。</p><p>增强半同步复制</p><p>强半同步和半同步不同是，等待 ACK 时 间不同 rpl_semi_sync_master_wait_point = AFTER_SYNC（唯一区别） 半同步的问题是因为等待 ACK 的点是 Commit 之后，此时 Master 已经完成数据 变更，用户已经可以看到最新数据，当 Binlog 还未同步到 Slave 时，发生主从切 换，那么此时从库是没有这个最新数据的， 用户又看到老数据。 增强半同步将等待 ACK 的点放在提交 Commit 之前，此时数据还未被提交，外 界看不到数据变更，此时如果发送主从切 换，新库依然还是老数据，不存在数据不 一致的问题。</p><h3 id="Q：Innodb-和-mylsam-存储引擎的区别"><a href="#Q：Innodb-和-mylsam-存储引擎的区别" class="headerlink" title="Q：Innodb 和 mylsam 存储引擎的区别"></a>Q：Innodb 和 mylsam 存储引擎的区别</h3><ol><li><p>是否支持行级锁 : MyISAM 只有表级锁 (table-level locking)，而 InnoDB 支持行级锁 (rowlevel locking) 和表级锁 , 默认为行级锁。</p></li><li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性 , 其执 行速度比 InnoDB 类型更快，但是不提供事务支持。但是 InnoDB 提供事务支持事务，外部 键等高级数据库功能。具有事务 (commit)、回滚 (rollback) 和崩溃修复能力 (crash recovery capabilities) 的事务安全 (transaction-safe (ACID compliant)) 型表。</p></li><li>是否支持外键： MyISAM 不支持，而 InnoDB 支持。</li><li>是否支持 MVCC：仅 InnoDB 支持。应对高并发事务 , MVCC 比单纯的加锁更高效 ;MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作 ;MVCC 可以使用乐观 (optimistic) 锁和悲观 (pessimistic) 锁来实现 ; 各数据库中 MVCC 实现并不统一</li></ol><p>来源：河北王校长</p><h3 id="手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前-哪些是update语句执行之后做的，哪些是commit语句执行之后做的"><a href="#手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前-哪些是update语句执行之后做的，哪些是commit语句执行之后做的" class="headerlink" title="手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前 哪些是update语句执行之后做的，哪些是commit语句执行之后做的?"></a><strong>手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前 哪些是update语句执行之后做的，哪些是commit语句执行之后做的?</strong></h3><blockquote><p>事实上，redo log在内存中有一个<code>redo log buffer</code>,binlog 也有一个<code>binlog cache</code>.所以在手动开启的事务中，你执行sql语句，其实是写到<code>redo log buffer</code>和<code>binlog cache</code>中去的(肯定不可能是直接写磁盘日志，一个是性能差一个是回滚的时候不可能去回滚磁盘日志吧)，然后当你执行commit的时候，首先要将redo log的提交状态由prepare改为commit状态，然后就要把<code>binlog cache</code>刷新到binlog日志(可能也只是flush到操作系统的page cache，这个就看你的mysql配置)，<code>redo log buffer</code>刷新到redo log 日志(刷新时机也是可以配置的一共有三种)。 如果你回滚的话，就只用把<code>binlog cache</code>和<code>redo log buffer</code>中的数据清除就行了。</p></blockquote><h3 id="在update过程中，mysql突然宕机，会发生什么情况"><a href="#在update过程中，mysql突然宕机，会发生什么情况" class="headerlink" title="在update过程中，mysql突然宕机，会发生什么情况?"></a>在update过程中，mysql突然宕机，会发生什么情况?</h3><ol><li>如果redolog写入了，处于prepare状态，binlog还没写入，那么宕机重启后，redolog中的这个事务就直接回滚了。</li><li>如果redolog写入了，binlog也写入了，但redolog还没有更新为commit状态，那么宕机重启以后，mysql会去检查对应事务在binlog中是否完整。如果是，就提交事务；如果不是，就回滚事务。 (redolog处于prepare状态，binlog完整启动时就提交事务，为啥要这么设计? 主要是因为binlog写入了，那么就会被从库或者用这个binlog恢复出来的库使用，为了数据一致性就采用了这个策略)，redo log和binlog是通过xid这个字段关联起来的。</li></ol><p>作者：暂停丶算不算放弃<br>链接：<a href="https://www.nowcoder.com/discuss/810539?source_id=profile_create_nctrack&amp;channel=-1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/810539?source_id=profile_create_nctrack&amp;channel=-1</a><br>来源：牛客网</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;多数来自王校长MYSQL系列&lt;br&gt;笔记优点：从调优角度去挖知识&lt;/p&gt;
&lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="中间件" scheme="https://missionodd.github.io/categories/技术/中间件/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="mysql" scheme="https://missionodd.github.io/tags/mysql/"/>
    
    <category term="优化" scheme="https://missionodd.github.io/tags/优化/"/>
    
  </entry>
  
  <entry>
    <title>面经 | 结合业务，步步深入，P8架构师二面摘录笔记</title>
    <link href="https://missionodd.github.io/2022/02/12/p8-interview-skills-2/"/>
    <id>https://missionodd.github.io/2022/02/12/p8-interview-skills-2/</id>
    <published>2022-02-12T07:50:37.000Z</published>
    <updated>2022-02-28T02:22:02.866Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6e9e70a41feb4d37023116c731924cbc770114a763dedfbeb79eb62bc55b7ba5">4c4fd9e09482e311844f0584b2bdee0d55a93e30a00b4effa04e9e685df4b31461221db616be3d2a781d374108b43c5fe8676ed097ca791d48ecff0323412ccd3bef72f4958205bf579ee454b2bbc67baae0759b324707b1e84703c16ab9b813b34619cf4e3b1e5f348b9300494d1cd639f74471522c9e5816e1d2db13b91eb1180dff1dfc2c1fbb9dcad8f4df3dda9782cae8d3af2874ee99caea9425b667acc6a8739a70dbb387d2a0b8cd7723760867dbcdcdb1b68694e3d91b11f1a6d633c8e9cc10b0a5bdc4ec51d4f5f3789a0d2032c335553298427f28c7567b1ea386b33f7ae9d4aeba32ad2b53a6b634325aa58f6d68fe269fe9ce7cee99fe4c10815f3c869794e91474ce78ac8e59270c1b027739af7f6bc084187ec34687e976f33da5275c8228d757f43cc1080b4ad5ca2bc0c653760248912b0e9ac31f6fa1f078188294ddeb2c4c269017a23fb7effe18ab1e7de94c023fac1ceb7222a536991e7b61722b5b0b5ffe073efa07047413d2d09607633fbb361199df8cb2fbd9d904a9cf624ccc45307918647e7f55b13d9b75015e1f43430e8100c0a858d037a12e0c7c73afee3b323dad4ffeec8ff12566b175f3357bb92594b263832a91a97c5e43eadccb1a59b6d5552b96d2d6ef213261d1e0d52e7c5138b2111e4992e33e1ff4fa0589f7fe76980678bdac2417cb253500006bf877eefc8722c3303059e82534d54887b654ee92dc0dae39f5b58a981b765d644bfb0be3b3e2047db07ffcdf8b523a80ae48fe097c727c7e83e7bda257b28990a2517aa32612fc8d34c624510ef7ee0a82dfe120b4f7fe7194921d0546ecea1ca01b5935009615ba4308b632a1dc795a4ecd448b9370625305f7fe1ad31f7c765aec1ca1144858b4721758dc336896ae362fd20e7bc2f7ac7b3ab094f0d7cef0fe9c6f2726c5d20a1a4e3360380083e4d8902b984917464cd674219decd75f1a80bdfeb525801851a299ffcce276e7efaf0429d00e06e3f8417b8f425c0616bcc183e58363af40135c47a0116a77cc0b421f60242a526f5617fcffefcef3d4eca8fe8833bc489be8bf1082b02fd71d6915a640585fb8ddd5e261dedb2fa08602b0191abe5258d10071645ec9a06b36a6aa638969f762ae2d275387bc1a5c89e89e52437233a9055f7bef0a34569290ef23268d0149565a728d02dbb6c68cb7e7b677de77d05948b55b802148bcab772829e25dc4ed59b3cffbb36e14bfcb269efee9c38cb1f969814d86671d3e04de7a8ed695df62752afb0f2431dac2c97dd72eb1b5cbed562a18d6ea5b809350f2dda6f4961b79940a3862e158723b45ebcdd930fb404b0585f3cd01f2355f52c03a151754afd5b66a68ba8c72283b71b99800c70c5c76edc93eafa83f9d4b527e51190d7ad77d610df6cc403d883a625a2c873f1e7dd33cae34535801ed732fd0386967d6f3afc62f8b76df680a387fc5cdaabfb5ea9ba47ed34087f5ea658f74ffeaebf1dc5231d28d3fb794b8b0d18b7839b9955d8ab1bcb45315e4640337a7059395b1003d8fa8931d9b2d1e52f77e42af1b637744fb00435b74a2b1dc1cd8b91a8b6f70d084bfda6629cd453c49f74170af3c5e85f670a926f45ce97572e5e89eb7e8299d83cd99c438638b1727e5a98870b6a5137eb86cf981f7e68ee83ddd7e24abae33e467789b0153cb33d9d48ad50dd2ebdad395f751dd22e4181232e1e380e607f7f060faef251dbe933a30591c932cb3bfee6a5f3c25969915cff5c4a194eeae8435fe89efc05ac174979148af2f53b1091c38d549246d95b8be8ea3888ba185cff36ba031cfe95edf394761417feb17c9c477ce2ecca4b14a87d2df196d7e1694a9eedff0bd186655fa7bf4ee7ab99810347ec95d3da10bd53b45a2cdf49cb82ff0329a4629cfed0f62eff1ee1f814c92a1a4dc4cb0b5373aa4f8768458ef016bd98e0fb663df7137971ea721899f255b0218a5ad36479fe0de281136160f3bf9d485081dec4df0d6b44e4bcb822f072aa72eefebfa92daa2a1c0da8ca09e464ae3373c3fca129fd805b78b605f56534f9616357c9d8a52ba3327810f3f1acff816e167255ec7094961b7ce4325043ea5a56962522c2e10951fddcb3104e6e5cebbe0ce7f37bd0fa28d7469e6305aa2577d7c5b46dd542ea7218205899822c9659b5e19621af12d438556f030839959e5e1d772102cd8c60fe00e12961dc30d62211bee01f9ae8e1884328daabdfe0cdf012de583b0453cb84274e76f2d3cebebbd4905030fdb58a395c866a21cddc10a52cf0f7d03b6761b3dfb40ab3484341e717a5e268fa6b2e9718d368fc76f0f49d055b27dfa4f8fac113e9c585a7ecab9a1cabc13ed42b0e4e6cc89f881d72359628d6df1293562f32a6d1fc18599c7093b99d01fec9da7a759db5bd76112d2ae088a0978cacef48a847503d217c1a16cd6a0779b46489b92c89d0a160f6e4b69933cb3da711539266e524fdc9cc90369b7a1915a63e413699d55f234be147e4fabc99673fca83a33e7927559ef3cc8dd2027f63d0da369d4c8a80ad3d851251e0b5cf6d2b43db1960ea7a1d4cad4145c4fa14774ec79becfb3befe01d1bc409d4a7246fb9ae896981533d6f5f281321c9c82d4b0e1a3e58b821dcf6dbd834e712cbc12eb0baa254d1cf8094c493d04d186f9c7bfc8c8bb86de66e66c7d3c91f61c32ce89f31f73450dfc953e41f808883f9fc7aa929ec6666cebfdcdd6d9d1bb604dd89dd22ee1b26307dd1badd379b5b9703dd32130d584a4b7dc7766d4f4f4de5864126b94600356e5580e6256cd1213bb9772df9d5d5c0ccac903960fe1cfdf586364c574b6758531714cda47d9b840b26ca519e3d0fdd49543413992acf2fe2e3cf75578483be2ff0ed25c83643b8d3812c29dd8ab7edb475419f7ab9b93e3d4058505aa50aecbbf8803ba4b171980c9046178a14da7fe3203abadf1321a866a2ab652c1d40a45d8a7b7491e4c85c3064500b8edbdee7693cb390c4796de0308ad2f484d28e18bd5243d4012498bcbe9ebd5b5f2842f76fd53383d49cc9eede90a4480996892b9030a1f8b66bdc0bba9de8d42e0879e378ee59ab6893e049a4de5e43d5c958b53b6edd84be5b8e840cb15334822b0da36902fde67f3fc4452fc8088ad60408ef77b03f0baeac0d6d26e941149525f27dce11b27d3ddf4d510b36ac8cc2ac21d994426608a614da0c3226d0657c460fa9f8775ec5f94742d4867b847b963fa3a6b5760abd985f82e2afd39171e4d0d1a51e70d9e8bec60b4b9da92e8457ec7c0e9deccba18149cb4ad34b85d6a307c3eeaf74d645b55e06a627f3fd0b13272096786f45ac53ca7ef12640d789d36dc63a36f01898c7c5d10552048a7f578540ae4c62f789158769bf3ab268a64e9dc501b51154d49aeb5d9736abb72868a51c6fd1d12f0dbb822b9a5e991d7e615f81f1ee55cfeca2ff5ee61656b6fdca78e749cc3f038230316b7c86b838481d7a1ea1b51f0279bc10933f6a0ce5fb6fa5064eb9a7eefb395b945ce3914abe4d33a8c4062ac8c8a1af96f30a4d9afd0c20f64d05f98bae9bce8318aa0f0ab282732df215dd9f2baca78b43e4b57e069c22c2963e2a42203a77de9283949fbaabf05ed0280c6e9642142ef3829bdacc7c8a02f77b3ba9ada463f04d21da81373578e8cea6b4ea4542b42fa3ce734d0894e94d753ed8a9c24b63720f1c894dd3cb8ffafe2d288cc70f20646ac3e2264dd392858d55bf0c017810c6d309c8967727e25cd4c35ade4a68045b36f0e4f7b63a4ea1ccc029b33247881c9c8344637c8670b843eb8392a65b22526ff632376746c86bf6119db6bc9bcbbd759824668521c9400a9c5f86b7917585f69665b4ac7ba11f11a8be9fadad34ac7e13931592b4d3a98a35623dabb6d50a5f2676c75f2d71f2ca6804c8f5576863ba7f06a617d5ac0772632d672f7fe39adbc20d2f6ad7409f005ae50e5e3d4e9f54ae28349da7a6ba6c70617b979644db002b6041f6fdc7706fb75671ef076948969687b6c57a8bfd9cda58a92a7b295fc83cbadf2174a92206df2e34065b8aef15faaf7cc8dd8927dca14eb75b3f9bbe11d36d75d0e69dc2ce0ef13bd4a842253a63226a23ac253e22176a35c5b95e9628c9e27c23a3ef76a4d375c00a02a4286d48d4cc98343f17d7267c438f061f415bfacab590505f2f76563e0b7f8fdaf0c29db87532a836b4d554b8d90813cfeceddd8a4c5e3ad45ec3a4e96fb20e189daf0648e8bced45b90bd15fafdd23a9ac266dbcee77a328653583efd6a17dccfc3c0496d9eb08ce540a4e940c4020a6ad770a369d2b3e27ac1174252a47eb06b925b29d1708bb349e9b2566edfdf626f8390e544f81ed908bc974cdd919d2b9dd7073005004df357d15255e8e24d2e74fdcf41336f7ba12a1b7e8ffdb044bbd985a5c5258022dd0ecc94fb307bba0b3437207e7d9aff22ad405bd496792261c97b62f0beab03c577ad4265a56809bf28f99e77be91f094e6477762f4d2d039a09a998ee877aa21b28e0d03d8006f68798319bbf87791ac024864d862899b6a35fa21aee40d88ba56d4fff4454db967a132abff7c45962e3333cac8ebd32b839f82afc0eeab09a90e8d6c9b0f306a058ac310be439be7a5cf5650df16f905a6411ad4dcd30dc10841e6dd1ab3e26175e2f36662e115842016e2698e4a5cf591ea350c7d37139425c42037e7b89f60ef970bfd4d38428b122d02c3581f1042b81b2a4d0f49bbe0ddf439df82843fff71623a34185a1a8b1c8f8b001cec90e0c3a7d22d9d87988393efcebc0d0459ec6a4120412e42e88651a05327625df30a8d9c8d85c7cab497725b1e5030a76e9710852f5d95faa086b54f3a06ff8429b0a3560b80342be18a1de084713828d8bd0022a6321fc4d027720d0bf14856cf219e5c8ee912dbc54ebc65e998fd5bbd4d9b972763dc542126c5e5997e2810b77c10e91e96000c7dd8acf994beebdf2a6cdc4df541e5f88962b49a5d1848c1aac1a339ef76529d1a4751634f79db36d00001fa85e4e12f3d058e797e1a5f38b50510d1f826a2d155cb5d75cb33c392c3ff244662988f91ca255da13ac4a9a14ca61b29e1e5c6d832cf9da63b48a96990af9103b2ad8ef399bbbb6cfea19fba01f83a4e028c8d76fb3e639eb5c96d17c688d460b31c72271d674a000cb247e5b57778264a362e1568a382958149a4223b1011df6dae9beea273d47d728cec029af6ab42fb009141b7c2c651764159acbe33505f44013490b7a4f4d44951cf749cf6cd5efe296a9156c733c15fc07e7094127ed81e94a9664fa20ed85af8badec85d551d22c2f4075c73c79bf606c42f2c02a85b66f133936efd0976ac8566570af60338d276c6261b631d2a0c28b1bd5cd0360908fceb5410727da48cbd6f96d910ea7b6a7c2412b8355750bc96cd7a7e7c0090c0d2a7939b32c0d20e9823866f8bdb19de25b35b531c115b40bb44494f685353027b2196673003868788416616cf8a4b2c3ba480301458f3a003e6ff8fe5980e7349b02aa4f2c44a28a3dd6125ae81731b17235f7fc7124fb37c6828ff90c09a2163a294c47983bd64eb200011001df6b0de1299433fc8258924ccf00373524803e1e617155d2a5761d47b8c8e38476003b331d69f1bb3935064e6b82fdff3025e945ce3ed3ab9020312b8e95c389524fd4cadb9bbc44d572bbe294ba3f2e290a3734ed2e956456a39523d3f99a4e115703c1279c601bf9607f1f88b418a5fcf794085e0b63fdaa26aca991040630c22c58a98c84b813ec38d966a50831ec5263f3607cc0c9b7012a72a7e5e0dffd376a1f75576dbc4893dff860f6ff71ca3fecc2d9b5bf9df384eb4c94a43e9603b62e821e22a368b118e3c04298cf14f33633b8ad49816a555fb140e3f2b4caec6a5eccdb5927077509ae35a95dda624e286d347cca0ecf5fbab8b870ea09cecdf2d8c2882f9556f88bae2206b554bcd51796515fea6eef5abb038ce11d3987eff9cc5cfd03abbad6994d68cf50541d0eab701184d1ef4fe36c504c31f49a44d096e1457495927f9055601e753f7e7a2988e5e890e2a8d7fd27b8276ca3378938ad99c60b8eb4c21df3cf31b09649b3f771ca115eb2a16499e39584e85af3a20e10f8a0e415459bf04da825ff066c30522bd02ad9ceca3a4a2d8016fd26d98268046b80123ee1c015c1247f9f3cdbf8c3054eca3704ceda1371a5eaf4d786fe65beb4e49fdaaa3f3092daeaac09eb515e2c969714027b4bde36eda001a239cb6ae679e8b65784afe13a2abefc2daa2437c4e8745afd8c2eda662948d4cfc6dd59a40807706f0eeec7228bf055938acfea04fc2694e52d30d2d04203e94229cc8a9f3a60a24fbba936c2994952917dae282c52ccac3b4c7f3de0be6233cc39084c71aebf3b4fbe724c67d9422de559620ee95ad7d6d0591f73354ed37060bbccc6cae647d22dd4666574f3bb6e697ab441b31123153d0b1f9099fde641a25137de703bcaad276092d482beb9c304a349bb905dd5f697f53d64a217ccd3a1ce1399d87226521e7db8e1c6258ca7c87b245fbc2ccdcc412b6d2c0e77f6cf67fa360a6b3eac53a66d83c04f298846a0792f43dd26811900c329bbec6022f814bc855c3e7f783deb60b99189d9dbb3f394ece94c9e5d14854085c7ec50016612b32db56d56ca98db42edc556d751fb383e5feade3d7c41c207659d9ed18f35e097a6d996a5855c25e33106260b12d86d1a1510666a083849de01a552d26ff8e284e9c02508cc42faeffe8dd11ffddde892cf11704a07f177dcfb71573546f8f4a1cfe4b776c2858f9153d6bbcfe506ff73e5f4e0aaf07992b235070aa7481c69e95b45be6e53d067a71f97ec57624e4faad906e1e896cf79307eff333e1420418a33452b2c93e63544e8ba4b04f8ca9c89461113827118353914ea3d1c1d10548505517abf1db916a9c6a2fbc8e8e2afbb41cf71dc251b70f8b149dd3b43c86c2304f986ea518bcc3a8c3d533f1722bc8057e18a6241ba2e467b02e9bb6ff996430f1182212fb3ef0ab90a0299d6e924005a8f1280dd8247e292c4b34ab7238f0bb2205bb5914ea8d37722b678c0b941bd55ed27e97b853efc8f02788a22813a691840ca6c9a816bc5481723efa7039abd26367d0bd8c66ddf52532fca862a4135a3b10b5419f73d08b9f10e6885c0a5073e7061bf49d097abeb1495e0d31af7acf37d3197e0dae6b65e2e76b456d006b86a3ad41df635a62c6b9f2cd2d10d038a0cb8b355bd5b8b151c66c6317de26b0367c59a8f207b1e0d854e721aa19dccbd5720a7889615e0791ce6b73c63cba54ef3cb350b684a6ef96ad933a10685db7a28b04fd167db1f2c215a8b073166447b340187b9fb01e297681fe6e589bd42ce564639de4315875d3f06c3ead2ddd310cb6c0b6566947b5c75c5a758b5055d6c9d00dd956e519687ecca3154520ea9efa49a85fb1940ee45ac851057e9a4614225f8a1e6379a37c58f147b78c2dfbc76365146c50b68356a08862ad3e112e734cd2750555b4ce36f157002922814d20462eacbfcefa19193b4711e9440fc9d7d5f7105e3bdc0dfa4a691b99ab8fe7da034fcc430edd9d0b52004814aeeaf9c47ffac878022270f0091f48ab5683033b4f1c34aca9f5e92a9e7535a01146452fc330c192d4597e36b6397972d75458d3732b0813234c1ba3c072e7569abbbc6bd03f289ee5de5be32bc9eeec6624b3fe6a6f5599748fc1debe235dd3d33018c4e88cbdbcfd0b257400e1fdc9e6e080f3ed1058c057e8b0c16cdab9cacee8f49013542f1837d739835647117f85e63801189902e74f8269a1844278a4ce51fe77327d7cf0f16a98661219c454634e199e05ae79389ddaf1a227d0be653b828c5ad7e3820b30e51472fdb9595403f02134f6b7ac8a3655a8fea325cb8714766746495e66546443d82f81487f6bc37a45947a7eeaa74aa279f584b955fc2e42a94ba8630366c6fb24d54c57b7f1163e0f5e36456b0d05873d937ccc02b339b3d9b33c5ca56ab6c70fec3eedec50398429122572a6ceee03c08622a87d2b956ceaa6ccf5061c00ffa9486919a1930d11c3eadd15c8307731b3923d036002123b574040283867a3dcc6660ca424954d88a8459cefecaf548f10f2cdf742d732ee6e1d8c1bfc125926586e044d22e00477403714fbec42065bedef789ee3c3b0bd8c4865ac133b1f643de0dfabb90e4386dc8178d09e550d6f0f729a29d8e0da1663da220b7e9d6f61de30ac42f1cde699259e1061a52ed17cf4716de1263771207831cdede1fdf1ccb4f48aa388547e7d3deb655f4fc27816d1d362fc99f554cc7b8ba9dcc124f2ddf35430cdd197f85d982e1750540c2a54a29abc53f33d85adabc4a606aa4f208722c78d15b3f5c03d88e625897e9505eff9da3fab93a06b353df8c3f9c21438e19fe23b23dc6d0959b113a73f42cc8286a8c6324696e317392721102ae7f9d1cd4f2b68bd28c0c7559334df234e26edbd06a5aa5fe6480fa5e695bdb62d3e0e20e34e968494a239c9737fb097a1e0867133c31bc1d0185684c69af826a5c069d2f432c7014206692c0b3388d7f1be4c8991871d3118344ab3919b27fe75a977354330f58918300f877c287626b8c7a205c93774fbafd255339a0526bcb11dbaf5ebb9d2dc501179a5444c7c8c9f3dfe6d62ef86fa06295cbfd43a2fcc82dbc17984d9a6f4a2aa058be99ed403ca6041620625ac5129688973d1ef8a5dda7eb6ffdb80d9482c970d33e2ec9fadd154e9890ac229bc6b8367e2d5d24a8f05e7d3eab598f2f93189370f52d53ef3db37e991602799559b855e96cc12d5238ca2a7f83d8750a6a0657d160aec104871d2fe8131b63e6e577643c80556179d7c936271323a101d32f7f084ea6f05b68cc36ab9489e6bcc2b944821869d103269899d965ccd744077ac082666e4a279f1564f73caf2177394e41ad8b241bcb4a19439fdcea49c0fce790c030f20451c2ab98949982fb4f32d786a0ee5f2c287ff4325b90471210f36097bfbc1e2b46a6a5b607fa3cb0c96343eabcb35d7708b3cf3f4c01c3792d55105a402c21064a8187e6ad2ffd409efe91b806d5b63cf436b538dabd814a6587cc0b1d3a338e65d2f3c2ccdfbcac1a483458064f3a817d9af2a52c7998749d0eaf5cd27c5cde34903621aef3ebbcac2fe5e1a6a74dec8ed467d626bcf1a6af84000bc2357b96ae58548b70362e33c46fe0c875803667834fc417a3542fa34e9db4b0e6f7e12b89b1790357f2d1a8c37f4d5b96d5983f01f9a3d3a8f8d49e3e31e734f5a8d7190d5786895e2c9cbb4123058b25297ce7bdf73aeb4c677122d7d690196212233b8fcf1b1ab37150df970d7c6b1ed8c67fc4f717c085b46608480a12e73098d2bf17a556db9c33f84ff5ace963a6048f3cc072ac57ad00685143d6bc14acec840a54b91fda7867c956e7e4798d437cc53a9e47c7fd674b3a5dde9b1e16df047ec2c22b464fd6a440985bfc91d5453a2e01b9ea904bdb23d008f144eac75fa4723589e2ea9ae4604d54a0e64faed4fcd8f178c80665755e1de617e238237f16ed464245fb5fcdb9da621f33cd3b7352d811b7a1716f97708fc824eb3a0e8cae7bd13a422b9d8489c3e541a501882397aadb4f6a78f1b658d34ccc40bc2d46f9536ca311d3b66f86982f7ac250864a7793aff8f38ad2500404ecbcc07cf582fcd380dc881faae5820d8d072fd09939e37bfa0d21a8a2d6db61c63d08501aabbf885a00c742353a455e17cb32000ccd07394ef82be5255fb8959937cdf7c0daaa07a64aa214aaa51ac34c5d989db3a989d70d4e38ce8b151f05af7cb04581fe37e41eb3171c5e3efa138bf089d9846880e6f3ca85e93f65f5382c9bf7b8850d75a17da55a743c53591a853a4ffbb3dcfe0ba68859232ea8fbc6b758432378737992acde40c4df09b2ce995b9bc8bc61071678ef133d592dffcbbff98b5f1114851b2ca023e075253f54998a072b7fdc41d751bec954a5796ef9f13aae4ed850a5374a91384b26772401f6060fe2897dfa6da1f21a65e34046132e726b00ab51201fcbaffa410a910400babe44d715798047a0e380e235361e4a9d6cb47d0eef73db461ca512c5eb5bfe2d1965d3882a6afc349ba28af532ad5673f3e9e9c6b4a9c22cabe66e9888efbda28d90f276c6a5d90f534146b0a52be5fc2ea22fd93d9cf2a6989484aca127821af34f15c9d03bb27add5824b648b312f3d3440852fa5664e384d7f67b2719388183876e58839f34fd129abf2790738ffc25be125d096eb31bd76542762ec7cca5b006ca07d00c12f4374bc412a6139a8e6a5206aaeb93f4dd43063a043c8fa0053d97195794263b085964010241984b1c04e70cac7aa9dd1e7e7e61ced45b6275d091d99c47477cc7861fe3b54baa548395e7e4484be3509d33476fd86b7ee35193ed997a7ce055bb1c5599f97e4d00f67281d0e2f65984528f5edc2850d3ec9df614a8f6bf1a1484c3cc39a6b601f5e14a0d1e5e00de69d2b50cfbf6aa967cf5fca6971382eded15ebfccd5773b0e719bfe9064fba2388717d6cc1828edf9c3bf936b767865a0aa68423fc649299d1552291467145122a881881118fa5b0b83272ffe7f71ddfa8994a98711b8834ffad8f3c5e2d3c9b5c367afa2182238df3ad777e61b480fc91e32fe8458ef0244509e43fd8b38c58009ce2826d5eaa25efde7d9bc1b16cfcdf8180184c87b1e397cd82f602476523d2a897726feac45ee0861772fad12f27f45ad972581d393deb16033dfc487b1c4d1dc2c131b3a0d03250399206c969840e01c3c22b24d3b7520c1e83396fe1495ec18fa7fe123180914f653b848149d95009898fb2e57b503e468bea61ea1fdc0a5a2b033b9c1da25ddf91fc17a881d69ea844147caf01e06e304406b810578c9df7ac790a3a15863c271b8ad841eef53a12cb3784a3cd9064944ad02b07d3d72fe443ef0154c85cabc4b634ddf606184c7260dc85dc0cd498e529e8e9797c21e4d64564453f8b92b9ecb1715349de7ac807d0446565d6ea1eecd39c4250c73c69c4412f20606fb43a9c93b881ed13881989ec85e048db38c010dc0c52b419ccaf9a536abe3a34e94325f30a132b031ce07653a07180af1966c5909011657b8db279f910cd445758960c8743b7054a91bca3658df17b9dcd79881a81aac2c4dbaf841edc37eea86c74639a821f5e182c6fd1de8b947f63df1f02cbccbd5519cb7dbe20d0a4bf922195d02bcf4a7392df27d9764fa535f1bfdb60bb891325bd4d469df3aadfd442b20125d3a2ed45fead87bf3e7f18814b53f28c5b686074a6a35bcd59e91b45fdeab11fdba880c0f16caf7fd04c1714fd7d49cd64c51cd5c5b2cd9b55e1e5aa45cbd21e420004056b8f5f361299651e92a35836c8184cf5d08b9cadbbb191083e2480d26bd32178ee22c262e729ba709c5c10255359126ec11d3c3ceffc1c9012a8566e753be78f1973c7b2c476b862eda933ca0e3e9e5dade6e4b4d4797dd8a3211400469fbde21dfb9c97a69b4969ace05ae5120e2293e96a0ea3371a60d4abdc299afc5d4080de61ab6c5dfe6df3a349a51597fa39416831d364f865b5c4477706e71d060aed930437dbbf15c7c50ba5eb537247afbeb6270e8e53a39958e81729dbb208151c197caf94f4f2092546adbca736914695198bc2305c4e5ca19f77071dcf446be91130ac8b0ddead5de56875d5c3b1905c0adb8efb38332ec52c83a4386e9a94e3a0fc6d0bfbd4408eba382746bc87e575791917b982a95e53f187f3f82d8d53cc6fb7351c7b131005d203abd0892c6cba280c5a48b4e0517076d80f1e59217f22bf247f195f6096c9e081b33768401f7d79dee804982728839707bf69858b11343b2a531eef07d14e9e46c61025aa958cbf7f12bb09e5ac99e6c283b4576dfda34cea67cc0461b53dce4d15b05af90730299a1cec371862bbe38dd8e0cf189945b8773245117ea29886d36fbd4df78565e8444d6140a085b18dd16b9bea4c2bd8698725a3e4e5ea818bcbacd6bea0e78622c2023d1617ab4d6e8b8fcb6dc4d2093dd95b0acc967355b689db392f6e8aa1caca1b6583fc0aec4d4c22e4c98b2f49a8027558a538066c87ecdd89d52cf2f18171ff67b73dc62d3eb993f8393b2edd2722ad3e377ffaf6ecebd7291d0a9f674914aef4f935bb96e436296aebcb918c113b6e9f001da4bf563cf04c935830e3f5a0c45f5e97303be2ebce7d673829bee5ebe31de2ec78f92228543e5a7205c260fc30f0a1405d37f4596d7fded545a36e6436fb3d96085acfc2156039ac8164810af58f4d6e824af51425cd7538b64d5cf7eb844f74fccd7db2bfea41514f60e19f8f75c1f120d03e1feb9ceeb1562cd7cf40864c3f152402811d56599ab8b24e27f386c60015d484415cca916e4fe9de57d714919f9acdedbd4857049d9207915e571bb4244a752910d0ee302a826da4ec0e76a0f606f35e2170fd7d51e9b23f38863cde8b8482bd5db7b8050cd8f124797dd668816c63ec84708f60e365db33f1139811f3bd2c1f0b9bab08b2bd9c1a8ab44b5ce622e91b6c8c6264c7693db8e1bc36489ad182daedd25a0056b870493a957ccae5ed21207d03c2219fb09b374003b4fe9e7613f4b9a3d480d1853ee4c231538332c0620f4a38a9db0c0c420d4c745ebc4a72be3ba19bd44ad98d59f2608d55c98a0154bd7ca78c8ea14a07fcf57aa6de6d59664d781c270e409489c0700b59f12cc3b38355b479e52ae8386a7563effcfe9ef226ba96bdf8630c2d9314bfbd1178040775b254910fcde8b34af0ad6f0c8fb48a0db29a6e8bc6f7dbbefb786e40a35bbc593a728ef1c74b18d2d54ee23f794e3bf17f9efd8d1c48a6b1d3baab9cbb9e6a10b4a70abd0818a6c388311fa671177ff3996477b211c5b8d980ad3f3a7e049a8a4fb15642296e2d1cee0044eeaa168d79b0c1c739ce42542488546eab393382e6165ea52e7dff69c26bf0e62d53596006faab9929798a17e3ccfb9d8d0eb858983d6ef8072489e58bfb8516ce32b55ae6ff65063ad30d359a5edfbfefc76a7350aea00f2a7fbd855045dca07c38787f435d5e0db6f9f01f143d1fa3ad20a360de0b8086acad8e8327f12f014a6a6b56eac2c635dcb38c94d87547f475c9af05200fb80a4c1f427717af276c7fcfe22161cfc66fc1e26d280a66b94098316f1a33ce83fc38b6bdf770e679f1f7e72f0edb470e53c622e4d379f525ba3c60c7a0fd5f4c55f7ec21b209b432e1d3f7a33653e05eb9d9ea685cbbdcfae13e22fcfeabe4399e87a647865bb8d299ef1ae8d960b28f4aae92c8362380c2632fa82529e0bb6cb999c2f22318150fb2cf19fe220ea90cb2ba121000bd0d859ee01da6f6ab6728307f622a7e9ce0f6281b0179ae71e4b7af4be098b0c417e888c6e2c1593de05ea552b040dda68fbfa44822164da669926b35e9c52245041a76037e21ba8b1394480416c30de21cbb9aa0b0cdc062290b48a04ae4ef943a4f1b62dc901d9b321e5c4777a0528a217711fd1b131ab800fbd04362ec954be97030da3cce696c8f160c71dec5f296eb43d149eaf64d4e11a56f0395c48c6e555bf0c9c36d736333ea8bc14515ac7ace2e2ceb21c249710694dd713f8efaa5848d48ae7809c0091602173b384ece1c90ea321c9b5fbda3291383cf1a26ac6db19f6a7cde36388c33f4456aa0843ecd24e03844eaf887d29ee9b7317b62c876204b32ba486f3a77a44ebf0eef47a4df06ce985cc65891f535382330e6b7423d87d6be336206a366b45d6f3022dd253bc61dd8d25716ca4f9dd7d627a179cd39d95454054efaeb3a599374ae3f4a965a9ee5c9eaa4524f8e07dcbc27a1998055be6e0ac0f25c70920da9e57925393fd4997440d55d2f8828c7fd473e27c319aef00eb842d7bf73d84cd6ece4ada24c6763f6680dc1ddd0086f95b69e60fe743c17977230d0fa3bec8227c83482ad96b219155754c2a6ee8bfcd827f19c3ea19065659c36b3e73142e31f1f016e940a5303b6643c5bbd86104b73f69674d9881c675a21361a38a540ce32a808396a0c6a38b34cf0db267fb1b4230c6ccbf7c13d56ab23d5a81d45acde0333857bea0d9bc1cc509515b4f0fdb9866d112cea2b3cce821387bf9f23e8833180ea6110fc2db539251603bf55390a5de24a42b36f4ce8d936aa3373b0ee179b5b640c574ffaf8b1e6251986901be4c570ba8b8c93a76fbfb36e950ea0c6a083fe2fec55812c8af2faaf73b7b55d0391cd9af14a39518f020b8c08e1926197159f31997ae0c13330cb8c558e05f8b59acedaee5b7e774785e87ac252305131aac719e03907210e53e39a425b4fd9acd84a784a7e32921b8fb7fcddd4c1801d321001019c58597d2cd5593010bf16d7766331cad299e3925dbd36d7d497ad1e1f1579d5b6bf2ffb7832d0296590a94a8c4980844358d1262bfbb054ea11f99939e3f4ea2471f0596aa92e4aca6e7dc2ac6a9da21327f1fe51325d9b1e521879e86b9b918df03aae0a1af47d181d1c472cd7f034e8a90fbc8b9be7cab679b8513f048f31346e3b61eea9e99c0c730c123bfe8edf06b2b1c3488858901e656e62fabdd8e436813d62c0af7c742f921c726c4b8ca1af82b9154fc8b75758c6aaa29ce21d156c5ba758b45dd5100569469d61b608f395ad16c71a703ace1290a3c062f0a40e14b049bd3be0c08b5f3275b78bc5affd4cd95ff730ab5faeded2d339887a0189f4712442c8acd03ab52fea21cd24225cdd503545ef8400b773524fa412e252979b744d7b2b2ea7e0f18970b851d2baee1d61b4582a58b1d1772c8765de26f425dfaad73c5c073157c45825530675dc55fea450c020d03bd7bc61f778e4c40a2816b44296300f1a347796f648d2628db38c4ef9211a007ff385ec0d43035c1609738701c04617da0adde5d1547f476b85db06a3f09702a2ffa5c271e7bed2b20aced3402168cd364b5922f14a50fd984749d38dda670d1964461c41a531d2a58681990f5a3de09fd609f6423780db35da78587698578560714086ae688798e907be41afd8ac57c14451b67b9525bb5db497ff30955295362b2bbc6be7cc1b7992b4897a3d6b2c00798d9f7fdc082918f1a8333af60df051c1ced557b0f9f6d7140569a0b6127eea123e09833caa9f39544e8e6d22f4fcbb85c891b873e0c17eb7e6cc38ca4fab564741b3be6677d5db4367e4ce5171ce881443a97421348e902170a7ae665971d2db9f6a5dc6ff47b5636c037c91fc5af398c04a402c068db145e4f6cb39ae50d5dddc410833f5cb83c4861649079529af976ebf3730f395fd89a7e7a0fb17b12851f16b56c7d0dc7736c944d219f9e74b7f9158c21b771e965a0fb4ba40d32021cd4d04b2bf2dc2b15db9fb4733e0d213ecf3096625a1bd265a72882227338186a14960452c1ce759bb09554ab222f52eeed97b9327ced94a04bd59021758cceb91bf34645ed4121b8e65be412cd45c16f413bb10afa7b1445b3e9ba862e8f8af67af2d9f90f292e5ca21d83c2792ad5d7f6d63e684aa355ec7d307156585161212119adcf78d5bb925f0f016e606f33eb88bc4b407ec02f3be1f4fdf7639ce1adc328b801ab328320cb01d71c903618b64e888b545f3fcdaf9d19b76d619ece68c9c357331903731477c17cc88033b677b69bad7fc02d1d24331a083326cd638e7056be8960762f0fe18f9f6e087799ffe6fe799eba4ee37acb00ffd9690cd7185f57938ce85fe6ca20bea95d20b9c3bf1901aba24d975ad083068d62b3cbb9c669d27d27a0211cec642ac54334ccd4fe391d7c7c94bf46b2342a52321750f3954f42454f75f33289159d71442ebeed717430f8e8a2f13445d836a65e56b3ed58a309020a1149489688251d30a0d5908ffd17d82376a885f3e46c6d4bb2c5d030e0ae7acc2206be607ab0396d05e57697af60c4df5e07825aafb9027eabf5c03c9b8bf8eb66a62469deb9016e0f2a5d127608eac5957a2142a25a8e763e23492b22762a3ba6505089f7c3514f080432a2fd1a095e07fad84a36ce13843cfe496218c7963319c4fc9b1e8cd7f5d0c549fa43729666401ed214cdd2930dcd2b9f705691bdb9972da1fafe1742e60d09d0464e52d2dcae68c91f77b7f55e38c3fdf1f7ae603bc507779d85513ed5b3d66a3d251009f659caad44fa73bdfe67bdc2b4f8b15ea63bd5a12a09d63c1d15eee1386c0c6cec505d73f86492853d1de8699e22778ce4f4eb0dbb0ed16a882be331b20455a07fc032b528c4989e4d1d8f9bc18f2972700fb78b87cb1716a3824d14c0ceec5316017b19af1338203b528647618abe87cf7c47f5ba4ee051975e3e008a2ec8f24eec34d499130302b429e92c4f0f486d50d7529775fb3086d4d60e91fed73ffcb57cdc2eeee0c8df778cc5b1ceba9f4429c03cbb1e9c566d7bf1900c5411e96f45492041db4e2e2de499ae236815b653b382c7d7a225b34413a8393f97680fd17ae6a956bf7f3dbd53bce22a86744e6761fa781c714515ef4f9265c72250eebc9dd5ad3f5ccb0bea446b558eb9be146fa88a66315350c39e36cda3ca4fe934f1744866ebeecbbe837d46c587c11d7ff942c6120ef2b5744d0c7ea9e4e887568ee3e0160f89309a5d7cedd0376099f3dbdc96d2fbf5b30f78a36f65c0421365f0f411281f43753f01906208bad6b60891e16b58f7d7184814278c4bc6dfd601f628bcef76814d92ceb8d86d4362491c9d942411eebd8849ca6ba48c3d464f894d80caa1d1bcf07c239cc16fa1e540092b85280ffa9ce330b41f4e1422d35c94e83950a0b50b46801c2f96795d21496414737763a1b3b9d6531184b8da915a0270a46ac8da2d08884bcc48bb833591ea2d2ad8eb11f5f678edbae94906789fab5c8ea672b4155d63398dc9123715ff87289524f4ad9460363f21248d618f292bb4de8956675a49729d7de22122133bce1c57ca41eaf98f0ba24592cb322151de3d80f6b1fb077e35858791bbb9d2c92bfdcdac45b9193c1150af448ed152b8f37a748a208b2591115c77146a0abf781f822bf76aa4f5ff7a5705a13599fd5c79ea2f199c88af4e50d550cd51996cf6684ac4e135f552fb034295412823362e5ded3eeb54b11f5c30497db4cf31db7c99bf51823668c9b438f712dedb4167d5ac4a4d31ca6e406aa097b00530cea68a221063e0cc825a6bd83465835d30c62c2f1e21b35ad281b10cec703d3a4039dc9720f229b9e0e6cebade87d2f68415575e37e9f58edd5ae137b24c72267285e71fea28b37d839ff402bceca1a9492331ef37c2cac83779fb4f5a7c8a7040f041da20f860c8f82069dea5a710d8969ea3f91a4b72087c6df3655fa6f6e1098fd71eefe4e71f784837427e5929783660f621d42c0bacae70abac2e432df5cf50d9b029a605cfffa472f663d136cd5c7384421691855b137c5d06feddd57bbc133729bbeb9b43e049fe104e738f35d3ceb873965645643baedd1f11cac8dcccd55b72f53f3e13f465d5874ceeeaf13ab693254b2695dfbd015ed06f26cb39ec70d8da78b7f1ab957a984e0d6b3bc2cf79e932e8083575402ad4db616680335fcffc8f62f2b3e3afb95c7ef8cc3a9dd9ffa95096704227fc1cf20608a12d13d7feb5b90e596662fb50a7d899575dc91105a9bcab87c9456986043a2ab84549a8416feb66558469055db1f9d6713f160d7fc333fcdc40c1a8c39f91c23e217010004ad76711ee87485b6b13badda78d966b694f7303658af2fdce1295b90bd2dc3f3773a4b1df9efed21a3099b8a98b6c7dca4f9a78e3d6c08a3653a4785b9a2985ff01f53952907816b661192418d3ad3b5a6442b08d1688555249c541cc9396527ad41c8d28b039df75a0dacc12d38f33fe35f43204ba394a7348362f3cd3a7c1b183fe6b7d129fc3f033d588cc1731843fddae2245a2d4b9aea2ec345ca1f06f189aa7ad1483afda8200b627cc2d4d49da53c1af46563ff49ee9789649f86ddf375d5b081103c7bc644483970c0b1970856c0cb9dfd127193350d9c50da55b0e1721d373c2cb0b287ec51103f02970a1674b78bdc137401508e9c8535d679fc238cae29409db200e6dfaa3b58f7d868d94ce9a75a99e62776e68e61afef86f6f30cfb99eb73cd8f1f6f2fb3bd0e4802026eabdabb7219c6be185a2054b61bf84552b0ccbaaf27303e395a6c493f927bbeeb6162f80cf6b7c4c527bd2642f3c2b9a16f016f4e813bdf7a5e542c7341c763a00d321053e8eda01b23a1f703844428af1b86cad3c47986db4240b522f5d8dbca4f211e52e5b16ffd662c56a4c248c358d59b984068fca1ccca11158a1a93787163360d9b0f416095909e1aa4a9fda9996762ca11e17434fe8ba1af5b0c2a65645d2d8372674fb46a0c12298511fd6b5d013209e1a4d441aa05a222c63d5b33346a5bf05e2d61131fd260d11a6d936d639284d10c3172515237e99236e3abd51b7e33623b08dcac22c767ca81497a08cd2c0a7e6aba8eeaa2c1d35c7afd608a8f59b8df712468039fe372f5c464790062105572280c17fc9f21dc937cebb48931f27fc5856f86afd6530b867564584ae3f9887d598bbe4f7f0c92258c4d0f12ffe4e12eb60f5fcf20cb72f71537e4462df437b00fab102b54e4970c93a2ca9c1477bcb1936610e839efe9fd1b0fb1397386098e7269f38a900691826e008e0b9729f9944a2130eb9a323f82c52bfe47d82399c05d62e976fff8198590ddf7f4d133e631f823c939df867c6e7805ec57a8e0bda89aaa2c9bca50474eab98c403167bba48da3a5d19745082850e28037fdffbe6ee69cb210154681941223a0ca35b86eae20dcf0c61c5882a2ebca8de4b1d931f27477b53dc6b984813c4d3ab71b2d1d36942499d6631e8ab44c11f97d2bf3bc0cdf65060644166667eca98e2604df0fb6c8f3b5b31a5205108e39fc7d6b456daaf640606da3bcb124fdf1eca3862b0acec16134f3f69a3213068d8e2b879ec1bd8de1c334c2f316e609481c33d7ea114f9a6756f0c2936da1f6a8d4f90b5e8972754977ab5212c1fdd711f25ee922685c1907c83182e438437ec2ff304f86fdceb38a50b08893170bb6f3a26b50777066832a0d9eb727502eedaa4649319e3c9e86bf44354b3ff992eccd42a7667d575e34890b9a21f08281d162d547cc3881e9d51086f768d354b01e98ba8d742dba4db853bb28bacba177259274e0a7db153f697f6c52f987874dc94e3a1cfc9456b2c57cedebc61752ff8e4d655d56a3646325378dbb9dca3ae7657b44741694c854b72bf5d373ecc55c219008995c9b1975020687193fb6cec8bb01c07f97ef29aeaf4ad74a96d4f2d85d1f126f2f0117aefecc5bad94658c73d710741983b147afaf4f0a75e17544b9806b4dffd4b8b6464a3aa23a31edd9036277a8c0bfa0f9a8638a54feac2a35fddd4dddfedc782bd23f98dfe37934157c448914f21595b9ebb21aab5439bf5e4962fe1c9cb98e4aef79ae9490a5f945820cd4a19eb19655ce1d98598728c4d9d8a7144846de775506229c0a75cbcf13cc52f70b80ffc9e17a1e3e0809657388af9649bc36ef043063d88a92bd79250ec2c5948a98899ec8f3224dcd8aed9df13efa3cc2056bef185841bbe91f9de311f0a941bf5f4fc657e52137dbfac1a7e25a6a6a180dde0db0bb244d010872ed84770e8b3c16c9016fd2b2e97dc30942fa690716b94d92f90073ec7be0bbce728ee853d5e779bcd51d61460d152094b64b6232d59780fc8f2069d3be5b5497111f48b3b7ffddb6d1decef69f5c5e394251397ae3566113fade15d749347e2f87024dd1f77a7c198afd35486e9e6881a77e700ef748467747716d0e99516c35480a95f40d9afc4ae857ec4699f92e3ce0447cee394e5421279ab09274fd57fac1f1ec8c23d7e973b22e77ec091affc2be45e73a820b630c010883414b854a909637251bcb1ef5ae423bac5093e40220f9a50db3c82b470218ac3beca904eefe094af34befac9a9a3747d7257a2c6331ae452aeeef1d9f0744e9aa7b13c797214ef2b87498ab43c58e76515c2a0258e14fb9fefcebb9dfdb5ca2684739d307097df7f64f7b1e7f85decfa59ba4a2951f59adf9155c7ca43844a181eefad7d8d72273cc10a2674d613aae234bcef31a14d58c8784ec1ecde8cbff9ccd0b37f2a6afad314b40b9cc8edcf4495ddeca09edf6fc2872f6bec01d6007c839bd49e36e1c23c9c75304993511d5ee12992a389e670e0ff86a1fc18303a4527bfd08c603dc603177b043f24647643cd5583c7514617e0924184ce50a62aaa30147c178afefa38d90a503f4af527b78bd246cf5215c69252f97cb54e4c1a46a1fac3b4ff14149f5919d6815445846dea8e15b404298af662f6343ee3c78127969fafc04b15d62241dc7cddf57305d99cda63705418dad7db2ac9c0b3c878bce76da69cb1aae310c524de552b21411fc78aa009a7517754b688589eaf608954c7d33a46585b46f35aa7b774bc796e1fabc4a625ec2217025c21f9cb4ea30eb5092ff552e86b2154721574e2b4ff18df6c2cb55a5864c11fd10946923a8d07f27e10010c803bc27d88753b194c64c7e3533ca6466a8fa1a45b551eca4056b9f6347394ed5b1b40bc529e42b78e5677f679e177060e40a9f1cf8cf9d5553b885166eb5cf4ac83669de4d9aa5fd4d35ab3270e91cc23141f63bf859d9e58587a6493b06e39907d219b28e9b54d594a2d84db27b2d59b211e048f9182e1929dfc021102ff635c20a3c8285e0c8024fde97797bd37fc8892ac221e0fc457649b8d82699e98263d9e38f2002d61c36f127ed6643168bae8786ec7e00a54dc8d9f0fb66af09fbb3eff59c2e6d9873270a2c67572a3f588b8449b7e006391cf5af194d8de1a019a5109d34d3502f3bc75550669574979d3c2c561c8fd333006eb15717356f38244c0a3de8d14b344ba5da930cd248feae7012b2d40a160022f8b64a6af4eb18240e6ed3f5193be4d93bd17d34917222d0cc2bc759ab32d450b32c1f6078dae79c5d3808fe8a264d8a084a2fd7e625c7db82f01d49e36ffeeb4e25c860dd1d4c2885667d94aae8384caab7bcc5956aa5186329d9fe6160be6187ec2de19b809e913a1d2e7832eb548ece64df2b545e660a9b8026aa1b7971681bb956b6208bb34da520101c6f08d48416a1ca1878d51121a5deabc510a7dbe48a787526cf9e0be9e90cc6ddb6fa379f22bba5f0ba77935ab87b8ae52c347611c916ed50e6270c687edd0079669eedd603882ca61dec970ee672b86401a31717abfaa3e8593f37702c68b608c16aa55e847e64162e5ffd127a69cbfc3acdc2cbb5c35bd31e0facaea4f2801a55f1dd2c0964d10399458dea470f557cbef3ff1a3635796a9d0cd8912e10ebd48e11df73a67e9f0802dd267a770e898e201362060579ee1428724cd85f7b9e86fd121052dadf80fa2a583a484adf82ddf34369f2510843cf712bb2d5dfea13b4497de6e1469f2467dc948b0e9780c7dfac50de18bc85d42731776ca309ed468ce9427053903eaf645bed90032529917529031fed94fce73705ec6ad39320075e17e3c715f309e1dd76bb94011fa0d6977bc70d903189c799f8429bb229f4cab19a01feb1034b784de0206f285e833a3459f3ae5520082190ce622ad2a9e283aac021f1cec28ebb98b56194d746c6150d2c7ec834386966f37c2d70982bde7576e250b7a77917047bc92d93bd28b07ef9459afe803cf06cfeaa70c043ba6135bb3c9d48a57eecc036ada3694f67e02d5a3fbfb3d05ce767d02bd0a87df3464bb67c5f5d1b12f57f78aac9fa5a0ece48a7f50fc1c4cdd28a9035dce21677d91defb4834c28d071dc1f564fdf11b5f9b9297cb5dfeb7db41a23ec6063946fecee570c4b3c61c8b1c91d360c827c9bc92cff722b88eb5a9e1a76534b6f2817c48214346ba6a7bb2274292a3f3546d59367239ac1908e33a435177d3247ee19ebb342854e8422228ac1aad68b8a833fcc6238acfa0118cb0b611dfe2a9da05d9b583c288db4421c114c7d09430e44ff9c01041051b937dcded2965623ba3508c4d55b52751dca961f89de2e0b3c440437324cffc36cac0ffbe0b69516d4016f7b3fd076488d977d5b91f169cd686553c818230ece4365e9e49318a20ee03c05b0a940a7ec41648c770801b8910e957929841e84ef835e52b81b3c140bf2e31e7be8fe76043f6dd29c2dad9df5fbf2766aaa198100a35cbd957a253d782e300f2a992de74685397b0d3d945730bd5ef4947f2e309541fdfd4a168a422428abdc37fe8231a6baea4f4214e202f7a21d6af329d865bb909b1d18e3ec76108f5cf99d05f1b292cb1808defd43f185173b1e792438043facf67a2438dba20b094a5bc1e818bc55e06bf5e04f7fa6e44f2b74ede3732490581fcbc6db33f9e949db81882a3317428cd7ea5c595d29b569979bee4d01d2b52d70e0ccdb21c7da5b3e8b56396b39a00eaa6cdefdbc55d9f477641078fa682af01bfad3f122f2eb8cc48375fca07b9852f946e571138e069d8b0d57f7eda8650cb4daeb215a6a256eb1c365417c6a855c982ef76748160488e366080d98bd1a899c44eba4e349baebb010f2171573072b016bec9a920a0e6cad52630ce75808bb6e6c6928fd66e9e4e2fa9dc3275f207b22df40490aa0922eea11493e146f8468b0cc2671d04e9564587db2376346bfdaa10a51a586ea306330d13b64e2fb99af203383723e2088232dab13d85796f03d34704d0171ad0c204ebfa99fc9eba3aba8f04afb2d46a4381669eb7745c648ccd4d9c915db43a7d74298ae4a09d1537153b9c0a2d197385e094d5aef15cc36168a0e5a720fb66a10146e5642fc743c44fe9de0b062ceb767e6d113e1a7a4f29ec23fbffd987cb810165a3df3747cbb58ba990e527b5b7ea77d68c59910b559b0d6b7be31fafc7b494e550e08350f3006418fd7f9651ec7e32741242a95000b75811ed91a181ea1cc0d76be429741e4ff2d2171fc67d0e760189867532e670a45ff45eb6705c84b70d8f6a0fb76dc6ed50f0771b0341b4cd0cba5dbc038932fb5d472720659b7b74de5a05b56363b3e048b27257d37d9f547be383f649592b7ee135435800fe9b2704ba80ce52d7dea7dfa2804037114eb21731a51891f199ae38ffa390590df2a15dfc384bbefa1ad2b273c92d0c3155b15bfa1a768ff814f9d1f43a2899c54c5a3efb519afdb2ad03d105124382e561856efbabdabf3f1e4beddadeae0c84fff98b00468f8367d4165ed02137a049e4f9cf9d804740c43bf31717a7d930435ea6d7898af27006a123f88a433fe1b0c038c2f3f89f77b4ffe7f1ff5fc70543cc96c0afc4675f1a511e80cae084ccf133729f1e28bf2dc3eb652bd806a9e68eed6c4544d5a7323d10e47c698767e7c5a10bd1ac941c21402bf0306f98f9d1a53c0a3b5361ac97dadd3d4358f28e3182846c7a4fdfdb0f276c45f294dae6c9dae5144311d839145ef31aeae65d020c69aa930ca70e7935ff83499d1978bf0668c04dc6b59dccd9f7318ac8b748ffaaed7ac368461ba85f18030dce322a701a286babe91a3a92a40d1d7406d5a604c5492a7372261f37a58559f34ad3639a3c40c3effab75b83693cde23dc161aa4f2841b5ca320fab91e289da3fcc68e6176a7a8f3301641dbead2e3a37732a3b2e139c30caac459d492a952f5c28c7994c41b7c7cb9683f0e9c391cdf103ee99467fa7b55ce48b8306f533560fb35fc542232a6e07da0244c8b49351f625ef446bda6519891d728025fa57c20951ad531d4bcf116bb02b984411899b9fefbe79d432908f4aae1b7a311072ad3aa5dd919480f4aece699a17d860531997762515c78d8c2b9b6044c0536ee3e41ac24eef95109f36ebe277a40eb1b1bdff2e05b4e0e959e8fb8ac80792bcf9489cd10f0eab504875ef7fb240dab46b4160ea44410a132d9bde25f13e07e0ea56821e18d9f2027b51f9ce876b1baa136f070d1b81882006dd8798752963b82e653557ed19b38cfe21b6fdb54b6d98cd3752a4472b316f1b7408f6980b38563eda30eb48fa41040b67341fe543cb651f62d6d86b74bbee8bd1d0bb782b66777dea60abf656bbded279fe504e883ccceff7ececfc1b59aaf2d3a30b5db8efb262f8fc70530b4bbd5d999b26ddebee5dec021dc0fb476a2ad5855e13341de6a6be25d50bb13ed159e07749bdfaa047a9df038de598a8ff2978668034b0cebd20c8b7e49ed48c68a75ea5b98cb5a6b3aa6199134ad7fd666050fe12579d91ea86526af7696faecd1356d91d6d39a9ada11e314fd84b0142d550dc552ef02508b5061413cbef36fc1a6bc05b7ee15cfbc49b7df7ee1a7906db406915670d55bc7fda96104f9a7e5ac2043461d3f650cfde9c32e01e65195008545fabb9675dedfb66c6d35fbfd3d79a8f56fa8e073e880c878bda97c67805133a49bd6cfdf06a9c828df16637161995f183baa7053ab4ff9dc7eb00624d0ffed6d9e82d18afbd2fd93c2f43bd4056eec9aaaec4c7406664cceeca265630bb48256ddb12fa541c3107f143999d4c163070ed2997ab100ea04857442153415a782eac23dc66074a2518235b92bf54eb173b6c5abc03240f18d41337a4eed421e3c6f97aec9172dc754975a4718cc6d01337f05df11457a05ca9ad3e7352cb81381f5d52c465baa10e87c9a1c067bcd17d992c0f69f8ea571347a1cbbbcea38af14ded572077544b1ff80ffccd8df68cb0f6ee15cce4f0c01d41263de9f53c6f28704b314dbf02ea086aa434f214d0217d5e69bee2e35524908016df0ded322c84f2406f88cdc0ef52d04320dabb765acc2fa222661da32adcc273151f1bca1899f5fda547f5d01737bee56f8ee9c2c32af84489996bea1cf48fd29883c81d3ec2f12bf003542a44cddec1aab8759bee50e806fc689e335912d3e12fbdd6adc3aee04f8504d2081cb08b988c0a8767c0521e89a9004862ba8fdcf7fae4d8885995712acce65775eb01a80a8441e9b80925475fc718bde6a3fefdc7b93a3a5d79c79b35b7e2f957a4c034141fda62eb5bd79ac7d5324d3199482d0ec042ddc462e384512dbd0efef2442f89fb4dbd2e7af131114d2f3ac43803de07fb268381efcb0cb3abb30b1247dc5af4d331737ac5d79ca3c093ec1e4b138a94446fe458c3891adc800df1737a56175777923818e1613b47581b6b2cdded35bc753526ea107e4a4326d7f490b8c92a882159cd69668255618d8013b71cacb63ba8ab4b2732732d3db862dae1ec25c94fb1ca31ecaac161fa393c208d203ed3e4ffb1a7f02485c52e8d6c18626be15785d4622ec2c1ce6c0e6d2c6d63b9d9c7a822eaee194b28a538e3f53c1f200bc40b8a2526e5df07d7c6da6d4f2a4f142db2e2ac3784c24b44de1bf6fa37cbfd580097085e6d32799e6a34e1c708ddf8f001ee1bc1e65f96121aa071361d5cc6937ed2e0deeb956eeb8a880c6c19f957a0a9d7fbc98c4f6995d4739060bb15330233e7cf310892a18cff70e75204b20e21b18724cc5d3f4c53868330044003bdfcf3260fc9d0dae04ceac1526af1b3f1bea153b20b14c3b6d640a218e82a64a631d9a9ab609c6bbed2d5e3b7140f3ee99ab7c079cc038da8e871702ee78cf5e715e486ab88d0e15c26fcaa90a1a48cfbad18f1a74ce5592ed104cc5389fd661c1f11a022291723167bb34045cbb6467323f1f765099f79c5ddf028bbfb4c29dc40b1db91b8d55943efdf18d85503a2f9d660eea517a8df1c1286e25db2c8011984ef359d08300b69ab66d55c5fbada7c035d3a32561efb6f29f4f11a3ef5d90d85234f053f30dc2ca00784ac0499638e9fc6797f8bd66a5ffc3bf8996a8b13b1c7cd693e9280e5b086ea909af08be78b1fbcef15a891adcf33c6a1cefb1a57d1d431df40fe91664d26a4d8f03e925b006afdd4dbe0053af0f1b45ae51176f165b7b7854b898713723f7489875d9f62c3a874e17139f5531a480e58feafdc639919ce09eb6aefc323b6e4f68d3a1c0f1446222f8b77668516d2ebb522406331c522fb486cc683c0d3e739fbf5f0a5f59259e87e100edf1fd6c7a080512d5d1f3e9ee877ef19eba6db134cf967e85f902eb8b05a1df16627e43111d79c45af007ed5b507ca9ccaa3df1c28baa5546b6bb1a48b02289ed26bb724bf8438f45eba8e211701f232de5a47e9ac9eab94f9685202491288b73171ffc6794c43cef8553c7727a64f08ef37c31a6aaaa56e232f12aa8dd98e5fb2cdd9eba5c176e0daf00305aa0e506fe4b54e570470507d968a3d94d1365792808f86128d1d47ae54cfbd49e11f95eb5fce7a5656ac13776c88b6180bd633be61d3ddb4509960d362ccb7e3aaeb072f55bb11f6c8a46a53c97a8a96701689ad40ff5f90f127d33bc84394662b46feb16a22c9e50f58bf7f3d618855b5552c6f71c07a54e5d9cbe1131d21a59ab424ae952f78525cc9e531ac4b926b723b2787a78ca1582b74f2cee73dffee950ee56917e26d6fc310d957cd60d99f78f2e65be0bb4c6b9c987b162eadbc91357fce66cfca7aa418d37f8fdbe10790af5f3606917fb1d59807409655e31dda3b66cc4c3f0118c157e9a7a57826fb43efd3cb0197f4ed12ff381b190920f7c5727e002aab3877029f4a193d7ff36140d7de7b4fe549d580438d87e4c0f8bb15b342f53db8802b53d9f0c4e333c2a7d375c1c375b76488f0fb6566a781df1177784e9e86c7e1087457bb3aa40528ad3fb87e14b92b455fc4db78c26147b6ac3817b16cd17d945318e2843647a4a3c95847c80cc8fdd22b4e290d5795d381ed721cb9568ccde104f7959ea927725a28cb31867e596cc6f040e1edd9841b44b25ccef8370d8cf5be22e8c733658166e40b0b1b8eea663b2cf2122b30e3affef210cd945686dc52f07ca6a4102728bae5c608e937002271738058f98130901bbc662f5831c65815c570d67343f16925a34eb93faf0cd2e3a70f99a063e469b53581e79cc2217c4615a1d49b0f94145a02158f20d45ef0bbb648394a365a80a2aaebd7e2aaa3c30bad290cfdbdc9d1db2474962043bd594a37828f8df9980d7510e4f00f13be19a28ca74fc639b85394d59df61838348ca2d844eef16ad72853db955393dd5dc4665040cdcb5be567ebc1c9c6c6793c55431ff2feebee70265ae7deb7a32579b95ee90e41b2a70402e618d129dbca02e52cc4e3e783d44c5537bfe815184cb3913fc046449bd277964f992c1d0e67f8da420c12aef3b599a486cb2d87cef378af7a49fbc66683481e16fd5726726571dab9315093197ec41dc36d171bb79495b34de3dddbf692424e2690019ea445c8b1e72d996509d6172e4f6253e8c70f4faaec3fc1f4154c054d8b1a5ae9976dd0d6ce7cde82cd8f6782cfdfb24986ab0f0c11fa67a10949d9dcb1efadc4f8c5007e2d52fff169cc3f0962dd44a40e8d45c708fdae1e31dfe1d8524fae3a7217d0f135cd9b322824d626ca6e42ebba1db81f502988a2291446a82b9c193104acf00130557db4539c818f84618f17e54b3d9976ce1aa29a1a42ca0327e78c08d59b7470997024f79ed080b7238cc12d3496bc29d42bcf1d99a81c46443962a57217e06f194a5fd8f36081a3c8d463eaa55078e11c6c25ec2a0da568287beb0c524763978209c93333a8243b7d0189856264f7e9c31a4b76ddc22e990c5bc668084fb3786077cc756e60c79cc264c5e4c3cedb33920a4e317114cc031a6d1771f26220f2a83b2c672a5324577834337e38cc31ea275e45f38c2568c070675f1cb54b5ff524cb3af9f9ca219f8c73cc553ce375d6f45e105e4305e87abd9f5f4889fca246a94b81bacb27073c61b497ba803b77283cd78bb1e33ddeae505262ac18e34a5d9857e8beeb0b136b49ca5cecbe28a9a54f2d5711f7be5bea4b478911030a9a4a410ba397fe95a77edbc48549bb4313b233f06b458828a3c38f75d41f5fbd5bd2de14d5b200b224fe8d6ae4a4b6b9ccf69511819b80a883043a414b811636739e77cc26e53ec4f65ce4427f192d5eb9d47318bb0f502588f8b308d462fef136ea702895b992f5a4306d7be5a365318361f7aed156960d8e26a9b67d240859802697ace97a439a692a86f28c6de004c6413a2740f3f071bc407411a7422d3dc950dd5e7c1cefd49746bc3d2e11dde66d3774b60a4babd4a5b08993fbbb3136e4728b25a1be4a460cae57718b5af5119b5b0a8775a3430573f3f94720c4fcea25e656a168943693c7bb53a0e74f61074bf7309f5563ea7fde0035687b4dd82a37d2644e7ddf0f7b2d94f39a4c7d2ceaabf8454eebc16c32db2f02805b3a60fdb95c1abc205cd0bc5700b9dc12a1c4de959874c566aaa4ad94b6a2e14c93bc8871bc1bfd151cac7848b20c4b5153ee0bdc0e6d328077341aacb724bfcf488f23ad41d72a9ee486b21ba9a325436623abf4278a80c391035a90d5c08c9c868d1fd2982046400ac34bc377a529585737ac84a3de53fbe94a65fbeaf7f4d59d6fd9410988d249e41b33667c17a90e4c33cfb5719b3df4eef750e61c03ee46ac7c3c18b35b102445ac184ce658527c52362302997da7c85d5ad1830682cfb3abe887f22053e33ac3319eeb25b5921916d3d3a4e0ab4c7dc9587d5177c937f1ee2d18e0cfd86f04d99812c9dac82c095d351d406cd5a87c4cbfbeb27e2e600bb290cbc23529359b52c9ea464923979ac8bb3dd1123cd8deb14937eaf2e4eaad1524858f3050450291106fe7e368acff248d48def2374d7cddc2e2e350b4b0c08cdc44f504ad40107db5913768fe0dcd24a0e31f3ea10b45e5bc4f4a91a2257a84235c75fdceb7bfc9cf0c7c88d0ba282f1c11924b1706793a6d7f87021d93c74894f9bd2805b91205cbfa68c0e7c7e9535308ff92fbc5dc6ea4f68a47dfd94cb66daa663f9782457a02f6639bdd7c7e9ebe33b58de0b67fb195511272266fd0a96facd054c7426ee183cc2807d9e05ff452d578df35d709cf4341d2a7c5ea34c101d0f6b0567cb40e6cb11e023386ea845e507430f8630c0b72e60cab23f1d99ac7cc7ce297b9e24e0c214480e018ca923ba3da33d5d30c486b6ff182a3cf1094b726304f0d3a4159a8dafe95b4d0aec99d224ddd80c49c041e39df1a9b4e8dc82de38255feeef9683f7910d6b66bd24bd94ccd2698851f081679d090978fd408fe60fd0c7b6a5caf7d6bf14968ad7b38fdc35696bfb701b627c12e76ec29271492ade90c97120135e47c0386af25402436b67fc58cdb858689ccc38ffc219afb012e726d988b283d52890085143b1a9f406cce98dea688c0b7473b6221048d7c719954f43719774aebc3cb345c40a31a48e7a222d96223bd2c8a3417773d8b0b9f78757127702c6bde619f5b05a236fe1ec9f73e2848e097506511e97467fdff8aa0728b54a50731114230ba141339de158dd8f0312a28995745bac2275dc4ecc50e1716db33d5136aa9add44e3a83d028d763463a2cabe4bdf36c7b0233d94f457d83eb712977b2347379ed09f1c34bd008644abe17054a47aaf6d2ed49990cfd8101406469020a0764c8d7c8f2eae1a5a1721d5f049b11232b6932a61c3dcf7ea2a2227a8c85631a6a51b8dc722370e13835ea4029e88f15c5084f660080a65d161c308c862b9c4e14c6d1e33a33fed98b19bc8994d97d3ffabdf951a3b43dc39c3c557d3cd7f4b0cbc414c092e84689e8bb8004e1271890d0ca88c4dbe7340e371deadc68cc9ee72efbf80c60f220e1161d821f3881ee5afc1beacc12df22101ffa9f1e91bc460045ffa0b5610f6765117d2da8fdd1b4ecc9d34eacbc614e783a48cf3915d38c810004cd0bfef533c7f561f35ee7a2319f946fe77b42e1025be382e3ab5aab2eec282f158c752f3018f9aa707720a4770ea9c5cbe6679ebe1a3a66bd69b0241bcb0171ebd4c9c071e9dea35fcfd339c07132851eaefec48a2056c6af61e390dce8b5b61f11b808cf80f0d1a036bf0b3e59123502dd506400ea4e802131dccb5832a9a708ff02b98c87bcaca57034fb9f5f02523f1b50871f9132a6daf3137082fd0bb782bae1bdcafbf6c8fcca3ffc9ac8acd187e50aaf91e7b944b2d32842b15b3fd98d1b8b5ce747932e1287f6198dca4cc8fdc415079d30f75399c220da2420a963aed996c5f8f1854377a1fea8fe21e81f494f6c3aaaf4a2910f8f9726f2ac78eef1c5198fe7adc6f8f3aea259ef86bb7e1030da649b7aabdf820fbb2e3104f1e339139e37cd6e7a20eb0163f1c5e8a620a8a7d9ebfb83e9305aed153200236af95d79c4fdad06a90b345b88901f1ccbb4dc1d88c0499bbc6f9052966064deaaf74a423690482820a14137e70db4ff93f3a84488f38fdd5621b222157d981fbb4213c0b507f9f9e0c9a466a55cfa84eb8d1550ead6ec751d19d85d58bfd7845a267ee56b1a257c29a8319dd8b84878621c0ccb959230bed524a59852f00a8c58f7394e2cd3a64c041a2909c18c4adbc74a072afc1b1b2fbd0e6d1a2813b251f5f9d3ea037a1ce623c75c719bf17e780d3a179443f87ee68ee8d3e82ede2193a8daad3432ccaf63de61e6a3fa223a28a4dda50617d125c3f1ba578ea8acef41f82f47cabd2c82abd0bd2015e8af38c762df22364165412bc228f8a17723434c1f99a19f485feb328a37bd79ed7727842f54be1140be19db1118fb52bc933d4bea77b8d68f75cc1b6b2534078d9e80dbef9b5a53698c3f881a944b7f5076c54925952c869cac48fc413a65a0f36f282fc484a795fb58c6a17b4917e293db00d91f3a97627fb77639b8d12c6c6ecc662564f2c0898a52744a10123d76a74f51578a8951e5736347a342136e50778438d6b18990ef8a17f1f04d77a1035dc78d5106aeefbc993709407e3333afc59b50af94673223ef4d925a261917f8b9f6dc3e1990c11893b35f32640dbb78ef9d15dc238b4415345dd0b882e546f117dabb5a78667e43642c973e63dd1f1f7e53fd910fa141c6a4d906c9c475d79b7c9755a0ede0e2e50cbc750bf9e860c7577ea8566b8bebf8621b2e9ebf6dcfb3ec0f7e0d4cf2b48db8e88a62c81ae70b828f6b7c7792bbd607698718be2cc02ca76123ddd9e34e7e6dd8d66deda9c4461902659439c3426e3bc211b77af83ee10761bcfb7fb185a5409ae78479bc5604e2b9d63b05a5f7c80c1bf616cd853fd53a57f82969a5ca444846983a818c88d2148b8ef324732f06bc0c853a887520ba0ee793e466d2b7aa25a384d98a560a9ada69e02afc1d045a02776503b7df7e74b24c9fc2d04a9465ee6e2a6d9479d47bb04632d39231b7be66bc6f0f4c05e620e6572f45b9b54b31b92f4271f8324719196d42c1dd6e29a0492203373e60908eee14fef0209e3890787f80e186bee57312d691afaccdfb11806016a029c9664e8de0d404e33c594dd20537fbc4aeafd7b8e1708e062740104221b9cf5160a743f13460bcf97a09faccec7655963cfca4ffed3722037215f51a9cba17da9f165c3e553e9c4edeccf3bf18c74501e8fdb7f3f4625e4de25a27038a9343d1a351361d3a637ebed42ce537f724ec1d75e11dc79e7d6b8cec7be714ba76b454781716194f7f4ad566d6b8f09044fc5263b645c42e587ed99c6e65a9466b37096a01d5489a21247b98211da36a057c953556d3d986e2652ed0122e04408ccc10bb71097fcfe0b329ad604f4719ab762cbd8e92e06c6ac4c8c166d8c1e9f7cd96533dc92b941b360e7c5452b95658d2848b06245b30716f574d8790865e0cea206e73e972e5a4028a0baf7d6aeba84bc6e83bc1a78756f3e92f1078166b32ac7951484c78d3072a5211746cb3fb8698fdc1a7e38b48f8d496b69ddaeb375239625777c9ab108ff064bca37172ffb1a48cfb6f9319c1b472ae79015c9430a8bc20d4fd31df4f500016da4fc3fe7284665d6e0b40ff7179e9ced87b5ddc45ad29bb699253aaa748b8a109edb098e7313c078798e70dfcf7a04aeb59ad3c7d1192c8f336d279e1ca557a686e0952bd7449e1f9439341f61cc6c9a86946d472949719be86958e5e3ac44442cdf7b0a79b03edbc08cac3cabcbacee69ab2a49cf38efc931999d471163a8a512ab1fff3cfcf6e7ba70aa778c2987e1ce2aee7a2ca26385caff84420ddba7e8f854324578b6a3f5d5cb9cf2a8690c91ca39d016de85467c7bc070f35de1c69993448c858a911a2f511939c04a86630077488ae19ebd8ece8a5a26164660dfc0148f0e9002505d4433a75f2fa34e7c1497bd814a4085795ae0b360e829897da2f893596ecfefe1c305235b4f617b48e1b5472296deed9d5211ce25b6c6d0874ae1c319583d5b1afdbe519f19cc245d5cb64e1513a68f996f71fa8828bac41068e25fd968151f2e94535bc5bc1f59606953131f4b5708fb201b054d9e8d40c2469cfbfa228762d474fc1fd0e558e18d6a30e8cdbbf38896764e2c48d2473b314d0dd1918383dc11767bb713bc210aec2bfc0ecb164e0f4ceae81f0c3a0f3c9b5cf0cdcb61847b2cbf5a1cda93c2eac7d88b7c617a50f4eb187e7bbcf141f5dade84ff6c310437838ebcbeb582654eb8d0a11000bfb008658c436007b73dd46f33e7427b19e3c377ba0642dd9872e1534503aa9d3d096c780cf0f7158798d8c32c681043bbf2a24028a5040de27b93fa8d3ca2d299252dfeec55bdbdcaf2cd46322f64f493b2164e0e983d395ca1ab9c8eb489050e1dc6cfa05db453e28b28222f450a9e60258a13b748755b853aecdfe142fef42d9e8cfdd50053caff5a1e1cd96c18a010a499ff3bebbb74590fb5a6086acab67a657be8ae09b42e469d9e8a8741c207ce67ff019c542b0ea3d9662440470917e87af680473cf1f89646aabe0ab6f0f3e38265154d7442bb03bcb90642a1cfc3773390fcb23cba6aef0bdbe906b3634272472dffcce213cb6094a26ff03c62085a2fb60cd1ce52a530357b5d3b33d629ca182ef38b54875c8c9f4e7523850510fe7750f463381c335979142fcd2ced6ef9d55c097c33060b5cc7a9827f06c3610c228604eff013223ef5cbb5495992b64daadcb5f5816658d3a5415e2b5f44d1e43d6db86baf6a210f616ade0a2f78833c3ba5132432104188d9b2c8e61bd825da81e8d45b19f70f55e456ee10922c2c1858c42a6dda3c0d282fb7abff4202bad113851f7f196c3a1e993b0aa0ac634b1021c6ac98112830f59c673da97478ced0587efd816c47b27be7a19b06f4b735e299dc5338b805bf889883776c6680be571dd68fd6ec309142b8806993cb3dc4124b6f6cc59abe391bd91f10766469f441a39558ce38c1214047072a0e40cc1b7d03adfd330e9a1cde34a4397c12f300417359a1bf71f04b059ef6f2bb0fa74745fd4e782d609795a4bad46fe45d285ace62bf8d1da20452f874dd2e1fc3d1466bb8cc692951cf8da4956aa80a51aace06104fe99e824fec09d1fd16750d4b58c5cf02781c8b5bf130b9723e5c192567d0825c0bd909e862eba520a10277b9fef6b7e098efadd9d9ba638a7ad995012b8bfd094f841a0db2c3ed89a4221503c1043a97d45cbed096c44482b51cb34457fa56a62ab477fb1b18884b992ee56ba019d0c1b114166f6ce595813a291f99c3824eba22db209ac949578ba8301a56ea9beb22d4c56b1d4d6527a1bb9c6a3161891fd96b3e8f75fd0fb17474e3ed99a633ed975868e36af14f60754be41a3bf2b666c44e5e371a7fe04a5b323fad384cbc3650003f4d91362d28f3eceb41bfb938ce1d874d35422ceb53302929696b79b7ba7b9fa65eb30145a28f2d66c1dad9558be9518c2a50172a57e34afc2f2a8ee8b2279f78e999007856024ecc484aa403ecc21e24acc74049885a5f810f5e25468ce1cf3a0d0dec897b437b62d0981d51f8140d5474a1e2620d4b663babed64fe00dc8960b7b4f3f2f3bc1ff97141f59b5016459eebde2e1c2f499441cfbb16c4190721e83d74ab3a2e4f7aefe41b406517d0ab812fadd26edc6fb9748fca96f46367d12095fa2b6c6ad0b5eb8530f3d1950f94dbce903d960f24a43fe7d578ce37989f3d4b9aba0d3c684c302c23ecee6197f9d10ebc3cac6f525531c62805cf6430e0a664b82476306a03ccf8eacd71423ba6a308db1018730bdb4106266fd3ad54dabb30dfbf9f30a05ab93d4f1efd1698fd291c98c5d7d6e1926d6867231d035fe367dabfff3eb1d554aa54ebd12219f51a9ff4d9804cc13709038e6fb50958d48499fd62b8fd74b64be84fb036661899fb269654c3b332e49b0ced998f555c4fd387dd46ae6c7ebda0e02e54f96215f50bf2d2702d72a79a5fa6e063507712e8127a45be5e159c175c6ffc00815f1ff61f9419389741b653ebecabbe5286beb8adde16c2c610627eefa04b218bd43a0f08ae0c6b68b41403eb0d66621745bcd3c894b28d155ab118e720b3808b1c6421e0065675b52164999e14ca44c586e344b89b8cec095e1d5ea4ec839b468025a9561d7e93afd208f04ee359c10484de72fbca6b9776e4a420133a4f2c76172917fc34cd6320e1a60f27a18b046bab9c2f045bca8e4f0a576d6bb32b9a8215c9b81f4833b52bc8e42a5ea73e726970c7c941a4a124ab805a0e8b35a36bdac283f8fdaa83b0730003261f7351f1e9b6fd74dd8f835721f931b7175c033934e93b6b28bb05ceb2b4317a95605843098d95dacd16de7434ed2f51cd1ded31799d1e6dde857e2a58fe66a2e59f9baeb21be790c883d681365e932e3f88918589b3c8459e6081ad3adb1c6c96fbf91ce5aab939f3b691ce74325947679bce75e22555c2ed668907f48a94c78c47e0ec69c86ef174194c760b7e37dbaab1ebb2cd6d7551d1e5a16adbf4cc099315c08c0f94aa81a3318c912fa1d8667a8bfa2b6502006759c27cb02040395a8fe3b789726b115a9733658a60be08b40a1e444f39c29ccbd84b065808dbe4f49534ad70775dfd698af9fea67f914fc9f2b2ebd67b5de6bb3c2e4e0d391882a918d24b8182cb0e9f357532b27bde292dc166ff70bcf0c0767f4e97fefb49d66a65f815df907952f2384f860aa502c4d0bfeede275a6a6d928150eb651e4aed319ecafcbe198ed149aa55c3e25f602217f57319e94adf0c28772b9d703784c654f08a07a31678a526f88dbff01a66678400f9dfe82916651eeb232f73442c70564c564340dc479a5544c3601fb010ae9e8c6f391f352a68d4ae19f182c2c81b06b47564649880b26b101dde06f01fc509b93903dd0aa79a93445e6e0add8d805314991f257c59057a802e4416cfd942057d7c119e75e1b12e0d77065253a1bfcb50409f2eece88f13942bcf44785093c176de7b28aa259d3dba173a0ba035d34d7b919e4df5698f900c284d4ffcef13f7977c55dadc3251e9fc39810e49f9b1a0bf79b5a0fe8a9e9c2b9726d3eafa74027060d7efac868b02dac23f5444535e319804b2827db24c57adb201a47dc7057a4cc6b6fe48d1292f8226225922aa1e6004f61da374cd1c6cd391ea140d7e9c88c9628a3f97282b7a9a8f7a5a57632ea4cc902321532d76b49417cb2e9729bd4136d0cbe574547875b0ecae97316cf6da14b7915ddf763562c3b5dd64272c1fdc345b6e0314185b3698241d86579085dc6df96747dc35c2504e98607b4c00ec3471383bbf85323967f5ed4e5409a77f49a1f80a8ecf7d821b07f9f960e733d0c0cecf4ef7b03d5146b72a54834b6f119f43617c5f5c3504b7393cd786ffcae01c5fb8db4c24a62ea8cea532601d6c44be84f811dbf4859dd1374adef15c29f84e3f7cc4b45a9f2b35d7d5599bf2eb284897d9e8a060026ca44636a584a4aa632aa4386d1ec32e8c77e8d3cabc346231f724fe482d4e26c13ce04f2e5cecbc07d91c44cd4786bc12f51cc1883e01e026bda97af28638750536b9b500a5e4bbd20d924c1ddffec050b2ddc86979b63cb58aac1d775d45cc4737c1c2e06ace960e8189460a7b57932f3016308820de7990006c2e04dbf5924816aff45d817c66de4250a188dd952692e1dad105d8a7825233e95911435b55ffd606c86470156d7be88381bb3db6d4aac5f2cd6686a7dbb2c9d3e21e7a1f484ba9a85728535bcfeb1d3d92363022a27b5a05a98c099c82ff771123214cf626db88e829f87a60b883aa0a42f2bc360a4d131a130ce0ba9dd2d68c086b57013b9f78d4986802b59394a1ddb5165c6a0dea7350b92574296ebfeb1bff10e0f7684bbf118c205cf4627f4d9c5e2aee743fa0df75f39794b7cbfd5a2a09f29066188bdd2ae35daa03a55452ebafa2c67d52edcd593cb308e6937917c78ceaa2662cb1dda44d73edb9c9b46be6d69c4f559176fde1889b909aa836ed4839755778e4de8296a21a05670405ecf03bfbd282d85acf3d527a279040072e2fa03d6514875aa905dcb92bb40b925307486796edd1b9feced2cd13d115ed4c071bce702c9db2a94cd7078385e603a42cb0bf6906e5ca457b3d63011169596815fcfab72e6b13051297b1e2d7defad3e0823999606841aa967f10718c127738158e9f32144eaa28df22a02533d9f2580e30208a371d851d08b94b435e0643e4e321da860d369a99026b52e8839c8a93078919138bf299540860e806100c41863d5b503c3d9cce30b1de2f4ae5f796b381e9f8ae1cc2c9b3e1bf6202f85e9421392ec18636b17a9f6ca74ca583460236f3a41d99139432f31ebf225dc60366afea4635737ca0f29b6ab5dea4ea98476ceba94da4a2ec5d9156cdc47ff10b687b951905d231ae8dc7ccdccfec0f35d2d7948332c1717f0dfd3c592bb347560c270a3d4603357f2d6a7fe488d5bf19f305db6de9bb6b9cf0e0ec0b65feba3875b574e95a7105f7233a179717da1f7f00240337a08e550b6163ecb249f09340d738ef61260bb0aed5bb39c139bf0e113a65037360109d6a4e644c796b9c4b08a8cff63f0095d4ddd399e8529282290fc5dff446f4f50338638e981e6215bf9403dfd4836a7bd59ff2e0baa15fdca8d678fc3b257a215b2cbf99a8d8fbd6e1f608e2c53a4170c20f2a3ebfa467ffffa3263a148e9126ae2d49a6db1bd85ea501e0d893dc8cb21362ae5fa446903f470b8f8d9a80a042dc309d099687581fc89a7cf236f1f5f1ef33849ce43422e7d6b64c54fffa863bbb43988e45b558f68950a3c42a1fc86688b83a62857a16914da00dab31f483c5af2412153c51214d7122c75bae340295e434563bb2ad387a9c9b52b0ccfe4a71147ad6c02469a11e5fc778dca0fec8a051d314a4588ae3fe3ff0d7ac5a6d599b9ae3cf6fb7b385d97f6a69c88412b74f44e8a26acb60b0ddd9ae6e8f8ef55a042596dee753c9095cf033fab318a70a007d5080464f7bfbdc2ef9c3ebfffcf61078d4f80fc6abee0c523024f7becc375a817691b09888dae16e2041c272d43f66a6d440e6b08c7675993fd93bd79c3423e2a075a2dd677a536ce4bbacc2e4d5acebe2fa420459a2c0046c6becddef686aa16b5eb31da9500428faebcf742d6d05054890b0bbbd5cb8960759a368f2e809d960d7b580d841701ca4ecb87fa40c15f3f2524066972aed3444e0bf4560abadafc5047c368db19a2d325399546fed4f655e30edf2206385c6cceb66b69ef81c1c1b5aff3c45172b4c57f8ca0f4951e4b431a6a5f0255bd6511597a5c4edbd33e9e2f3c702f11765947d985f3295498bf6701126bf2643650247673162d3eb74b43c721968bb281244993b67d79bf0f257be9bd69754f9d0b4fe6b623e3972cb5eea5899eca68f6dcf9e84dd33bd49b5b69f00c7925a955ca685a2eec4f82e43e30a277cd1218cb142a2bc32a9d9960f9689efeb1f34a0d4b52a13870b34d953d1c7878c5f245705b78d8cf59998e8f513304d77130b1b087a83b32c5882161d518e58d4f87629ee70ae18059f419307800c1534b183fcaa670df935f64c761313b81d27ada66c86ad60e21c9160d827ab16c018a654f8691e699ce0b095a16a4e2fb208638e50171d4c282721cf22f2cb3136e9d5f5dca760de10adc8fae67e0e00dfbf1a778e3e24c914d0f0abd74133375c1ae689e0ffbc70aa654073ce8259e9dec2675941393dcb5ad845a04c7f3cdc5ccc3e61e56ee3cf4d8d2ad1a7eb7ac0568b29590503542e11c6016a3fce02429e8c0567dd2fb7e4808a7cbb40114253fa1d210890d953773fbedb2625704e145af74fa0ca9f98481db10b89d5e8fc5e9d7a6e66961d697954a4f561ba3a152370adbb1ce7a9e491ab462c92b25806e342fa39295edfd676529defe01f5ab4403489c06415cb13f1a0274aa9dde9e069410fe7d03bd5d17a366dea8f25060a370cabd9cf4433e6fb51b5aa81c60451c911dad5d2f28cffe1b4194c8b9f225d94426e64ccf9d97052f8cc2dcdc49c0e9f22ae78eff60f3ace5da4d2879c1eef4adba93d78573de94db1c8991de18a2fcfa32626e9eeba5abf0d516d3ca07fa5ec3e9dea991ae4a599d905ff60b7328cad42c2594f73ba48db766ac7c647743044da9ca388b5b0e725ae090c122ec94b3086f720ca2ba499e11107b8ae1937a68af708d88b842b8772bc8db9585684aad0752fb8cfbe8210854bd88c057d363ce9744551b6d9ecebe949679cb26d0d08c500cb57e240951afa6ac2563709babe431a9bef663d19e41adabeeac24791b97f652b79433d78fda6d12eb9ebe7d6502c90fb129666321d7875d861132af9ec6c364621dd21f7ae72672af2d6bc9f0d4b2c2a7fe6b68286cdc3e79e7de</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密的文章,请联系博主获得阅读权限.&lt;/br&gt;</summary>
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="面经" scheme="https://missionodd.github.io/categories/技术/面经/"/>
    
    
    <category term="面经" scheme="https://missionodd.github.io/tags/面经/"/>
    
    <category term="java" scheme="https://missionodd.github.io/tags/java/"/>
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 | 网络知识问答梳理</title>
    <link href="https://missionodd.github.io/2022/02/10/network/"/>
    <id>https://missionodd.github.io/2022/02/10/network/</id>
    <published>2022-02-10T05:50:37.000Z</published>
    <updated>2022-03-17T14:30:03.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><strong>序列化就是将对象转换成二进制数据的过程，以方便传输或存储。而反序列就是将二进制转换为对象的过程。</strong><br>比如 网络传输 必须是二进制，但调用方请求的出入参数都是对象。就需要转换过程，如JSON对象和二进制互转，这个过程就是序列化和反序列化。<br>JDK 原生序列化。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>无状态，双向传输基于TCP/IP，灵活，明文传输不安全</p><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx 提示信息 2xx 成功 3xx 重定向 4xx客户端请求错误 5xx服务器错误<br>302 重定向<br>401 权限不足，需要授权<br>403  资源拒绝访问，需要登录<br>502 网关错误<br>503 超时</p><h4 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h4><p>Host  指定服务器域名<br>Content-Length 长度<br>Connection：keep-alive  长连接</p><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>早起1.0 每次请求都要一次TCP三次握手；<br>1.为了解决该问题，1.1 提出了长连接，<br>通过header 配置Connection：keep-alive ，建立CS持久连接，<br>减少建立和断开的额外开销；<br>2.长连接引入，使得管道pipeline网络传输成为可能，客户端可实现连续发请求，无需等待响应的阻塞其他的请求。但是，服务器依然按照顺序回应，必须一个一个处理回应，如果前面回应慢，引起 队头阻塞。</p><p>1.1性能一般般，需要HTTP的优化。</p><h4 id="HTTPS-解决HTTP什么问题？"><a href="#HTTPS-解决HTTP什么问题？" class="headerlink" title="HTTPS 解决HTTP什么问题？"></a>HTTPS 解决HTTP什么问题？</h4><p>解决明文传输的问题，HTTPS 在HTTP与TCP层之间加入 SSL/TLS 协议。一是把信息加密，解决窃听风险，二是校验机制，解决篡改信息风险，三是身份认证，解决冒充网站风险。</p><p>具体来说，HTTPS是 如何解决呢？<br>一个是混合加密，采用对称加密和非对称加密结合，保证信息密文<br>对称加密：只有一个密钥，运算快，密钥保密，无法安全密钥交换。<br>非对称加密：两个密钥，公钥任意分发，私钥保密，能交换密钥但速度慢。</p><p>建立通信前，非对称；通信过程，对称</p><p>二是摘要算法，用于签名，为数据生成唯一的指纹，校验数据完整性，防篡改。<br>摘要算法一般是不可逆的 ，散列函数与md5与sha系列。客户端在发送前，会通过摘要算法对明文计算，算出一个摘要指纹，把【摘要+明文】加密；在发送后，服务器解密得到【摘要+明文】，用同一个摘要算法对明文计算，算出摘要，并比对传过来的摘要是否想等。</p><p>三是数字证书<br>客户端先向服务器索取公钥，然后用公钥机密，传入服务器给私钥解密。<br>虽然摘要算法保证了数据不被篡改，但是，如何保证公钥不被篡改？<br>这个需要第三方权威机构CA，颁发数字证书，将服务器公钥放在数字证书。只要证书可信，公钥就是可信。<br>CA机构是分级的，树型，最顶是根CA，必须相信。<br>如何申请？<br>我们首先要知道，CA有自己的私钥，每个客户端都内置<br>已信任的CA的公钥。<br>1，服务器吧自己公钥注册给CA，<br>2，CA用自己私钥给公钥签名并颁发数字帐户上，<br>3，第一次客户端请求服务器，会拿到数字证书，会使用事先已内置浏览器或OS的CA公钥，校验数字证书真实性。<br>4，认证证书后，就获取服务器的公钥，加密报文数据，给服务私钥解密。</p><p>Q：HTTPS是如何建立连接的？期间交互了什么？<br>SSL/TLS 协议流程：<br>基本流程：C向S索取公钥，双方协商生成会话密钥，双方密钥通信。<br>前两步就是握手阶段。<br>详细流程：<br>握手四次通信：<br>1，ClientHello：客户端发送加密通信请求，这一步，客户端主要向服务端发送：TLS版本，客户端随机数（用于生产会话密钥），支持的加密算法列表</p><p>2， SeverHello，服务器回应：1，确认TLS版本，若浏览器不支持，关闭加密通信；2，服务端随机数（用于生产会话密钥），3，确认加密算法列表，4，数字证书。</p><p>3，客户端回应<br>首先通过客户端CA公钥校验证书，取出公钥，加密报文，向服务器发送：随机数（会被服务器公钥加密），加密通信算法改变通知（表示之后都是会话密钥通信），握手结束通知（表示客户端握手阶段结束，这里还会把数据做个摘要，发送给服务端校验）</p><ol start="4"><li>服务器的最后响应<br>这个过程产生3个随机数，通过加密算法的协商后，计算出本次通信的会话密钥。然后，向客户端发送最后端消息：<br>1，加密算法改变通知（之后都是会话密钥通信）；<br>2，服务端握手结束通知，表示服务端握手已结束（这里同时会把数据做个摘要，给客户端校验）。</li></ol><p>接下来就是，用会话密钥加密的HTTP请求。</p><h4 id="HTTP1-1-HTTP2-0-HTTP3-演变；"><a href="#HTTP1-1-HTTP2-0-HTTP3-演变；" class="headerlink" title="HTTP1.1 /HTTP2.0/HTTP3 演变；"></a>HTTP1.1 /HTTP2.0/HTTP3 演变；</h4><p>首先，将HTTP1.1 相比HTTP1.0 增加 TCP长连接，支持管道传输，节省了频繁建立和断开TCP的性能开销，减少多次请求等待的响应时间。<br>但是，有1.1的问题有三个：<br>一是数据太大，只压缩body，占用带宽；<br>二是队头阻塞，服务器顺序响应，一旦响应过慢，导致后续阻塞。<br>三是单向请求，不适应服务器推送场景。</p><p>那么，针对这些问题，HTTP2 进行改进：<br>一是头部压缩，如果头相同或相似，协议会自己消除重复，这是HPACK算法，实现原理是：客户端和服务端同时维护一张头表信息，所有字段都会存入这个表，生成一个索引号，只传输索引号即可，提高速度；<br>二是纯二进制格式，1.1 只是文本，头和主体用空格隔开，2.0头帧和数据帧都是二进制，也是提高传输速度。<br>三是数据流发送，不再像1.1顺序发送顺序响应，而是对数据包做标记，指出它属于哪个回应，同一连接发送连续数据包，每个请求或回应的所有数据包，统称为stream流。</p><p>三是数据流<br>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><p>四是多路复用<br>http2在一个连接里并发处理请求或回应，不再是按照顺序对应，不需排队，就没有队头阻塞问题。</p><p>五是服务器推送<br>增加新功能，不再是请求-答应模式，而是服务器主动推送消息。<br>比如，初始化HTML是，可以主动推送静态JS，CS到客户端，减少延迟等待。就是Server Push，可减少了多个RTT。</p><p>http2 缺陷：<br>多个HTTP请求复用1个TCP连接，下层的TCP协议不知道有多少个HTTP请求；<br>一旦丢包，触发TCP重传机制，此时，HTTP必须等待丢的包被重新传回来，这样阻塞了所有HTTP请求。</p><p>HTTP3 改成了UDP！<br>UDP不管顺序，不管丢包，不会出现队头阻塞，也不会出现丢包全部重传问题。</p><p>UDP不可靠，那么怎么实现类似TCP可靠呢？<br>QUIC协议保证。当某个流发生丢包，会阻塞这个流，其他流不受影响。然后是TLS1.3 把6次TCP+TLS握手合并为3次QUIC。<br>QUIC是一个UDP之上的伪TCP+TLS+HTTP2的多路复用协议。</p><h2 id="Q：一次请求发生了什么？"><a href="#Q：一次请求发生了什么？" class="headerlink" title="Q：一次请求发生了什么？"></a>Q：一次请求发生了什么？</h2><p>一是对URL解析，来确定是发送给WEB服务器请求。<br>包括协议头，服务器host，uri路径。<br>二是查询真真实IP，使用DNS服务器解析。在发送消息前，委托系统查询DNS服务器域名的真实IP。DNS服务器具有树状的层级，根域服务器保存所有域名，顶级域名服务器更少，只保存com或cn后缀的，权威域名保存更少，同时服务器数量也更多。<br>解析过程：客户端发出DNS请求，询问IP，在本地DNS服务器找，如果有自己返回IP，如果没有，委托根域名，根域名委托对应的顶级域名服务器，顶级域名服务器委托对应的权威域名服务器。权威域名服务器找到IP，告诉本地DNS缓存。</p><p>三是协议栈 封装<br><figure class="image-box">                <img src="3786F82F-6457-4550-A5A9-F1596205ABCA_20220228150247.png?v=1&type=image&token=V1:oAbMgcxeh4dd0mWA7fwzOxMQAo_vAQ8ncn8Cu-rEqrw" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><br>通过DNS获取IP后，就可以把HTTP的传输工作交给OS的协议栈。<br>协议栈的内部分为几部分，分别承担不同工作，上下关系有一定规则，上面会向下委托公，下面收到委托并执行。</p><p>应用程序通过调用socket 库，来委托协议栈工作，协议栈的上方分别是收发数据的TCP和UDP协议，下方是IP协议控制网络包的收发操作，在互联网上传数据时，数据会被切成一块块的网络包，而将网络包发送给对方的操作就是有IP负责。</p><p>IP包括ICMP协议 和ARP协议。<br>ICMP时告知网络包传输过程中产生的错误和各种控制信息。<br>ARP 是根据IP地址查询相应的以太网MAC地址。</p><p>IP下面是网卡驱动程序，负责控制网卡硬件。最下是网卡硬件，真正的网络信号的收发操作</p><p>四，细看，可靠传输TCP<br>先讲讲TCP，序号解决包乱序，校验和解决完整性，窗口大小声明窗口大小，解决两端流量处理能力的控制。此外，拥塞控制，控制发送的速度。</p><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><ul><li><p>一开始，客户端和服务端都处于  <code>CLOSED</code>  状态。先是服务端主动监听某个端口，处于  <code>LISTEN</code>  状态。</p></li><li><p>然后客户端主动发起连接  <code>SYN</code>，之后处于  <code>SYN-SENT</code>  状态。</p></li><li><p>服务端收到发起的连接，返回  <code>SYN</code>，并且  <code>ACK</code>  客户端的  <code>SYN</code>，之后处于  <code>SYN-RCVD</code>  状态。</p></li><li><p>客户端收到服务端发送的  <code>SYN</code>  和  <code>ACK</code>  之后，发送  <code>ACK</code>  的  <code>ACK</code>，之后处于  <code>ESTABLISHED</code>  状态，因为它一发一收成功了。</p></li><li><p>服务端收到  <code>ACK</code>  的  <code>ACK</code>  之后，处于  <code>ESTABLISHED</code>  状态，因为它也一发一收了。</p></li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>查看连接命令： netstat - napt 命令</p><h3 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h3><p>如果HTTP消息过长，超过了MSS的长度。<br>TCP 就要把HTTP的数据拆解一块块的数据发送，而不是一次性发送。</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为  <code>1500</code>  字节。</li></ul><ul><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被拆为MSS长度的单位，并加上TCP头，然后交给IP模块发送数据。</p><p>TCP会有两个端口，一个是浏览器监听 的短裤，随机，一个是服务器监听的80或443</p><figure class="image-box">                <img src="1ADA371D-52C5-44D6-9231-F5087EA7028A_20220228214150.png?v=1&type=image&token=V1:W1SnXQS3hWpVDWnHs53IsS8_HVJPDaPjIDjB3kjENfE" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>双方建立连接后，TCP报文的数据部分就是存放HTTP头+数据，组装好TCP报文之后，要交给下面的网络层处理</p><h3 id="远程定位-—-IP"><a href="#远程定位-—-IP" class="headerlink" title="远程定位 —- IP"></a>远程定位 —- IP</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p></blockquote><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p><h3 id="两点传输-—-MAC"><a href="#两点传输-—-MAC" class="headerlink" title="两点传输 — MAC"></a>两点传输 — MAC</h3><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><p><code>0800</code>  ：IP 协议</p></li><li><p><code>0806</code>  ：ARP 协议</p></li></ul><p>先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给  <code>Gateway</code>  列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要  <code>ARP</code>  协议帮我们找到路由器的 MAC 地址。</p><ul><li><p>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</p></li><li><p>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。如果对方和自己处于同一个子网中，那么就可以得到对方回应的 MAC 地址。</p><figure class="image-box">                <img src="A2E4BDD3-A5A6-44FA-8DFB-1E15722CE355_20220228221916.png?v=1&type=image&token=V1:RuUiMFuU-xJwTZUlj7ESjyJf8vlHyb066kLrMrfYN4s" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><h4 id="出口—-网卡"><a href="#出口—-网卡" class="headerlink" title="出口— 网卡"></a>出口— 网卡</h4><p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p></li></ul><p>网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS</strong>。</p><h4 id="送别者—-交换机"><a href="#送别者—-交换机" class="headerlink" title="送别者—-交换机"></a>送别者—-交换机</h4><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li><p>一个是设备的 MAC 地址，</p></li><li><p>另一个是该设备连接在交换机的哪个端口上。</p></li></ul><p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><h4 id="出境大门-—-路由器"><a href="#出境大门-—-路由器" class="headerlink" title="出境大门 — 路由器"></a>出境大门 — 路由器</h4><p>路由器是基于IP设计，俗称三层网路设备，各个端口都有MAC地址和IP地址；<br>而交换机是基于以太网设计，俗称二层网络设备，端口不具备MAC地址。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li><p>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</p></li><li><p>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</p></li></ul><p>知道对方的 IP 地址之后，接下来需要通过  <code>ARP</code>  协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>（城门）到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。（服务器内网）</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h3 id="互相扒皮—-服务器-与-客户端"><a href="#互相扒皮—-服务器-与-客户端" class="headerlink" title="互相扒皮— 服务器 与 客户端"></a>互相扒皮— 服务器 与 客户端</h3><p>应用层 HTTP<br>传输层 TCP<br>网络层 IP<br>链路层 以太网MAC<br>从高到低封装，从低到高拆解。</p><p>当 扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>———————<br>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><h3 id="扩展-ping原理-ICMP协议"><a href="#扩展-ping原理-ICMP协议" class="headerlink" title="扩展 ping原理 ICMP协议"></a>扩展 ping原理 ICMP协议</h3><p>也就是<strong>互联网控制报文协议</strong>，<code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><h2 id="细说-TCP"><a href="#细说-TCP" class="headerlink" title="细说 TCP"></a>细说 TCP</h2><p>首先，介绍TCP 头部格式。<br><figure class="image-box">                <img src="797DA83E-0574-4D7F-82CC-3440F36357D5_20220228224408.png?v=1&type=image&token=V1:XWMOSp193u83j6GshiGPmz4BIwQWv6PlX8pyz8iT894" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure></p><p>序列号：在建立连接时由计算机生成的随机数作为初始值，通过SYN包传输给接收端，每一次累加该数据字节的大小，解决乱序问题。</p><p>确认应答号：指下一次期望收到的数据的序列号，用来解决不丢包问题。</p><p>控制位：确认答应，异常断开，chu，结束</p><h3 id="Q：为什么需要-TCP-协议？TCP-工作在哪一层？"><a href="#Q：为什么需要-TCP-协议？TCP-工作在哪一层？" class="headerlink" title="Q：为什么需要 TCP 协议？TCP 工作在哪一层？"></a>Q：为什么需要 TCP 协议？TCP 工作在哪一层？</h3><figure class="image-box">                <img src="858E392E-2252-4CEA-A6B2-87A10AC1A95D_20220228225120.png?v=1&type=image&token=V1:OVmGFxz0wgPu7a6SeFkKHnHEzk7UBhhYa7LWsxI8GDs" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><h3 id="Q：什么是-TCP-？"><a href="#Q：什么是-TCP-？" class="headerlink" title="Q：什么是 TCP ？"></a>Q：什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p></li></ul><h3 id="Q：什么是TCP连接？"><a href="#Q：什么是TCP连接？" class="headerlink" title="Q：什么是TCP连接？"></a>Q：什么是TCP连接？</h3><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><h3 id="Q：如何唯一确定一个TCP连接？"><a href="#Q：如何唯一确定一个TCP连接？" class="headerlink" title="Q：如何唯一确定一个TCP连接？"></a>Q：如何唯一确定一个TCP连接？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li><p>源地址</p></li><li><p>源端口</p></li><li><p>目的地址</p></li><li><p>目的端口</p></li></ul><h3 id="Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:<br>最大TCP连接数 = 客户端IP数 x 客户端端口数<br>对于IPv4，2的32次方IP ，2的16次方端口，最大TCP连接数是2的48次方。</p><p>这是理论值，实际上：<br>Linux 文件描述符限制，socket是fd文件，打开句柄 1024，这个可调。<br>另一个是内存限制，每个TCP连接占用一定的内存。</p><h3 id="Q：UDP和TCP区别与场景？"><a href="#Q：UDP和TCP区别与场景？" class="headerlink" title="Q：UDP和TCP区别与场景？"></a>Q：UDP和TCP区别与场景？</h3><p>UDP 不提供控制机制，利用IP提高的无连接通信<br>UDP 协议简单，头部8字节，分别是 16位源端口，16位目标端口，16位包长度，16位校验和</p><p>区别：<br>1，连接<br>TCP面向连接，传输数据前先建立连接<br>UDP无连接<br>2，服务对象<br>TCP连接一对一<br>UDP一对一，一对多，多对多广播<br>3，可靠性<br>TCP可靠，校验和保证无差错，确认答应号保证不丢失，序号保证不重复，顺序性，<br>UDP不可靠，只是尽最大努力交付<br>4，拥塞控制，流量控制<br>TCP拥塞控制和流量控制，保证数据传输多安全性；<br>UPD即使网络非常堵塞，也不影响UDP发送速率<br>5，首部开销<br>TCP首部长度较长，不包括【选项】，20字节；<br>UDP首部只有8字节</p><p>6，应用场景<br>TCP：FTP文件传输 HTTP/HTTPS<br>UDP：DNS，视频，音频，广播通信</p><h3 id="Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h3><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><p>选项 常见：MSS最长报文大小</p><h3 id="Q：为什么是3次握手？不是两次，四次？"><a href="#Q：为什么是3次握手？不是两次，四次？" class="headerlink" title="Q：为什么是3次握手？不是两次，四次？"></a>Q：为什么是3次握手？不是两次，四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”但是，回答过于片面。<br>首先，了解TCP连接的连接概念。</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>那么，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接</strong></p><p>接下来，我从3个方面回答：</p><ul><li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）</p></li><li><p>三次握手才可以同步双方的初始序列号</p></li><li><p>三次握手才可以避免资源浪费</p></li></ul><p>原因一：避免历史连接<br>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong>。</p><p>如果旧SYN报文比当前SYN报文先抵达到服务端，服务端会返回SYN+ACK，客户端根据自身上下问题，判断是旧连接，那么客户端发送RST报文，表示中断这一次连接。舍弃之前的，重新开始新的SYN。</p><p>如果是两次握手，服务端就不能判断出历史连接而中断。</p><ul><li><p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是  <code>RST</code>  报文，以此中止历史连接；</p></li><li><p>如果不是历史连接，则第三次发送的报文是  <code>ACK</code>  报文，通信双方就会成功建立连接；</p></li></ul><p>原因二：同步双方初始序列号<br>TCP协议双方，都必须维护一个序列号，序列号是可靠传输的关键：可以去重，可以顺序接收，可以表示哪些数据包已经被对方接收。</p><p>第一次客户端发送初始序列号SYN，服务端需要ACK回应，同时发生自己的出生序列号SYN，客户端当然也要回应接收。<br>这样来回，次确保双方初始序列号被对方知晓。</p><p>原因三：避免资源浪费</p><p>如果只有两次握手，服务器ACK不知道客户端是否已经接收，这就导致服务端每次收到SYN就主动建立一个连接，这就有个问题，如果客户端SYN传输被网络阻塞，而引起了超时重发，之后阻塞的SYN也终于发送到服务端，意味着服务端接收了2次相同的SYN，服务器会重复处理请求，造成重复分配资源。</p><p>小结：三次握手是为了防止历史连接的 建立，帮助双方初始化序列号，减少重复资源的开销。<br>两次握手无法做到以上这些，四次握手显得多余。</p><h3 id="Q：为什么客户端和服务端的初始序列号ISN不相同？"><a href="#Q：为什么客户端和服务端的初始序列号ISN不相同？" class="headerlink" title="Q：为什么客户端和服务端的初始序列号ISN不相同？"></a>Q：为什么客户端和服务端的初始序列号ISN不相同？</h3><p>报文延迟，复制重发，丢失等造成不同连接之间互相影响，客户端和服务端初始化序列号不同，是为了兼容这些问题环境。</p><h3 id="Q：IP层会分片，TCP为什么要MSS？"><a href="#Q：IP层会分片，TCP为什么要MSS？" class="headerlink" title="Q：IP层会分片，TCP为什么要MSS？"></a>Q：IP层会分片，TCP为什么要MSS？</h3><p>首先介绍MTU 和 MSS。<br>MTU： 一个网络包的最大长度，以太网中一般位1500字节。<br>MSS：一个减去IP 和TCP 头部的网络包数据的最大长度</p><p>如果仅TCP报文交给IP分片，IP层超过一个MTU大小的数据发送，就要进行分片，把数据分片成若干片，保证每一个分片都小于MTU。分片后，由目标主机的IP层重新组装，再交给TCP传输层。</p><p>这里存在一个隐患，如果一个IP分片丢失，就需要整个IP报文的所有分片重传，因为IP层没有超时重传机制，那么，它由传输层TCP来负责超时和重传，接收方发现缺失，不会响应ACK，而是等对方超时后，重发整个TCO报文。</p><p>这样，非常无效率。</p><p>所以，TCP建立连接时，双方协商MSS值，当TCP层发现数据超过MSS时，就会先分片，他肯定不会大于MTU。IP自然不用分片。</p><p>经过TCP层分片后，如果TCP分片丢失，超时重发只是发送一个MSS单位的分片，大大增加重传的效率？</p><h3 id="Q：SYN攻击是什么？如何避免？"><a href="#Q：SYN攻击是什么？如何避免？" class="headerlink" title="Q：SYN攻击是什么？如何避免？"></a>Q：SYN攻击是什么？如何避免？</h3><p>就是在三次握手过程，攻击者伪造不同IP一直发送SYN报文，服务端接收后，就进入SYN_RCVD状态，且服务端发送ACK+SYN报文无回应，久而久之就会占满SYN接收队列（未连接队列），使得服务器不能正常给用户连接。</p><p>如何避免？<br>一是修改Linux内核参数，控制队列大小和饱和策略。<br>比如，限制SYN_RCVD状态连接的最大个数，超出处理能力时，采取丢弃策略。</p><p>二是启动sync cookies<br>首先，正常情况下：</p><ul><li><p>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</p></li><li><p>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</p></li><li><p>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</p></li><li><p>应用通过调用  <code>accept()</code>  socket 接口，从「 Accept 队列」取出的连接。</p></li><li><p>如果accept方法调用过慢时，就会导致「 Accept 队列」被占满。</p></li><li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li></ul><p>但开启sync cookies 后</p><ul><li><p>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</p></li><li><p>计算出一个  <code>cookie</code>  值，再以 SYN + ACK 中的「序列号」返回客户端，</p></li><li><p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</p></li><li><p>最后应用通过调用  <code>accpet()</code>  socket 接口，从「 Accept 队列」取出的连接。</p></li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>客户端发送首部FIN=1 的TCP报文，即FIN报文，之后进入FIN等待1状态。<br>服务端接收后响应ACK，进入等待关闭状态。<br>客户端接收ACK后，进入FIN等待2状态<br>等服务处理后面，再发送FIN报文，然后进入等待最后ACK状态。<br>客户端收到后，会一个ACK，进入时间等待状态TIME_WAIT。<br>服务器收到后，关闭连接。<br>服务端经过2MSL时间后，关闭连接。</p><p>每个方向都需要FIN 和 ACK，这里需要注意，TIME_WAIT是主动关闭连接才有</p><h4 id="Q：-为什么四次挥手？"><a href="#Q：-为什么四次挥手？" class="headerlink" title="Q： 为什么四次挥手？"></a>Q： 为什么四次挥手？</h4><p>因为双方都需要分开发送一个FIN 和分开响应一个ACK，来告知和确认。</p><h4 id="Q：为什么TIME-WAIT等待是2MSL？"><a href="#Q：为什么TIME-WAIT等待是2MSL？" class="headerlink" title="Q：为什么TIME_WAIT等待是2MSL？"></a>Q：为什么TIME_WAIT等待是2MSL？</h4><p>MSL是最大报文生存时间，它是任何报文在网络上生存的最长时间。<br>顺便一提，TTL是经过路由的跳数。MSL要大于等于TTL消耗位0的时间。</p><p>TIME_WAIT持续2倍MSL，在Linux中是60s，说白来，这其实是要等报文一来一回的时间。<br>比如，如果对方没有接收到最后ACK，超时重传FIN报文，然后我接收到FIN报文，ACK与重传FIN 正好一来一回，2MSL足够时间让我接收重传的FIN报文，之后，我重发ACK，2MSL重新计时。</p><h4 id="Q：为什么需要TIME-WAIT？"><a href="#Q：为什么需要TIME-WAIT？" class="headerlink" title="Q：为什么需要TIME_WAIT？"></a>Q：为什么需要TIME_WAIT？</h4><p>原因一 ： 防止旧连接的数据包<br>比如，双方关闭连接后，服务端的相同端口号的TCP连接被重用。<br>如果TIME_WAIT没有或过短，上一次由服务器发送，但被网络阻塞的报文，会现在发送过来给一个新的客户端，导致数据错乱。<br>等待2MSL时间，保证服务器所有数据包自然死亡。</p><p>原因二：保证连接正确关闭：<br>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>如果TIME_WAIT没有或过短，</p><ul><li><p>客户端四次挥手的最后一个  <code>ACK</code>  报文如果在网络中被丢失了，此时如果客户端  <code>TIME-WAIT</code>  过短或没有，则就直接进入了  <code>CLOSE</code>  状态了，那么服务端则会一直处在  <code>LASE-ACK</code>  状态。</p></li><li><p>当客户端发起建立连接的  <code>SYN</code>  请求报文后，服务端会发送  <code>RST</code>  报文给客户端，连接建立的过程就会被终止。</p></li></ul><h4 id="Q：TIME-WAIT-过多有什么危害？"><a href="#Q：TIME-WAIT-过多有什么危害？" class="headerlink" title="Q：TIME_WAIT 过多有什么危害？"></a>Q：TIME_WAIT 过多有什么危害？</h4><ul><li><p>第一是内存资源占用；</p></li><li><p>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</p></li></ul><h4 id="Q：-如何优化TIME-WAIT？"><a href="#Q：-如何优化TIME-WAIT？" class="headerlink" title="Q： 如何优化TIME_WAIT？"></a>Q： 如何优化TIME_WAIT？</h4><p>一是可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。<br>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p><p>由于引入了时间戳，我们在前面提到的  <code>2MSL</code>  问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><p>温馨提醒：<code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持  <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。小林在工作中就遇到过。。。排查了非常的久</p><p>二是当系统中处于 TIME_WAIT 的连接<strong>一旦超过一个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong>，问题更多</p><p>三是我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><h4 id="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><figure class="image-box">                <img src="88C54A0C-F18F-40A7-80F3-578C2C001BB3_20220301030128.png?v=1&type=image&token=V1:Yz1FxBY8R886pfetwNkycQ_fy2Zif_dTF5s4IPh4cbw" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><ul><li><p>服务端和客户端初始化  <code>socket</code>，得到文件描述符；</p></li><li><p>服务端调用  <code>bind</code>，将绑定在 IP 地址和端口;</p></li><li><p>服务端调用  <code>listen</code>，进行监听；</p></li><li><p>服务端调用  <code>accept</code>，等待客户端连接；</p></li><li><p>客户端调用  <code>connect</code>，向服务器端的地址和端口发起连接请求；</p></li><li><p>服务端  <code>accept</code>  返回用于传输的  <code>socket</code>  的文件描述符；</p></li><li><p>客户端调用  <code>write</code>  写入数据；服务端调用  <code>read</code>  读取数据；</p></li><li><p>客户端断开连接时，会调用  <code>close</code>，那么服务端  <code>read</code>  读取数据的时候，就会读取到了  <code>EOF</code>，待处理完数据后，服务端调用  <code>close</code>，表示连接关闭。</p></li></ul><p>这里需要注意的是，服务端调用  <code>accept</code>  时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h3 id="Q：-listen-时候参数-backlog-的意义？"><a href="#Q：-listen-时候参数-backlog-的意义？" class="headerlink" title="Q： listen 时候参数 backlog 的意义？"></a>Q： listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p><ul><li><p>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</p></li><li><p>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</p></li></ul><figure class="image-box">                <img src="E5A16EFC-F8E5-413F-A373-A9AE832AB3EA_20220301030414.png?v=1&type=image&token=V1:IrGEHjzfy7HoFoFVvIODOCSedyypxsuKtA6k7XErHQs" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><h4 id="Q：什么是-TCP-半连接队列和全连接队列？"><a href="#Q：什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="Q：什么是 TCP 半连接队列和全连接队列？"></a>Q：<strong>什么是 TCP 半连接队列和全连接队列？</strong></h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><p>半连接队列，也称 SYN 队列；全连接队列，也称 accepet 队列；服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来</strong>。</p><p><img src="3b87e950352ac65c20611873e5e4751793138a62.jpeg" alt="img"></p><h3 id="Q：accept-发送在三次握手的哪一步？"><a href="#Q：accept-发送在三次握手的哪一步？" class="headerlink" title="Q：accept 发送在三次握手的哪一步？"></a>Q：accept 发送在三次握手的哪一步？</h3><figure class="image-box">                <img src="2F2DCEA4-F84A-44B5-B5FD-F3F1F9292894_20220301030519.png?v=1&type=image&token=V1:E9Nf8kAwwyq1S2JJ4Qqf53TxBVbnze5R7dw2mCAKtEA" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><h3 id="Q：客户端调用-close-了，连接是断开的流程是什么？"><a href="#Q：客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="Q：客户端调用 close 了，连接是断开的流程是什么？"></a>Q：客户端调用 close 了，连接是断开的流程是什么？</h3><figure class="image-box">                <img src="FF99FD84-160C-451C-9D75-9BA45177F732_20220301030633.png?v=1&type=image&token=V1:Gby9jS5wb0Zu6mRJVZlZ6LovpSaNhvuwrtvx92VrAoM" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>————————————————</p><h4 id="Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？"><a href="#Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？" class="headerlink" title="Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？"></a>Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？</h4><p>如果有保活机制</p><ul><li><p>如果<strong>对端程序是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p></li><li><p>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p></li></ul><p>没有的话：</p><p>如果客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程</p><p>kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。<br>如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><ul><li><p>第一种，客户端主机宕机，又迅速重启，会发生什么？</p></li><li><p>第二种，客户端主机宕机，一直没有重启，会发生什么？</p></li></ul><p>客户端主机宕机，又迅速重启</p><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p><p>客户端主机宕机，一直没有重启</p><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了</p><h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><figure class="image-box">                <img src="image-20210921112213523.png" alt="img" title class>                <p>img</p>            </figure><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h2 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><figure class="image-box">                <img src="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p><p> 当 cwnd &lt; ssthresh 时，使用慢开始<a href>算法</a>。</p><p> 当 cwnd &gt; ssthresh 时，停止使用慢开始<a href>算法</a>而改用拥塞避免<a href>算法</a>。</p><p> 当 cwnd = ssthresh 时，既可使用慢开始<a href>算法</a>，也可使用拥塞控制避免<a href>算法</a>。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始<a href>算法</a>。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>快重传<a href>算法</a>可以避免这个问题。快重传<a href>算法</a>首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p><p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免<a href>算法</a>，使拥塞窗口缓慢地线性增大。</p><p>在采用快恢复<a href>算法</a>时，慢开始<a href>算法</a>只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><p>常见重传机制：</p><p>超时重传</p><p>快速重传</p><p>SACK</p><p>D-SACK</p><h1 id="TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解"></a>TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解</h1><p><a href="https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA</a></p><h1 id="精炼版"><a href="#精炼版" class="headerlink" title="精炼版"></a>精炼版</h1><p><a href="https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序列化和反序列化&quot;&gt;&lt;a href=&quot;#序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化和反序列化&quot;&gt;&lt;/a&gt;序列化和反序列化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;序列化就是将对象转换成二进制数据的过程，以方便传输或存储。而反序列就是将二进</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="计算机网络" scheme="https://missionodd.github.io/categories/技术/计算机网络/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="计算机网络" scheme="https://missionodd.github.io/tags/计算机网络/"/>
    
  </entry>
  
  <entry>
    <title>Redis | 底层数据结构 | 主从复制</title>
    <link href="https://missionodd.github.io/2022/02/10/redis-principle-cluster/"/>
    <id>https://missionodd.github.io/2022/02/10/redis-principle-cluster/</id>
    <published>2022-02-10T05:50:37.000Z</published>
    <updated>2022-03-16T15:30:45.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="讲讲Redis的5种数据结构的理解"><a href="#讲讲Redis的5种数据结构的理解" class="headerlink" title="讲讲Redis的5种数据结构的理解"></a>讲讲Redis的5种数据结构的理解</h4><p>5种，字符串，列表，哈希表对象，集合set，有序集合zset。<br>Redis对象有统一的数据结构，RedisObj，里面包含对象类型，对象底层实现数据结构标识encoding，指向底层结构的指针。</p><p>先说<strong>字符串</strong>：<br>底层是名为SDS的结构，有buf字节数组，对应长度，未使用空间长度。好处是：<br>1.O(1)定位长度，<br>2.对\0兼容的二进制安全，<br>3.追加字符串，可利用未使用空间，减少内存重新分配空间次数；<br>4.空间不够时，通过自动分配新空间而不会像strcat函数引起缓冲区溢出：小于1MB，按2倍扩容，扩容阈值为1MB。<br>5.用5种不同大小的SDS，灵活保存，节省内存看空间。</p><ol start="6"><li>空间节省还体现在编译优化上，我们先了解，编译器会有一个字节数对齐的工作，以更好地让CPU对内存的规整读写。SDS取消字节对齐，压缩空间。比如，结构体有char，int，对齐下是4+4字节，压缩后1+4字节。</li></ol><p>不过，空间只增不减，需要手动调API惰性释放</p><p><strong>列表</strong><br>双向链表或压缩列表，3.2后用quicklist，50后用了listpack<br>双向链表<br>表头：头节点指针，尾节点指针，长度<br>节点：前驱指针，后驱指针，值指针</p><p>插入多时会比数组好，但不连续内存存储，产生空间碎片，无法利用CPU缓存；多出存储头尾节点的空间开销；</p><p><strong>压缩列表</strong><br>内存紧凑列表，没有所谓对齐空闲，很好利用CPU缓存；<br>表头3个，整体字节数，尾部偏移量，节点数，表尾1个，8位1结束标记；<br>节点内部：上个节点长度，当前节点类型及长度，节点数据</p><p>这种设计，大大节省内存空间。<br>举例：<br>列表中存储字符串，如果用双链表，<strong>每个节点有三个指针，加上SDS的2个长度的存储，再加上字符串本身</strong>。32位操作系统，一个指针6-7字节左右，三指针占<strong>18字节</strong>；<br>如果字符串是个位数，基本每个整数占用1个字节，加起来20个字节左右，不包含字符串本身。<br>当<strong>开启压缩列表</strong>，存储结构变化，它会按照序列化的形式存储，每个节点除了存储字符串本身，<strong>只需存2个整数，一个是前一个节点的字符串长度，另一个是当前节点字符串类型长度。</strong>若它是个位数长度，只需每个整数只占1个字节，总之，字符串本身加上两个字节的额外开销，跟之前字符串加上20字节的额外开销，差了N陪。这样，开启压缩列表，每项存储节省18字节。在此情况，做内存节省，适当将redis里的列表长度的阈值调整，<strong>默认512调整到2048或1024</strong>，不建议特别大。这样满足更长列表的列表压缩，节省更多空间。</p><p>但是，压缩列表会产生一定的性能消耗<br>一是读写过程需要编码解码；<br>二是连锁更新问题。新增或修改元素时，一旦空间不够了，压缩列表就会重新分配。特别是插入元素较大，会导致后续的上个节点长度的整型记录发生连锁空间变大，即后续所有空间都要重新分配，造成访问压缩列表的性能下降。<br>比如，前节点原本长度小于254字节，prevlen上节点长度只需1字节空间保存，如果前节点增大超过253，prevlen上节点长度要用5字节保存，而这，又导致当前节点的增大，同样，下一个节点为了记录当前节点长度，也要增大，这是一个多米诺牌的效应。</p><p>结论是，压缩列表保存小数据和几乎不变的数据，控制在连锁更新能够接受的尺度。</p><p><strong>哈希桶 Hash</strong><br>底层是压缩列表 + 字典，新版本有变化，压缩列表改为listpack<br>压缩列表已经讲过，这里主要是用来存储键key。<br>字典的结构是：2个ht哈希表，ht指向dictEntry哈希节点数组，数组元素指向dictEntry哈希节点链表；<br>1.先说哈希节点，内有key，v，next三个指针，v是联合体结构，里面val有两种含义，一种是8字节指针，一种是8字节长度整型或浮点数，无指向，空间节省优化。</p><p>2.采用数组+链表，是解决哈希冲突的链式哈希法。一个ht哈希表内部有数组，数组大小，掩码，节点数量；set的时候，通过key.hash对掩码与运输，定位数组桶位，头插法插入链表。</p><p>3.扩容缩容时的渐进式rehash。与hasmap不同，rehash执行过程分散到crud过程，减少单次set操作的性能开销。利用两个ht哈希表实现，一个ht用于存储旧数据；另一个空ht用于扩缩容数组。当达到负载因子阈值，空ht会扩容2倍，新数据进入到在新数组，同时，旧数据在每次crud时分批分次迁移。这是一种归并思想。</p><p><strong>集合（sadd）</strong><br>底层是整数集合或字典<br>字典已经介绍过。<br>下面介绍<br>整数集合intset<br>内部有：元素编码，数量，数组<br>优点：</p><ol><li>连续内存空间，规整的元素大小划分，减少空间碎片</li><li>升级操作，针对不同规格的类型，选择编码合适的集合。当新元素超过当前编码，比如int16集合中新增int32，会对整个集合进行一个大小的升级。好处是节省内存资源。</li></ol><p>不过，只增不减。</p><p><strong>有序集合（Zset）</strong><br>底层是压缩列表或跳表。新版压缩列表改为listpack。</p><p>跳表<br>一个带有层级关系的有序双向链表。<br>主要介绍三个参数，层级，分值，跨度。<br>每个节点有随机层级，不同层级有不同跨度的指向关系，越高层级跨度越大。利用浮点数分值的有序性，实现一种下楼梯式地层层检索，似二分查询，沿途跳过过多少节点，就是节点跨度。<br>还有前进指针和后退指针，后推指针用于从尾到头的检索。<br>好处是，查询效率下降一定小于log（N），且保持顺序性。</p><p>能够实现排行榜。</p><p>3.2版本的<br>quicklist<br>跟链表类似，区别是节点val采用了压缩列表指针，并额外存储字节大小，元素个数，能控制压缩列表的大小或者元素个数，规避潜在的连锁更新风险，并没有完全解决</p><p>5.0版本的<br>listpack<br>为了解决连锁更新问题，listpack代替压缩列表，舍弃前一个节点长度。<br>结构是：表头： 字节数，元素数量，表尾：结束标识<br>节点：编码，数据，编码+数据总长度。</p><h2 id="Redis-3种高级结构"><a href="#Redis-3种高级结构" class="headerlink" title="Redis 3种高级结构"></a>Redis 3种高级结构</h2><p>bitmaps<br>01数组，实际上String类型上的一组面向bit操作的集合。<br>用于活跃用户统计，布隆过滤器</p><p>HyperLogLogs<br>是用来做基数统计的算法，HyperLogLogs 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>底层是散列出1w多个6bit的桶。类似bitmaps</p><p>实现滑动时间的UV数据统计</p><p>GEO<br>地理坐标<br>使用了GeoHash编码后，经纬度[120,40]就被编码成了1110011101，这个值就可以作为key对应的score值，把二维变成一维。</p><p>pipeline<br>网络管道技术，降低RT次数。<br> pipeline打包命令发送，节省网络时间。pipeline不是原子操作。<br> pipeline都会将数据顺序的传送顺序地返回（redis 单线程）</p><p>脚本<br> 大量 pipeline 应用场景可通过  <strong>Redis 脚本</strong>（Redis 版本 &gt;= 2.6）得到更高效的处理，后者在服务器端执行大量工作。脚本的一大优势是可通过最小的延迟读写数据，让读、计算、<strong>写等操作变得非常快（pipeline 在这种情况下不能使用，因为客户端在写命令前需要读命令返回的结果</strong>）。</p><h2 id="数据库空间"><a href="#数据库空间" class="headerlink" title="数据库空间"></a>数据库空间</h2><p>数据库空间是16隔DB，包括键-值空间和键-过期时间的字典。</p><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p>每一个键定时删除，CPU开销大；<br>每一次查询检查的惰性删除，容易内存泄露；<br>设置时间定期一次性检查删除，需要合理的频率和执行时长；<br>默认惰性+定期</p><p>RDB AOF对过期键的处理：<br>不同点：二者在主从服务器保持数据一致性载入文件对过期键的方式不同。<br>RDB文件，1.主服务器运行时载入会判断过期键不载入；2.从服务器运行时载入不会判断全载入，因为在主从服务器保持数据一致性时会先删除从服务器数据。<br>AOF文件，1.主服务器运行时载入判断过期键会在AOF文件中追加一条del命令；2.从服务器对过期键暂不处理，因为在主从服务器保持数据一致性时，主服务器统一发送del命令，从服务器才会处理过期键;AOF文件处理过期键是由主服务期统一管理。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>用引用计数器，因为没有循环引用。</p><h2 id="AOF持久化日志"><a href="#AOF持久化日志" class="headerlink" title="AOF持久化日志"></a>AOF持久化日志</h2><p>只记录写命令操作，追加方式；<br>先执行成功再记录<br>好处：<br>一是避开额外的检查开销<br>二是不会阻塞当前写操作命令执行；<br>风险：<br>一是非原子操作，未及时刷盘导致丢失<br>二是redis单线程写日志，受限于IO压力，可能给下一个命令造成阻塞</p><p>这都给写硬盘的时机有关</p><h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>写入过程：命令追加至AOF缓存区，然后write调用拷贝至内核缓冲区，等待内核刷盘，什么时候刷盘，由内核决定<br>Redis刷盘的3种策略：<br>Always：总是，每次同步<br>Everysec：每隔一秒<br>No：转交给系统控制</p><p>要么减少数据丢失，要么阻塞主进程，高可靠，高性能只能选其一；</p><p>系统刷盘函数：fsync（）</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>为了解决AOF日志过大问题，AOF会读取当前数据库所有数据，生成新的AOF文件，再进行旧AOF日志一次性覆盖。</p><p>AOF重写由<strong>子进程</strong>完成，避免阻塞主线程。<br>不使用线程是因为，多线程内存共享，修改 共享数据，需要加锁保证数据安全，降低性能。父子进程的采用数据副本，通过fork，系统把父进程的页表复制给子进程，页表是记录虚拟内存映射关系，不会物理复制。也就是说，虚拟空间不同，物理空间相同。<br>这样，实现内存共享，不过只标记为可读。当父子任意一方进行写一个页表项，CPU就会触发违反权限导致的缺页中断机制，会进行一部分页表项的物理复制，并重新调整映射，该过程就是写时复制：写操作时，才会对在写的物理内存复制。防止整体内存复制过长而引发父进程写阻塞当问题。<br>当然，复制进程页表，父进程会阻塞，但页表其实很小，开销不大。对在写的物理内存复制也会阻塞，这要数据量大小。如果是个bigkey，就有阻塞风险。</p><p>如果AOF重写过程中，主进程写入导致两块物理内存不一致，怎么办呢？<br>增加AOF重写缓冲区：重写AOF期间，写命令写入到”AOF缓冲区“与”AOF重写缓冲区“。<br>AOF文件重写工作完成后，此时还没覆盖旧AOF日志，会向主进程发送信号，这是进程之间的异步通信方式。</p><p>主进程接收到信号，把AOF重写缓冲区追加到新的AOF中，再把旧AOF日志覆盖。这个过程是阻塞的</p><p>整个过程，进程页表复制，写时复制，信号接收处理，都是阻塞的。其他情况不阻塞。</p><h2 id="RDB-快照-默认"><a href="#RDB-快照-默认" class="headerlink" title="RDB 快照  默认"></a>RDB 快照  默认</h2><p>所谓快照，就是记录一瞬间的东西，好比拍一张照片。</p><p>RDB记录某一个瞬间的二进制内存数据，是全量快照，而AOF是命令日志</p><p>好处是Redis要恢复数据时，RDB效率更高。</p><p>提供了两个命令：<br>save 和 bgsave： 区别是是否在主进程执行。<br>开启以后，会定期执行保存，这是比较重的操作，这个频率要控制。</p><p>缺点：<br>发送宕机时，RDB记录旧的数据，比秒级AOF丢失更多。</p><p>执行快照时，数据能被修改吗？<br>可以，使用bgsave，也是子进程写时复制技术。<br>能同步刚修改的数据吗？<br>不同步，只能交由下一次bgsave操作。</p><h2 id="RDB和AOF-混合文件持久化"><a href="#RDB和AOF-混合文件持久化" class="headerlink" title="RDB和AOF 混合文件持久化"></a>RDB和AOF 混合文件持久化</h2><p>为了高可用和高性能，控制持久化好频率。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>，不再有AOF全量数据。</p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><h2 id="缓存三个异常问题"><a href="#缓存三个异常问题" class="headerlink" title="缓存三个异常问题"></a>缓存三个异常问题</h2><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>大量缓存失效，同一时间过期或者Redis 宕机。<br>导致Mysql压力剧增，引发系统崩溃。</p><p>解决：<br>如果是缓存过期：<br>在设置缓存时，提前过期时间散列化，增加随机数；</p><p>如果访问缓存不存在，使用互斥锁，保证一个时间内只有一个请求来构建缓存。其他请求等待完成。当然，要设置超时时间，防止长时间阻塞。但锁开销大。</p><p>主备双key，一个主key，有过期时间；一个备key，永久缓存。<br>但，更新缓存需要同时更新主备双key。</p><p>定期程序更新，缓存不设置过期时间。<br>但，导致缓存紧张，引发淘汰策略。<br>解决上面可以用：<br>一是线程不仅要定期更新缓存，还要频繁检查缓存是否有效，就是把BD和缓存对比检查，有被淘汰的，就马上读取DB更新缓存。几乎实时，不然只查到空值。不推荐</p><p>二是消息队列，发现数据淘汰后，通过消息队列发送一条消息到后台线程，后台线程接收消息，先检查缓存是否存在，再读取DB更新到缓存。</p><p>在业务上线，要把缓存先加载，这就是所谓缓存预热。</p><p>如果是Redis 宕机<br>首先，最好集群化保证高可用，进行一个主从节点的复制。<br>再一个是，构建限流，熔断机制。<br>为了减少业务的影响，触发请求限流，只允许少部分请求进入，等待重启Redis并缓存预热后，再解除限流。<br>还有就是，启动熔断机制，暂停业务应用对缓存服务的访问，直接返回服务不可用错误。等Redis恢复，再允许访问。这主要保证除了Redis缓存外，其他的整体的服务依然可用。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>频繁访问的热点数据过期，大量高并发请求直接访问数据库，造成数据库被冲垮。这问题算是缓存雪崩的一个子集：<br>解决：<br>互斥锁：未查到缓存时，保证一个时间内只有一个业务对一个缓存构建，其他请求该缓存，要么等待要么返回默认值/null</p><p>不设置过期时间，后台异步更新缓存，或者热点数据准备过期前，通知后台线程更新以及重新设置过期时间。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>访问的数据不在缓存，也不在数据库。<br>一是校验请求合法性，二是返回空值或默认值，三是布隆过滤器。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h5 id="Q：redis-到底是单线程-还是-多线程？"><a href="#Q：redis-到底是单线程-还是-多线程？" class="headerlink" title="Q：redis 到底是单线程 还是 多线程？"></a>Q：redis 到底是单线程 还是 多线程？</h5><p>Redis 是单线程模型，这是指【从网络IO处理到实际的读写命令处理】都是单个线程完成的。有些命令是可用用后台子进程执行，比如快照生产，AOF重写。</p><p>严格意义上说，Redis4.0后并不是单线程，除了主线程之外，后台线程在处理一些比较长的操作，比如垃圾回收，无用连接的释放，大Key大删除。</p><p>在Redis6.0后，采用了多线程等待Socket读些，最终执行读写命令的过程依然在主线程。</p><h5 id="Q：为什么处理操作命令的过程在单线程呢？"><a href="#Q：为什么处理操作命令的过程在单线程呢？" class="headerlink" title="Q：为什么处理操作命令的过程在单线程呢？"></a>Q：为什么处理操作命令的过程在单线程呢？</h5><p>这样，Redis  不存在CPU瓶颈，主要受限于内存和网络。<br>如果采用多线程读写命令，虽然提高并发性能，但却引入了程序执行顺序的不确定性，带来并发读写的一系列问题， 增加系统复杂度，还有个线程的切换，甚至加锁解锁，死锁造成的性能消耗。</p><h5 id="Q：AOF重写缓冲区会被占满吗？"><a href="#Q：AOF重写缓冲区会被占满吗？" class="headerlink" title="Q：AOF重写缓冲区会被占满吗？"></a>Q：AOF重写缓冲区会被占满吗？</h5><p>理论不会，缓冲区维护着一些内存块的双向链表，每个节点指向对应aofblock空间。</p><h5 id="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"><a href="#Q：为什么AOF重写和RDB生成要开启子进程而不是线程？" class="headerlink" title="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"></a>Q：为什么AOF重写和RDB生成要开启子进程而不是线程？</h5><p>因为如果使用线程，多线程之前就会共享内存。那么修改共享数据，需要加锁，锁会阻塞主线程。</p><p>子进程的方式，可以利用写时复制的技术，不用加锁。</p><h5 id="Q：什么情况才会save？"><a href="#Q：什么情况才会save？" class="headerlink" title="Q：什么情况才会save？"></a>Q：什么情况才会save？</h5><p>当 Redis 内存数据高达几十 G，甚至上百 G 的时候，<strong>如果用 bgsave 进行 RDB 快照的话，在创建子进程的时候，会因为复制太大的页表而导致 Redis 阻塞在  <code>fork()</code>  函数，主线程无法继续执行，相当于停顿了</strong>。</p><p>所以针对这种情况建议用 save。</p><p>虽然 save 会一直阻塞 Redis 直到快照生成完毕，但是它这个阻塞并不是意味着停顿了，而是在执行生成快照的程序，只是期间主线程无法处理接下来的读写命令。</p><h5 id="Q：混合持久化如何区分开？"><a href="#Q：混合持久化如何区分开？" class="headerlink" title="Q：混合持久化如何区分开？"></a>Q：混合持久化如何区分开？</h5><p>头部有有个REDIS 表明锁RDB内容，中间遇到RDB结束标记，然后再解析AOF格式。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>避免单点故障，最好做集群化，做主从备份。<br>多台服务器要保存同一份数据，就要保持数据一致性。<br>Redis 提供了主从复制模式，且主从之间，采用读写分离。</p><p>客户端写操作：<br>对所有的数据写入只在主服务上进行，然后，讲最新的数据同步到从服务器，这样，主从服务器的数据保持一致；<br>客户端读操作：<br>通过负载均衡策略，可以在任意一台服务器读取。</p><h4 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h4><p>一是从服务器输入命令： replicaof  主IP+端口<br>建立连接，协商同步；<br>二是主服务器同步数据到从服务器，全量复制：主服务期生成并发送RDB文件，从接收后先清除，再载入。为了保证数据一执行，新写入的命令写到replication buffer 缓冲区中。<br>三是主服务器发送新写操作命令给从服务器；<br>将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，然后从服务器重新执行这些操作。</p><p>主从服务器再完成第一次同步后，会维护一个TCP连接。</p><p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p><p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p><h4 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h4><p>刚刚讲到，第一次会有生成RDB文件和传输RDB文件两个耗时操作。<br>特别是从服务器非常多，数据量非常大，有两个问题：<br>一是fork阻塞主线程，redis无法正常速度处理读写请求；<br>二是RDB占用主服务网络带宽，也会影响命令请求的速度；</p><p>这个时候，需要设置助手，主从架构分成树状架构。从不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器形式将数据同步给从服务器。</p><p>这种方式，把同步压力分摊到多个服务器。</p><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>主从服务器再完成第一次同步后，会基于长连接进行命令传播。<br>这有个问题，就是网络的不稳定性。<br>一旦网络断开，就无法保持数据一致性。<br>2.8之前，断开恢复会进行一次全量复制，这种开销是很恐怖的。<br>从2.8开始，从服务器会采用增量复制，继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p>主要有3步：<br>1从服务器在恢复网络后，会发送psync命令到主服务器，与第一次有区别，offset参数不是-1<br>2主服务器收到命令后，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；<br>3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p><h5 id="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"><a href="#Q：主服务器如何知道要传输哪些增量数据发送给从服务器？" class="headerlink" title="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"></a>Q：主服务器如何知道要传输哪些增量数据发送给从服务器？</h5><p>依靠两个东西：<br>repl_backlog_buff环形缓冲区，用于主从服务器断连后，从中找到差异的数据；<br>replication offset，标记上面的那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用master_repl_offset来记录自己写到的位置，从服务器使用slave_repl_offset 来记录自己 读到的位置</p><h5 id="Q：repl-backlog-buff缓冲区是什么时候写入的呢？"><a href="#Q：repl-backlog-buff缓冲区是什么时候写入的呢？" class="headerlink" title="Q：repl_backlog_buff缓冲区是什么时候写入的呢？"></a>Q：repl_backlog_buff缓冲区是什么时候写入的呢？</h5><p>在主服务器进行命令传播时，不仅会将写命令发送从服务器，还会将写命令写入到repl_backlog_buff 缓冲区里，因此，这个缓冲区里会保存着最近传播到写命令</p><p>当网络断开后，当从服务器重新连上主服务器时，从服务器会通过psync命令将自己的复制偏移量，slave_repl_ofset发送给主服务器，主服务根据自己的master_repl_offset和slave_repl_offset 之间的差距，然后决定对从服务器执行哪种同步操作：<br>如果从服务器要读取的数据数据在缓冲区，采用增量同步；<br>否则，采用全量同步。</p><p><strong>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</strong></p><p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。</p><p>因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p><p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p><h5 id="Q：如何解决覆盖问题？"><a href="#Q：如何解决覆盖问题？" class="headerlink" title="Q：如何解决覆盖问题？"></a>Q：如何解决覆盖问题？</h5><p>因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p><p>那 repl_backlog_buffer 缓冲区具体要调整到多大呢？</p><p>repl_backlog_buffer 最小的大小可以根据这面这个公式估算。</p><p>second* write_size_per_second</p><p>我来解释下这个公式的意思：</p><ul><li><p>second 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。</p></li><li><p>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</p></li></ul><p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p><p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p><p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p><p>关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p><p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p><p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p><p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p><p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p><h2 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h2><p><strong>先更新数据库，再更新缓存</strong><br>一是 db：1 2  缓存：2 1</p><p>二是 非原子操作，缓存可能会失败</p><p><strong>先更新缓存，再更新数据库</strong><br> 缓存：1 2 db：2 1</p><p>加分布式锁，保证一个时间只允许一个请求更新？  性能差，过期很快</p><p>旁路缓存策略。</p><ul><li><p>先删除缓存，再更新数据库；<br>缓存：  A删 B读旧改</p></li><li><p>先更新数据库，再删除缓存。<br>一是会写问题 A读db  B更db B写缓存 A写旧缓存<br>二是删除失败  写db后，删除失败，等过期才回写生效</p></li></ul><p>缓存过期 + 延迟双删<br>第二次删除前加睡眠，确保A请求在双删内部时间中，B能够读取db，回写缓存，然后A睡醒再删除缓存。</p><p>这方案尽可能保证一致性，极端情况，也会出现不一致。<br>比如，第二次的删除全部崩溃，这样，与先删缓存，再更新数据无差别。</p><p><strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？</strong><br>一 是重试机制<br>二 是 订阅binlog，再操作缓存。</p><p>基于消息队列的重试</p><ol><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ol><p>基于binlog的阿里中间件canal<br><strong>canal 工作原理</strong>  canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump（转储） 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )，canal 解析 binary log 对象(原始为 byte 流)</p><p>摘抄自：小林coding</p><hr><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><h4 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制?"></a>为什么要主从复制?</h4><p>1数据冗余 “数据的热备份”  2单机故障 “服务冗余”  3读写分离 “增加读请求能力”  4负载均衡 “分散单服务的压力”  5 高可用的基石  “哨兵和集群化”</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><p>将一台Redis服务器的数据，复制到其他Redis节点上，前者是主节点，后者是从节点，写操作交给主节点，读操作主要给从节点。</p><h4 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h4><p>slave节点初次连接master节点，会发送psync命令，并且触发全量复制，此时master节点fork一个后台进程，开始生成一份RDB快照，同时将那些从外面接收  到写命令缓存到缓冲区中，RDB文件生成完毕后，将此文件发送给slave节点，slave节点写入磁盘，再从磁盘价值到内存，接着master会将增加缓冲区的写命令发送给slave，slave执行写命令并同步数据，如果slave节点和master节点因网络故障而中断，会自动重连，连接之后master节点会复制缺少的数据给slave节点。</p><h6 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h6><p>建立长连接，  全量数据同步，  增量同步：命令传播，数据反复同步。</p><h5 id="主从同步类型"><a href="#主从同步类型" class="headerlink" title="主从同步类型"></a>主从同步类型</h5><p>1全量复制 全量同步一般发生在slave初始化过程，这时slave需要将master上的所有数据复制一份；  2增量复制  增量同步一般是slave初始化后开始正常工作时，主服务器发生写操作同步到从服务器的过程；</p><p>主从刚连接，全量同步，再增量同步；  redis优先考虑增量，如果不成功，就是会全量。</p><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p>runId 主节点ID  offset 复制便宜量  replication buffer 内部队列缓冲区  建立连接时创建，全量和增量都会用  repl_backlog_buffer 环形缓冲区  开启命令传播之前，会建立buffer。  buffer记录当前的master接收到新的写操作，offset和命令本身，是所有slave公用的buffer，salve发送psync之后，会和master的offset比较，，来决定是否增量复制。</p><h5 id="全量复制流程-（初始化）"><a href="#全量复制流程-（初始化）" class="headerlink" title="全量复制流程 （初始化）"></a>全量复制流程 （初始化）</h5><ul><li><p>master连接slave：【slave上输入save of命令】，发送psync ？ -1 命令，用于同步数据  “？” 表示是master的runID，“-1”表示offset第一次复制；</p></li><li><p>master回复ACK告知slave，它的runId和offset，slave将其保存</p></li><li><p>master fork子进程（如果单线程做耗时动作，性能非常差），生成RDB+AOF组合快照，然后向所有slave发送快照文件，并通过写时复制技术，继续执行接下来用户的一些写命令，并存放到replication buff 缓冲区当中；</p></li><li><p>slave 接收后，把本地数据清空，然后把快照加载到本地磁盘，接着加载到内存来执行。</p></li><li><p>master 发送replication buffer缓冲区给salve同步</p></li></ul><h5 id="增量复制流程-（重连接）"><a href="#增量复制流程-（重连接）" class="headerlink" title="增量复制流程 （重连接）"></a>增量复制流程 （重连接）</h5><p>1从服务器在恢复网络后，会发送psync runId offset命令到主服务器，与第一次有区别，offset参数不是-1 ；（runId比较，如果不一样，就全量复制）  2主服务器收到命令后，两offset求距离差，小于replication buff缓冲区大小，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；  3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><h5 id="Q：长连接还是短连接？"><a href="#Q：长连接还是短连接？" class="headerlink" title="Q：长连接还是短连接？"></a>Q：长连接还是短连接？</h5><p>长，减少连接开销；</p><h5 id="Q：判断某个节点是否正常？"><a href="#Q：判断某个节点是否正常？" class="headerlink" title="Q：判断某个节点是否正常？"></a>Q：判断某个节点是否正常？</h5><p>主从ping-pong心跳检查机制，一半以上的节点区ping一个节点，如果没有pong回应，集群认为该节点宕机；  master 10s发送一次，检查对方在线  slave 1s发一次，给从节点发送自己的复制偏移量，获取最新变更+检查对方在线</p><h5 id="Q：过期key如何处理？"><a href="#Q：过期key如何处理？" class="headerlink" title="Q：过期key如何处理？"></a>Q：过期key如何处理？</h5><p>处理key或者淘汰key，master模拟del命令发送给slave；</p><h4 id="Q-redis主从切换如何减少数据丢失？"><a href="#Q-redis主从切换如何减少数据丢失？" class="headerlink" title="Q: redis主从切换如何减少数据丢失？"></a><strong>Q: redis主从切换如何减少数据丢失？</strong></h4><p>1 一般是异步复制丢失。  解决：  一master本地缓存或持久化磁盘，在一段时间后写入新master；  二先写入rocketMQ，再发送一个延时消息去写入master。  2 脑裂丢失  脑裂就是一部分slave误以为master已死，选举新的master后，旧的master依旧存活，导致出现了两个master，从而读写数据混乱。  避免脑裂：  一种是投票超过半数作为leader，才被其他节点认可，这也是zookeeper方案。  重点是第二种，哨兵模式。  哨兵群会监控节点存活情况，当超过半数哨兵认为master主观下线，即master转为客户下线，就要推举新master。  哨兵内部讨论，每人1票，投超过半数，成为选举人。  选1举人，根据先优先级，再是节点的同步率，最后是创建时间，选择新的master。  slave会全量同步新的master。  旧的master恢复后，降级为slave，也会全量同步。  这个过程中，旧master全量同步过程就是产生<strong>脑裂丢失</strong>  解决：  两个参数  min-slaves-to-write 2 至少2个slave  min-slaves-max-lag 5 至少5秒  至少2个slave进行同步复制延迟不超过5秒，一旦违反，master停止接收任何请求，让原master下线，选举新的master。尽可能</p><h4 id="Q：redis如何做到故障自动切换？"><a href="#Q：redis如何做到故障自动切换？" class="headerlink" title="Q：redis如何做到故障自动切换？"></a>Q：redis如何做到故障自动切换？</h4><p>哨兵模式内部选举出一个选举人，选举人选举新的master。</p><h4 id="Q：数据备份方式"><a href="#Q：数据备份方式" class="headerlink" title="Q：数据备份方式"></a>Q：数据备份方式</h4><p>1热备  主库承担业务流量，通过实时备份数据到从库。</p><p>2冷备  主库承担业务流量，通过定期或者手动执行脚本备份数据到从库。  （redis）</p><p>3多活  由两个数据中心承担业务流量，互为主备，一般主数据中心会承担大部分流量，备数据会承担小部分流量。（多地域）</p><p>摘抄自：tojson</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;Redis数据结构&quot;&gt;&lt;a href=&quot;#Redis数据结构&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="Redis" scheme="https://missionodd.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计跳表 | 栈记录插入前驱可能，丢硬币控制插入层级（java）</title>
    <link href="https://missionodd.github.io/2022/02/10/design-skiplist/"/>
    <id>https://missionodd.github.io/2022/02/10/design-skiplist/</id>
    <published>2022-02-10T04:30:37.000Z</published>
    <updated>2022-02-16T10:19:23.648Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">the leetcode link</a></p><h3 id="1206-设计跳表"><a href="#1206-设计跳表" class="headerlink" title="1206 设计跳表"></a>1206 设计跳表</h3><p>不使用任何库函数，设计一个 跳表 。</p><p>跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：<br><a href="1506_skiplist.gif">skiplist</a></p><p>Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skip_list</a></p><p>在本题中，你的设计应该要包含这些函数：</p><p>bool search(int target) : 返回target是否存在于跳表中。<br>void add(int num): 插入一个元素到跳表。<br>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。<br>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p>示例 1:</p><p>输入<br>[“Skiplist”, “add”, “add”, “add”, “search”, “add”, “search”, “erase”, “erase”, “search”]<br>[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]<br>输出<br>[null, null, null, null, false, null, true, false, true, false]</p><p>解释<br>Skiplist skiplist = new Skiplist();<br>skiplist.add(1);<br>skiplist.add(2);<br>skiplist.add(3);<br>skiplist.search(0);   // 返回 false<br>skiplist.add(4);<br>skiplist.search(1);   // 返回 true<br>skiplist.erase(0);    // 返回 false，0 不在跳表中<br>skiplist.erase(1);    // 返回 true<br>skiplist.search(1);   // 返回 false，1 已被擦除</p><p>提示:</p><p>0 &lt;= num, target &lt;= 2 <em> 104<br>调用search, add,  erase操作次数不大于 5 </em> 104</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>设计Node，定义max_level，head ，level</li><li>通用步骤：枚举寻找目标所有层的前驱，过程是：先同层跳链表至前驱或尾节点，再进入下一层反复；</li><li>查询逻辑：在步骤2枚举过程中，一旦发现是前驱，则返回true；</li><li>删除逻辑：在步骤2枚举过程中，一旦发现是前驱，则同层的前驱指向其后驱，完成一次删除后进入下一层继续删除。优化：之后把可能产生的孤立头结点也删除；</li><li>插入逻辑：</li></ol><ul><li>第1步，在步骤2枚举过程中，一旦发现是前驱的可能，则压栈；这将得到一个能从底层至高层弹出所有前驱可能的栈。</li><li>第2步，先底层插入，才开始反复丢01硬币，概率性地从二层至高层插入新节点，以起始丢连续1的个数来控制插入多高层级，过程是：先不丢硬币，底层前驱出栈，新节点必插入在其后方，然后才开始丢硬币，决定是否插入次高一层，不插入则结束；如果要插入，就从栈取出当前层前驱，新节点插入在其后方形成连接，如果丢硬币运气太好，栈用完仍需插入，此时说明高度已超出原有层，则新建一层：新建头节点作为前驱，后方插入新节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;  <span class="comment">// 层级最大阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node right; <span class="comment">//指向同层的后驱</span></span><br><span class="line">        Node down; <span class="comment">//指向同节点的下一层，底层为空</span></span><br><span class="line">        Node(<span class="keyword">int</span> val, Node right, Node down)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.down = down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node head; <span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 当前最大层级</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Skiplist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        level = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;target) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 寻找新节点的所有符合条件的可能前驱节点，用栈记录下</span></span><br><span class="line">        Deque&lt;Node&gt; prevStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;num) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line"></span><br><span class="line">            prevStack.push(node); <span class="comment">// 高level到低level压栈 保存所有前驱节点</span></span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反复丢01硬币，决定插入新节点的level，底level必须插入，硬币初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> coins = <span class="number">1</span>;  <span class="comment">// 硬币初始化为1</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        Node prev = <span class="keyword">null</span>, newNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(coins == <span class="number">1</span> &amp;&amp; level &lt; MAX_LEVEL)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!prevStack.isEmpty())&#123;</span><br><span class="line">                <span class="comment">// 当有前驱，高level到低level弹栈</span></span><br><span class="line">                prev = prevStack.pop();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 当无前驱，则新建head作为前驱节点，level++</span></span><br><span class="line">                head = <span class="keyword">new</span> Node(-<span class="number">1</span>, <span class="keyword">null</span>, head);</span><br><span class="line">                prev = head;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入到当前层的链表上</span></span><br><span class="line">            newNode = <span class="keyword">new</span> Node(num, prev.right , newNode);</span><br><span class="line">            prev.right = newNode;</span><br><span class="line"></span><br><span class="line">            coins = rand.nextInt(<span class="number">2</span>);  <span class="comment">//丢硬币 [0,1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;num) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line">            <span class="comment">// 删除当前层的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val == num)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                node.right = node.right.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除孤立头节点</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.down;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/design-skiplist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1206-设计跳表&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="跳表" scheme="https://missionodd.github.io/tags/跳表/"/>
    
    <category term="模拟" scheme="https://missionodd.github.io/tags/模拟/"/>
    
  </entry>
  
  <entry>
    <title>用 Rand7() 实现 Rand10() | 分页 | 翻看日历的时候，把题做出来</title>
    <link href="https://missionodd.github.io/2022/02/04/implement-rand10-using-rand7/"/>
    <id>https://missionodd.github.io/2022/02/04/implement-rand10-using-rand7/</id>
    <published>2022-02-04T04:30:37.000Z</published>
    <updated>2022-02-16T10:31:48.316Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="470"><li>用 Rand7() 实现 Rand10()<br>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</li></ol></blockquote><blockquote><p>你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p></blockquote><blockquote><p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</p></blockquote><blockquote><p>示例 1:<br>输入: 1<br>输出: [2]</p></blockquote><blockquote><p>示例 2:<br>输入: 2<br>输出: [2,8]</p></blockquote><blockquote><p>示例 3:<br>输入: 3<br>输出: [3,8,10]</p></blockquote><blockquote><p>提示:<br>1 &lt;= n &lt;= 105</p></blockquote><h3 id="随机择日"><a href="#随机择日" class="headerlink" title="随机择日"></a>随机择日</h3><p>一个名为卢迪的宅男，他相信着，八月是循环的高发期，且时常有”/remake”自己的想法。</p><p>于是，<strong>他计划在2022年8月的随机一天，去坐公交车</strong>，为了遇见车途中可能发生的时空循环。</p><figure class="image-box">                <img src="https://pic.leetcode-cn.com/1644778673-nOHaQj-image.png" alt="image.png" title class>                <p>image.png</p>            </figure><p>看日历，很巧妙，2022年的8月的1号刚好是从周一开始。</p><p>一周有7天，而本题又很巧有Random7()的功能。</p><p>虽然卢迪不会做题，但他想了一个方法，<strong>利用Random7()，实现了等概率随机选择哪一天上公交</strong>！</p><p>这小伙子怎么做呢？</p><p>只见他眼疾手快，啪一下，直接写一行代码 <code>return rand7()</code>，</p><p>竟然把Ramdom7()作为输出结果。。。。。。真无语了</p><blockquote><p>第一次提交，输出结果是几，他就选择周几，记为a<br>第二次提交，输出结果是几，他就选择日历上的第几行，记为b</p></blockquote><p><code>补充说明，8月1号所在行是第1行，9月5号所在行是第6行。</code></p><p>当然，这样抽选的范围是从8月1号到9月18号，为49天。</p><p>抽到每一天的概率都是(1/7)*(1/7)，也相当实现Random49()。</p><p>但这不是他想要的结果，他<strong>只会在8月份中选择一天</strong>。</p><p>如果抽到9月份，他<strong>拒绝采样</strong>，重复第一次和二次的提交过程，重新择日。</p><p>有了拒绝采样步骤，就能实现Random31()，这才是他想要的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">他的随机过程：</span><br><span class="line">a=5，b=5，很不巧，8月没有这一天。拒绝采样，重新再来；</span><br><span class="line">a=2，b=7，很不巧，8月没有这一天。拒绝采样，重新再来；</span><br><span class="line">a=2，b=4，成功随机定位到23号出伏日；</span><br></pre></td></tr></table></figure><p><strong>Q：已知a和b，如何用公式计算出几号日期？</strong></p><blockquote><p>利用简单的分页公式：<strong>index = (pageNum - 1) * size + currentPageIndex</strong><br>页号是从1开始，把一周看作一页，得到： 几号日期 = (b-1) <em> 7 + a<br>例如：23号 = (4-1) </em> 7 + 2</p></blockquote><p>用<strong>分页思想</strong>，也可以得到一条<strong>随机数公式</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randAB = (randB-1) * A + randA</span><br></pre></td></tr></table></figure></p><p>比如上述例子，通过两个Random7()推出Random49()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand49  = (rand7-1) * 7 + rand7</span><br></pre></td></tr></table></figure></p><h3 id="关于拒绝采样范围过大的问题"><a href="#关于拒绝采样范围过大的问题" class="headerlink" title="关于拒绝采样范围过大的问题"></a>关于拒绝采样范围过大的问题</h3><p>卢迪突然接到父母指示，8月10号后不能出家门。</p><p>他只能计划在8月1号到8月10号中随机选择一天，意味着要实现Random10()。</p><p>他按照之前的方法操作，由于拒绝采样的范围过大，他总是抽取到8月10号以后的日子。</p><p>时间已过去很久，依然没抽中前10天，运气过背，他快抽麻了……</p><p>于是，他想办法优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">抽中第 1，11，21，31的位置就是1号出发</span><br><span class="line">抽中第 2，12，22，32的位置就是2号出发</span><br><span class="line">抽中第 3，13，23，33的位置就是3号出发</span><br><span class="line">......</span><br><span class="line">抽中第10，20，30，40的位置就是10号出发</span><br></pre></td></tr></table></figure></p><p>这样，采样范围由10就变成40，他马上抽中结果了。</p><p>这就是取余数的思路<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">几号日期 = index %10 + 1</span><br></pre></td></tr></table></figure></p><p>先决定取样范围：应为N的倍数，再用模N+1方式得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(index&gt;40)&#123;</span><br><span class="line">    index = rand7()+(rand7()-1)*7;</span><br><span class="line">&#125;</span><br><span class="line">return index%10+1;</span><br></pre></td></tr></table></figure></p><h3 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">41</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">40</span>)&#123;</span><br><span class="line">            index = (rand7()-<span class="number">1</span>)*<span class="number">7</span> + rand7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index%<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-rand10-using-rand7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="模拟" scheme="https://missionodd.github.io/tags/模拟/"/>
    
  </entry>
  
  <entry>
    <title>双端递减队列 | 滑动窗口最大值</title>
    <link href="https://missionodd.github.io/2022/02/02/sliding-window-maximum/"/>
    <id>https://missionodd.github.io/2022/02/02/sliding-window-maximum/</id>
    <published>2022-02-02T04:30:37.000Z</published>
    <updated>2022-02-16T10:08:36.156Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p></blockquote><blockquote><p>返回 滑动窗口中的最大值 。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [1], k = 1<br>输出：[1]</p></blockquote><blockquote><p>提示：<br>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104<br>1 &lt;= k &lt;= nums.length</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>定义递减的双端链表</li><li>链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</li><li>先校验是否足够组成窗口</li><li>若3步骤通过，窗口最大值取队头的元素</li><li>若3步骤通过，判断链头元素是否在下一个窗口内，不在则舍弃</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        1. 定义递减的双端链表</span></span><br><span class="line"><span class="comment">        2. 链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</span></span><br><span class="line"><span class="comment">        3. 先校验是否足够组成窗口</span></span><br><span class="line"><span class="comment">        4. 窗口最大值取队头的元素</span></span><br><span class="line"><span class="comment">        5. 判断链头元素是否在下一个窗口内，不在则舍弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1. 定义递减的双端链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; d = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">            <span class="comment">// 2. 链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</span></span><br><span class="line">            <span class="keyword">while</span>(!d.isEmpty() &amp;&amp; d.peekLast()&lt;nums[r])&#123;</span><br><span class="line">                d.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            d.addLast(nums[r]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 先校验是否足够组成窗口</span></span><br><span class="line">            <span class="keyword">if</span>(r-k+<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 4. 窗口最大值取队头的元素</span></span><br><span class="line">               res[index++] = d.peekFirst();</span><br><span class="line">                <span class="comment">// 5. 判断链头元素是否在下一个窗口内，不在则舍弃</span></span><br><span class="line">               <span class="keyword">if</span>(d.peekFirst()== nums[r-k+<span class="number">1</span>])&#123;</span><br><span class="line">                    d.removeFirst();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;block</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="双端队列" scheme="https://missionodd.github.io/tags/双端队列/"/>
    
    <category term="滑动窗口" scheme="https://missionodd.github.io/tags/滑动窗口/"/>
    
  </entry>
  
  <entry>
    <title>位运算 | 2bit标识3状态 | 有限状态自动机</title>
    <link href="https://missionodd.github.io/2022/02/02/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"/>
    <id>https://missionodd.github.io/2022/02/02/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</id>
    <published>2022-02-02T04:30:37.000Z</published>
    <updated>2022-02-16T10:13:26.193Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 56 - II. 数组中数字出现的次数 II<br>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [3,4,3,3]<br>输出：4</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p></blockquote><blockquote><p>限制：<br>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题解主要是根据k神题解的<strong>有限状态自动机</strong>思路，补充了一些数据结构的可视化，方便大家理解。</p><h3 id="一个结论"><a href="#一个结论" class="headerlink" title="一个结论"></a>一个结论</h3><p><strong>如果所有数字都出现3次，把所有数字的每一个二进制位分别求和，各位置的结果均为 3 的倍数。</strong><br>对于本题，我们分别统计所有数字的每二进制位中 1 的出现次数，并把各位置的结果<strong>分别对 3 求余，结果得到只出现一次的数字</strong>。<br>比如： [3,4,3,3]<br>|  0 |  0 |  0 |  1 |  1 |<br>|—-|—-|—-|—-|—-|<br>|  0 |  0 |  1 |  0 |  0 |<br>|  0 |  0 |  0 |  1 |  1 |<br>|  0 |  0 |  0 |  1 |  1 |<br>出现次数：<br>|  0 |  0 |  1 |  3 |  3 |<br>|—-|—-|—-|—-|—-|<br>模3：<br>|  0 |  0 |  1 |  0 |  0 |<br>|—-|—-|—-|—-|—-|<br>得到结果：4</p><h2 id="方法：有限状态自动机"><a href="#方法：有限状态自动机" class="headerlink" title="方法：有限状态自动机"></a>方法：有限状态自动机</h2><p>对于所有数字中的某二进制位 1 的个数mod 3，会得到3个结果，即存在3种状态：0,1,2。</p><p>1bit只有0和1，无法表示3种状态。</p><p>于是，我们把<strong>每二进制位的位置，用2bit表示：00，01，10</strong><br>比如：<br>各位的出现次数及其对应的mod3状态：<br>|  0 |  0 |  1 |  2 |  3 |<br>|—-|—-|—-|—-|—-|<br>| 00 | 00 | 01 | 10 | 00 |</p><ul><li>对于每一个二进制位置，累加过程mod3的状态转移是循环的：<br><code>出现0次：00</code> -》 <code>出现1次：01</code> -》 <code>出现2次：10</code> -》<code>出现3次：00</code> -》<code>出现4次：01</code> …</li><li>对于不同两个二进制位置，状态同步转移，比如一个位出现1次，另一个位出现4次，此时次数mod3状态是一致的，当新累加一个数，两者状态都要一次转移，可能入0转移到自己，可能入1就到下个状态。</li></ul><h3 id="Q：这样2bit的结构具体如何在代码中表达？"><a href="#Q：这样2bit的结构具体如何在代码中表达？" class="headerlink" title="Q：这样2bit的结构具体如何在代码中表达？"></a>Q：这样2bit的结构具体如何在代码中表达？</h3><p>定义两个变量表示当前mod3状态：ones，twos<br>ones表示所有2bit二进制位的所有第一位；<br>twos表示所有2bit二进制位的所有第二位；<br>比如：<br>出现次数mod3状态：<br>| 0<strong>0</strong> | 0<strong>0</strong> | 1<strong>0</strong> | 0<strong>1</strong> | 0<strong>1</strong> |<br>|—-|—-|—-|—-|—-|<br>ones是：<br>|  <strong>0</strong> |  <strong>0</strong> |  <strong>0</strong> |  <strong>1</strong> |  <strong>1</strong> |<br>|—-|—-|—-|—-|—-|<br>twos是：<br>|  0 |  0 |  1 |  0 |  0 |<br>|—-|—-|—-|—-|—-|</p><h3 id="状态转移方程推导"><a href="#状态转移方程推导" class="headerlink" title="状态转移方程推导"></a>状态转移方程推导</h3><p>对于某一个二进制位：<br>定义第一位one，第二位two，新累加二进制位数：n<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span> &amp;&amp; one == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one  <span class="comment"># one = 1</span></span><br><span class="line">    two = two   <span class="comment"># two = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> two == <span class="number">0</span> &amp;&amp; one == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one  <span class="comment"># one = 0</span></span><br><span class="line">    two = ~two  <span class="comment"># two = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span> &amp;&amp; one == <span class="number">0</span>:</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = one   <span class="comment"># one = 0</span></span><br><span class="line">    two = ~two  <span class="comment"># two = 0</span></span><br></pre></td></tr></table></figure></p><p>已知位运算特性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特性1：异或运算：x ^ 0 = x​ ， x ^ 1 = ~x</span><br><span class="line">特性2：与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span><br></pre></td></tr></table></figure></p><p>观察可知：<br>a.当 two是1时，one不变<br>b.当 two是0时，入1则one取反，入0则one不变 <code>（符合特性1: one = one^n）</code><br><code>（a,b符合特性2: one = (one^n) &amp; ~two）</code><br>c.当 one变为0时，入1则two取反，入0则two不变<code>（符合特性1：two = two^n）</code><br>d.当 one变为1时，two不变<br><code>（c,d符合特性2: two = (two^n) &amp; ~one）</code></p><p>推导简化公式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int ones = 0, twos = 0;</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        return ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode lin</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="位运算" scheme="https://missionodd.github.io/tags/位运算/"/>
    
  </entry>
  
  <entry>
    <title>jvm | 虚拟机全面扫盲+深入理解的原创笔记</title>
    <link href="https://missionodd.github.io/2022/02/01/jvm-notes/"/>
    <id>https://missionodd.github.io/2022/02/01/jvm-notes/</id>
    <published>2022-02-01T05:50:37.000Z</published>
    <updated>2022-03-17T15:25:50.024Z</updated>
    
    <content type="html"><![CDATA[<p><strong>引言：</strong><br>来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。<br>优点：笔记知识点关联性好，挖得深，延伸多。<br>缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般</p><h1 id="1-class文件"><a href="#1-class文件" class="headerlink" title="1. class文件"></a>1. class文件</h1><figure class="image-box">                <img src="image-20220208022707509.png" alt="class文件" title class>                <p>class文件</p>            </figure><p><a href="https://blog.csdn.net/lioncatch/article/details/105919391" target="_blank" rel="noopener">https://blog.csdn.net/lioncatch/article/details/105919391</a></p><p><a href="https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc</a></p><p>8字节 2进制  Java文件编译之后</p><ul><li><h3 id="4字节魔数：标志文件类型；视频，照片也有魔数"><a href="#4字节魔数：标志文件类型；视频，照片也有魔数" class="headerlink" title="4字节魔数：标志文件类型；视频，照片也有魔数"></a>4字节魔数：标志文件类型；视频，照片也有魔数</h3></li><li><h3 id="次版本号和主版本号：标志JDK版本；兼容低版本问题"><a href="#次版本号和主版本号：标志JDK版本；兼容低版本问题" class="headerlink" title="次版本号和主版本号：标志JDK版本；兼容低版本问题"></a>次版本号和主版本号：标志JDK版本；兼容低版本问题</h3></li><li><h3 id="常量池计数器：记录后面常量池的常量（数据项）个数；※"><a href="#常量池计数器：记录后面常量池的常量（数据项）个数；※" class="headerlink" title="常量池计数器：记录后面常量池的常量（数据项）个数；※"></a>常量池计数器：记录后面常量池的常量（数据项）个数；※</h3></li><li><h3 id="常量池：字面量-符号引用"><a href="#常量池：字面量-符号引用" class="headerlink" title="常量池：字面量+符号引用"></a>常量池：字面量+符号引用</h3><p> 1.字面量：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值。<br> 2.符号引用<br>   package名字，权限命名，字段名称，方法名称，字段描述符，方法描述符，方法句柄，方法类型，动态调用点和动态常量（不了解）<br>   <strong>一句话：这部分就是常量池，装载了全部类的字段，方法，类名称的信息；</strong></p><figure class="image-box">                <img src="image_20220118183346.png?v=1&type=image&token=V1:3n03VpBe2yMBZgKD5g9o0h5d90CeNevbyQO6LX2UnvQ" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image-20220208023504211.png" alt="符号引用" title class>                <p>符号引用</p>            </figure><p><strong>每个常量项的第一个字节 对应上图中的tag标志 找到对应的结构</strong></p><figure class="image-box">                <img src="image_20220118170506.png?v=1&type=image&token=V1:6K2y024TT-YRQvmLRY5b09neyTtm2iaN319VPeQprHY" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184004.png?v=1&type=image&token=V1:rLsRMkCAd22AUMMS2KXLkI8chGO6nlPHBPOsm1vbbXM" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184033.png?v=1&type=image&token=V1:3CCva6EeaLck4wLZttiedHSfKB0KY8VF3QdPIXjTUjE" alt title class>                <p></p>            </figure></li></ul><ol start="2"><li>面试题</li></ol><ul><li><p>Q  哪些字面量会进入常量池中？</p><ol><li>【final修饰】的8种基本类型的值会进入常量池。</li><li>【非final类型】（包括static的）的8种基本类型的值，只有【double、float、long】的值会进入常量池。</li><li><p>常量池中包含的字符串类型字面量（【双引号引起来的字符串值】）。</p></li><li><p>final类型的8种基本类型的值会进常量池。</p></li><li><p>final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进常量池。</p></li><li><p>常量池中包含的字符串类型字量（双引号引起来的字符串值）。</p></li></ol></li><li><p>java 字段名和方法名，有无长度限制？<br>A: 有，CONSTANT_Utf8_info 存储字符串字面量， 最大长度是65535，大小限制在小于64kb</p><figure class="image-box">                <img src="image_20220119024159.png?v=1&type=image&token=V1:W7pDbZc-acY3wco7miFQ9qcUzZDjMeym7ot3fpzX19A" alt title class>                <p></p>            </figure></li><li><p>Q 字符串有长度限制吗？是多少？<br>  答：</p><ol><li>运行期限制<br>首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,<br>由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</li><li>编译时期限制<br>通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错。<br>原来是为了弥补早期设计时的一个bug，“长度刚好65535个字节，且以1个字节长度的指令结束，这条指令不能被异常处理器处理”，因此就将数组的最大长度限制到了65534了。跟程序计数器有关</li></ol></li></ul><p>运行时拼接或者赋值的话范围是在整形的最大范围。<br><a href="https://blog.csdn.net/rd_w_csdn/article/details/110387250" target="_blank" rel="noopener">https://blog.csdn.net/rd_w_csdn/article/details/110387250</a></p><p><del>错误回答：</del><br><del>CONSTANT_Utf8_info 中有 u2 length; 表明了该类型存储数据的长度。 u2 是无符号的 16 位整数，因此理论上允许的的最大长度是 2^16=65536。而 java class 文件是使用一种变体 UTF-8 格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534 个字节。</del></p><p><code>Modified UTF-8</code>  UTF-8 缩略编码是改进版的<code>UTF-8</code>编码，它和标准的UTF-8编码有下面三点区别：</p><ol><li><code>null</code>空字符的编码从一个字节的<code>&#39;\u0000&#39;</code>改变为2个字节的形式，即11000000 10000000，因此在字符串的编码中不会出现嵌入的null字符；</li><li>只使用1~3个字节的格式；（即范围由\u0000-\uffff）</li><li>辅助字符以代理对的形式表示。 <strong>补充字符通常指大于u+ffff而小于等于u+10ffff范围内的字符</strong></li></ol><ul><li>Q常量池计数器从0还是1开始？<br>A: 从1开始，0索引留给无法指向的东西，即没有父类，没有类名的，比如匿名内部类，Object类</li></ul><figure class="image-box">                <img src="image_20220116204409.png" alt title class>                <p></p>            </figure><ul><li><h3 id="2字节的访问标志："><a href="#2字节的访问标志：" class="headerlink" title="2字节的访问标志："></a>2字节的访问标志：</h3><p>  表明这个class有什么修饰符 只有两个字节</p><figure class="image-box">                <img src="image-20220208024117844.png" alt title class>                <p></p>            </figure></li></ul><p>举例: 原来是00 20(看下表中ACC_SUPER描述，最低限度必须有此标志)<br>如果：类是public类型-的，则第一个ACC_PUBLIC为true 则加上00 01 ，结果为00 21<br>如果：类还是 final类型-的，则第二个为true，再加上00 10 ，结果为00 31</p><p>00 21 = 00 20 + 00 01 ( 加了public)<br>表示为public 的类<br>设置的数值刚好不会出现相加和其他状态相等的情况，很巧妙<br><strong>一句话 访问标识就是只用两个字节表示了这个类的修饰符有哪些</strong></p><ul><li><h3 id="类、父类-This-class-Super-class"><a href="#类、父类-This-class-Super-class" class="headerlink" title="类、父类(This class,Super class)"></a>类、父类(This class,Super class)</h3><p>如 00 02 和 00 003两个标识符也都是一个两字节的引用，我们class文件中，分别引向常量池中00 02的第二个常量项和00 03 第三个常量项<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到类名</p><figure class="image-box">                <img src="20200506112335237.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></li><li><h3 id="接口索引计数器"><a href="#接口索引计数器" class="headerlink" title="接口索引计数器"></a>接口索引计数器</h3><p>类文件实现了接口的数量，没有就是00 00 ，有一个就是 00 01</p></li><li><h3 id="接口索引项"><a href="#接口索引项" class="headerlink" title="接口索引项"></a>接口索引项</h3><p>指向常量池索引<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到接口名</p></li></ul><ul><li><h3 id="字段表：字段个数，字段1，字段2。。。。"><a href="#字段表：字段个数，字段1，字段2。。。。" class="headerlink" title="字段表：字段个数，字段1，字段2。。。。"></a>字段表：字段个数，字段1，字段2。。。。</h3><p>和上面差不多<br>字段表，方法表，class类都有自己的属性表！<br>`<br>※  注意：ConstantValue属性：</p><p>  final static String = “hello”<br>必须是String 类型，其值直接存储在字段表里面附带自己的属性表的ConstantValue属性指向的常量池里面，这样就可以类未加载直接用，效率提升<br>`</p></li></ul><blockquote><p>ConstantValue属性<br>属性表中的一个属性<br>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p><p>在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p><p>为什么ConstantValue的属性值只限于基本类型和string？</p><p>因为从常量池中只能引用到基本类型和String类型的字面量</p><p>final、static、static final修饰的字段赋值的区别</p><p>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</p><p>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</p><p>static<br>final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。</p><p>可以理解为在编译期即把结果放入了常量池中。</p></blockquote><figure class="image-box">                <img src="image_20220118180056.png?v=1&type=image&token=V1:CPihlXhsDyMBxTiSaP4vHqG9vSKcCYlTGlI4SJLB2Os" alt title class>                <p></p>            </figure><p><strong>分析第一个 access_flags</strong><br>—-其实跟之前我们讲访问标识的时候一样，不一样的是这次的访问标志修饰符是修饰字段的<br>所以在标志名称上有些不同<br><img src="image-20220208024515966.png" alt="在这里插入图片描述"></p><p>这里加一张图用另一种方式表示我们的修饰符<br><figure class="image-box">                <img src="image-20220208024418503.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></p><p><strong>分析第四个 attributes_count</strong><br>表示这个字段所拥有的attribute类型的个数，如果是00 01 就表示一个<br><strong>分析第五个 attributes[attributes_count]</strong><br>就是一个长度为 attributes_count，类型是：属性类型的数组<br>这个类型我们暂时不分析，到后面讲到 属性 时一起讲</p><p><strong>一句话总结<br>就是一个装有我们定义的所有属性的数组，长度为字段个数，里面的每一个表信息都表示一个字段</strong></p><ul><li><h3 id="方法表：-方法个数，方法1，方法2。。。。"><a href="#方法表：-方法个数，方法1，方法2。。。。" class="headerlink" title="方法表： 方法个数，方法1，方法2。。。。"></a>方法表： 方法个数，方法1，方法2。。。。</h3></li><li>字段表，方法表，class类都有自己的属性表！<figure class="image-box">                <img src="image_20220118182212.png?v=1&type=image&token=V1:I_meGZXidnP-pQ7GadHjyGZ5OJv_1gQzErPxNEyHeg0" alt title class>                <p></p>            </figure>access_flags的修饰类型<figure class="image-box">                <img src="image-20220208024616971-16442595798677.png" alt title class>                <p></p>            </figure></li></ul><p>※※  方法的代码存储在： 方法表里面附带自己的属性表的CODE属性里面。<br><a href="https://blog.csdn.net/weixin_29732737/article/details/113051809" target="_blank" rel="noopener">https://blog.csdn.net/weixin_29732737/article/details/113051809</a><br> <strong>max_stack</strong><br>操作数栈的最大深度，说明方法在编译把方法的栈深度已经定好了。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。<br><strong>max_locals</strong><br>局部变量表所需要的空间，长度不能变<br>单位是Slot，int、byte和returnAddress不超过32位的数据类型采用1个Slot来存储；<br>double和long等64位的数据类型采用两个Slot存储<br><strong>其他（包括异常信息）</strong><br>code_length存储了方法体中的字节码指令的长度<br>code就存储了具体的字节码指令<br>exception_table_length<br>显示异常(受检查的异常)中的个数(try-cacatch中的异常)<br>exception_info<br>这是受检查异常的具体信息</p><ul><li><h3 id="属性表：-属性个数，属性1，属性2。。。。"><a href="#属性表：-属性个数，属性1，属性2。。。。" class="headerlink" title="属性表： 属性个数，属性1，属性2。。。。"></a>属性表： 属性个数，属性1，属性2。。。。</h3>上面所说的<strong>字段</strong>和<strong>方法</strong>的最后都有一项：<strong>属性项数组</strong>，里面装的就是这个类型了,比如ConstantValue和Code<br>其实class文件还有一个属性表，就是上面那张图没有覆盖掉的最后一部分<br>在Class文件、字段表、方法表都可以携带自己的属性表集合！！！<br>属性表中不要求各个属性表具有严格的顺序，只要不与已有属性重名即可</li></ul><h1 id="2-JVM-类加载的整体流程"><a href="#2-JVM-类加载的整体流程" class="headerlink" title="2. JVM 类加载的整体流程"></a>2. JVM 类加载的整体流程</h1><p> 普通回答（过于绝对）：<br> 加载，连接，初始化<br> 连接又分为验证，准备，解析</p><p>※ 从细节回答：<br>真正是分为7到8步</p><ol><li>加载<br> 静态加载，java编译为class文件二进制字节流，获得的是class文件二进制字节流</li><li>验证<br> 进入连接阶段的验证：<br>第一步，文件格式验证： 魔数和主次版本号</li><li>加载<br> 验证成功后，把class文件二进制字节流 加载到 方法区<br>  作用： 结构调整，把静态存储文件转换为运行时数据结构<br> （思考： class常量池和方法区的运行时常量池的区别和联系）</li><li>加载<br> 堆内存生成当前类class对象 作为方法区中这个类的各种访问入口，比如：Object类，java.lang.Object 一定先加载，放入堆，提供给其他类访问</li><li>验证<br> 跳到连接阶段的验证：<br>第二步，元数据验证，字节码描述的信息进行语义分析</li><li>验证<br> 跳到连接阶段的验证：<br>第三步，字节码验证，通过数据流和控制流分析<br> <a href="https://blog.csdn.net/weixin_38608626/article/details/88173916" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38608626/article/details/88173916</a></li><li>准备<br> 0值的初始转化，含了给这个类的静态变量static和其他数据分配内存空间（<strong>仅仅是分配内存空间，具体初始化在最后一步</strong>）。<br> static int a=123;  这一阶段a会变成0</li><li>初始化<br> （解析： 第四步，符号验证，常量池内符号引用转直接引用，确定解析一定初始化之前，不确定在何时）【直接引用与虚拟机有关，不同的虚拟机翻译出来一般不会相同】<br> JVM用赋值或者缺省值将静态变量进行初始化，并执行静态初始化程序（static块中的代码），初始化发生在执行main方法之前，但在指定的类初始化之前他的父类必须先初始化，若其父类仍然存在父类，那也需递归的初始化。</li></ol><p>真正执行java代码，会调用<code>&lt;clinit&gt;()</code>方法 ：<br><code>在编译生成class文件时,会自动产生两个方法,一个是类的初始化方法&lt;clinit&gt;, 另一个是实例的初始化方法&lt;init&gt;。</code><br>只有被static修饰并且赋值的静态属性才会产生<code>&lt;clinit&gt;()</code>方法，不管是直接赋值还是在静态块中赋值，最后都会被合并成一个<code>&lt;clinit&gt;()</code>方法，并按照代码中的顺序依次赋值。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口。</li><li>在初始化一个接口时，并不会先初始化它的父接口。</li></ul><h3 id="（面试题）-什么情况下立即对类初始化？"><a href="#（面试题）-什么情况下立即对类初始化？" class="headerlink" title="（面试题） 什么情况下立即对类初始化？"></a>（面试题） 什么情况下立即对类初始化？</h3><p>1 遇到四条字节码指令会立即初始化：</p><ul><li>创建普通对象的指令：new</li><li>访问类字段（static 字段，或者称为类变量）的指令：getstatic, putstatic</li><li>invokestatic 指令：用于调用类方法(static方法)。<br>（new引用类会立即初始化， new数组不会初始化： 原因：创建数组得到指令：newarray , anewarray , multianewarray，不是new指令）</li></ul><p>2 反射直接初始化<br>3 父类未初始化先初始化<br>4 有main函数<br>5 java.lang.invoke.MethodHandle 实例最后解析结构结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，必须触发其初始化。<br>6 jdk1.8 接口default 方法</p><p>引申知识：</p><ul><li><p>加载：<br>  双亲委派模型：<br>  1启动类加载器（lib目录，根加载器），<br>  2拓展类加载器（lib-&gt;ext目录），<br>  3系统类加载器<br>(又叫应用程序加载器，加载用户类路径（classpath）上的指定类库，可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器)<br> 4当然，可以通过继承Classloader实现自定义加载器<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><ul><li><p>（面试） 双亲委派好处？<br>1.顺序加载。父类优先加载，<strong>避免重复加载</strong><br>2.安全性和唯一性。<strong>避免核心类篡改</strong></p><p>  利用 沙箱安全机制。 比如：加载器发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来（或自己写）的java.lang.Integer<br>  <code>tips： instance of 是根据类名称+类加载器 定位</code></p></li><li>JVM加载数组？<br>数组这个类加载，不是类加载器加载，其内存区域是运行中内存动态构造的。<br>类型的类在new时，才由加载器加载。<br>如何标记出唯一数组？</li></ul><ol><li>当引用类被加载器加载时，数组标志在加载器的<code>命名空间</code>上。</li><li>基础类型数组类型直接标记在<code>启动类加载器</code>的<code>命名空间</code>上。</li></ol></li></ul><p><strong>命名空间</strong><br>    <a href="https://blog.csdn.net/chuifuhuo6864/article/details/100887587" target="_blank" rel="noopener">https://blog.csdn.net/chuifuhuo6864/article/details/100887587</a></p><blockquote><p>由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间。命名空间由一系列唯一的名称组成，每一个被装载的类有一个名字。JAVA虚拟机为每一个类装载器维护一个名字空间。例如，一旦JAVA虚拟机将一个名为Volcano的类装入一个特定的命名空间，它就不能再装载名为Valcano的其他类到相同的命名空间了。可以把多个Valcano类装入一个JAVA虚拟机中，因为可以通过创建多个类装载器从而在一个JAVA应用程序中创建多个命名空间。<br><strong>初始类装载器/</strong> <strong>定义类装载器</strong></p><p>命名空间有助于安全的实现，因为你可以有效地在装入了不同命名空间的类之间设置一个防护罩。在JAVA虚拟机中，在同一个命名空间内的类可以直接进行交互，而不同的命名空间中的类甚至不能觉察彼此的存在，除非显示地提供了允许它们进行交互的机制，如获取Class对象的引用后使用反射来访问。</p><p>如果要求某个类装载器去装载一个类型，但是却返回了其他类装载器装载的类型，这种装载器被称为是那个类型的<strong>初始类装载器</strong><br>；而实际装载那个类型的类装载器被称为该类型的<strong>定义类装载器</strong><br>。任何被要求装载类型，并且能够返回Class实例的引用代表这个类型的类装载器，都是这个类型的初始类装载器。</p></blockquote><h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h1><p>1.常量池常量池,也叫Class常量池(常量池==Class常量池)。Java文件被编译成Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区各种字面量(Literal)和符号引用。在Class文件结构中，最头的4个字节用于存储魔数(MagicNumber)，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念。如下</p><p>2.运行时常量池</p><p>2.1运行时常量池的简介运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中2.2方法区的Class文件信息，Class常量池和运行时常量池的三者关系字符串常量池</p><p>3.1字符串常量池的简介字符串常量池又称为：字符串池，全局字符串池,英文也叫StringPo。在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3. 运行时数据区"></a>3. 运行时数据区</h1><ol><li>线程共享<br> 方法区，堆</li><li>线程私有<br> 虚拟机栈，本地方法栈，程序计数器</li></ol><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol><li>小内存，几乎无OOM，控制代码执行位置，比如循环，线程block恢复，wait恢复</li></ol><h2 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h2><ol><li>存储类信息 （第四步加载过程）</li><li>常量，静态变量</li><li>即时编译后的代码缓存数据 【Class方法表中Code属性，保存执行指令字节，将其缓存在方法区】</li></ol><p>元空间：能不限制使用系统内存资源</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ol><li>存放编译期生成的字面量+符号引用</li><li>具备动态性<br>不要求常量一定只有编译期才能产生<br><strong>String.intern()</strong> 是一个Native方法。调用intern()方法后，JVM 就会在当前类的运行时常量池中查找是否存在与str等值的String，若存在则直接返回运行时常量池中相应Strnig的引用；若不存在，则会在运行时常量池中创建一个等值的String，然后返回这个String在运行时常量池中的引用。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol><li>对象头（Header）: （Mark Word+ class指针+ 数组长度）<br>hashcode，GC分代年龄，锁标志状态，当前锁，偏向锁ID，偏向时间戳</li><li>实例数据（ Instance）</li><li>对齐填充（Padding）： 不满8字节的倍数就对齐填充<br><strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。 如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></li></ol><p><strong>（面试题） 64位JVM 中 new Object()  在Java中占多少内存？</strong><br>16字节。<br>Mark Word （8字节）+ class指针（指针压缩4字节，否则8字节）+实例数据（0字节）+对齐填充（4字节或0字节）</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>java栈是针对每一个线程的，每一个线程都会有自己的栈，维护在其内部的引用就是本地变量表。</p><p>通过线程想起栈，提问，对象是如何被线程访问定位的呀？问的非常底层。<br><a href="https://blog.csdn.net/y471519146/article/details/104638340" target="_blank" rel="noopener">https://blog.csdn.net/y471519146/article/details/104638340</a></p><ol><li>使用句柄。句柄是一个对象的唯一标示。中间有一个句柄池，存在于java堆的内存区域，线程指向句柄池，句柄池reference链接到对象地址</li><li>使用直接指针。线程对象指向另一对象。<br>优劣：直接指针访问快，但gc清理将对象位置移动，每个线程的指针就要改变，消耗大。<br>句柄优势：稳定，句柄池位置不变，当gc清理将对象位置移动，只需改变句柄池1个链接。</li></ol><h3 id="栈帧※"><a href="#栈帧※" class="headerlink" title="栈帧※"></a>栈帧※</h3><ol><li>1个方法创建1个栈帧：存储方法的局部变量表，操作数栈，动态链接，返回地址等。【class方法表中附带属性表中code属性有局部变量所需要的空间】</li><li>开始调用到完成过程就是一个栈帧的入栈出栈<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5>存储方法里的局部变量（包括方法参数），编译完成存储【class方法表中附带属性表中code属性】<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5>方法调用的最大深度【code属性的max_stack】，比如递归，调用数超出，则StackOverflowError。<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5>方法调用过程中，链接其他方法或其他类<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5>谁调用返回给谁。分两点</li><li>正常退出。</li><li>异常退出。抛错给调用方。</li></ol><p>####</p><h2 id="堆-展开知识-（第二期）"><a href="#堆-展开知识-（第二期）" class="headerlink" title="堆 展开知识 （第二期）"></a>堆 展开知识 （第二期）</h2><p>Q:新生代  eden s0 s1 是根据什么思想 8:1:1分区 ？ 回收器都是这样吗？<br>基于标记复制算法思想； 而基于标记清理算法就不是。</p><p>第一次minorgc： eden 空，s0 年龄1<br>第二次minorgc：eden空，s0空，s1 年龄有1和2<br>此时 s0 和 s1 角色互换<br>第三次minorgc：eden 1岁，s0空，s1 年龄有2和3<br>                             eden 空，s0空年龄有1,、2和3 ，s1空<br>此时 s0 和 s1 角色互换…</p><p>为什么需要s0和s1？<br> 需要空闲的缓冲内存，存储清理后的存活对象，避免s0区空间碎片化。</p><p>老年代</p><ol><li>年龄15岁以上</li><li>超大对象，超过阈值设置 max tenuring thread hold</li><li><p>相同年龄所有对象大小总和大于一个幸存者空间的一半，取年龄大于等于的对象，<br>所以年轻代空间利用，只有 90%</p><p>（一旦老年代要满就引发fullgc）</p></li></ol><p>※ 空间分配担保策略<br> minorGC发生之前，第一步先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立确保安全，如果条件不成立，比如空间剩余500M；<br> 就会第二步检查虚拟机HandlePromotionFailure参数是否true，是否允许担保失败；<br> 如果允许担保失败，jvm再次第三步检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小；</p><ul><li>如果大于，比如平均之前300M，冒险尝试一次minorGC，  存在风险：minorGC后存活对象还是大于500M，超出最大可用连续空间，说明老年代要满了就引发fullGC。<ul><li>如果小于 或 HandlePromotionFailure参数false，就直接fullGC。</li></ul></li></ul><p>（面试）如何判断对象是否存活？ gc过程是什么？<br>可达性分析算法，通过一系列称为“GC Roots”根节点，开始引用链的搜索，如果对象搜索不到，证明对象不可达，标记白色，最终被垃圾回收。<br>引申：引用计数器算法，每个对象有引用计数器，Redis使用<br>5个问题：</p><h3 id="1-gcroots-是什么？"><a href="#1-gcroots-是什么？" class="headerlink" title="1.gcroots 是什么？"></a>1.gcroots 是什么？</h3><p>是可达性分析的起点，是两个栈的栈帧的本地变量表中引用的对象，方法区中静态属性引用的对象，方法区中常量引用对象（两个栈两个方法区），其实还有，jvm内部也有引用，锁的获取和释放。</p><h3 id="2-引用链是什么？"><a href="#2-引用链是什么？" class="headerlink" title="2.引用链是什么？"></a>2.引用链是什么？</h3><p>强：常见，永远不被垃圾回收<br>软：非必须，内存溢出OOM之前，列入回收范围进行第二次回收，还溢出就抛错<br>弱：生存到下一次垃圾收集之前<br>虚：幽（或幻）灵引用，主要用于监测对象是否已经从内存中删除，堆外内存回收。</p><p>软引用尝试保留其引用对象，弱引用不会试图保留其引用对象，虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除。</p><blockquote><ul><li><p>虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中</p></li><li><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</p></li></ul></blockquote><h3 id="3-对象不可达意味着什么？一定被回收吗？"><a href="#3-对象不可达意味着什么？一定被回收吗？" class="headerlink" title="3.对象不可达意味着什么？一定被回收吗？"></a>3.对象不可达意味着什么？一定被回收吗？</h3><p>意味对象即将被垃圾回收，当然，不会立即回收。<br>※ 对象会放入f-q 的队列，会启动一条低优先级别的线程，读取对象，一个个调用对象的finalize方法，如果方法被覆盖并且被调用过，jvm会对该对象置为非必要垃圾回收，它逃过垃圾回收</p><h3 id="4-三色标记法是什么？"><a href="#4-三色标记法是什么？" class="headerlink" title="4.三色标记法是什么？"></a>4.三色标记法是什么？</h3><p>白： 对象不可达<br>黑： 已被访问，所有关联对象也扫描过<br>灰：未被扫描 （重新标记有关）</p><ul><li><figure class="image-box">                <img src="7779607-eecbd09f81b721f8.gif" alt="img" title class>                <p>img</p>            </figure></li></ul><p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p><ol><li><p>初始时，所有对象都在【白色集合】中；</p></li><li><p>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</p></li><li><p>从灰色集合中获取对象：<br>3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中；<br>3.2. 将本对象挪到【黑色集合】里面。</p></li><li><p>重复步骤3，直至【灰色集合】为空时结束。</p></li><li><p>结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收。</p><blockquote><p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p></blockquote></li></ol><p>当 Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。</p><p>而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p><p><strong>多标-浮动垃圾</strong></p><p>假设已经遍历到 E（变为灰色了），此时应用执行了 objD.fieldE = null (D &gt; E 的引用断开)：<br><figure class="image-box">                <img src="1153954-20201220213532679-409632912.png" alt="img" title class>                <p>img</p>            </figure></p><p>此刻之后，对象 E/F/G 是“应该”被回收的。然而因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮 GC 不会回收这部分内存。</p><p>这部分本应该回收 但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p><p>另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p><p><strong>漏标-读写屏障</strong></p><p>假设 GC 线程已经遍历到 E（变为灰色了），此时应用线程先执行了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG;</span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 灰色E 断开引用 白色G</span></span><br><span class="line">objD.fieldG = G;  <span class="comment">// 黑色D 引用 白色G</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="1153954-20201220214557708-22631031.png" alt="img" title class>                <p>img</p>            </figure><p>此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。</p><p>最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。</p><p>不难分析，漏标只有同时满足以下两个条件时才会发生：</p><ol><li>灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。</li><li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li></ol><p>从代码的角度看：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG; <span class="comment">// 1.读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 3.写</span></span><br></pre></td></tr></table></figure><ol><li>读取对象 E 的成员变量 fieldG 的引用值，即对象 G；</li><li>对象 E 往其成员变量 fieldG，写入 null值。</li><li>对象 D 往其成员变量 fieldG，写入对象 G ；</li></ol><p>我们只要在上面这三步中的任意一步中做一些“手脚”，将对象 G 记录起来，然后作为灰色对象再进行遍历即可。比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。</p><blockquote><p>重新标记是需要 STW 的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记 STW 的时间，这个是优化问题了。</p></blockquote><p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。<br>它们的拦截的目的很简单：就是在读写前后，将对象 G 给记录下来。</p><p><strong>写屏障(仅拓展)</strong></p><ul><li><p>CMS：写屏障 + 增量更新</p><blockquote><p>当有新引用插入进来时，记录下新的引用对象。</p><p>思路：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。</p></blockquote></li></ul><ul><li><p>G1：写屏障 + SATB</p><blockquote><p>当原来成员变量的引用发生变化之前，记录下原来的引用对象。</p><p>思路：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的 GC Roots 确定后，当时的对象图就已经确定了</p><p>比如 当时 D 是引用着 G 的，那后续的标记也应该是按照这个时刻的对象图走（D 引用着 G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p></blockquote></li><li><p>ZGC：读屏障</p><blockquote><p>当读取成员变量时，一律记录下来</p></blockquote></li></ul><h3 id="5-有没有跨代引用的问题？※"><a href="#5-有没有跨代引用的问题？※" class="headerlink" title="5.有没有跨代引用的问题？※"></a>5.有没有跨代引用的问题？※</h3><p>minorGC时候，如果当前年轻对象被老年代的对象引用，那么就需要遍历老年代对象里面的引用，如果有引用就不删除年轻代对象。 遍历过多，这消耗过大。</p><p>空间换时间，引入<strong>记忆集</strong>（<strong>RememberSet数据结构</strong>），<br><strong>（卡表CardTable是具体实现类似数组的一种实现）</strong></p><p>用于记录从非收集区域指向收集区域的一个指针集合的抽象数据结构。</p><p>它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题。<br><a href="https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc</a></p><blockquote><p>记忆集根据记录的精度分三类：<br>字长精度：记录的是老年代指向新生代地址。<br>对象精度：记录的是老年代引用的新生代对象。<br>卡精度：记录的是新生代一段地址是否存在被老年代引用的记录。</p></blockquote><p>把地址的值右移9位相当于除于512就是卡表索引，每字节512为一组对应卡表同一个元素，一组就是一个卡页，<br>如果这个卡页中只要有一个对象被其他区域对象所引用，对应卡表元素的值就变成1，也就是所谓的元素变脏。</p><p>在垃圾回收时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页对应的内存包含跨代指针，把他们加入GC Roots中一并扫描。</p><h3 id="垃圾回收的3种算法"><a href="#垃圾回收的3种算法" class="headerlink" title="垃圾回收的3种算法"></a>垃圾回收的3种算法</h3><ul><li><p>标记-清除算法<br>标记后统一回收<br>空间问题: 他只有一块内存空间，会产生空间碎片，导致没有太多的可用的比较大的连续空间，导致对象创建找不到容纳空间，直接进入老年代。<br>优点：快，找到并马上删除</p></li><li><p>标记-复制算法<br>起初思想是将内存分半，内存1:1，一部分存储新对象，一部分负责我们的存活对象。实现的时候，eden，s0，s1，幸存者区1个缓冲<br>缺点：至少10%空间浪费，相对慢<br>优点：针对创建对象，有很大的可用连续空间，GC后，eden区域清空，都是连续空空间，没有空间碎片</p></li></ul><ul><li>标记-整理算法<br>优化了标记复制算法和标志清除算法的改进，</li></ul><ol><li>标记并清除</li><li>存活对象整理到1边<br>删除快，没有空间碎片</li></ol><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="image-box">                <img src="image_20220129152044.png?v=1&type=image&token=V1:muO6XhBva0We3ErRpB0T7PPyoRqWWSq-G6D2IwZ9ymA" alt title class>                <p></p>            </figure><ol><li>新生代：serial 单线程<br>单核服务器最快最理想，有stw暂停和安全点线程挂起的问题。<br>Q：会不会有CPU时间切片轮询？为什么单核快呢？<br>其他线程必须挂起Stop the world，cpu时间片都要落到垃圾收集的线程里面，其他线程不会有cpu时间片轮询，即便有，cpu时间片也是0。其他线程处于内核态，只有垃圾收集器处于用户态。</li></ol><p>为什么Stop the world呢？</p><ol start="2"><li><p>新生代：并发的parNew 。 serial 的多线程版本<br>标记复制算法</p></li><li><p>新生代：parallel Scavenge。<br>能多线程，又能关注和控制吞吐量。<br>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)<br>不与CMS合作</p></li></ol><p>两个控制参数：<br>    最大垃圾收集停顿时间<br>    直接设置吞吐量大小<br>如何控制吞吐量？<br>    首先，运行用户代码不会变。<br>    那么，通过多运行几回垃圾收集，来提高一次虚拟机运行的吞吐量。<br>    比如： 注意吞吐量参数是（0,100）</p><ol start="4"><li><p>老年代：Serial Old 收集器<br>单线程，标记整理算法</p></li><li><p>老年代：Pallel Old 收集器<br>标记整理算法，jdk1.6才开始，吞吐量优先。</p></li><li><p>老年代：CMS 收集器<br>Concurent Mark Sweep 多线程标记清除，以最短回收停顿时间为目标的收集器。<br>记忆：<br>三个mark一清除，初重stw</p></li></ol><p>CMS步骤过程：<br>初始标记 stw，标记gcroots 直接关联对象<br>并发标记  不停顿，扫描old区对象。</p><blockquote><p>刚才产生的集合中标记出存活对象；<br>应用程序也在运行；<br>并不能保证可以标记出所有的存活对象；</p></blockquote><p>重新标记 stw，修正<br>并发清除</p><p>stop the world 其他线程被挂起，处于内核态。</p><p>※※<br>CMS 缺点：<br>首先承认，G1 出来之前，jdk9之前, CMS是靠谱的。</p><ol><li>对资源处理非常敏感。<br>在并发标记时，占用CPU线程数，影响项目中运行所用线程数。因为占用资源，可能导致资源不足。默认启动(核数n+3)/4线程，这样，核数多防止占用。</li><li><p>无法处理浮动垃圾。<br>并发清除，程序运行依然运行，有新垃圾出现，本次收集无法处理，留到下一次GC才清理，这就是“浮动垃圾”。如果对象被疯狂访问，大量对象堆积，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p></li><li><p>“标记清除算法”虽然快，会产生大量空间碎片。</p></li></ol><h3 id="stop-the-word-※※"><a href="#stop-the-word-※※" class="headerlink" title="stop the word ※※"></a>stop the word ※※</h3><p>引入概念：根节点枚举。<br>在开始标记收集的时候，不管单线程还是并发，不管是对象还是线程，一定在一致性的快照里，才能进行。<br>如果不知道当前的状态的话，没办法进行后续的标记。<br>一致性快照的分析工作就是根节点枚举期间：所有线程停顿。</p><p>OopMap 特定的位置记录下栈和寄存器中的哪些位置是引用</p><blockquote><p> OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。<br> 一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。<br> 我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。<br> <strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong><br> 通过上面的解释，我们可以很清楚的看到使用 OopMap 可以避免全栈扫描，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC 。</p></blockquote><h3 id="安全点Safepoint"><a href="#安全点Safepoint" class="headerlink" title="安全点Safepoint"></a>安全点Safepoint</h3><p>垃圾收集过程，用户线程到达特定位置，这位置不会产生新对象，也不会影响项目的执行，只能让垃圾收集非常安全的进行下去。<br>位置：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置</p><p>OopMap线程找对象<br>回顾句柄池，直接指针。</p><p>如何线程如何找Class文件？<br>找常量池里的Constant_class_info指向Constant_utf8_info,找到权限命名，再去方法区。（类加载过程中，对象加载到方法区，再在堆生成class对象，作为访问类的入口）在堆中定位到Class。</p><p>想继续找方法？<br>方法表-&gt;属性表-&gt;code-&gt;max stack，max local，方法入口-&gt; 代码</p><h3 id="G1垃圾收集器※※"><a href="#G1垃圾收集器※※" class="headerlink" title="G1垃圾收集器※※"></a>G1垃圾收集器※※</h3><figure class="image-box">                <img src="image-20220208015310593.png" alt title class>                <p></p>            </figure><ol><li>分代理论垃圾收集，只不过是增加一个拓展。</li><li>把内存区域分成多个大小相等的内存区域块Region。</li><li>jdk9发布，把吞吐量组合取代了，成为服务端默认。如果换成CMS，那么JDK参数配置开启CMS，不过提示Warnings：CMS以后会被废弃。</li><li>内存分块会按照“意愿”进行局部收集。</li><li><p>Region堆内存布局的原理：<br>不再坚持固定大小的分代理论，把内存区域分成多个大小相等的内存区域块Region，每个Region会根据需要扮演新生代eden，survival），老年代的角色。<br>如果有大对象？<br>G1会分出一部分区域作为特殊区域专门存储大对象，如果通过G1检测，只要大小超过<strong>超过1.5个region</strong>，就可以判断大对象，就放到H。Region可以通过JVM参数设置，1-32GB之间。如果超过16GB，肯定放在大对象区域。<br>大对象区域称为：humongous，全称：attempt_allocation_humongous。<br>对于超大对象，比如32GB，会分配两个连续的Region空间。</p></li><li><p><strong>标榜：可预测停顿时间的模型。</strong><br> 关注每个模块里回收价值的大小，通过设置一个很低的最大允许GC时间ms，，-XX：MaxGCPauseMillis =200，根据200ms去找它能够进行收集的Region，比如：收10个Region需要花300ms，由于超过200ms，按比例降低先收集6-7Region达到而200ms要求。</p><ul><li>由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制</li></ul></li></ol><ul><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,<strong>每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</li></ul><p>Q：如何解决跨代Region引用问题？<br>A：使用记忆集，结构相对复杂，是个双向卡表。</p><p>步骤：<br>1.初始标记：stw<br>    GCRoots根节点枚举，在安全点进行<br>2.并发标记<br>3.最终标记：stw<br>4.筛选回收<br>    <strong>根据MaxGCPauseMillis最大允许GC时间，优先回收价值最大的Region， 保证可预测停顿时间。</strong></p><h3 id="JVM调优经验-※※"><a href="#JVM调优经验-※※" class="headerlink" title="JVM调优经验 ※※"></a>JVM调优经验 ※※</h3><p>根据用户访问量，在不同时刻导致JVM回收<br>在上线前，做压测，监督内存空间的使用，以及发生GC回收的频率和停顿时间。</p><ol><li><p>大访问的压力，一边回收一边对象持续创建，minorGC会比较频繁，那么，一：<strong>调大年轻代的大小</strong>。二：如果发生时间不长，很快回收，且回收率高，不会导致老年代短时间内有对象填充，那么就，<strong>进行持续压测</strong>，观察老年代的上限。</p></li><li><p>大对象创建的频繁且常访问，导致FullGC比较频繁，（对于G1会分配到humongous区）。一：压测观察大对象的大小，过大可以把对象拆分，维持在JVM参数下；二：适当调大判断为大对象的参数，防止它直接进入老年代；三：发生OOM异常，如何排查呢？压测过程，一定先dump出来堆内存的heap文件，导入visual VM工具，主要查看堆栈信息。找内存占用高的对象，Reference指向堆栈信息，最终定位代码。springboot的Context上下文是单例，很难发生大对象频繁创建。四:  线程无法到达安全点，请求第三方等待中，比如60s超时时间，其他线程的已经在安全点STW，这里细说：用户态和内核态。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;引言：&lt;/strong&gt;&lt;br&gt;来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。&lt;br&gt;优点：笔记知识点关联性好，挖得深，延伸多。&lt;br&gt;缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="jvm" scheme="https://missionodd.github.io/categories/技术/jvm/"/>
    
    
    <category term="java" scheme="https://missionodd.github.io/tags/java/"/>
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="jvm" scheme="https://missionodd.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>经验 | 性能优化的整体脉络的梳理</title>
    <link href="https://missionodd.github.io/2022/02/01/overall-performance-optimization/"/>
    <id>https://missionodd.github.io/2022/02/01/overall-performance-optimization/</id>
    <published>2022-02-01T05:50:37.000Z</published>
    <updated>2022-03-17T03:44:07.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化要求我们关注整体效果，兼顾可靠性，扩展性，以及极端情况的异常场景。<br>笔记特点：大部分是已掌握的内容，一些知识只会概括提及。</p><h2 id="衡量指标※"><a href="#衡量指标※" class="headerlink" title="衡量指标※"></a>衡量指标※</h2><p>性能：有限资源，有限时间完成工作。</p><p>体现在横坐标为时间，纵坐标多种指标。</p><p>加载性能低，会导致搜索排名下降。</p><p>性能指标：</p><p>吞吐率 和 响应速度</p><p>响应速度是串行的优化，通过优化步骤解决问题；<br>吞吐率是并行的优化，充分利用计算机资源；</p><p>侧重于优化响应速度，就能提高吞吐率</p><p>这两点，构成了高并发。</p><p>类比，十字路口，开车排队到经过红绿灯时间，就是一个请求的响应时间；如果灯信号时间短一点，一些车可能通过快一点，如果灯信号切换过于频繁（限流力度过大），单位时间内通过的车过少，导致后面的车排队时间更长，这个就是吞吐量减少</p><p>吞吐率:</p><p>QPS，TPS，<br>HPS： HTTP请求数</p><p>细化指标：</p><ul><li>平均响应时间：所有耗时的平均，但不能体现出方差，抖动大小，</li><li>响应时间百分位数，TP值：理解为一种阈值，像合格率（水位），反应出应用接口的整体响应情况。指数目标是 干掉严重影响系统的长尾请求。</li></ul><blockquote><p>例若有100个请求， 每一个请求的响应时间分别是 1-100 平均分布 平均响应时间： 1-100 的平均值，即 50.5 95% percentile ： 按从小到大排序，累计第95百分位，也就是 95 （即样本里95% 的数据都不高于这个值）</p></blockquote><ul><li>并发量：同时进入的请求数量，指在同一个时间点，同时请求服务的客户数量。</li></ul><p>注意：吞吐率和并发数是两个完全独立的概念。拿银行柜台来举个例子，并发数指同时有多少人往银行柜台涌来。吞吐率则指银行柜台在一段时间内可以服务多少个人。</p><ul><li><p>秒开率：APP启动速度，页面加载速度。</p><p>使用CDN加载；用mokey脚本检查白屏，用动画或加载骨架，减少白屏情况；HTTP2的缓存推送机制提前推送JS，CSS；</p></li><li><p>正确性：接口请求无BUG。</p><p>比如，一个事故，测出的并发量特别高，这是由于项目使用了熔断，压测过程触发熔断，又因为没有对接口正确性判断，造成低级错误的报告。</p></li></ul><p>性能优化：</p><p>基准测试，木桶理论，Amdahl定律</p><p>基准测试：测试最佳性能。</p><p>比如，要排除掉项目启动，进行缓存预热，消除JIT编译器影响。</p><p>木桶理论：性能瓶颈取决于最慢的组件。</p><p>比如，DB的I/O落盘。这是首先要解决的问题。</p><p>性能优化注意点：</p><p>一是依据数字不是猜</p><p>二是个体数据不足信</p><p>三不要过早优化和过度优化</p><p>四保持良好编码习惯</p><h2 id="7类技术优化手段※"><a href="#7类技术优化手段※" class="headerlink" title="7类技术优化手段※"></a><strong>7类技术优化手段</strong>※</h2><p>复用优化</p><p>计算优化</p><p>结果集优化</p><p>资源冲突优化</p><p>算法优化</p><p>高效实现</p><p>JVM优化</p><hr><p>其他：</p><p>数据库优化</p><p>操作系统优化</p><p>架构优化</p><p>协议优化</p><p>等等</p><p>展开：</p><p><strong>复用优化</strong></p><p>1、代码复用：抽成公共方法，抽成公共模块；</p><p>2、数据复用：首先想到缓冲和缓存。</p><blockquote><p> <strong>缓冲(Buffer)</strong>：对数据暂存，然后批量传输或写入；<br> 多使用顺序方式，缓解不同设备频繁，缓慢地随机写。<br> <strong>缓存(Cache):</strong>对已读数据的复用；<br> 缓存在相对高速区域，针对读操作。</p></blockquote><p>3、池化复用：对象创建和销毁成本高。</p><blockquote><p>线程池，连接池，把对象预热存储，方便所有后续使用。</p></blockquote><p>4、对象复用：clone思想的原型模式，共享技术的享元模式</p><p><strong>计算优化</strong></p><p>1、并行优化：想加快任务执行，最快最优就是让它并行执行。</p><blockquote><p>硬件上是：CPU等设备多核，多机。</p><p>模式上是：</p><p>多机：采用负载均衡，将流量或大计算拆分多个部分，同时处理，比如Hadoop，用MapReduce将任务打散，多机并行计算；</p><p>多进程：nginx的NIO进程模型，master进程统一管理worker进程，由worker进程真正代理，利用了CPU多核。</p><p>redis的主进程读写，子进程RDB快照写时复制技术；</p><p>多线程：Netty的Reactor的NIO模型。boss线程接收请求，worker线程真正计算。</p><p>多协程：更轻量，比如GO语言</p></blockquote><p>2、同步变异步：涉及编程模型的改变</p><p>同步简单，但对突发的，时间段倾斜的流量，问题大，容易失败。</p><p>3、异步方式：请求横向扩容，缓解瞬时压力，使流量平滑。</p><p>4、惰性加载：单例模式，代理模式，分页加载</p><p>加载图片文件，可以先加载占位符，再通过后台线程慢慢加载所需要资源。</p><p><strong>结果集优化</strong></p><p>让体积更小，传输效率和解析效率更高</p><p>1、protobuf二进制优先于JSON，优先于XML</p><p>2、Nginx，开启HTTP的GZIP压缩，保持数据紧凑</p><p>3、批量处理的方式：对于时效性要求不高，对业务能力要求高的业务，要减少网络连接的交互，先存缓冲区，再批量交付。</p><p>4、数据结构优化：对于要二次使用的结果集，会存入缓存，可以根据使用场景，存储索引，bitmap位图，二进制数，B+树，跳表，压缩列表来加快读速度。大对象优化为只保留有用属性粒度</p><p><strong>资源冲突优化</strong></p><p>涉及共享资源，如：单机HashMap，mysql的数据行，单资源Redis的某key的setnx，多个资源协调的事务和分布式事务。</p><p>就要选择合适的锁。</p><p>锁应用各种地方，mysql的行锁表锁，java各种锁，底层cpu锁，jvm锁，操作系统内部锁</p><p>按照锁级别，分为乐观锁和悲观锁，乐观锁效率更高</p><p>按照锁类型，分为公平锁和非公平锁，任务调度上有差别</p><p>锁越重，性能消耗越大，</p><p>实现无锁的机制，对性能提升巨大的。</p><p><strong>算法优化</strong></p><p>提高复杂业务的性能，一般采用空间换时间，加快处理速度。</p><p>算法是代码调优，考验开发者的编程技巧和API掌握程度。</p><p>常用的递归，二分，快排，动态规划，贪心等。</p><p><strong>高效实现</strong></p><p>1、技术选型，尽量选择设计良好，性能优越的组件；</p><p>Netty作为非阻塞web容器，</p><p>语法分析器javacc，效率比正则表达式更好</p><p>2、维护性，采用适配器模式，以便在测压找到瓶颈点，用更高性能的组件进行替换。</p><p><strong>JVM优化</strong></p><p>配置参数，一定程度提高JAVA程序的性能。</p><p>如果不当，可能OOM。</p><p>1、G1垃圾回收器，内存高效回收，CMS已经被java14移除</p><p>2、堆大小调整，minorGC和fullGC</p><p>3、大对象阈值设置</p><p>4、代码层面优化</p><p>5、监控线上堆栈信息</p><p>6、开启补齐，避免伪共享</p><hr><h2 id="分析哪些资源，容易成为瓶颈"><a href="#分析哪些资源，容易成为瓶颈" class="headerlink" title="分析哪些资源，容易成为瓶颈"></a>分析哪些资源，容易成为瓶颈</h2><p>1、系统组件之间的速度不均衡；</p><p><strong>CPU，内存，IO组件，容易成为瓶颈。</strong></p><p>CPU：</p><p>top命令，CPU性能</p><p>uptime命令，看负载，评估任务排队情况</p><p>vmstat，CPU繁忙程度，上下文切换程度。</p><p><strong>缓存行伪共享问题</strong></p><p>内存：</p><p>top命令，看进程实际占用内存</p><p>free命令，看剩余内存</p><p>大内存时代，采用<strong>HugePage</strong>将4kb快表页增大2MB，但竞争加剧会增加性能。</p><p><strong>JVM预分配好内存</strong>，加快运行速度</p><p>IO设备：</p><p>IO设备是包括所有外围设备</p><p>缓冲区解决差异的唯一工具，但断电容易丢失。</p><p>iostat命令工具，查看IO性能。</p><p>网络：</p><p>iotop命令，看网络流量最高的进程</p><p>netstat命令，看机器网络连接汇总</p><p><strong>零拷贝技术</strong>，kafka，Nginx</p><p>优化IO+网络</p><p>kafka操作磁盘 吞吐量高的原因?</p><p>磁盘慢是慢在寻道操作，磁盘顺序写和随机写的速度差达到6千倍，kafka采用顺序写。</p><h2 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h2><p>nmon获取系统性能数据工具</p><p>jvisualvm 获取JVM性能数据</p><p>CPU分析：代码执行时长和热度</p><p>内存快照分析：内存泄漏</p><p>线程分析：死锁情况</p><p>HotSpot VM 的JMC，获取java性能详细数据</p><p>web容器，线程，内存，锁，socket IO，方法，垃圾回收</p><p>JIT，TLAB</p><p>arthas 获取单个请求的调用链耗时</p><p>trace命令获取调用链</p><p>wrk HTTP压测工具，获取web接口性能工具</p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>为了测量某一段代码的具体执行情况。</p><ul><li>最简单，编写统计执行代码时间。</li></ul><p>​    这不一定正确，代码块频繁时，JVM会有JIT编译和内联优化，要想得到稳定结果，需要执行上万次循环预热；</p><p>​    有大量埋点，统计指标单一</p><ul><li><p>JMH基准测试工具。JDK12内置，低版本需要引入。通过注解形式单独配置，OptionSBuilder全局配置</p><p>通过开启多个进程多个线程的子任务完成预热，然后真正的迭代，最终结果合并</p><p>精度高，纳秒级，多指标，可图形化结果</p></li></ul><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>保持各自节奏，顺序不打乱</p><p>结合批量处理，减少网络IO操作</p><p>优化用户体验，音视频的提前缓冲</p><ul><li>文件IO流  是装饰器模式</li></ul><p>缓冲区读取一块一块的部分数据</p><ul><li>日志缓冲</li></ul><p>Logback异步采样，写入缓冲区达到阈值，才持久化。</p><ul><li><p>kafka发送缓冲</p><p>生产者发送前有个缓冲区，如果生产者断电，消息丢失；</p><p>解决：</p><p>缓冲区设置非常小，退化到单条，影响网络性能</p><p>发送前持久化消息日志，发送后处理完回调再记录一条日志，扫描对比。</p></li><li><p>Mysql的innodb_buffer调整大小，减少换页；</p></li><li><p>StringBuilder 和StringBuffer，字符缓冲区，提供拼接字符串的性能</p></li><li><p>磁盘，网络IO，缓冲区提高信息流转效率，可以flush强制刷新数据。半连接队列，全连接队列</p></li><li><p>ID生成器，缓冲一部分ID段，避免频繁耗时的交互。</p></li></ul><p>缓冲区饱和策略：丢弃，异常，等待</p><p>缓冲区数据丢失解决：</p><p>优雅关闭，没完全解决；</p><p>预写日志，故障后重启，根据日志恢复数据。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>让页面秒开</li><li>减少数据库压力</li><li>处理冷热数据</li></ul><p>堆内缓存</p><p>大多数对内缓存，会将对象的引用设置为弱引用或软引用，当缓存非常频繁，而且数据量大，如果发生GC回收，缓存空间被释放，又瞬速沾满，从而再次垃圾回收。</p><p>设置缓存小一些，减轻JVM负担。</p><p>进一步加速</p><p>linux文件缓存：</p><p>预读算法，从磁盘智能加载到缓存</p><p>缓存算法影响命中率和性能，</p><p>目前最好的是Caffeine（咖啡呢）使用的W-TinyLFU算法，性能非常高</p><p>例子</p><p>HTTP 304 Not Modified，请求头if-Modified-Since判断客户端缓存是否最新</p><p>CDN，用户最近最快节点，读取静态文件内容，贵</p><p>双写缓存不一致问题：延迟双删，binlog-MQ</p><h2 id="数据冷热分离"><a href="#数据冷热分离" class="headerlink" title="数据冷热分离"></a>数据冷热分离</h2><p>数据双写</p><p>冷热库CRUD在统一事务</p><p>由于热库和冷库类型不同，事务大概率是分布式，缺陷：难以改造。</p><p>写入MQ分发</p><p>通过MQ发布订阅，分发到冷热库，逻辑非常清晰</p><p>binlog订阅</p><p>canal组件获取数据，结合MQ，同步到其他数据源</p><h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>减少创建对象的成本，资源反复利用。</p><p>公共对象池化包 Commons Pool 2，Jedis连接池使用到。</p><p>maxTotal：对象上限</p><p>maxIdle ：最大空闲数</p><p>maxIdle： 最小空闲数（核心对象数）</p><p>maxWaitMillis：资源用尽时，最大等待直到对象空闲时间，-1表示永远不超时。超时快速失败</p><p>minEvictableIdleTimeMillis 资源池中资源最小空闲时间(单位为毫秒)，达到此值后空闲资源将被移除，默认30min</p><p><strong>HikariCP连接池为什么快？ （Hi卡乐CP）</strong></p><p>1，有效减少数据库连接创建，消耗的资源消耗；</p><p>2，FastList代替ArrayList，通过初始化的默认值，减少越界检查。通常情况下，同一个Connection创建了多个Statement时，后打开的Statement会先关闭，FastList从数组的尾部开始遍历删除，更为高效</p><p>3，优化并精简字节码，使用javassist，减少动态代理的性能消耗，比如invokestatic指令代替invokevirtual，指令更便于JVM去做更底层的优化。这个优化甚至把<strong>栈帧中的栈深度从5降到了4，减少了push和pop指令</strong>。</p><p>4，无锁的ConcurrentBag，减少并发场景下的锁竞争，减少伪共享</p><p>​    ConcurrentBag，有三个重要的成员变量：</p><ul><li><p>ThreadLocal 缓存，加快本地连接获取速度</p></li><li><p>CopyOnWriteArrayList，sharedList共享写时拷贝List</p></li><li><p>SynchronousQueue，无存储的等待队列</p><p> ConcurrentBag 的优化思路就是CAS尝试从ThreadLocal中找空闲连接来避免锁竞争，如果没有可用元素则再次从共享的CopyOnWriteArrayList中获取，还找不到就放入SynchronousQueue等着。</p><p>通过将连接本地存储化来减少竞争，又根据连接池读多写少的特性用 CopyOnWriteArrayList 来实现 sharedList 。</p><p>这里还有个<strong>中途窃取的概念</strong>，其实没什么花头，就是充分利用连接。</p><p>根传统锁模型不同，它用了标记模型，抢占资源只是CAS操作进行”标记状态“ <code>STATE_IN_USE</code>。</p><p><strong>中途窃取</strong>无非就是本来属于某个线程的本地连接，当它归还连接的时，恰巧有另一个线程从 sharedList 遍历找到这个连接，这时候连接的状态是 <code>STATE_NOT_IN_USE</code>，那么这个连接就会被另一个线程也保存到 ThreadLocal 中了。 否则是没有窃取，就唤醒等待队列的线程。</p></li></ul><p>冷门技巧优化：根据业务的类型设置多个连接池，减少连接资源争抢。</p><ul><li>快速响应时间，把数据快速返回给用户</li><li>可以慢慢执行，耗时比较长，对时效性要求不高</li></ul><p>池一般存储的是执行对象，缓存一般存储的是数据对象</p><p>结果缓存池：保存某个执行步骤的结果，使得下次无需从头执行；</p><p>比如：热点文章页面静态化，无需再从头渲染。</p><h2 id="大对象复用与聚焦"><a href="#大对象复用与聚焦" class="headerlink" title="大对象复用与聚焦"></a>大对象复用与聚焦</h2><p>substring方法，JDK 8 是new复制出部分字符串，在JDK 6直接获取源字符串，</p><p>借鉴意义：在大对象中获取部分信息，根据业务情况，决定是否有原对象的引用关系。</p><p>扩容，StringBuilder，StringBuffer，HashMap，ArrayList等：扩容操作需要重新组织数据，注意线程安全问题；</p><p>优化：</p><p>查询用户的字段，Redis存储的用户的JSON字符串数据打散， 改为Hash对象结构，方便hget</p><p>bitmap  </p><p>java Bitset</p><p>potobuf</p><p>数据结构优化：对于要二次使用的结果集，会存入缓存，可以根据使用场景，存储索引，bitmap位图，二进制数，B+树，跳表，压缩列表来加快读速度。大对象优化为只保留有用属性粒度</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>大多数设计模式并不能增加性能，下面列举性能相关的设计模式：</p><p>代理模式，单例模式，享元模式，原型模式</p><p>代理模式</p><p>通过一个代理类，控制一个对象的访问</p><p>jdk面向接口，CGLib字节码增强，新版本性能差不多。</p><p>Spring AOP如果引入CGLIB，就是用CGLIB对java字节码增强，完成一个切面编程。比如权限，日志等切面。</p><p>虽然方便代码，但动态代理模式的处理更慢。</p><p>可以通过arthas分析慢逻辑来优化。</p><p>单例模式</p><p>scope注解指定bean的作用域，标识多例还是单例</p><p>默认是单例，线程安全。</p><p>单例有懒汉和饿汉加载方式：</p><p>饿汉会造成空间资源的浪费。</p><p>懒汉需要DCL或者静态内部类创建实例。</p><p>享元模式</p><p>通过共享技术，最大限度复用对象一般使用唯一的标识码进行判断，然后返回对应的对象。</p><p>比如，池化对象。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p>很多设计都使用享元模式，只是语境下差别。</p><p>原型模式</p><p>首先缓存一个实例，然后通过这个实例克隆出新对象，</p><p>一般可配合工厂模式。</p><p>必须实现 Cloneable 接口，</p><p>由于 Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生异常。</p><p>clone如果只拷贝当前对象，实现的就是浅拷贝。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>IO密集型，计算密集型</p><p>线程池</p><p>写时复制</p><p>StringBuilder 对 StringBuffer</p><p>HashMap对CurrentHashMap</p><p>ArrayList对CopyOnWriteList</p><p>FastThreadLocal</p><p>首先ThreadLocalMap没有链表红黑树，使用了开放地址法。</p><p>FastThreadLocal 底层是数组，定位数据直接根据数组下标 index 获取；</p><p>而且，写了9个多余long类型，对伪共享问题优化</p><p>Foin/Join</p><p>CompletableFuture</p><p>不正确使用问题：</p><p>线程池不正确，造成资源分配不可控</p><p>IO密集，线程池太小，造成请求频繁失败</p><p>线程池用等待线程释放饱和策略，造成业务阻塞</p><p>SimpleDateFormat的时间错乱： 多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p><p>解决方案：</p><p>　　1、将SimpleDateFormat定义成局部变量</p><p>　　2、 加一把线程同步锁：synchronized(lock)</p><p>　　3、使用ThreadLocal，每个线程都拥有自己的SimpleDateFormat对象副本。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁分层升级</p><p>乐观锁</p><p>悲观锁</p><p>Redis分布式锁，lua脚本，看门狗续期锁</p><p>无锁</p><h2 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h2><p>BIO到NIO，再到AIO</p><p>Netty Rector模型</p><p>select/epoll</p><p>响应式编程：WebFlux底层使用Netty，一种面向数据流和变化传播，表达为生产者消费者之间进行流量控制（背压问题），通过全面操作异步化，来减少无效的等待和资源消耗。</p><p>Spring Gateway 的RouteLocator</p><p>背压是反应流中的一个重要概念，可以理解为，生产者可以感受到消费者反馈的消费压力，并根据压力进行动态调整生产速率。</p><h2 id="Springboot-性能优化"><a href="#Springboot-性能优化" class="headerlink" title="Springboot 性能优化"></a>Springboot 性能优化</h2><p>1，首先要暴露数据，比如缓存命中率，连接池参数，业务数据，然后开启监控。</p><p>可以用普罗米修斯暴露数据，配合Grafana数据展示。</p><p>可以看火焰图找到性能瓶颈；</p><p>2，优化请求链路</p><p>HTTP优化：使用HTTP2</p><ul><li><p>CDN，Cache-control浏览器缓存</p></li><li><p>减少单页面请求的域名数，4个之内。因为每次请求域名，查DNS找IP，再调用服务器。若没有本地DNS缓存，产生一定的调用链路开销。</p></li><li>开启GZIP，减少传输效率，Nginx或者Okhttp</li><li>对JS，CSS等资源压缩，应用在前后端分离模式。</li><li>使用keep alive 长连接，减少连接创建和关闭消耗</li></ul><p>JVM优化</p><pre><code>- G1- 堆大小- 堆比例- 进入老年代阈值调整- -XX:+AlwaysPreTouch 在服务启动的时候真实的分配物理内存给JVM</code></pre><p>访问数据库慢优化</p><p>​    - 本地缓存</p><p>分布式</p><p>​    - skywalking 全链路追踪</p><p>Controller</p><ul><li>保持结果集精简 JSON</li></ul><p>Service</p><pre><code>- 单例- 设计模式组织代码- 分布式事务，保证最终一致性：</code></pre><p>Dao</p><pre><code>-  使用合理缓存，避免缓存穿透-  注意sql在分库分表环境执行的性能</code></pre><p>使用HikariCP连接池</p><h2 id="常用代码优化法则"><a href="#常用代码优化法则" class="headerlink" title="常用代码优化法则"></a>常用代码优化法则</h2><ul><li>多使用局部变量：栈分配，可避免堆上分配，堆是垃圾回收主要区域，也避免过多对象造成GC压力。</li><li>减少变量的作用范围：在if分支内，减少创建。</li><li>访问静态变量用类名，不要用this，否则导致多了一步找类的寻址指令。</li><li>StringBuilder或StringBuffer拼接字符串，减少字符串创建</li><li>重写HashCode，要重写equals</li><li>HashMap等集合初始化，指定初始值</li><li>不要在多线程下使用同一个Random，否则seed会在并发访问发生竞争，建议ThreadLocalRandom，配置jvm参数使用速度快的urandom随机生成器</li><li>自增推荐LongAddr，这是synchronized和volatile组合；AtomicLong是CAS替换，导致自旋。</li><li>不要捕捉RuntimeException，要提前判断</li><li>能复用的SQL合理PreparedStatement预编译，能对SQL执行提速，对能复用的SQL语句<strong>放入缓存执行计划中</strong>，下次执行跳过解析动作，所谓预编译语句就是将这类语句的值用占位符替代,可以视为将sql语句模板或者说参数化，防止SQL注入</li><li>日志打印优化，使用占位符，避免多余的字符串拼接操作；减少日志打印，减少占用IO资源</li><li>减少事务作用范围</li><li>位移操作代替乘除法</li><li>不要打印大集合</li><li>少用反射，它通过解析字节码实现，性能不理想，若使用，可加缓存优化</li><li>正则表达式预先编译，初始化一次即可，加快速度；正则解析很慢，可改为状态机</li><li>invokestatic指令调用静态绑定方法 ，代替invokevirtual调用实例动态绑定方法</li></ul><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>inline –方法内联：对于短小方法体，采用直接追加代码的方式。</p><p>分层编译层次：</p><p>1字节码解释执行</p><p>2执行不带profiling的C1代码</p><p>3执行仅带方法调用以及循环次数profiling的C1代码</p><p>4执行带所有profiling的C1代码</p><p>5执行C2代码</p><p>profiling是指运行时程序执行状态的数据：循环调用次数，方法调用次数，分支跳转次数，类型转换次数。</p><h2 id="逃逸分析："><a href="#逃逸分析：" class="headerlink" title="逃逸分析："></a>逃逸分析：</h2><p><strong>对象，除了基本类型，一定是在堆上分配吗？错。</strong></p><p>经过逃逸分析，可分析出对象的作用范围，来决定是否讲对象分配到堆上。</p><p>成员变量可以分配到栈上，方法返回对象可以分配到堆上。</p><ol><li>对象是否被存入堆中（静态字段或堆中对象的实例字段）</li><li>对象是否被传入未知代码中（方法的调用者和参数）</li></ol><p>总体分3点：</p><p><strong>对象可能分配在栈上</strong></p><p>JVM通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。</p><p><strong>分离对象或标量替换</strong></p><p>当JVM通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，我们将这个打散的过程叫做标量替换。将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。</p><p><strong>同步锁消除</strong></p><p>如果JVM通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。</p><p><strong>这里，需要注意的是：这种情况针对的是synchronized锁，而对于Lock锁，则JVM并不能消除。</strong></p><h2 id="什么是JVM预热"><a href="#什么是JVM预热" class="headerlink" title="什么是JVM预热"></a>什么是JVM预热</h2><p><strong>JVM预热</strong> ： JVM Warm Up</p><p>一旦类加载完成，所有重要的类（在进程启动时使用）都会被推送到JVM缓存（本机代码）中，这使得它们在运行时可以更快地访问。其他类是根据每个请求加载的。<br>对Java Web应用程序的第一个请求通常比进程的生命周期中的平均响应时间慢得多。这个预热期通常可以归因于延迟类加载和及时编译。<br>记住，对于低延迟应用程序，我们需要预先缓存所有类，以便在运行时访问时立即可用。<br>这种调优JVM的过程称为预热。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3VmYW55YW5nX2NoaW5h,size_16,color_FFFFFF,t_70.png" alt title class>                <p></p>            </figure><p><strong>基于采样的热点探测</strong>：<br> 周期采样，检测各线程栈顶方法，经常出现的方法即为热点方法。好处是简单高效，缺点是不精确，容易受线程运行状态的影响。</p><p><strong>基于计数的热点探测</strong>：<br> （包括方法调用计数器和回边计数器）每个方法建立计数器，用来统计调用次数。如果该方法执行次数超过阈值，则该方法被认定为热点方法。好处是足够精确。缺点是空间损耗大，且实现较难。</p><p>另外，可以通过如XX:CompileThreshold等参数来修改阈值，不过，没有绝对把握，还是不要动为好。</p><p>TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。</p><p>是对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内。</p><p>JIT指导代码优化</p><p>为什么我们在刚写代码的时候，总是被建议不要写很大的方法体？方法内联的JIT优化策略就是其中一个重要的原因。（还有GC友好等原因）</p><p>JVM内的每一次方法调用，都是栈帧在内存中出栈入栈的过程，方法多了性能损耗自然大，所以要进行方法内联，即把方法执行逻辑直接复制到调用方内部，避免方法调用。</p><p>但是，方法内联是有方法大小限制的，超过了一定大小的方法，没法做内联优化。所以，平常应该注意，尽量避免写很大很冗长的方法。</p><p>方法内联虽然只是一种简单优化，但是，是后续其他优化的基石。</p><p>而JVM的分层优化涉及的点非常多[1]：</p><p>局部优化：关注局部数据流分析，数组越界检查消除；寄存器优化，优化跳转、循环、异常处理等；代码简化，如公共表达式提取等等等。</p><p>控制流优化：专注于代码重排序、循环缩减、循环展开、异常定位优化等等等。</p><p>全局优化：主要关注冗余消除，如方法调用、锁；逃逸分析；GC和内存分配优化等等等。</p><h2 id="综合思考性能优化"><a href="#综合思考性能优化" class="headerlink" title="综合思考性能优化"></a>综合思考性能优化</h2><ul><li>业务需求层面</li></ul><p>报表业务，查询缓慢，有时候造成内存溢出</p><p>经过分析，查询时间跨度范围太大造成，缩小到1个月，速度快多了。</p><ul><li>硬件层面</li></ul><p>有一个定时任务，每次将CPU用满，由于系统架构硬伤，无法横向扩容，经过技术评估，如果改成按照数据分片执行的模式，则需要消耗长达1个月工时。</p><p>那么，这个时候，增加硬件。</p><p>尽可能在效果，手段，工时权衡。</p><p>如何找到优化目标？</p><p>利用率：一般是瞬时值，属于采样范围，用来判断有没有峰值</p><p>饱和度：一般指资源是否被合理利用，能否分担更多工作</p><p>错误信息：严重的特别关注</p><p>联想信息：靠经验去猜，然后用工具验证。</p><h2 id="基本解决方式"><a href="#基本解决方式" class="headerlink" title="基本解决方式"></a>基本解决方式</h2><p><strong>CPU问题</strong></p><p>top-Hp命令获取CPU占用最高线程，针对性优化</p><p>棘手问题经验：线程阻塞在ForkJoin线程池上</p><p>代码在等待I/O时，采用并行流（parallelStream）处理，但Java默认所有的方式是所有并行流的地方，共用同一套线程池。这个线程池的并行度只有CPU的两倍。并发量增加，造成任务排队，产生积压。</p><p><strong>内存问题</strong></p><p>通常是OOM。如果内存资源紧张，CPU利用率低，考虑时间换空间。</p><p>一般在高并发应用，会把Swap关掉，因为它很容易引起卡顿。</p><p><strong>IO问题</strong></p><p>一般情况，磁盘IO小，网络IO大</p><p>通过调整日志级别，清理无用日志代码，缓解磁盘IO的压力</p><p>通过RPC调用一个远程服务，期望使用NIO减少无效的等待，或者并行方式加快信息读取</p><p>类似ES数据库，写入造成繁重的磁盘IO，可以增加硬件的配置，换成SSD固态磁盘，或增加新的磁盘；调整segment块大小，translog的刷新速度等。</p><p>对于网络IO，</p><p>springboot和OkHttp开启gzip压缩，</p><p>结果集合并</p><p>使用批量的方式</p><p>netstat命令，获取进程网络状态</p><p><strong>中间层</strong></p><p>加入中间层，缓冲/缓冲，池化，牺牲信息的时效性，加快信息处理的处理速度。</p><p><strong>资源同步</strong></p><p>切分冲突资源的粒度</p><p>减少资源锁定的时间</p><p>将读写分开</p><p><strong>组织优化</strong></p><p>重构–设计模式</p><p>异步化</p><p><strong>资源利用不足</strong></p><p>资源不能合理利用，就是浪费。</p><p>轮转：一定压力下系统的最优状态</p><p>IO密集：并行</p><p>合理利用空闲空间：高位要加大容量</p><h2 id="PDCA-循环方法论"><a href="#PDCA-循环方法论" class="headerlink" title="PDCA 循环方法论"></a>PDCA 循环方法论</h2><p>管理性能优化的过程</p><p>P计划阶段：收集指标，找性能问题，设定改进目标，制定改进措施</p><p>D执行阶段：执行计划</p><p>C检查阶段：检查优化效果，及时发现改进过程的经验和问题</p><p>A处理阶段：将成熟经验推广，有点及面覆盖，为负面形成解决方法，将错误方法形成经验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;性能优化要求我们关注整体效果，兼顾可靠性，扩展性，以及极端情况的异常场景。&lt;br&gt;笔记特点：大部分是已掌握的内容，一些知识只会概括提及。&lt;/</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="优化" scheme="https://missionodd.github.io/categories/技术/优化/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="系统" scheme="https://missionodd.github.io/tags/系统/"/>
    
    <category term="性能" scheme="https://missionodd.github.io/tags/性能/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务 | volatile | 单例模式 | OS | 杂笔摘抄</title>
    <link href="https://missionodd.github.io/2022/01/26/distributed-volatile-series/"/>
    <id>https://missionodd.github.io/2022/01/26/distributed-volatile-series/</id>
    <published>2022-01-26T05:50:37.000Z</published>
    <updated>2022-03-17T03:37:11.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>在客户端请求服务端时，就是在服务端写入对应的客户端文件描述符FD，如果多个客户端同时请求一个服务端，每一次请求开一个线程，会耗费CPU资源，因此，用一个线程监听多个服务器资源，就是IO多路复用，通信模型有三种，select/poll/epoll。<br>第一种select，在需要判断是否有节点就绪时，会把文件描述符FD从用户态拷贝到内核态中，因为在内核态中判断，效率会比较高。<br>当遍历完文件描述符FD，会把事件返回，select再由用户态向内核态会耗费系统资源，效率比较低，除此，文件描述符以数组保存，在32位，有最大数量1024，64位为2048。拷贝过程中，是用bitmap位图来标记文件描述符的状态，并且使用完后需要置位。</p><p>第二种poll 为了解决数组上限和位图置位问题，引用新结构体pollfd，包含fd，event，revent，首先看fd，是由链表保存，解决连接上限问题，event是读写和异常事件，revent是返回事件，可重用，解决select中位图置位问题，需要循环遍历判断就绪，时间O(n)。</p><p>第三种epoll，可以把就绪判断控制在O(1)，通过三个方法实现，epoll_create()会创建poll实例；epoll_ctl()，会FD注册到内核，避免了用户态的拷贝，内核中保存FD是用了红黑树；epoll_wait()，在<br>红黑树中有就绪时间时，会把它在双向链表中，让用户调用epoll_wait()时，会直接从链表中返回，这里涉及两种触发模式，LT和ET模式；LT水平触发，wait检查fd就绪时，不立即转化双链表，当下次调用wait方法时，再通知进程，这是默认的触发方式；ET边缘触发，通知后进程立即处理事件，下次调用wait方法不会通知，减少epoll时间被重复触发的次数，效率比LT高。</p><h2 id="Spring-Cloud-微服务"><a href="#Spring-Cloud-微服务" class="headerlink" title="Spring Cloud 微服务"></a>Spring Cloud 微服务</h2><p>起初，一个项目的所有功能模块都在一个工程中编码，编译，打包，比如部署在一个tomcat容器中，一般只需要一个数据库，随着业务和用户增长，tomcat需要集群化，负载均衡则需要一个nginx，甚至用到文件或缓存服务器，这样存在单个项目过大 ，而且耦合严重的问题。流行的微服务就可以把项目拆分粒度更小，耦合度降低，并且可以独立部署和扩展，可维护性更强，一个微服务可以部署多个节点来支撑。当服务过多，需要有效识别和管理服务，就需要引入服务治理，通过服务的发现和注册，比如阿里nacos，充当注册中心，把所有启动的服务注册进来，当然，它也可以作为配置中心。</p><blockquote><p>注册中心：Eureka册中心将返回所有可用的服务实例给消费者，但是一般不推荐这种情况。另一种方法就是本地Map存储服务实例列表，服务的消费者向注册中心订阅某个服务，并提交一个监听器，当注册中心中服务发生变更时，监听器会收到通知，这时消费者更新本地的服务实例列表，以保证所有的服务均是可用的。<br>配置中心：客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象，对比apollo，配置都没有心跳机制，nacos2.0 采用则统一gRBC通信，流式推送更可靠，吞吐量更少，QPS更高，缺点是没有权限配置，只提供给轻量化的配置）</p></blockquote><p>之前服务注册中心，通过30秒心跳包确定服务是否存活，30秒续约一次。但是，服务扩容时，由于心跳处理不及时，如果大量服务瞬时进行注册，有一定的概率推送超时，但是会在重试后推送成功，保持数据一致性，这种重试会使系统处于达不到稳态。nacos2.0长连接心跳，响应及时，推送失败率少，快速达到稳态。</p><blockquote><p>nacos 1.x</p><ul><li>每个服务实例都通过心跳续约，在Dubbo场景每个接口对应一个服务，当Dubbo的应用接口数较多时需要心跳续约TPS会很高。<br>心跳续约感知时延长，需要达到续约超时时间才能删除实例，一般需要15S，时效性较差</li><li>通过UDP推送变更数据不可靠，需要客户端定时进行数据全量对账保证数据的正确性，大量无效查询，整体服务的QPS很高<br>通信方式基于HTTP短链接的方式，Nacos侧释放连接会进入</li><li>TIME_WAIT状态，当QPS较高时会有连接耗尽导致报错的风险，当然这里通过SDK引入HTTP连接池能缓解，但不能根治</li><li>配置的长轮询方式会导致相关数据进入JVM Old区申请和释放内存，引起频繁的CMS GC</li></ul><p>nacos 2.x</p><ul><li>应用POD按照长连接维度进行心跳续约，不需要按照实例级，大大降低重复请求</li><li>长连接断开时可以快速感知到，不用等待续约超时时长就可以移除实例</li><li>NIO流式推送机制相对于UDP更可靠，并且可以降低应用对账数据频率</li><li>没有连接反复创建的开销，大幅降低TIME_WAIT连接多问题<br>长连接也解决了配置模块长轮询CMS GC问题</li></ul></blockquote><p>消费者服务向提供者服务请求，可以采用dubbo组件，进行RPC远程调用，通信基于HTTP2长连接，交换数据格式基于Protocolbuf。</p><blockquote><p>Triple 协议是 Dubbo3 推出的主力协议。它采用分层设计，其数据交换格式基于Protobuf (Protocol Buffers) 协议开发，具备优秀的序列化/反序列化效率，当然还支持多种序列化方式，也支持众多开发语言。在传输层协议，Triple 选择了 HTTP/2，相较于 HTTP/1.1，其传输效率有了很大提升。此外HTTP/2作为一个成熟的开放标准，具备丰富的安全、流控等能力，同时拥有良好的互操作性。Triple 不仅可以用于Server端服务调用，也可以支持浏览器、移动App和IoT设备与后端服务的交互，同时 Triple协议无缝支持 Dubbo3 的全部服务治理能力。</p></blockquote><p>当并发比较高，需要做负载均衡，Ribbon组件提供多种负载均衡策略，轮询，随机，最少活跃，最短响应，一致性hash。<br>当依赖服务无法请求，导致调用链的大量服务雪崩，可以使用 Sentinel组件，可以使用熔断降级和限流阻止情况的发生。如果所有方法都用同一个线程池第线程，A把打满线程池，导致B不可用线程池，Hystrix采用可以创建多个线程池隔离，也能进信号量隔离，舱壁模式；Sentinel用tomcat现有的线程池，不创建新池，只能信号量隔离（并发线程数限流）。防止恶意流量，需要限流，其策略采用漏斗或者令牌桶算法。</p><p>要了解多服务的调用链路和顺序，监控性能指标，需要搭建APM系统，采用Skywalking全链路服务追踪，无入侵埋点，使用java Agent探针，通过字节码注入实现拦截和数据收集。比zipkin效率高。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>少数情况，需要使用分布式事务。单机时代，可以把多个逻辑放在同一事务中，保证原子性，当两个逻辑在A，B两个节点时，需要保证要么全部成功，要么全部失败，需要引入第三方事务协调者TC，分别向A，B下达开始began命令，A和B分别预处理本地事务，处于uncommitted状态，会被排他锁锁定，本地处理好事务，会ack通知事务协调者；所有ack成功，此时进入第二阶段提交，TC下达提交commit或回滚rollback命令，A，B返回提交成功或回滚的ack响应。但是会存在一个问题，下达二阶段提交命令，由于网络或其他原因，造成无法及时送达，A，B处于阻塞状态。</p><p>解决这个问题，需要再引入一次提交precommit命令，ack协商，保证各节点状态相同，还引入超时机制解决阻塞，这就是3阶段提交3pc。在第一次预提交事务之后，插入一次询问是否提交就绪，并设置超时时间来解决阻塞问题。 三阶段提交解决了二阶段提交的单点故障问题并减少了阻塞。引入了超时机制，仍然有一致性问题，而且整体的交互过程更长了。PreCommit后，发出abort请求，只有一个Cohort收到abort，其他继续Commit，不一致性。</p><p>2pc问题<br>1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>2PC与3PC的区别：<br>    相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>*2PC：主持人<strong>跟第一位组员通话后</strong>，主持人<strong>失忆</strong>，<strong>组员</strong>得知结果并<strong>执行后痴呆</strong>，重选主持人，<strong>没人去提案</strong>，任务阻塞。</p><p><strong>3PC：</strong>即使主持人通知一部分组员执行后<strong>失忆</strong>，<strong>全体决策组员过一段时间决定全体自发提案或全体默认否决</strong>，此时没有阻塞，也没有不一致</p><p>如果主持人通知全体组员，大家再次确定，进入第三阶段</p><p>这时主持人通知第一位组员，请通过提案后两人<strong>失忆</strong>，<strong>重选</strong>出主持人，<strong>所有人仍自发去提案</strong>，没有问题；如果主持人通知是否决任务，通知第一位组员否决后两人<strong>失忆</strong>，<strong>重选</strong>出主持人，<strong>所有人仍自发去提案</strong>，出现不一致。</p><p>其实在我看来，解决单点故障减少阻塞的并不是将第一阶段掰成两半的操作，而是在最后提交的时候，超时自动提交。</p><p>两阶段完全也可以做成超时自动提交，只不过这样就和三阶段一样，无法保证数据的一致性。<br><figure class="image-box">                <img src="image_20220220170723.jpeg?v=1&type=image&token=V1:wIKY4Q2qtCsc_zurcS0boXyzKsv6apc4fDSJ40yytuA" alt title class>                <p></p>            </figure></p><p>为了得到最终一致性，我们要用补偿机制。</p><p><strong>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务</strong>，从思想上看和 2PC 差不多，用于补偿。</p><p>TCC是成熟的分布式事务解决方案，核心思想是事务补偿机制，包括try，confirm，cancel三个接口。try尝试锁定所有需要使用的资源，当所有回答yes，进入confirm 提交事务阶段，如果出现失败，调用cancel会滚补偿，不过有一个缺点，就编码量大。</p><blockquote><p>优点：<br>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。<br>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。<br>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。<br>缺点：TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p></blockquote><p>SAGA 是一种长活事务，把一个大的事务分解成一个个小事务T，每一个小事务T，都有一个对应的补偿任务C，当小事务失败，有两种补偿，1是正向重试T，2是反向恢复C。</p><p>也可以借助本地事务状态表来实现分布式事务：初始状态为1，每次成功调用一次服务，则更新一次状态，在所有状态为3时，就说明所有服务调用成功。</p><p>基于消息中间件的分布式事务解决方案：利用额外的MQ实现事务一致性，在业务A中把B的任务记录为msg B，逻辑合并在同一个事务中，并且把消息存储在本地DB表中，状态为待发送，并且开一个异步定时任务在本地轮询扫描这个表作为后续重试机制，通过MQ把消息发送到B，过程中可能存在消息投递失败的可能，此时就依靠<code>重试机制</code>来保证，当B收到消息时，在做对应操作前，会检查之前是否做过，因为集群或重试重复消息，需要做去重的幂等处理，保证消息不被重复消费。而后面如果B消费失败的话，则依赖MQ本身的重试来完成。B做完返回ACK到MQ，弹出MQ对应消息，同时将A接收ACK将对应消息状态更新或者消息清除；当然，后面A处理任务也是幂等。<br>多次重试后消息状态改为“超时”，要么回滚整个业务，要么再加一个单独地定时任务，它会间隔更长时间的定期轮训长时间处于<code>超时</code>状态的消息，通过一个<strong>check补偿机制</strong>来查询确认该消息对应的业务是否成功，如果对应的业务处理成功，则将消息然后将其投递给MQ，走一遍幂等业务；如果业务处理多次失败，则将对应的消息更新为失败，多次尝试失败记录警告，并通知等待人工干预，比如后台补单操作。因此在使用该方案时，消息生产者必须同时实现一个check查询服务，来供消息服务做消息的确认。</p><p>联想“支付场景”逻辑</p><p><a href="https://www.cnblogs.com/myseries/p/10819804.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10819804.html</a></p><p>独立消息服务<br><figure class="image-box">                <img src="image_20220220181659.png?v=1&type=image&token=V1:wI5_dncmAo9J1SqGOy916FBsmqKqYsfb54Unekn4JFY" alt title class>                <p></p>            </figure></p><blockquote><p>优点：<br>消息数据独立存储，降低业务系统与消息系统之间的耦合。<br>实现部分事务可重试<br>缺点：<br>强依赖MQ可靠<br>一次消息发送需要两次网络请求(half消息 + commit/rollback)。</p></blockquote><p>业界有一些为“最终一致性”而生的消息队列，如Notify（阿里）、QMQ（去哪儿）等，其设计初衷，就是为了交易系统中的高可靠通知。</p><p>seata支持多种模式：<br>XA协议：2PC，3PC，实现强一致性<br>TCC，SAGA，独创的AT模式，实现最终一致性；</p><p>AT模式，有几个重要的角色，TM用于开启全局事务，可提交或会滚，A，B对应两个子任务，TC是事务协调者。<br>第一步，TM，A，B分别把自己注册给TC<br>第二步，TM开启全局事务，A处理事务，首先向TC注册分支事务，然后预处理A的操作，并向sql写入会滚日志，最终提交本地事务；同样，B也注册分支事务，预处理自己的逻辑，写会滚日志，提交处理成功告诉TC。<br>第三步，所有逻辑处理完，TM提交全局事务，TC分别向A，B提交分支事务，并且删除所有回滚日志。或者，进行全局的回滚。</p><h2 id="单例模式的原因"><a href="#单例模式的原因" class="headerlink" title="单例模式的原因"></a>单例模式的原因</h2><p>双重校验锁DCL ——double check lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.懒汉实现惰性加载资源。</p><ol start="2"><li><p>volatile修饰，设置内存屏障，强制指令执行顺序，先分配内存空间，再创建对象，最后引用指向该对象。</p></li><li><p>static修饰，定义属于类变量，保证单例</p></li><li>第一个判断null，过滤synchronized锁的性能消耗</li><li>同步块，设置临界区，同时间只允许一个线程完成对象的创建。</li><li>第二个判断null，防止多线程进入第一个判断null，而导致多对象的创建。</li></ol><blockquote><p>Q: 过去DCL不安全的原因？<br>JVM1.4前，允许指令混乱情况。final：一个线程构造函数为final修饰变量赋值，另一个线程可能获取final的初始化0值；volatile：只保证读可见性，不保证写的顺序</p></blockquote><blockquote><p>Q: 不用volatile，先临时变量，再赋值到单例变量，是否能解决指令重排？<br> 不能，JVM只是潜在的reorder推手之一，CPU和缓存也会导致重排</p></blockquote><blockquote><p>Q: 新版本volatile如何保证DCL安全？<br>设置内存屏障，防止指令重拍，其中store-load屏障是保证读写顺序，实现volatile上的happens-before语义，即一个线程对volatile变量的写，先于其他线程对该变量的同时读。屏障的结果就是原来只保证volatile字段本身的可见性，现在保证本身以及所有相关字段的可见性，代价就是造成访问volatile字段的更大性能开销。</p></blockquote><blockquote><p>Q：是否可以用final实现DCL？<br>能。<br>a.对final字段的写必然先于其它线程装载该final字段的共享引用。（final字段必须被正确地赋值后其它线程才能读取到它）<br>b. 构造函数执行完毕后，对 final 字段的所有写以及通过这些 final 字段间接可及的变量变为“冻结”，所有在冻结之后获得对这个对象的引用的线程都会保证看到所有冻结字段的冻结值。（所有线程对final及其间接字段有一致的可见性）<br>c. 初始化 final 字段的写将不会与构造函数关联的冻结后面的操作一起重排序。（构造函数内部，对某个final字段而言，它的冻结点之前的操作必然先于冻结点之后的操作）</p></blockquote><blockquote><p> 再来说一下final域的重排规则：</p><ol><li>写final的重排规则：<br>JMM禁止编译器把final域的写重排序到构造函数之外。<br>在final域的写之后，插入一个StoreStore屏障。<br>也就是说确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</li><li>读final的重排规则：<br>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。<br>在读final域操作的前面插入一个LoadLoad屏障。<br>也就是说确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</li><li>如果final域是引用类型，那么增加如下约束：<br>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>就是确保在构造函数外把这个被构造对象的引用赋值给一个引用变量之前，final域已经完全初始化并且赋值给了当前构造对象的成员域，至于初始化和赋值这两个操作则不确保先后顺序。）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: DCL是否是实现单例的最佳方案？是否有代替？<br>不是。DCL的目的是懒加载和提高性能，但现代JMM加强volatile保证可靠，但副作用是性能开销变大，且加上了同步块的开销。</p></blockquote><p>完美方案：<br>推荐通过内部类实现惰性加载：<br>有一个大前提，JVM保证类的加载过程是线程互斥。<br>第一个调用getInstance，instance只被创建1次，且赋值给instance的内存已初始化完毕，避免reorder，此外，该方法第一次使用互斥机制，解决同步块带来的性能问题；<br>当然，只有第一次调用getInstance时才让instance加载，所以是惰性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;      </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             …          </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonContainer</span></span>&#123;</span><br><span class="line">             <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> SingletonContainer.instance;          </span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/doraeimo/article/details/5714239" target="_blank" rel="noopener">https://blog.csdn.net/doraeimo/article/details/5714239</a></p><h2 id="volatile-保证可见性？"><a href="#volatile-保证可见性？" class="headerlink" title="volatile 保证可见性？"></a>volatile 保证可见性？</h2><p>层层深入讲。</p><ol><li>可见性是指解决多线程在操作同一变量时，多个工作内存中的值不一样的问题。</li><li>JMM中定义了8种原子操作保证可见性：<br> 除了lock和unlock，<br> 还定义了<br> read load use 作为一种读原子操作<br> assign store write 作为一种写原子操作<br> 主存值read到执行引擎，执行引擎值load到一个栈存副本变量，栈存值use 到执行引擎，以便计算处理；<br> 执行引擎值 assign到栈存副本变量，栈存副本值store到主存，主存值write 到主存的变量，以便共享；<br> 避免在 读过程 或 写过程 中间操作被打断。<br> 虽然use 和assign存在 被打断的可能，但工作内存和主内存依旧想等。<br> 因此在多线程内，适合flag赋值，不适合a++等非原子操作，运算结果a会对中间加数a产生依赖。</li><li>原子操作的底层实现需要两种方式：<br> 一个是通过总线的，总线上有一个<strong>缓存一致性协议</strong>。总线有一个数据修改，所有的数据修改都是从总线推到主存，这个时候，其他cpu会<strong>嗅探</strong>总线上的修改，然后推送给其他cpu置旧的缓存不可用，下次再使用，就会从主存里读取（这部分可展开CPU底层）。还有一个是通过<strong>内存屏障</strong>，<strong>禁止指令重排序</strong>。<br> <strong>内存屏障有4种，load和store指令之前执行，比如：volidate 有读和写操作，在写前加store屏障，保证写写操作，不能重排序；在写后加storeLoad屏障，保证先写再读。在第一个读后加入loadLoad，保证读读的顺序；读后加入loadStore，保证读写顺序，StoreLoad虽然是全能屏障，同时具有其他3个屏障的效果，但开销大，因为处理器通常要把当前的写缓冲区的内容全部刷新到内存。基本上这就是volidate的禁止重排序的配合。</strong></li></ol><h3 id="Q：问点简单的，细说8种原子操作？"><a href="#Q：问点简单的，细说8种原子操作？" class="headerlink" title="Q：问点简单的，细说8种原子操作？"></a>Q：问点简单的，细说8种原子操作？</h3><p>（这要背了。。。）</p><ol><li><strong>read</strong>  读取：作用于主内存，将共享变量从主内存传动到线程的工作内存中，供后面的 load 动作使用。</li><li><strong>load</strong>  载入：作用于工作内存，把 read 读取的值放到工作内存中的副本变量中。</li><li><strong>store</strong>  存储：作用于工作内存，把工作内存中的变量传送到主内存中，为随后的 write 操作使用。</li><li><strong>write</strong>  写入：作用于主内存，把 store 传送值写到主内存的变量中。</li><li><strong>use</strong>  使用：作用于工作内存，把工作内存的值传递给执行引擎，当虚拟机遇到一个需要使用这个变量的指令，就会执行这个动作。</li><li><strong>assign</strong>  赋值：作用于工作内存，把执行引擎获取到的值赋值给工作内存中的变量，当虚拟机栈遇到给变量赋值的指令，执行该操作。比如  <code>int i = 1;</code></li><li><strong>lock（锁定）</strong>  作用于主内存，把变量标记为线程独占状态。</li><li><strong>unlock（解锁）</strong>  作用于主内存，它将释放独占状态。</li></ol><figure class="image-box">                <img src="JMM操作指令.png" alt="深入浅出Java虚拟机" title class>                <p>深入浅出Java虚拟机</p>            </figure><h3 id="Q：解释缓存一致性协议和嗅探机制？"><a href="#Q：解释缓存一致性协议和嗅探机制？" class="headerlink" title="Q：解释缓存一致性协议和嗅探机制？"></a>Q：解释缓存一致性协议和嗅探机制？</h3><p>a.  cpu三级缓存讲起，为解决主内存IO速度远远低于CPU运行速度，防止读CPU被阻塞，浪费CPU性能，CPU引入L1/L2/L3缓存行。<br>由于高速缓存行的引入，导致了多核CPU的并行访问缓存数据不一致的问题。比如更新一个CPU核的缓存，另外CPU依然存旧的值。<br>b. 为了解决脏数据和丢失更新的问题，要实现写原子操作，那么，需要两个锁：<br>一个总线锁，锁cpu和主内存通信，还阻塞其他CPU，保证锁期间只有一个CPU改写，但其他CPU也不能操作其他内存数据，似乎无影响操作也锁上了，开销过大。<br>一个缓存锁，只锁定被修改的缓存行。锁期间会进行一个CPU缓存的更新，以及其他缓存失效。这利用了缓存一致性协议mesi。缓存行有4状态：M修改，E独占，S共享，I失效。<br>共享表示主存和所有cpu的值一致，独占表示只有一个cpu有缓存，失效表示当前cpu存储旧值，修改表示当前cpu存储新值。<br>当一个cpu由共享态被主存改为修改态，cpu会更新一个排他标志，并且，通过总线，广播通知其他CPU，其他CPU异步“嗅探”事件后，把数据改为失效态。等下一次访问，再更新。</p><p>拓展性表格：<br>|  |M |S |E |I |<br>|–|–|–|–|–|<br>|M |X |X |X |O |<br>|E |X |X |X |O |<br>|S |X |X |O |O |<br>|I |O |O |O |O |</p><h3 id="Q：有缓存锁？为什么还要总线锁？"><a href="#Q：有缓存锁？为什么还要总线锁？" class="headerlink" title="Q：有缓存锁？为什么还要总线锁？"></a>Q：有缓存锁？为什么还要总线锁？</h3><p>（小细节不放过）</p><p>有两种情况不能用缓存锁：<br>一是数据大或数据跨多缓存行，二是部分CPU不支持缓存锁。<br>现代CPU总线锁和缓存锁并存实现数据一致性。</p><h3 id="Q：从硬件架构来说，CPU为什么会重排序？"><a href="#Q：从硬件架构来说，CPU为什么会重排序？" class="headerlink" title="Q：从硬件架构来说，CPU为什么会重排序？"></a>Q：从硬件架构来说，CPU为什么会重排序？</h3><p>​    前面指令如果依赖的数据发生缓存缺失，那么需要去内存磁盘读取数据，这个过程很耗时，如果不乱序执行的话，后面所有的指令都会被block住，这样CPU的吞吐量上不去，所有会有乱序执行机制，让后面没有数据依赖关系的指令可以不用等前面指令执行完了再执行（IPC，指令级并发）</p><p>作者：sakura1027<br>链接：<a href="https://www.nowcoder.com/discuss/459561?channel=-1&amp;source_id=profile_follow_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/459561?channel=-1&amp;source_id=profile_follow_post_nctrack</a><br>来源：牛客网</p><p>​    首先，我们要知道，CPU是并行流水线作业。本质上是利用了电路天然的并行性。这些电路，实际上都是一个个晶体管组合而成的。想要计算得快，一方面，我们要在 CPU 里，同样的面积里面，多放一些晶体管，<strong>也就是增加密度</strong>；另一方面，我们要让晶体管“打开”和“关闭”得更快一点，<strong>也就是提升主频</strong>。而这两者，都会增加功耗，带来耗电和散热的问题。</p><p>​    在 CPU 内部，和我们平时戴的电子石英表类似，有一个<strong>叫晶体振荡器（Oscillator Crystal）的东西</strong>，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。<strong>晶振带来的每一次“滴答”，就是时钟周期时间</strong>。Clock Cycle Time 一次晶振时间，时钟周期。简称<strong>CPI</strong></p><p>比如2.8GHz 就是电脑的主频，<strong>CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条</strong>。<strong>2.0GHz意味着每秒钟它会产生20亿个时钟脉冲信号，每个时钟信号周期为0.5纳秒</strong></p><p>对于 CPU 时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数”，<strong>加法和乘法都对应着一条 CPU 指令</strong>，<strong>但是乘法需要的 Cycles 就比加法要多</strong></p><p>现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机性能优化的重要一环。</p><p>指令执行过程拆分成“取指令、译码、执行”这样三大步骤。这为一个指令周期。</p><p>CPU一个时钟周期有很多条并行的流水线。</p><p>比如，五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，<strong>虽然执行一条指令的时钟周期变成了 5，但是我们可以把 CPU 的主频提得更高了</strong>。</p><p>并行如何保证顺序流水线之间顺序？</p><p>数据冒险，其实就是同时在执行的多个指令之间，有数据依赖的情况。这些数据依赖，我们可以分成三大类，分别是先写后读（Read After Write，RAW）、先读后写（Write After Read，WAR）和写后再写（Write After Write，WAW）。</p><p>解决这些数据冒险的办法，就是流水线停顿（Pipeline Stall），或者叫流水线冒泡（Pipeline Bubbling），起到延迟再等等的作用。好像是内存屏障。</p><h3 id="Q：什么是三级缓存？"><a href="#Q：什么是三级缓存？" class="headerlink" title="Q：什么是三级缓存？"></a>Q：什么是三级缓存？</h3><p>刚刚提到，为解决主内存IO速度远远低于CPU运行速度，防止读CPU被阻塞而引入L1/L2/L3。<br>L1各CPU独立，保存L2的数据，最小最快，如256k；L2各CPU独立，保存L3的数据，更大偏慢，如1M；L3各CPU共享，注意，不是所有CPU核共享，有多个L3，每几个CPU核共享一个L3，保存主存取的数据，最大最慢，如6MB。具体是二级还是三级根据CPU硬件而定。</p><p>CPU需要数据的时候，会先在一级缓存中寻找数据，一般一级缓存的数据命中率可以达到80%。如果一级缓存中找不到数据，CPU就会到二级缓存中寻找数据，如果依旧找不到的话，就会到三级缓存中找。有的CPU有四级缓存，三级缓存中没有，那就到四级缓存中找。</p><p>缓存怎么存呢？用缓存行，一个缓存行为64字节。<br>偏爱存储连续相邻的空间位置数据，体现为经常是访问数据+相邻数据，存指令也是，这就是空间局部性，比如mysql的B+树。如果一个信息被访问一次，近期可能会再次被访问，比如循环，递归，方法的反复调用，这就是时间局部性。共同构成局部性原理。</p><h3 id="Q：既然提到缓存行，知道伪共享问题吗？如何解决？"><a href="#Q：既然提到缓存行，知道伪共享问题吗？如何解决？" class="headerlink" title="Q：既然提到缓存行，知道伪共享问题吗？如何解决？"></a>Q：既然提到缓存行，知道伪共享问题吗？如何解决？</h3><p>（深…不见底）<br>伪共享，不是缓存是否真假共享问题哈，而是一个性能问题。<br>a. 首先，我们知道，对共享数据的写操作，会加锁+EMSI操作，耗费性能。<br>b. 伪共享，就是几个在逻辑上相互独立但在同一个内存单元内的数据，由于被cpu加载在同一个缓存行当中，当在多线程环境下，被不同的cpu执行，导致缓存行失效而引起的大量的缓存命中率降低。<br>例如：当两个线程分别对一个数组中的两份数据进行写操作，每个线程操作不同index上的数据，看上去，两份数据之间是不存在同步问题的，但是，由于他们可能在同一个cpu缓存行当中，这就会使这一份缓存行出现大量的缓存失效，如前所说，一个线程更新CPU缓存，会让其他CPU缓存失效掉。<br>c. 解决伪共享，采用缓存行填充，Cache Line Padding。具体就是定义无用变量代码。<br>解决伪共享问题的一个办法是让每一份数据占据一个缓存行：因为缓存行的大小是64个字节，那我们只要让数组中每份数据的大小大于64个字节，就可以保证他们在不同的缓存行当中，就能避免这样的伪共享问题。<br>比如一个类当中原本只有一个long类型的属性。这样这个类型的对象只占了16个字节（java对象头有8字节），如果这个类被定义成一个长度为4的volatile数组，这个数组的所有数据都可能在一个缓存行当中，就可能出现伪共享问题，那么这个时候，就可以采用补齐(padding)的办法，在这个类中加上public long a,b,c,d,e,f,g;这6个无用的属性定义，8字节对象头+8字节long*7个，使得这个类的一个实例占用内存达到64字节，这样这个类型的伪共享问题就得到了解决，在多线程当中对这个类型的数组进行写操作就能避免伪共享问题。（妙）</p><p><del>Q: 8字节对象头包括什么？算了，先不问这个</del></p><h3 id="Q：volatile的使用会导致什么问题？能避免吗？"><a href="#Q：volatile的使用会导致什么问题？能避免吗？" class="headerlink" title="Q：volatile的使用会导致什么问题？能避免吗？"></a>Q：volatile的使用会导致什么问题？能避免吗？</h3><p>（真的能问）</p><ol><li>volatile和cas使用过多会产生工作内存和主内存频繁交互、嗅探等操作，其很多事无效的操作，而系统共用一条总线，总线（bus）带宽资源有限，其中还有其他数据流、显存等交互，总线流量激增，这样就导致总线风暴。</li><li>不保证原子性。使用<code>volatile</code>在相关领域周围竖立记忆障碍物.好处是这不会导致线程进入”阻塞”状态。原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。但上面提到，use和assign是被打断的，以至于a++不是原子操作。只能一定程度上保证有序性。</li><li>可能导致内核态与用户态的上下文切换。 它不会像锁一样直接引起线程<code>上下文的切换和调度</code>。当<code>volatile</code>访问该字段时，程序必须刷新对中央存储器的更改并更新需要周期的高速缓存存储器。在CPU的“嗅探”到消息后，CPU中断去处理失效，此时CPU程序计数器栈会发生上下文切换。</li><li>当然，还有刚说的伪共享。几个逻辑上独立数据，加载在同一个缓存行，更新引发批量缓存失效问题。</li></ol><p>解决原子性，可以采用Atomic原子变量，有两种写set和lazySet<br>set方法使用CAS + volatile，在写操作的前后都加了内存屏障。lazySet方法并不是直接的操作value字段，而是通过Unsafe类的方法先通过初始化时候计算出的value字段的偏移变量找到字段地址，然后调用本地方法进行操作的，在本地方法中只在写操作前面加了一个屏障，而后面没有加。相当于只用普通变量。<br>因为引入CAS轻量级锁，有自旋操作，更消耗CPU。</p><p>总之，使用volatile或Atomic，根据具体业务场景而定。</p><h3 id="Q-CAS底层？"><a href="#Q-CAS底层？" class="headerlink" title="Q:CAS底层？"></a>Q:CAS底层？</h3><ol><li>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性</li><li><p>cmpxchg指令加上lock前缀（lock cmpxchg）</p><p>3.锁住总线，使得其他处理器暂时无法通过总线访问内存。</p><p>4.StoreLoad内存屏障，<strong>禁止该指令与之前和之后的读和写指令重排序</strong>，使得线程把不是单单被修改的数据会被回写到主内存，而是写缓存中所有的数据都回写到主内存。</p><p>5.而将写缓冲区的数据回写到内存时，就会通过缓存一致性协议（如，MESI协议）和窥探技术来保证写入的数据被其他处理器的缓存可见。这就相当于实现了volatile的内存语义。</p></li></ol><h3 id="Q：上面有提到CPU上下文切换，来说说用户态和内核态？"><a href="#Q：上面有提到CPU上下文切换，来说说用户态和内核态？" class="headerlink" title="Q：上面有提到CPU上下文切换，来说说用户态和内核态？"></a>Q：上面有提到CPU上下文切换，来说说用户态和内核态？</h3><p>（来了，来了。扯操作系统，干爆！）</p><p>从4个点讲：</p><p> a. 从CPU指令集开始讲，多个汇编指令的集合就是CPU指令集。</p><p>CPU指令集分为4个权限：ring 0，ring 1，ring 2 和 ring 3；</p><p>ring 0 权限最高，ring 3 权限最低。</p><ul><li>ring 0被叫做内核态，完全在操作系统内核中运行，可以使用所有 <code>C P U 指令集</code>；</li><li>ring 3被叫做用户态，在应用程序中运行，，不能使用操作硬件资源的 <code>C P U 指令集</code>，比如 <code>I O</code> 读写、网卡访问、申请内存都不行。</li><li>ring1与ring2主要是访问驱动程序，win10 和 linux 只有 ring 0 和ring 3。</li></ul><p>b. 为什么划分权限？内核模式下任何异常都是灾难性的，会导致停机。用户模式下，可以限制对硬件的直接控制权限，只能通过系统提供的调用接口来控制。在这种保护模式下，即时用户程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在用户模式下运行的。</p><p>c. 再说，每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用。用户程序会使用用户栈，为了可以操作ring 0 级别的 CPU 指令集， CPU切换权限级别为 ring 0，进入内核态，CPU再执行相应的ring 0 级别的 CPU 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。</p><p>d. 再一个是，用户态与内核态的虚拟内存寻址空间。操作系统会把一个进程的虚拟控制内存地址划分为两部分，以32位Linux操作系统为例，假如有<code>4G</code>寻址空间范围 ，高位部分为内核栈， <code>1G</code>由内核使用；低位部分为用户栈， <code>3G</code>由各个进程使用。</p><p><code>Q: 我插一句。。。</code></p><p>c. 先别插话，讲最后一点，用户态和内核态切换的开销大。</p><ul><li>保留用户态现场（上下文、寄存器、用户栈等）</li><li>复制用户态参数，用户栈切到内核栈，进入内核态</li><li>额外的检查（因为内核代码对用户不信任）</li><li>执行内核态代码</li><li>复制内核态代码执行结果，回到用户态</li><li>恢复用户态现场（上下文、寄存器、用户栈等）</li></ul><p><code>Q: 那我问一句。。。</code></p><p>d.  还有！还有！关于什么情况会导致用户态到内核态切换？</p><p>1-系统调用，如fork()创建新进程；</p><p>2-异常，如缺页异常 ；</p><p>3-CPU中断，如硬盘读写操作完成，中断处理后边程序。</p><h4 id="Q-插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？"><a href="#Q-插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？" class="headerlink" title="Q: 插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？"></a>Q: 插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？</h4><p>（问这么细）</p><p>都不是1. 用户态只能操作自己的3G空间，内核态是能操作4G的所有范围；2. 内核态自己的1G是所有进程共享的，指所有进程的内核态逻辑地址是共享同一块内存地址，记住，这是虚拟映射空间！！！这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。所以，这个地址空间，包括整个进程的虚拟地址空间，对于每个进程来说都是逻辑独立的，而且，每个进程看到的逻辑地址空间都是一样的，实际上，物理内存有共享部分和独立部分。</p><h4 id="Q：再插一句，问题来了，不同进程-有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※"><a href="#Q：再插一句，问题来了，不同进程-有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※" class="headerlink" title="Q：再插一句，问题来了，不同进程 有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※"></a>Q：再插一句，问题来了，不同进程 有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※</h4><p>（啊啊啊，这势头，内存继续深挖…）</p><p>这就要靠 每个进程的的<strong>页表</strong>了，每个进程都有一个自己的页表，使得某逻辑地址对应于某个物理内存。</p><p>首先，我们要对进程的虚拟内存空间有清晰的认识：</p><ul><li><p>操作系统为每个进程分配的内存空间是一样的；如32位Linux操作系统的内存空间是0-4G。</p></li><li><p>操作系统为每个进程分配的内存空间所提交的物理内存空间在用户的角度一般是不同的，在内核是相同的。</p></li><li><p>用户可以通过操作系统将同一块物理内存映射到不同的进程空间。</p></li></ul><p>正因为 每个进程都有一个自己的页表，使得相同的逻辑地址映射到 不同 或 存在相同 的物理内存。对于线程 ，它也有自己的页表，只是页表的 逻辑地址 映射到的物理内存相同。</p><h4 id="Q-大概讲下，虚拟内存映射过程？"><a href="#Q-大概讲下，虚拟内存映射过程？" class="headerlink" title="Q: 大概讲下，虚拟内存映射过程？"></a>Q: 大概讲下，虚拟内存映射过程？</h4><p>（挖了个大坑。。。预感还问页面置换算法。。。）</p><ol><li><p>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</p><blockquote><p>页表的每一个表项分两部分，第一部分记录此页<a href="https://github.com/Durant35/durant35.github.io/issues/24">是否在物理内存</a>上，第二部分记录<a href="https://github.com/Durant35/durant35.github.io/issues/24">物理内存页的地址</a>（如果在的话）</p></blockquote><p>2.当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则<a href="https://github.com/Durant35/durant35.github.io/issues/24">缺页异常</a></p></li></ol><blockquote><p>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。这里用到一些<strong>页面置换算法</strong></p></blockquote><ol start="3"><li><p>辅助映射的硬件：内存管理单元MMU，通常是 CPU 的一部分，<strong>本身有少量的存储空间</strong>用来存放从虚拟地址到物理地址的查找表；</p></li><li><p>三种内存管理方式：分别是<strong>分段、分页、段页</strong></p><p><strong>分段</strong></p><p>分段管理下的虚拟地址由两部分组成，段号和段内偏移量</p><p><img src="640.png" alt="图片"></p><blockquote><ol><li>通过段号映射段表的项</li><li>从项中获取到段基地址</li><li>段基地址+段内偏移量=使用的物理内存</li></ol></blockquote><p>有两个不足：</p><p>一是容易产生内存碎片：没有足够一个段的空间映射就是内存碎片，解决方法是<strong>内存碎片整理</strong>，而内存碎片整理是通过<strong>内存交换</strong>的方式来实现，即内存部分数据加载硬盘，再读时，会紧挨另一个段形成连续物理内存。</p><p>二是内存交换效率低：因为容易造成内存碎片，导致内存交换的频率较高，又因为因为硬盘的访问速度比内存慢太多了，把一大段连续的内存写入到硬盘，再又从硬盘读取出来，如果交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿，过程也很慢的，所以说分段方式内存交换效率低。</p><p>为了解决内存分段管理造成的内存碎片与内存交换效率低的问题，就出现了内存分页。</p></li></ol><hr><p>   分页方式是这样解决的，如果内存空间不够时，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页释放掉，也就是加载到硬盘，称为换出，一旦需要的时候再加载进来，称为换入。所以一次性写入硬盘的也只有一个页或几个页，内存的交换效率自然就提升了。</p><p>   分页方式使加载程序的时候，不再需要一次性都把程序加载到物理内存中。完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去（用大白话说，当你需要用到的时候才会去使用对应的物理内存）。</p><hr><p>   简单分页：是每个进程都会分配一个页表，虚拟地址会分为两部分，页号和页内偏移量，页号作为页表的索引,页表包含物理页每页所在物理内存的基地址，页内偏移量+物理内存基地址就组成了物理内存地址，如下图所示</p><p>   <img src="640.png" alt="图片"></p><p>   就是下面这几步</p><blockquote><ol><li>页号找到页表中的页项</li><li>获取页项的物理页号基地址</li><li>偏移量+物理页号基地址计算出物理内存地址</li></ol></blockquote><p>   不足之处：</p><p>   每个进程分配一个页表会有空间上的缺陷，因为操作系统上可以运行非常多的进程，那不就意味着页表数量非常多。</p><blockquote><p>以32 位的环境为例，虚拟地址空间范围共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间范围的映射就要/有 4MB 的内存来存储页表。</p></blockquote><blockquote><p>4MB看起来不大，但是数量上来了就很恐怖了，假设 100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p></blockquote>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贴心提示：</span><br><span class="line"> 1B(Byte 字节)=8bit，</span><br><span class="line"> 1KB (Kilobyte 千字节)=1024B，</span><br><span class="line"> 1MB (Megabyte 兆字节 简称“兆”)=1024KB，</span><br><span class="line"> 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB</span><br></pre></td></tr></table></figure><p>   为了解决空间上的问题，在对分页方式的基础上，进行优化，出现了多级页表方式</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>   在页表的基础上做一次二级分页，把刚刚提到的100万「页表项」分为<strong>一级页表</strong>「1024个页表项」,「一级页表项」下又关联<strong>二级页表</strong>「1024个页表项」，这样一级页表的1024个页表项就覆盖到了4GB的空间范围映射，并且<strong>二级页表按需加载</strong>，这样页表占用的空间就大大降低。</p><p>   做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 就是一个巨大的节约。</p><p>   <img src="image-20220222221928062.png" alt="image-20220222221928062"></p><p>   在二级的基础上是不是又可以继续分级呢，能分二级，必然也能分三级、四级，在64位操作系统是做了四级分页。</p><h4 id="TBL快表-：一种CPU的高速缓存"><a href="#TBL快表-：一种CPU的高速缓存" class="headerlink" title="TBL快表 ：一种CPU的高速缓存"></a>TBL快表 ：一种CPU的高速缓存</h4><p>   多级页表虽然解决了空间上的问题，但是我们发现这种方式需要走多道转换才能找到映射的物理内存地址，经过的多道转换造成了时间上的开销。</p><p>   程序是局部性的，即在一段时间内，整个程序的执行仅限于程序的某一部分。相应的，执行所访问的存储空间也局限于某个内存区域。</p><p>   操作系统就利用这一特性，把最多使用的几个页表项放到TBL快表缓存, CPU 在寻址时，会先查 TLB快表，如果没找到，才会继续查常规的页表，TLB 的命中率其实很高的，因为程序最常访问的页就那么几个。</p><h4 id="内存段页"><a href="#内存段页" class="headerlink" title="内存段页"></a><strong>内存段页</strong></h4><p>   段式与页式并不是相对的，他们也可以组合在一起使用，在段的基础上进行分页分级。</p><ol><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制</li><li><p>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页</p><p>虚拟地址结构由段号、段内页号和页内位移三部分组成</p><p><img src="640.png" alt="图片"></p><p>就是下面这几步</p><blockquote><ol><li>通过段号获取段表的段项</li><li>通过段项获取到页表地址</li><li>通过页表地址找到段页表</li><li>通过段内页号找到段页表的段页项</li><li>通过段页项获取物理页基地址</li><li>通过物理页基地址+偏移量计算出物理内存地址</li></ol></blockquote></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>   多级分页通过树+懒加载+缓存解决了空间占用与时间消耗的问题，虚拟地址很好的做到了让进程与物理内存地址解耦，正因如此，多进程使用物理内存时才不会有冲突，很好的做到了相互独立与隔离。正因如此，多进程使用物理内存时才不会有冲突，很好的做到了相互独立与隔离。</p><h4 id="Q：虚拟内存的好处？"><a href="#Q：虚拟内存的好处？" class="headerlink" title="Q：虚拟内存的好处？"></a>Q：虚拟内存的好处？</h4><ul><li>既然每个进程的内存空间都是一致而且固定的，所以<a href="https://github.com/Durant35/durant35.github.io/issues/24">链接器在链接可执行文件时，可以设定内存地址</a>，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处；</li><li>当不同的进程使用同样的代码时，比如库文件中的代码，<a href="https://github.com/Durant35/durant35.github.io/issues/24">物理内存中可以只存储一份</a>这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存；</li><li>在<a href="https://github.com/Durant35/durant35.github.io/issues/24">程序需要分配连续的内存空间</a>的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li></ul><h4 id="Q：页面置换算法？"><a href="#Q：页面置换算法？" class="headerlink" title="Q：页面置换算法？"></a>Q：页面置换算法？</h4><p>（ 。。。果然）</p><p>当所需页不在内存，要将其调入，但如果内存没有空闲空间，为了保证进程所需的页能够调用，必须选择另外一些页调出。此时选择页面置换算法，算法的好坏直接影响系统性能，不适当的算法可能会产生系统“抖动”。</p><p>内存进程过多，缺页越拼单，有效访问存储器的时间急速减少，换句话，就是大部分时间用于页面的换进/换出，而几乎不能完成任何有效的工作，这就是系统的“抖动状态”。</p><blockquote><ol><li><p>最佳置换算法</p><p>理论算法，选择不再使用或最长时间内不再使用的页淘汰</p></li><li><p>先进先出置换算法</p><p>选择先进的页淘汰，与进程实际运行规律不符，缺页率高，抖动高</p></li><li><p>最近最久未使用置换算法LRU</p><p>作用如名字所说，比较符合业务。</p></li><li><p>时钟置换算法</p><p>所有页面用指针链接成一个循环队列。当某页被访问时，其访问位置为1，当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描。</p></li></ol></blockquote><h4 id="Q：问简单的，进程和线程的区别？"><a href="#Q：问简单的，进程和线程的区别？" class="headerlink" title="Q：问简单的，进程和线程的区别？"></a>Q：问简单的，进程和线程的区别？</h4><p>进程是最小的资源分配单位，线程是最小CPU调度单位</p><p>进程：</p><p>P C B是 进程 存在的唯一标识，这意味一个 进程 一定会有对应的PCB，进程消失，P C B也会随之消失。</p><p>P C B通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列；</p><ul><li>将所有处于就绪状态的 进程 链在一起，称为就绪队列</li><li>把所有因等待某事件而处于等待状态的 进程 链在一起就组成各种阻塞队列</li></ul><p>CPU把一个进程切换到另一个进程运行的过程，称为进程上下文切换；一个进程的上下文切换，同时可能影响其他CPU核心上的进程的执行效率。</p><h3 id="Q：插一句，-什么是CPU上下文切换？"><a href="#Q：插一句，-什么是CPU上下文切换？" class="headerlink" title="Q：插一句， 什么是CPU上下文切换？"></a>Q：插一句， 什么是CPU上下文切换？</h3><p>C P U上下文 是指 C P U 寄存器 和 程序计数器</p><ul><li>C P U 寄存器 是 C P U 内置的容量小，速度极快的缓存</li><li>程序计数器是用来存储 是 CPU 正在执行的指令位置或即将执行的下一条指令位置</li></ul><p>上下文切换就是把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些指令寄存器(IR)和程序寄存器(PC)等寄存器中。这些被保存下来的上下文会存储在操作系统的内核中，等待任务重新调度执行时再次加载进来，这样就能保证任务的原来状态不受影响，让任务看起来是连续运行的。</p><p>根据场景不同，CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p><p>进程是由内核管理与调度的，所以 进程上下文切换 发生在内核态，进程上下文切换的内容包含用户空间资源（虚拟内存、栈、全局变量等）与内核空间资源（内核堆栈、寄存器等）</p><p>什么时候会发生进程调度？</p><ul><li>进程的CPU时间片耗尽，被系统挂起，切换到其他等待CPU的进程运行。</li><li>进程所需要的系统资源不足。要等待资源满足后才可以运行。这个时候会被系统挂起。</li><li>进程通过sleep函数主动将自己挂起。</li><li>当有优先级更高的进程运行时，当前进程会被挂起，由高优先级的进程运行。</li><li>硬中断发生时，CPU上的进程会被挂起，转而执行内核的中断服务程序。</li></ul><h3 id><a href="#" class="headerlink" title="***"></a>***</h3><p>特别需要注意的是<strong>操作系统会将当前任务的虚拟内存一并保存</strong>。而Linux中通过TLB快表来管理虚拟内存到物理内存的映射关系。TLB用于虚拟地址与实地址之间的交互，提供一个寻找实地址的缓存区，能够有效减少寻找物理地址所消耗时间。<strong>当虚拟内存被刷新后，TLB也会被更新。</strong>如果没有TLB，则每次取数据都需要<strong>两次访问内存</strong>，即查页表获得物理地址和取数据。在多核的技术下，这会极大的降低程序的执行效率。因为缓存L3 Cache 是被几个核共享的。当TLB被更新后，<strong>缓存中的TLB数据会失效</strong>，每个CPU都需要从主存中<strong>重新载入</strong>，一个进程的上下文切换，同时为保证缓存一致性，<strong>可能影响其他CPU核心上的进程</strong>的执行效率。</p><p>线程：</p><p>一个进程下面能有一个或多个线程，每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p>线程带来的好处有以下几点</p><ul><li>一个进程中可以同时存在多个线程</li><li>让进程具备多任务并行处理能力</li><li>同进程下的各个线程之间可以共享进程资源 （同进程内的多线程通信十分简单高效）</li><li>更轻量与高效</li></ul><p>线程带来的坏处有以下几点</p><ul><li>因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同</li><li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃（一般游戏的用户设计不会采用多线程方式）</li></ul><h2 id="线程与进程的对比"><a href="#线程与进程的对比" class="headerlink" title="线程与进程的对比"></a><strong>线程与进程的对比</strong></h2><ul><li>进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）</li><li>线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的，一个是快表失效，二是重新载入几个核，三是为保证缓存一致性，影响其他CPU核心上的进程</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了</li></ul><p>线程比进程不管是时间效率，还是空间效率都要高。</p><h4 id="Q：刚聊到进程共享，进程之间的通信有哪些？"><a href="#Q：刚聊到进程共享，进程之间的通信有哪些？" class="headerlink" title="Q：刚聊到进程共享，进程之间的通信有哪些？"></a>Q：刚聊到进程共享，进程之间的通信有哪些？</h4><p>一般来说，每个进程都是独立的，操作系统为每个进程之间提供了「隔离」。所以进程之间不能直接互相访问，但可以借助它们共享的「内核空间」来实现通信。</p><p><strong>1.管道</strong></p><p>管道是用环形队列实现的，数据从写端流入，从读端流出，这样就实现了进程间通信。一个管道只能单向传输数据，进程之间的双向传输则需要创建两个管道。比如管道符 。</p><p> <strong>2.消息队列</strong></p><p>消息队列是存储在内核中的消息<strong>链表</strong>，遵循队列的<strong>先进先出</strong>原则。</p><p>消息块遵循进程双方自定义的数据类型，有固定大小。</p><p>消息队列不适合传输较大的数据，因为每个消息块的大小有限制。</p><p>消息队列存在于内核中，所以进程的读写消息需要在用户态与内核态频繁切换，系统开销较大。</p><p><strong>3.共享内存+信号量</strong></p><p>mmap是一种内存映射文件的方法。利用mmap把普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问。</p><p>信号量有效解决了进程间竞争共享资源而导致的数据不同步，用于实现进程的访问共享资源的互斥与同步。</p><p><strong>4. 信号</strong></p><p>信号可以理解为给进程发送一个<strong>命令</strong>。</p><p><strong>5.Socket</strong></p><p>实现跨越网络的进程通信</p><h4 id="Q：线程通信有哪些？"><a href="#Q：线程通信有哪些？" class="headerlink" title="Q：线程通信有哪些？"></a>Q：线程通信有哪些？</h4><p>1 锁与同步   包括互斥锁、条件变量、读写锁</p><p>2 等待/通知机制    基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>, <code>notifyAll()</code>方法来实现的。</p><p>3 信号量 Semaphore</p><p>4 管道流 PipedOutputStream<code>、</code>PipedInputStream</p><h2 id="你的代码如何保证原子性？"><a href="#你的代码如何保证原子性？" class="headerlink" title="你的代码如何保证原子性？"></a>你的代码如何保证原子性？</h2><p>一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><ul><li>synchronized同步代码块</li><li>cas原子类工具</li><li>lock锁机制</li></ul><h1 id="sychronized-和-lock区别"><a href="#sychronized-和-lock区别" class="headerlink" title="sychronized 和 lock区别"></a>sychronized 和 lock区别</h1><p>sychronized有两种方法，一种是作用在方法，另一种作用在代码块；<br>如进入临界区前，先判断ACC_SYCHRONIZED标记，有才可以进入moniter对象之后，执行moniterenter指令，把当前的计数器+1，然后开始执行方法，当结束时，先释放moniter对象，再执行moniterexit让计数器-1，然后结束方法。<br>出现异常，也能够自动释放，但有个问题，它无法中断。<br>而Lock，可以调用方法中断，当锁竞争激烈，性能较好。</p><h1 id="讲讲代理模式"><a href="#讲讲代理模式" class="headerlink" title="讲讲代理模式"></a>讲讲代理模式</h1><p>当client 使用RealObj时，先创建proxy代理类，在使用时抽取出RealObj接口，叫做抽象主题类，原来RealObj叫做主题实现类。那么，代理类场景，比如1. I/O处理图片文件，设置虚拟代理，当真正需要使用才会创建出来； 2.设置访问权限，设置保护代理，实现防火墙网关；3.网络访问，grpc/dubbo远程调用，使用远程代理对方式；4. 日志记录代理，AOP实现； 5. 缓存数据，需要缓存代理，AOP实现；6. 事务创建到提交代理过程代理；<br>一种是静态代理，自己new对象作为代理对象，另一种是动态代理，JDK反射，实现Handler，调用newProxyInstance；Cglib操作asm框架在字节码层实现 spring AOP有实现接口就用JDK，无则Cglib。</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>TCP  强调传输字节流，连接可靠；<br>UDP 强调报文包的发送，连接不可靠；<br>UDP包含源端口，目的端口，数据的长度，为了防止数据出错的校验和，发送的数据<br>TCP包包含以上五项，还增加了序号，确保发送的顺序，确认序号几个字段，防止丢包，还有一些状态位，建立连接时的syn，确认响应时的ack，端位连接的fin，还增加窗口大小，用来流量和拥塞控制；</p><p>TCP传输过程，建立连接三次握手，传输数据，释放连接四次挥手；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;select-poll-epoll&quot;&gt;&lt;a href=&quot;#select-poll-epoll&quot; class=&quot;headerlink&quot; title=&quot;select/poll/epoll&quot;&gt;&lt;/a&gt;select/poll/epoll&lt;/h2&gt;&lt;p&gt;在客户端请求服务端时</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="高并发" scheme="https://missionodd.github.io/categories/技术/高并发/"/>
    
    <category term="并发编程" scheme="https://missionodd.github.io/categories/技术/高并发/并发编程/"/>
    
    
    <category term="java" scheme="https://missionodd.github.io/tags/java/"/>
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="分布式" scheme="https://missionodd.github.io/tags/分布式/"/>
    
  </entry>
  
  <entry>
    <title>Spring | 高频知识口述</title>
    <link href="https://missionodd.github.io/2022/01/23/spring-notes/"/>
    <id>https://missionodd.github.io/2022/01/23/spring-notes/</id>
    <published>2022-01-23T05:50:37.000Z</published>
    <updated>2022-03-16T19:18:03.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q：-IOC-和-AOP"><a href="#Q：-IOC-和-AOP" class="headerlink" title="Q： IOC 和 AOP"></a>Q： IOC 和 AOP</h2><p>spring 要控制和管理bean，就要从bean的配置，实例化，设置属性，初始化，这一套的实现以及操作bean就是控制反转 IOC｡ Aop是切面编程，对局部功能的增强。<br>Spring想要通过IOC来控制反转去创建bean,就需要从XML或注解文件中通过loader读取为 resource,再通过 bean define reader读取为 bean definition,保存在registry｡再通过 stractegy策略来实例化，再使用bean wrapper填充属性，最后初始化完成bean的创建。在实例化和初始化的前后，肯定，是会有生命周期的回调。 InstantationAwareBeanPostProcessor用在实例化前后，beanPostProcessor作用于初始化阶段的前后。</p><p>Aop面向切面编程主要是使用aspectJ实现，并且引入了连接点，置入等概念。但它的实现主要还是用动态代理， 优先使用cjlib，可以改为JDK实现。</p><h2 id="Q：如何解决循环依赖问题？"><a href="#Q：如何解决循环依赖问题？" class="headerlink" title="Q：如何解决循环依赖问题？"></a>Q：如何解决循环依赖问题？</h2><p>引入了AOP动态代理之后，循环依赖的解决方式会更加复杂。<br>就要用到三级缓存才能解决，一级缓存是单例成品的容器。singletonObjects，二级缓存是lazy懒加载的半成品容器earlySingletonObjects，三级缓存是工厂池singletonFactories。<br>如在创建A过程中，引用B，发现B对A是有引用的。<br>首先，A先从一级，二级，三级缓存依次找bean，如果3个缓存没有，会在创建一个FactoryA缓存在第3级的工厂池中，然后A要填充属性时，发现需要创建B。<br>于是，又先创建FactoryB到第3级工厂池，接着B填充属性，需要A，就把FactoryA的半成品Bean或代理对象移动到2级缓存，再提供给B注入，在B创建完毕后，B的成品放入1级缓存，并删除掉B的3级缓存。<br>回到A，A此时拿到了B的成品注入，完全创建后，A的成品放入1级缓存，删除A的1级和2级缓存。</p><h2 id="Q：为什么需要三级缓存？-不是二级缓存？"><a href="#Q：为什么需要三级缓存？-不是二级缓存？" class="headerlink" title="Q：为什么需要三级缓存？  不是二级缓存？"></a>Q：为什么需要三级缓存？  不是二级缓存？</h2><p>只要两个缓存确实可以做到解决循环依赖的问题，但是有一种情况，就是这个Bean需要AOP切面代理，如果加上AOP，两级缓存是无法解决的。<strong>3级缓存的value类型是ObjectFactory，是一个函数接口 ，存在的意义是保证在整个容器的加载过程中同名的bean对象只能有一个，它能生产两种产品：单例的半成品Bean和多例的Bean代理对象。在对象需要被引用注入时，我们不可能每次都从3级缓存的工厂中给我产生一个新的代理对象，所以还要借助另外一个2级缓存来保存产生的代理对象</strong>。</p><h2 id="Q：为什么Bean代理对象多例，不一开始使用做单例缓存，然后取消2级缓存？"><a href="#Q：为什么Bean代理对象多例，不一开始使用做单例缓存，然后取消2级缓存？" class="headerlink" title="Q：为什么Bean代理对象多例，不一开始使用做单例缓存，然后取消2级缓存？"></a>Q：为什么Bean代理对象多例，不一开始使用做单例缓存，然后取消2级缓存？</h2><p>可以但没必要。一个是引入2级缓存已经统一了单例的半成品Bean和多例的Bean代理对象的获取，已保证AOP代理对象也只创建一次；Spring希望AOP代理对象的创建是在Bean初始化的后置处理器中，<br>2级缓存的存在，避免循环依赖中再次通过工厂获取bean这一复杂流程，提升加载效率；因为从3级缓存获取对象时需要每次都通过工厂去拿，需要遍历所有的后置处理器、判断是否创建代理对象，而判断是否创建代理对象本身也是一个复杂耗时的过程；</p><h2 id="Q：能不能去掉2级缓存，初始化完毕，然后代理对象放到1级缓存中？"><a href="#Q：能不能去掉2级缓存，初始化完毕，然后代理对象放到1级缓存中？" class="headerlink" title="Q：能不能去掉2级缓存，初始化完毕，然后代理对象放到1级缓存中？"></a>Q：能不能去掉2级缓存，初始化完毕，然后代理对象放到1级缓存中？</h2><p>一，1级缓存放的是已经初始化完毕的 Bean，要知道 A 依赖了 B 和 C ，A 这时候还没有初始化完毕。<br>二，3级缓存返回的代理对象是不同的，没有2级缓存，就会导致 B 和 C 依赖了不同的 A。</p><h2 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h2><p>用户发起请求，被前端控制器DispatcherServlet拦截，然后调用处理器映射器HandlerMapping，根据URL去获得一个处理链Handler ExecutionChain，里边包括了拦截器Interceptor和我们写的Controller，通过层层拦截校验最终获得处理器适配器HandlerAdatper，同时真正执行处理器Hander（Controller），处理业务后，返回一个ModelAndView对象给前端控制器，里边包含数据和跳转的路径。然后前端控制器会选择一个合适的视图解析器ViewReslover去进行一个视图的渲染。<br>这里边，可以内部转发和重定向，可以处理文件上传和处理普通HTTP请求。</p><p>这里边，拦截器使用了责任链模式，handler的处理与视图的解析使用了适配器模式，利用反射处理请求入参和返回结果视图。</p><p>这里边，对于@ResponseBody，是在RequestMappingHandlerAdapter中设置了messageConverters的逻辑<br>，根据HTTP头的Accept信息，或默认JSON，通过HttpMessageConverters对消息对象的转化。</p><h2 id="Spring容器启动流程"><a href="#Spring容器启动流程" class="headerlink" title="Spring容器启动流程"></a>Spring容器启动流程</h2><p>部署一个web应用在web容器中，它会提供一个全局的上下文环境，这个上下文就是ServletContext，它为后面的IoC容器提供宿主环境，当web容器启动的时候，会执行web.xml中的ContextLoaderListener监听器初始化contextInitialized方法，调用父类的initWebApplicationContext方法，这个方法里面执行了三个任务：1.创建WebApplicationContext容器，2.加载context-param中spring配置文件，3.初始化配置文件并且创建配置文件中的bean。监听器初始化完毕后，开始初始化web.xml中配置的servlet ，用DispatcherServlet举例，它是一个前端控制器，用来转发、匹配、处理每个servlet 请求。DispatcherServlet上下文在初始化的时候会建立自己的上下文，先从ServletContext 中获取之前的WebApplicationContext作为自己上下文的父类上下文，有了这个父类上下文之后，再初始化自己持有的上下文，创建springmvc相关的bean，初始化处理器映射、视图解析等等，初始化完后，spring把Servlet的相关的属性作为属性key，存到servletcontext中，方便后面使用。这样每个Servlet 都持有自己的上下文，拥有自己独立的bean 空间，各个servlet 共享相同的bean，也就是根上下文定义的那些bean。web容器停止时候会执行ContextLoaderListener的contextDestroyed方法销毁context容器。</p><h2 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h2><p>1、new了一个SpringApplication对象，使用SPI机制扫描spring.factories文件，加载所有的初始化器和监听器。</p><p>2、调用run() 方法，准备上下文环境，创建上下文对象，根据环境insert组件，比如说autowired，configuration等 。</p><p>3，最后刷新环境，启动spring容器和serverlet容器。</p><h2 id="Springboot自动装配原理"><a href="#Springboot自动装配原理" class="headerlink" title="Springboot自动装配原理"></a>Springboot自动装配原理</h2><p>主要是SPI机制。Springboot启动时会扫描Import注解找到Selector类，调用selectImports方法，读取所有spring.factories配置文件，根据文件中定义的自动配置类路径，按需将Bean加载到Spring容器中。</p><p>主要依赖类上的@ springbootapplication注解，它由3个分注解组成，@ComponentScan 扫描当前包和子包，@SpringBootConfiguration 代表当前是一个配置类，第三个数自动装配的核心，@EnableAutoConfiguration ，有两个@Import注解实现，第一个批量注册Bean，第二个是扫描系统中所有spring.factories拿到配置类，根据@Condition 配置是否生效。</p><h2 id="Spring-事务传播机制"><a href="#Spring-事务传播机制" class="headerlink" title="Spring 事务传播机制"></a>Spring 事务传播机制</h2><p>Spring有4个事务机制，它们的区别体现在嵌套时的不同传播策略：<br>对于无事务，要么创建事务，要么不创建，要么抛出异常；<br>对于一个创建事务，有嵌套时加入策略，嵌套时挂起并新建事务，嵌套时挂起并非事务运行，嵌套时抛出异常，嵌套时savePoint机制。</p><h2 id="Mybatis-原理"><a href="#Mybatis-原理" class="headerlink" title="Mybatis 原理"></a>Mybatis 原理</h2><p>读取mybatis-config,xml配置文件，加载Mapper.xml映射文件，里面放置了很多SQL语句，然后通过构造一个单例的会话工厂SqlSessionFactory，开启一个会话对象SqlSession，会话有API执行SQL语句，通过执行器Executor真正去与数据库通信，输入和查询结果通过MappedStatement交互。</p><h2 id="Q：Spring-用到了哪些设计模式？"><a href="#Q：Spring-用到了哪些设计模式？" class="headerlink" title="Q：Spring 用到了哪些设计模式？"></a>Q：Spring 用到了哪些设计模式？</h2><p>1、简单工厂模式：<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p><p>2、工厂方法模式：<code>FactoryBean</code>就是典型的工厂方法模式。spring在使用<code>getBean()</code>调用获得该bean时，会自动调用该bean的<code>getObject()</code>方法。每个 Bean 都会对应一个 <code>FactoryBean</code>，如 <code>SqlSessionFactory</code> 对应 <code>SqlSessionFactoryBean</code>。</p><p>3、单例模式：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p><p>4、适配器模式：SpringMVC中的适配器<code>HandlerAdatper</code>。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p><p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 <code>HandlerAdapter</code> 实现类，当请求过来，SpringMVC会调用<code>getHandler()</code>获取相应的Controller，然后获取该Controller对应的 <code>HandlerAdapter</code>，最后调用<code>HandlerAdapter</code>的<code>handle()</code>方法处理请求，实际上调用的是Controller的<code>handleRequest()</code>。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p><p>常用的处理器适配器：<code>SimpleControllerHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>，<code>AnnotationMethodHandlerAdapter</code>。</p><p>5、代理模式：spring 的 aop 使用了动态代理，有两种方式<code>JdkDynamicAopProxy</code>和<code>Cglib2AopProxy</code>。</p><p>6、观察者模式：spring 中 observer 模式常用的地方是 listener 的实现，如<code>ApplicationListener</code>。</p><p>7、模板模式： Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等，就使用到了模板模式。</p><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><p>构造器注入，构造器注入会先初始化其依赖对象，而set注入是后初始化其依赖对象；</p><p>字段注入</p><p>Setter注入</p><p>@Autowired是Spring的注解，Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常；@Resource 是JDK1.6支持的注解，默认按照名称(Byname)进行装配，而@Autowired还要结合@Qualifier注解来使用，且@Resource是jdk的注释，可与Spring解耦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q：-IOC-和-AOP&quot;&gt;&lt;a href=&quot;#Q：-IOC-和-AOP&quot; class=&quot;headerlink&quot; title=&quot;Q： IOC 和 AOP&quot;&gt;&lt;/a&gt;Q： IOC 和 AOP&lt;/h2&gt;&lt;p&gt;spring 要控制和管理bean，就要从bean的配置，实</summary>
      
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
    <category term="Spring" scheme="https://missionodd.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面经| 项目面-小公司毕业3年</title>
    <link href="https://missionodd.github.io/2022/01/13/10k-interview-skills/"/>
    <id>https://missionodd.github.io/2022/01/13/10k-interview-skills/</id>
    <published>2022-01-13T07:50:37.000Z</published>
    <updated>2022-03-16T16:35:29.708Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="129d2f5ebb17ed1049f913c43f76e7ab09f1561b3c8f20681069011c8bd90174">b80e90f5a47de8d40219e41b80d8f3027f3fe6fc21ea9ef9280dbddf772e0600d706e4f9bc0638d0cd409acde6a24d05653ad036b1c255319e6134754f781072884eb6f66d68a6fbba079f120691df6837798b1cbdaac7895f076a23a670608f3637ffa4594d614d844421b375dc455710afaaff6180a2fad90952452d1ed2d719fda93612c5b9ee97f767be7ff91888115dd6df388e7491712125ece10265397bcb3fe5f69a2894714ca9e9c792dff94ee8aca205f5febec1426e9969f6ab5a9ba5f30c2c78c4a4b6b8c60e6e0ce28e42830bed926ca01c778adbc289f04c5d08f42dd215953d9f2571e547b02549bff104aeeaf1eacb5727f7eb29f1810aba2ba2e7611782fdad14b6c3de34a10838f169ef35cc959ade9dbbce4f5598cd6cde5ffb52f5a2fa720d0caf569ad9d0b151df346304918359eb8cc00c646254cd2d904022e52bda958dafb169c86f9ba57ca92c4a439f6f40a0f12ac95d9b022595da1e406359df39a1c613ea3f6bfa90244f2c2d607d3ca18afc2e65bc6f380e56ab53824b7974679794e2c0656731701ccfc937b6ac74d00ee832a343658f25e918c8f04fd5eaeddc4d06cfa4e8d5c180113b23bf42b70736698cfe11693deda40f059f11b5c36b582f66b37cdd8ec865b308615680888f6b56479f84bee2fd75d2f07bb474996bc25a68a906786a1e664dd749682a116e7d8563838dba6f83593bd102e451c052ab47500fa9d95c4a90751e248dfda25766de47b8199c781ad8d0730bedb42086c107f0927919a810f97676daac8244164c6c645d8a944acc6b4551093e393ac2c9724eb4370350b56a6a10f7616934e1c5a9f5ae000e70798b0f2c306774b3ad856e3b6b6f7d197fdc3ee7de8e78eed74673fce036f8efe504d91f3e17899f01e641918cb72d3348288bb99744e1d9f3ca86a1a8c52975796a3e8cf86eea0074a981d36a88e354b94948d5754991c2ba3350b427f6547de90cbd75d328cf57bee74c62212c7e32ecf736c7d6c48f9ba78f1b50e1ee5537594df5b0230cbc9499bc9d6fa74d723e6cace73911e7ce6186a9b6ed0f3f501af2e112415656cdb018364c40319ce3ca95e75e8f35fe082f7ee45c63692d6a056f35a219712441c1ca81edb622b176d9980fb92effa6082fa15b16773008b1de772d3ec6f9113c9b4a7723f07c3f305621deeb7042d33dd7055dd894026c2230d351ca7621bdd6f4b7262121fa5cefd4b8d755aa795bfcd1d4aba46ac543f248ffc4e980f81864193fafa6ddb45a4f0866d6ff35d40ad4203cb1bbf0e31dde299219392ce9f0cb120c24fd23dc731df29c276e269091a30ad7873102f289b5c6bc2fdde0c8011a985ae2db2b4949b7b5c117c03bc2c1b217754e109a330b97b40ba9f9f75ed44b375614a84811af0ae6535d63efbe60c0bc589e5cbfec7d2f922aff3f9944db75385194183bf3c38c8817e4eaa0e1ba18542b20e3e37343ecc47419c5ccd97e0a4419c0347ed15e3c6b575699bc0901ba07f074050b4d7ab3eaf738ba6578dca6130bc89b54124e8372ae7bd2a950071ceb178e21e5e6642eb348f4be86acdd21a17173cd560c65246a971441561e3a424201dc22c0e5fe594cb556640d8c4a9c4d8a0de5488d755180260a50770fa35ecfbcc0485ea8caf4d098be4f0bdfc17d3dd82d764f18136ec90478b61932e66de1f9540d2a0d7ee0a67a30760b37dc1b5a8d288130f2e957b4ea849ffcb5396926ddcf3ca896533217511b544312dccceeb7d794c8df870040ed25e55d970d4f2e85342c63e075c8f41df321153699f3ad842faa58ed3c92e7b776a4735ca0c2c13af775770e6937bc240cada6a932ec896e9d5dd55a3906253e5073ee30166152a632ef060fa37b3f4ed0a29e7e774c146546b0ce07768a3efbc556eb05358d9871662251a01887fd67c36f90fd3cb735d7555890b3d7e4c56f2dbea2af35cbe7211e1724c23e7caf6870ab60834691e2d02d0269341ac6edf0fcca00cbc02f7a395e896764e3a8b056ad87d09308bcd69e96704de5443515cdc916fd2256d2f7b05937853e98fe48dca48c211f77dcc815fb2ee5cee029ab8a659151b8fe7d9dd368f1f2ef2e3d602e1c8259ae8074e6889acfe1a9c3098298ba6d90bbfa2950e1909a7f722dafd95685ecf462bd1f56f2fd8a9b3bc812923e6bfce378eed589b09c8d5f9eaad554013841d6873ba829e4e649a49451ed60a8d63e882d680ea24030a9b386a65885e1679f928f491c0d8bcb33b74c6b6e58252d4de17cc9f99da1818c154e1c01c9d11d55c82097e91de831fecf7f22d4fe13ab918f18cd646d8fcacc94852e392e5028b0eb073bad7757d29fd76ab9244608c2f85c949c72424e546b6fd4c7dbef4eb9fdf5ca5a60f1158ac79242354bd89a7eecc1f82771bd79ec059e73bd35110207bb52a3db0554b5ab76301b36b37e94642d3d1b47b92b224a53c18b9ef3659f2aebffb1903f926e0bc849f3c234377e6f11284885b9ad50272925775f4473f0397dc292ce3eb58c8cb2e48410a34fbfaa26392ea00fa27485fffb8d3b2d5605ee2cd0fa3537db4f608872f4f870e4d6726f3a0478615e732b3ab7b7b5b30ba73130b405f446c1bb19c576fcc9f7e06ca413ac9599ca4576a663be08ae8f81018aa03ec99eb5a2558e5fbbe70311cb1796251a53764195d778667fa545f2f5069165483a69f69e6dc237d92c5babd9b9bd4cbb437b71bac761700b102ea60777aa51279e91c53536e81d80b32e213e09ea914fd356a3fd3b798b711887166a26f373ce4dd01d643a970e1c46fe4d8e612087c898152566ca9a7976d2bda7566c20f78cb00d5662c03fc9a6e2e3afe8cd947e9a657a7d0dc101f8cdbbcdb3f9ce4a29313d2e1cbd0cbc099a0fbf6ce9f6292b51f7f779d27caf98de323ab47fa97408ed16d8e374ff0e8e76099c023aa79226a03b23e0461f66f214382cba051680cc28b54cfc9d1399cc69899265074ffe2b4aa7377a531302c88d756b5b1ce8864e3bd9091a39d5ccd3f9237b5c640c0d6901999ac1601eac1a0a097593098f136251a7c9c2bdf4045cf2dc0e1c380cdf9c48c1171ecc3e7144e60590fae207fa679e9e9080630d812242e6ed2c37534720f7f3e3908b09e2ddc93183159a5d4a3a1ca5a4f5d31d9f47cb49ee457e656dbd5230cbe45c7cbbe74830a41f34f9d8ab6881f0f1eace311b2ff46db8edc73cbefaa41d794bf292ee0eb16b6c80f55febaf81629a428e777c9c493c204d2877f1b85ceff15fb65ee1a5e67a5d9a4c1c85d45ab56909d1ef3e8c51c11689482f9f70ace7a6674a8c11d3309ef7b0ab382840399289333a8c0eba65a907095c2b7a511b81697b2eab897d1d141dca743608581338ec9e7be188f4a1543a1813e7870ee95c2313b21942d0e2d571e4f286c061e4621812fc94709a438e493e98e8a9311e424b12c8f9ecce45993f09bcba784ee9748d93ddf4a583f09ec8bdd5ffdb63807640e818e90f28f5b71b911379b068f15706850b8b8c115a41c9256b811917f74d720d1312b087b09be5504c22a8bbc091cb1b2f4c6b9dcaaf22318d0f27b137571dd2ece6b27e7222f58d0334379d4d541803c57a42281b572f27673dc67847fe58690624c4b2cef341d3d87b2a237c3865faa9e015b604172341f62d4eba8edce2e496414fd59b7ec73eb852e77ff5516b15f7ec37ee5c3230f79cdb3d699815af22f676c3d0d28dd3c242778c5e8ea091ab094711642a6fe1887d9743d8890037f736de81582ac8ccb97c8dd46756e488233814264cfd2ee59fb5ccaeada988f055fe5c7cefe6d48182ee8b28540d003087f1b5aa8659332100c016f1c6f620bcf25881ecf4b45daab72b30391f451d519bae66fd091037f162f1aeaf21ae01cb6171cd390aa04de77c1de386c80ebc2a49f20416f1e7dcfbf26e699a420f9858b358dd20aee6846492638d7306cac3e56f4a03e6a6bd8a87b659eed1fe91fbdfb310054e5147752a639f207d9db1ca33f1b0b87c69f73ca0e7233d7a05df5e2e043b3be67e2f885149ff9061e8cec964ee79f596e9956b54544b41d54aff9d431be40973f36e9fdee1ff3e44677fb66f3c9936663d2c5c04684310ea9bd614ec5f8c297bd373e7cf5b8a000652fab92f41388d51d96944843e6d1d606c128528b2101184fe873ab199fdf72e989e1a47d2efc1be64907b6f849dc241e95667662d7c07f7bb504cca1a86249d7bb8d10aa7f496c820bd7e210956e45ee436f0d573a48ae366c765e4a832523564e554adf64f3c95b13c9b4496f99e905b861bf356f26305262736829ba6162200f2258a1d40f02f9e8484152c952e31ba8d8ee71cf80324cf065f1161317107cde36ded70a72a5e577539999525fb687416b89665019f753d5525f05cd4c6ea56a560b949ccf96316408d32a6805b11110dbb44da0a038d5fd531eb6a6b003d656d4265c1a64f55be08827e5a0d3e385639e2d3f41c472c89328392c170556a2e9de6a2e6755edd69ab9bd6e0a9132ad5e428d6160c13fb2b3bae70495ba2abf3da704ec8bd73ce7b091dff338d2358e5a5c72471ba8dc998809bc0de1ab07f339333ca42b57632686ed0054dd80d33d81643bb55ff438b801fd0b02aaf6ff3b111fa41534a8a34261d4c2966ae9c2b7454834dddf2d85423ca00f2f1df9f2da0284a56ad6d77c57234980fbbe16ea664b313031a8170d58b91bba6ad7181056eec224fe70129bdb7bc88689b2d0f06d87adaf8d11a2284a0189d2fd09d5706f364b2d5fdef7114b905fe7cb62bcc9f179e4d675d1f22797548f39a86e34837c55bbe5bd94ba964273b5745fc2fb9487b6c5b8b0effa3ce324ca062025de1b7ae4fa4568cf90a8b3a2c4b98b12232fbefd93b7ab23cbebb1484392f1b0fbbd282976a18a37c8235c5e71a9c4253d0963be522b249200ca43887447e46a5dda140b997ab7c7687b7d45d5bd67cbb1d9b69e969345e3fd7ef6ea649e24f869b06bae9a8ff9bdb88f72988df3154771dd5d924eaa85664ad057669b8940b39a7df3a894c433cf73a6e40e5f7479068c971cc5980eb8e649fa7679c5095f57742a8a04a06f557a1e6664cf89d8e12479c0ef20c9e244dfefd7fab74a033c9c26a632d165bb4352e9c19528acff248b6605ebd862810a8077003004ef3cf601f719c95e11782aa805cfc783ddc7b5275d24c696fca96b30e3f131e1a7d72d1fb37909c05bdf0af84e3222b36eca5ac09c847deba8fbd80e1e11d3dca8bcf03398ee514de211ef4ef9ca9278c9699b340f511b2221ddbea7773326f7ce4b71b165fdb8455502de9b1cf863bf3a6b60c5b547f1f60eed7117ed41f352d9eb28102c6d7852d640435e6aae2a5a6e58da503cc854e43b8ec02de17951c91ea637455f1069265771eb78117018f049a29d29e57b4845bc48f2dbf57970687d6b8d9a92911d20a276e4d0769e302b54a0cce110aa35bfcd5540abc8db0fdd01945020da6709bc07097a33835fb7a17a319e2a5e00c97b55d921afb5e5d8379c1ff8931a02ae081bf1c9719a5e66c20b030ff87dcead2c3f8b531197eafbcd989b063c22b822f88cf0630706431cb627aa5c924cbd6b997aa5435d7cfd490ec44458bb8b18d71472dbcb2a76447be6e0ad38becf67ac797724e6256b72b39150a4845d81c4996bdc81e1b59acd5867106b04466beb68a933faaba256d39f0ddc056cd6f64e01f127dad7901321d0ce823bb26b2220198546c0182dc2cad8709752f810719836c17b41a01e110f9135d6723bf8a7fb4139e30db4c2396d3b94c738b9af8a8b1ac3d15dd6e374917214a56ae841ee5ddb3f7e26662c5ad31ed0978d405881a366e3fba2b4c94af8eceaa7b3653c973e1cfea21250be2fa6e52ccdfc132b6464f0ede18bed42fbad9832ecf99ff289e058bfc3bed733d88768aa8a418dcf6e25aef9f2714c65cdf40a452688c07c8af9d2e1fe637f9084ac93b107fb54093aa606bffc3fc4c32da474a42d6de3ec15105df3752e912f28a79add8c86199e0e8b05d2c04170ac1715c0ac97c1fe19d2146ec4ab13654bb656ae0f25fc469d9e8dc2ba66590dc882d12457072d5d76465046f833f36ca1c38dd8be4b1c7ff07cf288f803aaf65040e2ed66f3c3732d2cc2c7ab5679d7a2a65e8d4b627e85c36cc51c6e1d77f098d4fff5972b92b2e8c61ee99098e87255539c0ee3ba16221ecbcdd7f15df2364e0e69ccd1bb4f32536467be720802bb6ffae0a6ec1265ef7fa0eb2028bb0a2c6633c09f46dabbba3104b87f35dbffdbf65a5dd8dd9f296a03ff58eaadffe4e7a981c5ce2e081324bf1e7c57281ccec2ee10ed818340cccc067bbfdd47c586e8c4ef25ad9f868b846aabda4482726954e97cb6968f381ab743c03e9ff5cb68baf26f318d44fb1402d0d7d548eed72a4156807263c6e2b5c72739e3c805ca20dcb657a38ec87fb31149c9ecba045d4136e0f8d97f3084225b149d48677864f3358d3cf4c64aa2e0ce39ecde42fb1ac7a78c1c272426a1c79fc94f7190bc0962900f7bad8c926460f866149dcf64e4cc5b2eb0e4c9806b2d7227569af4e346830706371881d79dbba8ecead362cf6a3a376045237d68de09f13783ed624aa76f675a1e8fa3b94697d289e7eeb35877feb3f18e49c6be6bc6d5c474cd33f6cc911e1df911d10693ff9c3078a3c734a00dfbb2b0fc6145de0e9aaca39be2c9f8355771a8280afa10492a1acc55cf5c7cbd83cca2ec468d56007db08744339122241ead42b31295be02ca380915e506e2522ee9bf337d879d6d14cf104ce6db83f9924f93046445acc304f8132a633669bf8407eb662d0b75ae88b6991e36c29270cc9bd3895a803f438cded17e64a3ab5658854f2bbb374fd5ca306662930f000e16b52bc58743599d2b0c58ffba6635fefae99e41ac8c894a2b4faefc3ce60c6450338e6e833af415c1a32b9ec4f3a41f6ed1993a50ba8d85c48a603645af4e1d8bd2e9730f2e4f2c53f9e789101685987d19bd1f83b9fa67853ce00a0373c1f6a1efdabcd47a0394b9cc2f6678cd88c6ea0515c82acd7deaf1654451a3045e529adf0486a24a3382ead5177760b1a6acbae9cbedb21cf871d6c51f87a1af3f04b212f17ae7a2478d4c1bc8a0aa9c501f7639e010cbdb1e871a30b7b2d2f8cc0574c9002e3bc8ae466869123718f9078565b622344ce16c428ea5cbb99372418f0dfd44f16d1652aa4509fbee396573ea3a33cfb1f87de397eab7b22edfeeb54787c35e3016780c190b92ad1fa9c4e9ab9560a9391130268ec88c8e3bca1cb5118323e588e21c2e53496c5fcafa25732419e0b1e26ba79f7dc7ee2a84d9d6373a2d92e28e22784038efddbf1e7fc8af75d828a5f076b38ceab1bd6f5c322de08a8a496cd030cbeb35fd1fa6ca96f068d1e338d9fcc24d7b04741cbdbecd2e016ec7720efa56c4f0a1422b8eb4530f9efa39a3bcaa092f16c80692f98b84f73bcb9916c412f210c9fad5fbdb440de2237a60fbc285be4747ece5fa9e34225986f368cbab5f3e07e89601f6b9c6510bdf37f619e909e03e5aaec2959e27ff0911eab0793bdce645e5f78fa8130e92d75585d43c85717cd6b5a4645885e2e6b092d6499a44db620c774e692fdb85422589029fce68aed9993c79b92c0a39b29af964e0bb5669b8b2631b32e290047a7ef939722f2873597b5e7ba6c2ff3851d918c873a6aac3e2a65e8bc625995ed963f4159fe3e71044bcad1696b69c5fa2639f628eeab491694fb2d006b2dd0e710db262f5e8fde82df0efdcab6b7ed20e9cddc3ec57e3cd300d5217c3f7470489245f275e16af7f2713a6e714e110c63da75b990a08f1caa8a716d448410e89c99bc62934cd4f0d04ec936b0e82cc1ed848fda11135c819f9aec62399b7b7d493ec0a54abacf7a488b45a12b36a487f1587e201f556ad1f61540c3807b0c604b79bb47de5794215d2e9c34c0a714fe6b3cecb78f9d458b5670402ca38ffc6e4ef64b9dbc2ca2515ff84edd30cf4b26b78a40149973c6b9507987715579145a2d88a4f2906b42c5dd1648965e44492fbd5d1ed1f0f7084c09574cae8e210be9edfbe724b9ca315a308edba57fa7098161aac04025a07ba38f43c477d1091545922a03cdf3ac7c2686a61e43d6f4dd3d8e3667615d41fe9f103929f426920171bb638e4fbd102308455cd3527064e1943d8ede9ffe7c6b159202ede690a8eb803a193299ad9389cb0d2bcce9eda775165036ed371bfe4fa81fa3e112f54c955f834e6963bf2ba75904124cd3f32532c395d4da54225792bd4ccfd53db58b6fbb8a0ae98e886129d276ae5c87f396d9ac70f0428d3e2f3439740c2f1874ef9aa0ae156662b47b76f37bf69f97d66f6e2a2901f0ba79bdf5c29a073b97271a2b3226fd66ed33a065595119c0119db36427b081dc32517c960722cc663cc1bba4d4764270c410f2093157f92f663e0d1a950e21179fac1e29789bf9ec2f7c06f8edf01814e239420c14b9ec72cabcc8598debd341891a004b805df06c86e248d429b8abf5ecd316471485aec5e6535e43c5bbc1307f472cb98d45c83189da249170d2cb236efd6b573420b614836c563fa6dd8d79fdd4fbddc96a19df28865a213cdcf1cafa1bdf479bf4df90b343f2deb9670d93cdc44923e006faa900681b9d519ad166e925e9cc8b63069370598a1a1907fef857f69c8f6620b8fc765b3fad6efec67939964a953fa540853b24a5e747143d9eaf20303a803079659aac8231b645e00e7db5c61778c9c4923f70131d7fc0cdb45006ce5e83553bd55bd53c79560daeaec142f9863558d1e8aa065e972483b2601ccfbccba744cb29c61d2d5e2508fb0f59dbe8595b9b97db252b0a877eac02429d79375f662ffb854e39faa92c2cbf8f939ce931fddd612203b9e7dcdcd648f060fdd12c720377257ad6cbdb302c0a09e634087f39c142605a4fd4e23c8bfd552bf83ea2e1295feeb3ba37fe5b2dc66e5f0db367886859335d8aa391645f909a75ece9b9d14917bcf66f9e083004e3abc7af9a66500f6897377c8bfb35cd9c7609755b29f086b3a70436f14e862d3a092810de04b66214f7d5c79b3f0b48b614b6d9bf9e7f6258b46a38d69d79a334f12f472100bf7a6a4f0a8c9bd7479fd59f9442628d6bf4282b20630aa6f8d8ba029f101b75e71ab81538319b69c3f9b3cd9596e8b9079d5fe5f681564cce3b9221d7ef010732db69671a89adfbfbcb5d98062968043bfa17a8b386a3954ce5222c79ff5da72cb58aa08cb3a723b17076a6132ffcd54718361fa194bd89de208bd40aba304710c0ae6ac923a2c31c55f2ef7f8e6650897ebf916d21f472b5836086abcea87d67d908813ecf5696671a1b8840bf26033475dca033959ea9b0950e8ea0361a36f52c62928bf09e199fb8a8e05da589cdf16ccea983183a7f3d70b5c794bfba05715223112a02240d45cb5db092a761634b694b651a0aad60e873399e4df5617fb03a6ba34606678f0c4907b34534c2fd0f19945a175bd0a2aee8528ad58c03571ddb5484682a75dfc4ad81b2ba14bfc04f2a489c8f03b5f33cbaee6a0fa6642560889ba931144a2b1b4708c0628200417ad70de37d26269aed9184c5d374e80a6625e3f18050ac0d6c4d632489a1369188ff45d206a3f28fcb07eb8ec8602c43aa1a3bf75a4229c060ec05e9f6e1ff6cc29e23cb3c12b86bac8dd3d84322a4999eae128a4c3154954063602fb4dd78e06a125fbed69af142bed4942367738e2b516e55b62af26375a660b30ce51f48491d9c134be3b2adf27d8d53026bc7df2e32dd9316fd6bdd60b8fa9d22e34ea27612316886574a1b4ed014946b21aaf7fa7e2fa85d1ba9fcc9d4ac9bdd22aa8be1e3564060824a5bd9396ad4348e5bec05da490b8e6ff795912b1be630a4c4245e3f6255ab2603dde527d1e868105878f79464082b0a357808d4e228311e2ea81512558b623d0b73eef604e73f164ce942fa8d78ab422d53f8a79901801cfa65e864b53ff138bc261315ae7a600d4f0c765e96d0bec878424babcce297ab4f46c2fac96e11d9b116cb2f6fcad246d3b088a6c6a4a5c21c4855e85dd5cf8a9dd2c45df3c12db95823bdd537627a6ae42b5baf085c730a33d6acd0fe56561e71ebb259769e60285c91b7e72c37d9a3811e8bf20ac12fd72121893d038b728e4c1856df56d7dde88a85a2cd4b6e0c303708f68236282be2d6e0145939e6b373b4c33b2ffc2333e1c16b86cd13602ec004fb5d59ad29d43b575ed83d791eea24399f54c7ea286b0cc8db945578f039c6936bb01005eeaeb3856654864cbc809c8ea056ed62e96634223f06a314411e0b7d925539fb1eff304904f562abefeba71e2316696a3842274dc5c311163edee566fa7cc6985bf5695a9c76c4a998cf7472b324a007b0acfc267897ddf5279289c2f700400301479072ada41e5f17fc60aca54a9832e87f6e2262ecc670d4f73949322b0ffb237ab5f31c54c2ab9c66fff05367666bd3ca4412495f43ccfb7855f82952bda9b6b2ada5c9fa65726ebf4b7d8e909208464cf5099f11525e543abfd0b82ef60ff0114d103233d24abd73bd1ce1cdf9acac8eb627731a2a87e2a4f523803d2b9cf336c6d62ddd0e143ee38a2c224a5ea6126dbb28a23fe1b023d8e7184f8113f5a89d036a80180aa3ee05d7920523c8b606e91a3e2d77e988cc32215c2c83496bf38054355fafc4bf36305c490678f598d187dd12d1b2edba623c89b1a1f1a4d5d7c6d3d4796ab19747595eaaba16a64ca5148c211d055ca89d55c7863bf9b0398cf19ed9eb5ef0f5159ffa9c5986a343ddecca993cc3e48198a8e364762bdd9dfd55a58c092697d983e3a0278713ea8415d0802aab1cb43dd8cba1d0570f60a4a71c330605d7c1eb7b40cf3adc299a74c7c53d02ab716109f46f1178dda6971e518fab8b6e7b0053fcac617be2d522c00e5660aab081a0f9f461c2d5326d8fc7b3aecb26882ecf1bab0f7b5fe2d0dfe6ac3c0c9fda742b669a68d49f824d0172e088ca8a94bcec6cbdb33fdb05d5d41ca3ed34b4b48dc55d72061aee8f3962da7e8c06a8a7315c17a893a80e4f9ee580fda8801905b3d3fa64d9bd20ee3fe0bc75acad94bd357048b6dfbd65fc894a54e2a801b3b86c1970ac70dd46eafdde4e86320a6641f5c3fb35d833e3e36c5fe7e8d8526a2b5e3f21ad40ac1f9682c0bb318579b1ee49488757a1f3b72531e3c25bc78412cce7ee885f88e36435fe10cdc6330bcc2410bb6f0647f8a6f4b9c092afef84a317ff384291bb596b979c6bc456eb14b591e8e01f0e6302283c8e10353b1372e885601e34b90d8633409115cd417ef9a85b11e8bc4a6d09e83f67f4706e211add6593bc55777b401a0002e6cc86d47555190b7a4dbb5a96641f3d0fc29f8653c7bf77f09c244586693def91a8863a46afef8d9271b3646f2b75ffc45c964909cc9cf3f1aa9312025ca63e8499f52734bd82b8e7a5c1048c2d7a7726c9d376976a769f4a01bcee09567c218aa1b0b13377e86a17a16f3692589bd7a467928f13c0e1bf92172d6f58d1c3c9f71f132a1074e96e3fe1be5b7e9d7ae85080bddc60a5131dad5ec062ea4f576714159c42bbfe47fe573883d0a3db9d30a1ffffe73a32021ca671b8d09083b3b0510efa2b2a03b29f6ee77c9fcab4c1e302a12d3bcef3bfa031f6837c71bf812101245141f3b8c6906ea6b0b585db896b6da515af895592b161a7c13eb1ac0de976d89e74407baac1481c952d9a52dd23a4ba95ef29845029829549cced7f087bd524e5196f02e44955d6f60b8d2f2a09f052656eb98355ad6910ae11ae5b36af66f2789d3029adc1e6449cb84f5a875df82bd9c01b7f86e0da467cc67d499f19af25a0d280707ee66d79d26170527c94575eb91f7251f5720de1eba4ba6da020bcc3060d8e1b20f53f5bd9e950e436d41b9f93ff987474898743d4427e8a6d99fdee8a8ece6d2f2983d70813615d88b3588e29b5ca4ffbbdf287dfd2e1bb6b0ac95aa8fdcd995b0d4b093e186ba490f02c86d57be205d6df6f0143deec090b1b8c91f41f584708ac3f203ae4adc81902c96cab85621b33ec5a9aac5829166b942a2db438f9b5c3799365cfae8145551e6170e3dbb0c0265273e20af5248d7d9c932feaa622f3af8adc812749e3b52524bf200ff85b994701500254c733aab74ff3998889a3ffd49e30448b8145fdf9aa6d72fe9cbb6bc21979a5c83fe09aab2a917e52a018ec2f7a5535597a10f8cef27f1df9c4265f08b32a08a39a2618f1091ec10f7d16092ea34334ef289eb244d3173c7820e4867c9e2d1fbae87a5d9ea5294df72827c035f8667fb36eee19108ff7e3583bef3f29dd8b898f49851014c134745f9d58481ddc2ee41aecc8b5b5f4374df8643043cd1288d0c3782d779857290b19dcaa40a0e8a38f692e2a28a3fc2090115358be54fcf73df4c7613724d7aad478a6d8245fc20a0dc109318d775e8771007fa857c24ed28854522fdd583d04ff9279fd5b10d2b0f423a0c18b9ff02bf6118ea6d934105e4db5666b5e30438022cc6126182458f6dd6acd86012c9bffed340a771d013d3657bbc62fc00127164c2d29a3376c74028d1a8ddf03dfa695b04167f2a61e02b704f1324e2f4ddd980fc5a936518cf0445d4c49e2e918e1b8c603fa186c50c8c986ae2c89c72751c26bb88bd983d22b5b3b3eea1b8fa090f4c65f07b4e549745387665ad65817c40aba3b58fe763af3e97848d85de0c1905e7c34378bd23e7c4d5fee45568c67882db5fa3b430d13b2edbb3600ba8a4178f3237a805c78f02520fc27120f3569193f46d79fe929d6a6649e125e3bc1fc6e7bfa43db748895e9f66b4f788b049667f6962036e196fcfc17f396e98552a3ace05202085ca4aff2ecd00043fdcae95c0233d62332ddaedb8ba7f8dbf84da861072cad7c5b3108e16517245e205a01b2d3938c21aa6fbae92391613210527815ee082b97c2deac43f996bbffa590b25ee4b8f0ddbdad88662273135c48d8e32ccba464ecc67e8db0af6f60de16cdcf6d053661f8278c3a832889acc7546297f97af0236cf0cd1350b7964a1500f5d559224831fdc25a50f3c64d515f390ba8dfe3df403a980d3492f02cb1ef4fd497d2923b4bd5d8bfc77ba038bac63d5b0dfa109652c77b090be8132c8ae82bdd759d8837a43ae7955a89184274aae476b83d8cb8b159096be0a2424ca308611eb5df923accca4c30fbfccf6a2b8dd10b225b0c9f8ecff0d9f7fdb35c20df611862fa055740d45ced977234e06efe70689f2ff30a20ce32722131c0b6d5c747c0a711d9d1e5075824d5432d1cbba2905a29a796f13bfd852113511955a662f576e52fdbed823480ce564c0ec346517f2c81dee2c170de455648261bb7332de61db5552aa046e2672140038055649df3a4bfa32771cc477cef623a165a945033d7ba5d7ddcf472b15eb44b3929e1d57190dd000dcad4d1443bb4aa24f2a73556aa827b5c138008d8e16c392904dc189547412c38bc27e2748f5e615e6878449ae0b3ef78aa3dfae34509c9bbd450c1044d97f79ea0243aebf47331755f7cb66a4e777e232677c16044c064fb9a2c8166d991ada0b046068f38a1980e0abeeb5fadc1c339fa905d1c43a6358f077d59a23e425b38f95c047ac56e5e04510b9cf1ef214c3152ee0dacc0a57f748e6b3f0afcf1df289b656f1c61535b6c0000bb81e7efc547b66d8cb7f068544130bd838a6fdcc5d7dd7ed99b6a009f7adb67f7936f881a139af342399523d6be106d5a1299ecc9649e9ce01d205a4c08aae2f699406f046a3a93c8ca07b68927482576ca85540a5794cd30887d1a953ee4ffac9db36f6dbccc151f2a4647a9eb9013643acf5dfea98becf1740ac4148aa49a2d3ed680809e40eaa0524feadd21dc88392b16521c6717b90793974febd9efd3fd3deb2f854fdcd6b00cbcadbbeb70d1cd2079a95de102900b4be1385340ae6740aa15f3a9efebeecc60eb880b457c840189152739721cd33841e5ad32103e3138ccdae148fef8b4baaf0c9c180745e19c96b31f7667d8bb387b39c19fe3b8b26ac774583ff59dc15510529fc56c23abf604babdf3fe26208fcfb4d9f4160e5f0cc5e8428d143e03a33106e4bdcef264f8cec1a81af02715e461d075e523794a43f99c3275384d3bd29edbb3a7560d7200b9e3784e2ea7073c748ecd77dd14ad2713fef66557b1bab0bf846034cd9b9320c85797335e71689ae09be8b583c21890273321cf9efdba8a433b6e68f8833b659a08a6de3cbf0c88f6cba4e9be9c7bcc79aa6f71b59f7fa0e36e2fa2b15fc3dcbf61f7961efc6501402707043b627ef84c5903576bb0d4f9f43e1cd082d09b544468fece28320d366a83f094bacfe971d0f14dae29a43358773e685a16980aeb853df3e66387824490450e6d1208207ca7a2b4e450f6404ba6c4676eb6cb17642dcdf9a3109371afa41038db358906cdf3d812aff0eaa89dd34dce3d55e8ff1ed3da30b87a850c8919f38b66b009b44a2230c3e76127574f313eafcd09788f767c3ee514b04707c21b98599c5d7a505559c36615e0c4c7cb4ce65feb83c35acd0f32fe274c5ea5531551cd9004cd2c7e9cc92d82d3f936301065298e0823b483d756f3dfd5e94086682e9f60a9216cbefac97792c824997898361f26310eb40b2b5c07c42a0108f3a5e7a261ece084a21e36a3e60dbe288cb64bd057d59acd2344d796eafe21d13ccf5fe2593f3bcc10f85bbef2d6c337ec9e1fc027fe5b7a4296bfc9e2474fc0e6bc1bbd09be9f3369e9092ea5180ab7d274bcf06af88b0a8c867d0c70b80e2722fa35a5723e7c1cd6032fcd162801001595cb395069ade35edd0f55cb2e817e4fc71fa408af20c4a4c2e6a035f1b889f87d292d0da283ce7727bb7ff7a78f08e18d95f79ebdd80a826d2d7421ecfb529e772189d1589508cc62feed867cf1cb31504ce9296467a5decfe87573fa7f0b54786de9c783359a54270d8ae4aa5ac9ca80adf063c302003089ba12225839e63f41ec58532302762ef081a14a94bb425d99b2fa1539a329fa8855172e433ce2a8b66e7a2757f12831ee557b39d68553ab99587aaa61e67e2a369a2526dbc70447a12c3120cc5a834fa2d8e3d374693b40bf1d1b1bd4688dbe23f9828260f04fdf79fd8a8a35ac69a1f9450a7c45608b1c9fef24d2bdf1208de1914989777cccf744e004187ac641271007004dd719be6cd345036dc06a6af43bb563b0c5342bfa87e0558862ed84c2220c0f7911f56af4fcbbe3d03627449d32d76e1554d3981f2b9a30324379d7b5d268058af5ddf9d00e40e3ececc953dee2dfbc02cf3e6107ac070f6c647f101c5d5f12af5c53dd7e3ef4ccb289b7927a165541d2a50c4d91f9a11919ec5683e3a15d3817a36628fca10873d7e2339b7ba4e90846cdf65ae803b6485046bd5a85a235d1e5c7b182baec8914137e4bd3f8d0880e4980067f78541622b6deb5b8534ceafe22721e694e7ef91e7758b0c6e11dba7159f0e03972da822ccb41bbfeba3c71885b827a12aef399894d0031bdaba4f97ff0c19d1d22030110fef2c8469ff5d558ae9b27f46a2863597734cce149e634a47d27380151a727b58c7ee11ba6c54c762fb7e6ca258cc00f8433a720b54082dd803cb682f1c8b847aa6a3e7bd3e2cb786f527ef8aac144caad6db26ebc4fc61b9519e72d2af61170f0ca8aff9b4402fe688cbf6925366e335c90358d2cadacd6046055ee50d5a96e21ec8771479c9731a39f762ef9a3e029c760b43d397d100f582a209e098ce397523170f9eba62cb9ad9e21a4eb0f7115976358fe3c86dcaf2f25e01a2da34c9c7aae000cf67f0b779045e4c1542e8725c8c2f9b9686c305c3d85bce88e4cbab059b8b46b05e68d557ab47c697c76f2647b7d86ed51daa3bf6147b545dbea4a70aeebc5fa8f055fb8440025405d3e36b53eeea926a826ee472097bc7e6f66349dbe45bff0be260105d2adf7c7efda40e5b4194f380371e9cdec2f5356b18881ef4487bebaf267a67efa325896d29979dbb221708604d40f38290625909a8dd0337704f0ddea223a2da9a6046d51d1154117051bb57cd0b6ab40254a37a8550d3f2f4e54d256c2752bf919c547b0c4601689c0615732874f8e13f3d02f502c57685c693130dae21df1f9ba9c509260a9df3eb3319dd14e9642775e4b3db33fc0c2fd23d2f8e6a405cc2b78400b690657583442f60b4d90b074d90f35fb586783c2af687abda4b950698d8c2a5e9636ee9dbc2d05d1768b1ecc23e10708af71c3273bb13df64eee8f2e8ce7c1211b305e7b91b882146e8d5a7ef912fe7efeb423f82866d4350e41b1105e9b907957763547b64384a581fda6c469f55a762f4b6561cff4005b84714b952d38375c596d5a86fd1fca6f60c0dea2d21b0ced4d42a33ae7f9488116f4195994675216d46e22cd86ea059c267fa1fe310c65bdd62d517d68a05c301648407e6652075a7c4486df7c2316935c1fc0184cc6e909616d503421c3c4414513f4dc83c0e9ca070e1ad75e5cbe8ad2756ca81d9632ff4ce01ca42f7d91cb707269693679de7ed72fc313970b4e036776cc20161ab389ba1b441fc3dff9e080c96f09c0f1fe4b2de76a1ff3c3495b4c8e3f96d980f8787f3f889d82f0adbe111c7f244b26a9344677e00d03769edee1cc7473536e908b12b7c76a7ea50711e4c82a2c64d7db977ed10c87d308cfa0ad1ef31597ba5e4b6073fc8b59a73b48a15eec45111d99d01ed5f9bec112f3d4b54903e315448be8e3fb2af745f055f26f7e824c197b9b5c8fded1e152d0de77f8dcafaf147b0d6bfdbb895d89dbf1d94139b11f71c0cc2a69f5d5522fb301f4636183165464d2ea2ec7de2d386d36e87439374d353eef4c81c3750108ff4c382e6338113b91196b481e14f2557f031335ee2eda8dca55915204da6aae9d4814e3ea7803ea963b37dc5df835e6be97d86343f8d83dda2f89cf948aea452344d6314509eb4b1661bd69b15bf2ccad64824c88b12c47ba17ef69d7af1f213cb71258d6af0e407f39edf3e9f7a723e48d1cf477172c5b8075a17e7ae99016f2dc175b43e9c55fe9ccffb978413727cdb50c1e8adc301e9cfcce73c77953637a7ac80a82dbf37957035be4fd24e9f7d2d9916faab59f602fbf1aff9b6c97b5a336d4ba707153300f0b275d80148c6c84f626a08cbc515e42f4b111ffe295835b81570e92f3f4c3459807f6b074d86ea0e55492deaee50aaadd5a2156f8cec1f536f51388bde8b743b60079fca80c2c31bd5503e456f91de906fbd08952dfabd5a96c16ba880dd7f1cfb1d11ff81af7082022ea83ce45eeb5a828c744454594118e60f6fe4b79b68f1859a50165d6d1b375e6d580f4666d9ee9861eae7e09e24f92260c6d85a0d473458fce9934d10bb49792c4c12a0a50509f9e21b03768bc0bb0021d0706397ed327eed9b77579b28fef9384c0899fa3175c450711adc87a2e4ac5eb3e4df7986b0a7440ef4f5ab0abfc2d4da5f0a29d1d336df636890c65a1189b74eb1f706dde98b5401d81cb88cbb0ed5ba6e2540a17f6fd0749862801c3f9719115e54f074f3c2058c89aa3a4ab3e77fced7ea6601c424a64d466b4921e8f6ae5533439369d6b70e31d60342eee1f5c2c38e5f0ceae97c1c25c7a46830a9197a5a7cf336c02d44aa6ee58fefe6cad627e626771c2874f25fff1efe84f88ca84b35901b1b0da5355998757b5db4510a8a28989064ad891ff15f2a230b1c0f5896425c01f1a59e9096cccbd1de7acd94cf2597c3ba74dffa757c6f2fbc09c4f1266e6f0153edeb0a24ba9769705a935ecead7c2090c69305378cda5852e51194238d567fee0750f9ea4548656b36dc45caa747418c6390a55547bede315797b03a8f4f51e32ef224669ce12eee4921fa89d9c87beece7a835df090228a8016eca94c3d6f1a7fe371ecfa80797fcdd29483c9b6c17a8e74c897e22ba699ad531232c3c163ad5b851bc4440847a8209d2cdb916e63094558b3358a526e49256e9047a587d7d119cb8257e6ef10de243c9bf0b82f8db1f92b2784a18d48587332f02183d45d91b85e832aff571913ca08f3f644d27ce8f9280c592b48be3e9a07b93ddbfb66763a004eb629c47dee7f0788304b112a653c2d898fe65087a71ac344b4be477e5c1f18c54a06e733bc50df5fb87b8c307399feac2c11587b891ae2025562796f2d9df6eb7df0f33c2aa18da9cdbac1a078fa510f6910881839cc11ef1ebbd2b86ceb211df98893615cadaf977b4359a7de3c7417db5d10a84cc00c45472d63af059973a882bc522d39953323d35143aa7642ab31f7fde10c27b1bdda43f36855071acfa8568fbf4699097e2e61d9b92783fe20a590eed394d24bc48e49d1dc48d70241ff2d406adea2055530e1e7ec03407ed07b2eb50cb9074d6bfcddf0cd773957893594ee94dc245dd300dd1e1ad571b4349aaca04527aa9fd7fdaffea9e263f907827a125e53b3edb1d6dca8720333bbd8549a310cd05502837235f065ee1967d4c18aa0c2d2390e96c9add11514fcdb682741a53eec1565496a2c1b4f9d38a446c3b6294ed25206be72df15add77623ffd9a70295483cb8c8e338ef39f47c2bebb6167e503e437602ff7770c1d810d193befd2b7ac26a78bcd4c140b354c3db1f214b896d461b97dade2804991b6e8eba63c6bba50f17731fff7191b41d176ffdf72d3e4b26e9950e0dec8f875a8c5294a9d5648d47670643305f54d5fade824de689df785685e057d5ef89edf0db10ca8c6dbb1ede12329e753d99e58652da9556d990b513378c1460a6c2093b319e4704085c2a0269e1ddb11fca71f2bffd781971a8ad1ed48589a8cb1641247edbabc4484674fb9009a3accf51dd68ccdd3e774a9f06289c0d6fd486daa0445f250f2d1fd2282013040275675873380d283de5d6d4add8ae4c4f187835564a09412fbd8208b1182f2d57df76e3f72ce82c57a88dec063d531cd748aa1fd51a697e07f5c20b52142cf5bd55d5e36258da17040e6cd879dc1e36666e96ed6ed29badf37f5c8a1a252519c527a85f2c9fcdc77c8e5efea738892ee6134843025b7823735435b5ff30a850b6a43f19b003673492a2fc27ce6059e786419ac5532b8e8d9b5c5223a6349780eeceff069b856d8373bd272464db5b155e62b02375f46e62693360fe997b921273bf4cda244a93cc4dccf7734a60d829df8cb46c000b234ff5add92673afa5625772aafcb2f43199c006d2d1655f1412982bb3252440fc75c86195b925831aee75b59c0349c3764e421495d287f7f67a1f0f0c0db9029356dd3929b93f32b5796422ad76d07d273fd677bd248c976b1352dd62260f6fd8e23a387c590e4760555f90210dad5e7aa95a7dce670227f3c9692eef22b7c77efcc40ce165a72f7e9ac10c6ea861383020783ec3170fa573c785930f42307dadd7675945fb03b47f2af1732ed472300f84081e9108cb977d6c25c301f30896193c9c6689eabd26a81c5bbdd3569d0a36af0f1f1f2cdbfce0a34f9d8dfa4d19c05f9dd4de39f83468386f0495a18e863d5fe684c6a29d5e01fe5eda35b88173bde62fc447a82f75cdf4d41d0ca92fe53d46440b5e0451047885a73f0eb44a40f6f4ed8410bfa291257f70643d792b5b97df91a788c5871d0d683aebc5abc9eb4e9bee1efc3eefbb8a0d7d8f34b55e60a16543783e75cbaaa2f26462a7b47929fa2436cf22fae341211602e41acc830b19bbec79ef898e93f03e7b974b833db607795060c1b2efe856f0c8990323c3e3777ec918fd3056733705bfd60603fc14096bdfb9b10fe6ccde918a5dbe8ef76c6a38fccec30afd7807443ac52e275638824c36ce44962da581899c534e7e8b465d8aee7957ddb99007109a5bd17beb0300c59299a3379f402751be61f465c5ae31b15e9723a05c73a4a0d7e9ea99543ff45ed377c607ad4928d96dc9315303a7fbc6033d8d327efdbc59e11c9d07d4868b00502faba39c1511f14defaa256459de7d94de8cb739cf09ea872ce8f41fee74830de980b89abaf6db93b99322f91ceb505a56626e0ea68dfa7ab6523eca83902f4a6b390ee74bd518f8c882f9afd274ba2e9d5d6777af1c3498e3d9c14786a7ed4ba06ee4b795a405ff3214d5641b20912d51b460821b0830e7b92f0319fcec6cbbeb4fc908681a54e693ad34782d4ad71a05240f53e42d06cc6de36d981a73592be2c830d960f374c5a83fca7c2ccd5ae32fad6984740c5a65288700c6f770e9cb937c989ebcf70a3d84933e8d8d8a799830b5c67e3b111fb74ce451cb9e5c18b42fa2246b8bc9cafd4cda4f46b6959b44ed4af24e7e57bc11d52e2050ddf91a888b869cf62ed00c818f79aa22b9e2d50caee4a7d7369e5d133c685ff0c97060043f976554617d196b9ab1ca7bf0c618c98933cf089bf09047b9da9818e94371be887ca6ad9d743abe8ec4bb9ee286091a50d8a69dc9e7cd34aabbcf356ba898287ecb16f7275989b0beaf073b5c5a19cf35daf47faf912e6dc5b22bb8465b4ca22a748d1b87d1ea4c1811c80c4fb53573be598cb117ef6a16605aaf4d79f2b6b77f7ae1c304f5051738185ce4f6ec4240d596f9c19a64a8a392f14d70666d05f596fb2a6b25a6c8c9a75c596dc7662de6938ea6a3d9d913bfda8d282dd7707184973e73692d9bea6c8eb812371947cb178e376578dbca57ae253d65278d6e99408f45d4b5d6f028825cbe29f42862127bba0eecb93e9d2f5a2449b7d6e126c6751295088e034478ff1c66503ecb417173ef5e724e941cc305cd008537f2fa9108e6ce3c0a2185ab59b1ec76df5b21b1244ff8742818ac990e28ddedd4b456cdc1c9f730ab6d1ebbd32e3bd73eef158773f3c3183d1f18eaf3e581ee1f790ef3b1aad64fb3ea1276f91532b57414f03c03f92aa2d22654c965040929e523213437c12bcf0399ed1ce108b0d509d4a55b6f3705954ed5b2019841d327a92a855b78cd641e60c10887dd3777b798dec3404dd8e5e0cd58406aa8bbae4f6ab62e4543d6485c445ffa032e33aa69009bf4b079a1cc2df0e74aeb9bce475105632ae945a1967b642581046b2bdbd3ec9bae4a2c1c8ad41f9800abe2f7e1e016d0a8707f41db1124540a0a019a321bb04956475aa6e9f8ab5c17e6ff1762ff3ee75a338d45f3828edd9ca8be9353d586d553f4bbc34cfd32f2b62bfcd582c8aeda4921bf579112cadcbc878b8b939e697a0986a53171f256024d3851326e427beb50b2c34e125791ad2250fbc5f03d356041e9c9e0b21bf94c9e1e30133ffad1e357de9662dc6e56af8a2849d6c14d98ad803240f2e6fd8982b19de9cc7edb629760af0650c478ffb486d615b5d2707987cf72c794b7eda3b595f4c2190436cb523734c027c707a1608f436130af33fa757b41d5a875cb9e82eaedf1bc34b504a2b8f6da5856a7e5c6e1aa33dda04bb7d65dc1bfc086610955bdcd67e516079f844bfa9026d745bd8fea0f7976ee968ba64ede56a76ab67fe26d1b7110266d96bf5a44f64237c4141fc91ad44d685bec69e5bb66191e8b9d8301ffd08a0acd33d65e5125fbc8d2ef2dfd62b69de2950db0f85bdd528d2bac4a665142716d7ed07ab3d3b34059a7112d4a4d1eac1c2442afff915a8d50f2c0a44ea5fb1724c82bb459f67e01e62cf443baaac1e617158c6d351319b8db4295262d024352372406457e2211d95d9a80b9310ad4f6b09c3e2c3ecb834df6d9f2f826c1c8e2b55108b0be7b90dadbd05c236c389d4ab7f6af84de92775104bcda0b91c6752d5a8d64e4a685c62762f667baf6a7276553889a846a8e3f150ae67009837876bebd7acfc806160c575458dafda90a48d6e8a2f33589defd4d3ce404ac51c2961e60f56f80e75a9eb59b5fb66c25e823bb919ed7c77dd174c43a703407780e8dc6ffad554e29633eadc43826cc78fea3248f64907dbf4fdde1a7480e9715411cc516c851f3e5b4836441a92bace3d0a73c4883e9f1e91bf93d498bad3af355bb8b3d922301b18412b443a8fed950e70fe583d8a4a42785e0f6c9aa0712bcfb3f249721dab7b64020a60eb495467d214c0e8dc487c538d0ccbe0bea2fcc631edf38c5ee38a3f7ab15a1f3fae9746b3a64cc63e130a2b2ebce4a403b783205951d8399c8c7b681710ada3bb0cefeec4baf9a9ec3919c8ead049c76e42e8619e360df947cfecde6ccb2d3619bf7de9c9dcef818aea9b72a6d34535518245e254e826a97d8f81a59f663ddab1f99f774a7b9e1011feaf60abac9cf48a9ab67be151b62d928e0c1420049e498d1d7d6e5bb0bed46980dac073b34acc5751d51a020c78f357081fec78a9b7913c968ee514ed277b2b6e639d76c04fa77630dc09fe9d0b10a065bd692e54806e266c09a29bb8d7a1280aff099ccb28b282f45e85939a596c4a2918f5d794bc60cdd9b4681bbdc92ae327f94478a661cbf2c14731ea7a79729832a91f3be9ce2302b8ae4696e49f19f1bcd04987b0fc35a1683a9f4876b0b4c8fad5f0bd74d144ae2376196b55d02d89696adaef5e6e0af9d85561d18eee1d3ee389e4ab64e6b4012dc8c40767d748619c251cf78598a3e5e0308ef22c87f5b85432a89a970bb0dacaf98df91178df9e8b23154d17e9e3131f6e01958c2889c6571530b8cb52463caa6a6b68625ca4ac90f3a3c98ca8e62685765c235e378228997c6d28c0a04e8b1a6165d731fe4315bdd92350176f8ad0dbb2007ae41167060d84063286350f689ae8a453f42a0e46fda95486ac71299c3fe7fe2a88e308ab309d9fe81dcedff99f7b8c85586492b0496f08e9b8506a086420a8a1453f6456bf54bccd48784a496531951a758d21001411480582b1c890665820bfb4ef00b37f37312d608b95e5a87607ac24f40a4333575c018d800e1bb96aa5ecbcd9d2ce507a5217e277cf56e1c2dc847d968706195aeef6c822dd04e342d667c3819417469cf75dba04d2ac313525408d96a41424eb5f13ae726a5531fbea1b9fdb7a608dca08a85c8b64aebfa7bc67a27a9ab21db6ed5ca8786f243ad76603da27a7c1a61998b1b1e12b7c6f3c3bb58d26ba00ba3b28985706d216ac7987176ee386ad1aca7e9959f9f3899843a56635b2f69c9a6c520441913b1b7c04977b9cdadfc3faf8114317aaada28c715a6bee61fb53183d191b30edcca97c80323bca0adcc429d290d85a483e7bbd54590c7e37977c96d09dbd372db14584cdf71563857e1a335e9509a667019eb78871ff378a28767701c823a6de6bf9fae54af0d3cf9a8cc85eb8a748be35f82e8e3a0ae4f8b21f29aca6aeaa45e45cc4dc45fa101643d7d1421f9750b644c7c7e8ae9318a5aa0458a8dde0a4251d61187646a7753058063151a99cdee920e6a043638abb1cef9c7d612007a2fcff9970577ef9a9e08ccf1dfb9c3cc04483d6e73bbf4d50bcd5ad01a7478881355a20ed3dc9990db838fcd1a715a7a104873ca5c2298f8e34f7f290c812219e7a25675d01552140cd3f46bdced1e8430093a9a103aad55f192252cad71de43648bac4d5916911d116c21b17153862e84d9041166714db6b2db8e8fab63aecbe96facef53b143798fb7aa26a838feba5c814a7e9d6e1e4a43d6f30bfb1a92a41d8504577133cc4cb59944c0fa42abee311a3b9180b53019c541d524b17b223a0fed60cc8fbbd41dbbdd9a5aabec9ee8800f4128927ba197fb2d5880c2782999490b160631ee8772872c8cbf4112065d5f6978307d8591fbf733deac21f1075a7e1199a755a9b1dd8e9c3638f22768cc7bd78d975822448a069296904d0f6142bbb97fa509311319161658e03892febbde4dbfc07f390fce9a35f189b596bea452651be87313353ac831019c542c9ceafe39c87ea610f4e28744f371346e661eb49af0151d865edfc4ac28e35e6c06a008e0122978f7a99588d9b75d13da68834286fe2d50aacffe8157dcc41d5594908402f9fd2d9468138e896dbda1945bb47cbcfd0ffea729af2d9fd1118a9db358c236e0d0cde490934a4041630a70ca801af8812659023f056d823748258e12c3a6048fd0eade1baad9a86c99954e79e8f5db28e928364efc34e55679e3f331c9710f354c927b6bfa47485a6cfe154a595cbb7624f5119f453024fddc92be069ef4cd41f72a390e93ccc7685d665d5c24c9d7b37fc475042562530bff5153f3b1043ee006d32d7368bcb37d53bc6b249d8af9bc49c0557a8efa7d41e60d4c41b249c83c0dd2133d829bba14d88774c2101e072f493a298c7dbfac1cb8090210752391cfb9a1abf2afaedc4467d82163eccf95ce12e3e762ca8ce5dec539c9497e180c589f81fffcbd474da9fd9c16761b85d7282db39b3fc669c57c0774df4701fb279dec13785514f5280a122443743199682aacf117ff148942e92e7b37ca847e7ce4acfb81689498087b8804ba05fff69f6edfeea3bdcaa495549f9d4ee3ffbb9e6764a3921237343ef9b3832f940142e30d9c43315eaa929c7d894be4e1a839da145e37e19f5f6a198875721f778566799d0384f14f65180cd857a11a712615e2636fddf6ba25ba1d6113d295356dee679a840dc8355eeea4b9dcc79f0d8a10f35b8bf485d3d051730c9a9e35532875526170d3ef6cfa1e97f245628b7e0e995db7b82f54f1124fe691c3862f28b65fd3f5e0421de553439345df4d60a080aed8deb5af06e84affe035568fbef78d1e8ba67022f4db3cf18d5b8ece486ddbf18127efe5e9f5ac2d964d7dd96d738e5043ed56ec2c2d13dd9afc7a4c9eb3c6aff56af9ae3dc48d74be04aa2ede03e18f2472e3b244c6b883634a3daadd622854785fae56b931df529b448ddd34e6894c14854fb00bed661f7a43d300d4e3f2d630cf1b1284a44480313844abedc620342398e9cd27bcbff8c3fc71f81dae5276624076d83aa612f9ba25364e26eb5cb111938eed60a3dda7f3bc1f42a59af472b1708d07e440f1263bedfb9698a2d120e7ee515795c534a01cfda116c8a2b85ca8df0c83d4f98ee22c6c4fefc57ee2c940a054ac92b2fc4febdc24ad7de40512ab58a3f48fa1825915ee541b35ec30734612bb6954372a9933052f7168a80e18d9242ce4ce667dea9f6184708e4b90fd4ef858165b66da2e66c25cbbcf1f5ab9799db7498f404936885c36107040e1445a65006c6af71e5e3b13e657c98441fb3458200b91461d32c4a6b67f382c354af9baff0c43a473fedec2665ef4e05bc2909fe15f07582fe4968cfc99d926fb53563753eb2b524c71cc98b7ae3e270322cb84877c9000b42d6e85f07ff1e21164d5e3e7197480cd067fcf1c5d70cee01297a5feaf6f9da8b6c1749c1ed16396d26400cba4dbc9ad53ea7cac43cbce43cf95afde3549edf645c98472e60e36ecd2829fc1ee9d1ecea9043913def3d6934870c045a8a9c53728a7b9efd4b9a54e66a6070bab9ba94119d3620bc6d721f13baf20ec4ba6bf054cd1d87ba297de3b37be7025fe5e24b7b91f2a4ebc35518986c790fcf8af2d3824873f2411e89a90c36623a3a4e5cb3f782895d151401989d9206abd2be1659e8c81ae510e47ba50c0899e385726b8aa88f1ec61f258cd32e1875c70494f66b227cb53b08ab2ad1607bdd8b7e7480247a800527546b7720a6e74adb18f1c9493ce998ee32d071a2c3ce21113cb5daf72319a64ee72a1de396877e18391894191ee9f66aef5ec470a4d36c9ad53cd8596b16d072407896bb8fd6fab7660565f709be01e7c3ece17926ef4768037bd4dd3b585d470e6d35308cb87f3aed347afe3bdb51ac2ac4162c22605ba164c0d495a274633c9a933f747242beac474edb657a166c3d19d37b4459538efda10fdaf099ab9dc27341f896db0b7053226bdf4ca7f30711de0bb86f8c1503b59ef6f06f21a4f5938c0939840f2843b8d56d882939ed66fd37dd20884a101c9b26e54f81cdaf88dec70f0a25348ed0b6b6cffedb3e81a38ad750fc71d7053e6b3708e36f5e7c7af3bfb0b823a7cefde0b2344ff495c151ce328933385584ecbde29e00ec1b7775911e3e6cf142c5d426d8ba6896e25a84b8902f145c636f50427c3a7ecdf680a3f3dd9e35077029fe9bea929f4e7cc78b18bdea62b106426b56b78280bedf25b39e1468db270d9ec8afe151ec6adf59934727e6d02c01ee5274433095026a1b1bae3e22356f0260b69e5fb2f6cdbf3421cc9b47b6513c43d7eb0b95e18df491931c53b03556aa2c5ee786c00dc912b2d455e05e3b14143712a21c5d007a879ecb2d290f7730976fc939c6978d6c53596656c4e45abe4a4ded54d5e687b3b916de12fefd0f9252121832948eaf358b4397e1670700145270d8ac5cc419907cb8698e52c1d6e9b2bb7dd6b3fcd2a124719550e29be8028182388c20b6cf5c3fbb1ed3bea1748ddaa7c8b22f24405ef9125d3b8630f758ab8f991aac1613d73b16afe10df912fb19947739345fbf9eff4b01b975d0edee7eebebc6da58fe4ff78a2156dae2ad15f20be2624341f34421b6bd9cd03aece7e7789ee27dc14a014c0866375571cbbc4050edb758b748295bffe8231a453b6a2157be84c7b6366bdfb4f17fa55efd4ed36c95722ca20f09a2782bcf2a60c69464033901ff91a6d3f48aaaa30ce481c42e1c6bd168fcc229e5ddf453390d5119414d7599958d11e7cfaad388204f1ee9c920c900b48f7ebd153a42831bbb8b6b419f4e1c9078df91206b1de3fbed27107c43cc44552a1c5762272c9ca3e5c5c15d47d399394c01981770977e712559eb7c466255b9e1907afaba868e40efdbd75b47b6b390f840a86215e212fed488703ff01a25999e212b1a78658588937a550868fb38ecb8a61dbfcedec89ea05dc6f2d78d612211155965be18c4ca9c76fde8ac07bf466ef0f6a08d22659b4533b4485c51ccc4375097eebeca628baff998ebff68116614d73b3993d0cf24e0dc46378dc31ad63718bc33afc3e65769082be4df840db3438358c22ff51a006dd63bbe9047e1b343fa228c051198959c7d6fbc69f87293badefd0c8aa86b0eb6404228a542ae5681e3295bbad9b9a1d0e851e227cefb16262465feb701ca4974388a162c393cf3f8f1b276a1690a2b98d8442d701ea870fe04626e4635745b37c5a8725820d64b487cb5feaf64b929dc03a26babb097b960779aa281b21fa8a37bff79640c550af4db9303ea009f3e10fc40f247c8ecbb8f2bd7286a11df96742e1038c7bc88c21f3f6e13f9fe98f461206d417aec5e93e139d3841a7acee2a03069c1ad5e2b28438be142d59d7e44a3fde7eb0e6c961b2443fb4faf2b2c90d7f4585ca08d486fa40ec41ad0a26013eb161e5def9f409ab845a4e9436c78adf8d205f7f5eed7f210a9545ef819c9ba5493a1e2e69f5729947aa9e6b828dff847ed3ae11764cc702133f2480ef143aed87973e5a0bba160b65fb603a1c320359f2811a994aff4cf12937a2ae2696033c07c095818d17ab0ed0fa3df9c119b8f19072419cb139a113418910fbbf24076e971706094c7f6b456225ec4e5a0821ba70151790397e3bcfffb4269de8f7a1715a6a5a818b572021b1a96c994a08cff143f64ca115dbb1e8183561cc4ef70b4ba665ae6e2559c15b0dbc303939a876aec88e01dfe70f5a19fa082d41e7804c20120bdf6433fa6ac1a686ada33fcdeea2e7e7863e61642a665e49bf3146db3b5eb22d9f85d2bb22d86117da44a36aadd530c06ddd49bd6e5e616144b8c42d813273eeb6ce7c833862b1acc2cc5ba82d653f11990acacbf82e153d677fabded544c76eea699ffd215982c12be32f4ccb9d70b29daa4a6c10ff1e4fba5e6766319be0ec5662646939476e8c454b6e6f884fb6512e9f250037c2bac82</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是一篇加密的文章,请联系博主获得阅读权限.&lt;/br&gt;</summary>
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="面经" scheme="https://missionodd.github.io/categories/技术/面经/"/>
    
    
    <category term="面经" scheme="https://missionodd.github.io/tags/面经/"/>
    
    <category term="java" scheme="https://missionodd.github.io/tags/java/"/>
    
    <category term="MQ" scheme="https://missionodd.github.io/tags/MQ/"/>
    
    <category term="技术" scheme="https://missionodd.github.io/tags/技术/"/>
    
    <category term="原理" scheme="https://missionodd.github.io/tags/原理/"/>
    
  </entry>
  
  <entry>
    <title>设计栈 |  模拟栈的压入、弹出序列</title>
    <link href="https://missionodd.github.io/2022/01/13/zhan-de-ya-ru-dan-chu-xu-lie-lcof/"/>
    <id>https://missionodd.github.io/2022/01/13/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</id>
    <published>2022-01-13T04:30:37.000Z</published>
    <updated>2022-02-16T12:16:18.359Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 31. 栈的压入、弹出序列<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></blockquote><blockquote><p>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p></blockquote><blockquote><p>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p></blockquote><blockquote><p>提示：<br>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>既然本题需要模栈的压入、弹出序列，就要模拟到底，自己设计一个简单的栈</p><ol><li>设计栈：定义一个长度为pushed.length数组作为栈，定义一个整型变量作为栈顶</li><li>枚举压栈，当栈顶元素和出栈的第一个元素相同，则弹栈，出栈列表指针后移并继续判断。</li><li>最后判断出栈列表指针是否指向出栈列表的末尾。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++)&#123;</span><br><span class="line">            stack[top] = pushed[i]; <span class="comment">// push</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &lt; popped.length &amp;&amp; top &gt;= <span class="number">0</span> &amp;&amp; stack[top] == popped[j])&#123;</span><br><span class="line">                top--; <span class="comment">// pop</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j==popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>空间优化：把已经枚举过的pushed[]前部分作为栈</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++)&#123;</span><br><span class="line">            pushed[top] = pushed[i]; <span class="comment">// push</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &lt; popped.length &amp;&amp; top &gt;= <span class="number">0</span> &amp;&amp; pushed[top] == popped[j])&#123;</span><br><span class="line">                top--; <span class="comment">// pop</span></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j==popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="模拟" scheme="https://missionodd.github.io/tags/模拟/"/>
    
    <category term="栈" scheme="https://missionodd.github.io/tags/栈/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包是什么？ 如何解决？</title>
    <link href="https://missionodd.github.io/2022/01/12/zhan-bao/"/>
    <id>https://missionodd.github.io/2022/01/12/zhan-bao/</id>
    <published>2022-01-12T14:15:08.000Z</published>
    <updated>2022-03-17T14:30:45.061Z</updated>
    
    <content type="html"><![CDATA[<p>事情从一个健身教练说起吧。</p><p>李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件<strong>琛琛</strong>上发布广告。</p><p>键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！</p><p>还记得<strong>四层网络协议</strong>长什么样子吗？</p><figure class="image-box">                <img src="v2-3ce2ef6cc4a7f288941ade57c9799450_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>四层网络模型每层各司其职，消息在进入每一层时都会多加一个<strong>报头</strong>，每多一个报头可以理解为<strong>数据报多戴一顶帽子</strong>。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，<strong><code>mac头部</code>记录的是硬件的唯一地址，<code>IP头</code>记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程</strong>。</p><p>在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。</p><figure class="image-box">                <img src="v2-a74a8e2932a412ffdbcb98f884fc086f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="为什么要将数据切片"><a href="#为什么要将数据切片" class="headerlink" title="为什么要将数据切片"></a><strong>为什么要将数据切片</strong></h3><p>软件<strong>琛琛</strong>是属于<strong>应用层</strong>上的。</p><p>而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是<strong>传输层上的 TCP 协议</strong>。消息在进入<strong>传输层（TCP）</strong>时会被切片为一个个数据包。这个数据包的长度是<code>MSS</code>。</p><p>可以把网络比喻为一个水管，是有一定的<strong>粗细</strong>的，这个粗细由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>，一般认为是的<code>MTU</code>（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。</p><figure class="image-box">                <img src="v2-5db7c25baee72ee2b77ca3bcbee97312_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="MTU-和-MSS-有什么区别"><a href="#MTU-和-MSS-有什么区别" class="headerlink" title="MTU 和 MSS 有什么区别"></a><strong>MTU 和 MSS 有什么区别</strong></h3><figure class="image-box">                <img src="v2-ce18e60cfc7a9bbe120b85ac4a7077ec_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</li><li><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</li></ul><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a><strong>什么是粘包</strong></h3><p>那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。</p><figure class="image-box">                <img src="v2-1daa1040cda53b3015f7001a2a72897f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的<strong>字节流（stream）</strong>。</p><figure class="image-box">                <img src="v2-17ecf0e357371feddf343f93b658ec84_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>但由于聊天软件<strong>琛琛</strong>是新开发的，而且开发者叫<strong>小白</strong>，完了，是个<strong>臭名昭著的造 bug 工程师</strong>。经过他的代码，在处理<strong>字节流</strong>的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的<strong>粘包</strong>。</p><figure class="image-box">                <img src="v2-b57e49bce332079e2a62c656b2d422e5_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>一个号称<strong>健康终结者</strong>的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a><strong>为什么会出现粘包</strong></h3><p>那就要从 TCP 是啥说起。</p><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-e2a59fa4a549dadabd73e202ad0fe6e8_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>其中跟<strong>粘包</strong>关系最大的就是<strong>基于字节流</strong>这个特点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间<strong>没有任何边界</strong>。</p><figure class="image-box">                <img src="v2-7b36d6b7eae993081244621846b11704_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p><h3 id="为什么要组装发送的数据"><a href="#为什么要组装发送的数据" class="headerlink" title="为什么要组装发送的数据"></a><strong>为什么要组装发送的数据</strong></h3><p>上面提到 TCP <strong>切割</strong>数据包是为了能顺利通过网络这根水管。相反，还有一个<strong>组装</strong>的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较<strong>浪费</strong>网络 io 。</p><figure class="image-box">                <img src="image-20220112222810497.png" alt="image-20220112222810497" title class>                <p>image-20220112222810497</p>            </figure><p>比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。</p><p>优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先<strong>等待</strong>，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。</p><p>上面说的其实就是<code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><figure class="image-box">                <img src="v2-495ef2712c3b542cf277a5121cfe3ab4_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>由于启动了<strong>Nagle算法</strong>， msg1 小于 mss ，此时等待<code>200ms</code>内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为<code>MSS</code>。此时发送出去。</li><li>剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。</li><li>剩余的 msg3(2) 长度不足<code>mss</code>，同时在<code>200ms</code>内没有等到下一个包，等待超时，直接发送。</li><li>此时三个包虽然在图里<strong>颜色不同</strong>，但是实际场景中，他们都是<strong>一整个 01 串</strong>，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就<strong>像是两个包粘在一起</strong>，就会导致<strong>粘包问题</strong>。</li></ul><h3 id="关掉-Nagle-算法就不会粘包了吗？"><a href="#关掉-Nagle-算法就不会粘包了吗？" class="headerlink" title="关掉 Nagle 算法就不会粘包了吗？"></a><strong>关掉 Nagle 算法就不会粘包了吗？</strong></h3><p><strong>Nagle</strong> 算法其实是个<strong>有些年代</strong>的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。</p><p>但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。</p><p>所以现在<strong>一般也会把它关掉</strong>。</p><p>看起来，Nagle 算法的优化作用貌似不大，还会导致<strong>粘包”问题”</strong>。那么是不是关掉这个算法就可以解决掉这个<strong>粘包”问题”</strong>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP_NODELAY = 1</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-53dd931a4d8ea89ea1fbc0bbcfa50072_r.jpg" alt="preview" title class>                <p>preview</p>            </figure><ul><li>接受端应用层在收到 <strong>msg1</strong> 时立马就取走了，那此时 <strong>msg1</strong> 没粘包问题</li><li><strong>msg2 </strong>到了后，应用层在忙，没来得及取走，就呆在 <strong>TCP Recv Buffer</strong> 中了</li><li><strong>msg3 </strong>此时也到了，跟 <strong>msg2</strong> 和 <strong>msg3</strong> 一起放在了 <strong>TCP Recv Buffer</strong> 中</li><li>这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中<strong>都是 01 串</strong>，此时一起取走，发现还是粘包。</li></ul><p>因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。</p><h3 id="怎么处理粘包"><a href="#怎么处理粘包" class="headerlink" title="怎么处理粘包"></a><strong>怎么处理粘包</strong></h3><p>粘包出现的根本原因是不确定<strong>消息的边界</strong>。接收端在面对<strong>“无边无际”的二进制流</strong>的时候，根本不知道收了多少 01 才算<strong>一个消息</strong>。一不小心拿多了就说是<strong>粘包</strong>。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong>，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。</p><p>常见的方法有</p><ul><li>加入特殊标志</li></ul><figure class="image-box">                <img src="image-20220112222646626.png" alt="image-20220112222646626" title class>                <p>image-20220112222646626</p>            </figure><p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p><ul><li>加入消息长度信息</li></ul><figure class="image-box">                <img src="v2-67108ed6fe1b9f89f4c831882ff9ff1c_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。</p><p>可能这时候会有朋友会问，采用<code>0xfffffe</code>标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？</p><p>是的，<strong>怕</strong>，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（<code>校验和</code>或者对整段完整数据进行 <code>CRC</code> 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。</p><figure class="image-box">                <img src="v2-a12fe05290289991e6d3fc4ed2137664_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="UDP-会粘包吗"><a href="#UDP-会粘包吗" class="headerlink" title="UDP 会粘包吗"></a><strong>UDP 会粘包吗</strong></h3><p>跟 <code>TCP</code> 同为传输层的另一个协议，<strong>UDP，User Datagram Protocol</strong>。用户数据包协议，是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-cb14cd4ee7817c81e0140fb0466e26ce_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p>我们先看下<strong>IP报头</strong></p><figure class="image-box">                <img src="v2-8d684c81269540bc81237b343755f7fc_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 <strong>UDP 的报头</strong>。</p><figure class="image-box">                <img src="v2-a62f8fa5871ce69211fa809032e633b6_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>在报头中有<code>16bit</code>用于指示 <strong>UDP 数据报文的长度</strong>，假设这个长度是 n ，以此作为<strong>数据边界</strong>。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个<strong>完整的</strong>数据报，从而避免粘包和拆包的问题。</p><p>当然，就算没有这个位（<strong>16位 UDP 长度</strong>），因为 IP 的头部已经包含了数据的<strong>总长度</strong>信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个<strong>总长度</strong>其实就包含了 UDP 的头部和 UDP 的数据。</p><p>因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了<code>数据和选项</code>以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。</p><figure class="image-box">                <img src="v2-0640a5a91302b68c71aafde8aeae2722_720w.jpg" alt="img" title class>                <p>img</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-4fdde9161d9f6be4fe2a372c1ff6d49b_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>TCP首部里是没有长度这个信息的，跟UDP类似，同样可以通过下面的公式获得当前包的TCP数据长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220112223526763.png" alt="img" title class>                <p>img</p>            </figure><p>跟 UDP 不同在于，TCP 发送端在发的时候就<strong>不保证发的是一个完整的数据报</strong>，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。</p><h3 id="为什么长度字段冗余还要加到-UDP-首部中"><a href="#为什么长度字段冗余还要加到-UDP-首部中" class="headerlink" title="为什么长度字段冗余还要加到 UDP 首部中"></a><strong>为什么长度字段冗余还要加到 UDP 首部中</strong></h3><p>关于这一点，查了很多资料，<code>《 TCP-IP 详解（卷2）》</code>里说可能是因为要用于计算校验和。也有的说是因为UDP底层使用的可以不是IP协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是IP层协议，而是其他网络层协议，就不能继续这么计算了。</p><p>但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，<strong>如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢</strong>？</p><p>因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。</p><figure class="image-box">                <img src="image-20220112223547322.png" alt="image-20220112223547322" title class>                <p>image-20220112223547322</p>            </figure><p>面试的时候咱就把这些全说出去，<strong>显得</strong>咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，<strong>加分加分</strong>。</p><p>如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！</p><h3 id="IP-层有粘包问题吗"><a href="#IP-层有粘包问题吗" class="headerlink" title="IP 层有粘包问题吗"></a><strong>IP 层有粘包问题吗</strong></h3><p>IP 层会对大包进行切片，是不是也有粘包问题？</p><p>先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。</p><p>先看看 IP 层的切片分包是怎么回事。</p><figure class="image-box">                <img src="v2-1f597892a79da54e5830c2e64c2fcb4a_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>如果消息过长，<code>IP层</code>会按 <strong>MTU 长度</strong>把消息分成 <strong>N 个切片</strong>，每个切片带有自身在<strong>包里的位置（offset）</strong>和<strong>同样的IP头信息</strong>。</li><li>各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后<strong>在最后的终点汇合后再组装</strong>。</li><li>在接收端收到第一个切片包时会申请一块新内存，创建IP包的数据结构，等待其他切片分包数据到位。</li><li>等消息全部到位后就把整个消息包给到上层（传输层）进行处理。</li></ul><p>可以看出整个过程，<code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。</p><p><code>IP 层</code>表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。</p><p>听起来就像 “<strong>我不管产品的需求傻不傻X，我实现了就行，我不问，也懒得争了</strong>”，这思路值得每一位优秀的划水程序员学习，<strong>respect</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。</p><ul><li>TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。</li><li>TCP 粘包跟Nagle算法有关系，但关闭 Nagle 算法并不解决粘包问题。</li><li>UDP 是基于数据报的传输协议，不会有粘包问题。</li><li>IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。</li><li><code>TCP</code> 发送端可以发 <code>10 次</code>字节流数据，接收端可以分 <code>100 次</code>去取；<code>UDP</code> 发送端发了 <code>10 次</code>数据报，那接收端就要在 <code>10 次</code>收完。</li></ul><p>数据包也只是按着 TCP 的方式进行组装和拆分，<strong>如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已</strong>。</p>]]></content>
    
    
    <summary type="html">转载自：https://zhuanlan.zhihu.com/p/359177898</summary>
    
    
    
    <category term="技术" scheme="https://missionodd.github.io/categories/技术/"/>
    
    <category term="计算机网络" scheme="https://missionodd.github.io/categories/技术/计算机网络/"/>
    
    
    <category term="TCP/IP" scheme="https://missionodd.github.io/tags/TCP-IP/"/>
    
    <category term="粘包" scheme="https://missionodd.github.io/tags/粘包/"/>
    
  </entry>
  
  <entry>
    <title>完全背包思路| 剪绳子 （java）</title>
    <link href="https://missionodd.github.io/2022/01/12/jian-sheng-zi-lcof/"/>
    <id>https://missionodd.github.io/2022/01/12/jian-sheng-zi-lcof/</id>
    <published>2022-01-12T04:30:37.000Z</published>
    <updated>2022-02-16T10:08:41.017Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 14- I. 剪绳子<br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p></blockquote><blockquote><p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p></blockquote><blockquote><p>提示：<br>2 &lt;= n &lt;= 58</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code> 完全背包问题对于大于等于4的数，拆成每个数都越靠近e，收益越大，由于是整数，那么，拆成2或3收益最大比如：n=4，收益最大[2,2]n=5, 收益最大[2,3]n=6, 收益最大[3,3]n=7, 收益最大[2,2,3]n=8, 收益最大[2,3,3]...我们抽象出来，得到：物品重量：2，3物品价值：2，3背包容量：n最大价值：最大乘积</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     完全背包问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里dp最大乘积，包括不剪绳子的情况，这是等于原值，不是等于0</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">2</span>;w&lt;=<span class="number">3</span>;w++)&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++)&#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i-w]*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/jian-sheng-zi-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;剑</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="完全背包" scheme="https://missionodd.github.io/tags/完全背包/"/>
    
  </entry>
  
  <entry>
    <title>01背包 | 分割等和子集</title>
    <link href="https://missionodd.github.io/2022/01/09/partition-equal-subset-sum/"/>
    <id>https://missionodd.github.io/2022/01/09/partition-equal-subset-sum/</id>
    <published>2022-01-09T04:30:37.000Z</published>
    <updated>2022-02-16T10:06:49.531Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="416"><li>分割等和子集<br>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</li></ol></blockquote><blockquote><p>示例 1：<br>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>转成01背包问题:</strong></p><ul><li>物品重量：数组元素各数值， 如[1,5,11,5]</li><li>物品价值：数组元素各数值， 如[1,5,11,5]</li><li>背包容量：target = sum / 2</li><li>求：是否存在背包正好装满的情况，存在则说明找到了总和为 sum / 2 的子集</li><li>递推公式：dp[j] = max(dp[j], dp[j-num] + num);</li></ul><p><strong>步骤：</strong></p><ol><li><p>定义dp一维滚动数组<br>01背包中，dp[j] 表示：背包容量为j的背包，所背的物品价值可以最大为dp[j]。</p></li><li><p>确定递推公式<br>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>该题的物品i的重量是nums[i]，其价值也是nums[i]。<br>所以递推公式：dp[j] = max(dp[j], dp[j-num] + num);<br>3.dp数组如何初始化<br>由于题目给的价值都是正整数那么非0下标都初始化为0；<br>如果题目给的价值有负数，那么非0下标就要初始化为负无穷。<br><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</strong>。</p></li><li><p>确定遍历顺序<br>01背包一维滚动数组：先遍历物品，再遍历背包</p></li><li>确定返回结果<br>dp[j]的数值一定是小于等于j的。<br>如果dp[target] == target， 说明存在背包正好装满的价值总和，存在则说明找到了总和为 sum / 2 的子集。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        转成01背包问题:</span></span><br><span class="line"><span class="comment">        物品重量：数组元素各数值， 如[1,5,11,5]</span></span><br><span class="line"><span class="comment">        物品价值：数组元素各数值， 如[1,5,11,5]</span></span><br><span class="line"><span class="comment">        背包容量：target = sum / 2</span></span><br><span class="line"><span class="comment">        求：是否存在背包正好装满的情况，说明找到了总和为 sum / 2 的子集</span></span><br><span class="line"><span class="comment">        递推公式：dp[j] = max(dp[j], dp[j-num] + num);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总和为奇数，不能平分</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= num; j--)&#123; <span class="comment">//倒叙保证使用1次物品，正序会覆盖上一层左侧值</span></span><br><span class="line">                <span class="comment">//物品 i 的重量是 nums[i]，其价值也是 nums[i]</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-num] + num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/partition-equal-subset-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;the leetcode link&lt;/a&gt;&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="01背包" scheme="https://missionodd.github.io/tags/01背包/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 |  双串题 | 不同的子序列</title>
    <link href="https://missionodd.github.io/2022/01/05/distinct-subsequences/"/>
    <id>https://missionodd.github.io/2022/01/05/distinct-subsequences/</id>
    <published>2022-01-05T07:50:37.000Z</published>
    <updated>2022-02-08T01:49:22.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="115"><li>不同的子序列<br>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</li></ol><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p></blockquote><blockquote><p>示例 1：<br>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>rabbbit<br>rabbbit<br>rabbbit</p></blockquote><blockquote><p>示例 2：<br>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>babgbag<br>babgbag<br>babgbag<br>babgbag<br>babgbag</p></blockquote><blockquote><p>提示：<br>0 &lt;= s.length, t.length &lt;= 1000<br>s 和 t 由英文字母组成</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>s, t引入头部””空字符；定义m、n分别是s、t长度，定义二维数组dp[m+1][n+1]，值表示s[0：i]可以组成t[0：j]的子序列最大数量；<br><code>（i，j泛指符合题目不超边界的相关变量，[0：i]表示枚举从0到i）</code></li><li>初始化</li></ol><ul><li>s[0：i]全部删除取得子序列“”，成功组成t[0]即“” ，所以dp[0：m][0] = 1</li><li>s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</li></ul><ol start="3"><li>递推过程</li></ol><ul><li>结尾字符相等，取两种情况的结合<br>第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等<br>第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</li><li>结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]<br><code>tips：由于引入“”的关系，s的当前字符指针是i-1，t的当前字符指针是j-1，与dp的i-1，j-1区别开</code></li></ul><ol start="4"><li>剪枝优化，限制t[0：j]长度不可能大于s[0：i]</li><li>返回结果</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s[0：i]全部删除取得子序列“”，成功组成t[0]“” ，所以dp[0：m][0] = 1</span></span><br><span class="line">        <span class="comment">//s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Math.min(i,n);j++)&#123; <span class="comment">// 剪枝操作，t[0：j]长度不可能大于s[0：i]</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">// 结尾字符相等，取两种情况的结合</span></span><br><span class="line">                    <span class="comment">//第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等</span></span><br><span class="line">                    <span class="comment">//第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/distinct-subsequences/&quot; targ</summary>
      
    
    
    
    <category term="算法" scheme="https://missionodd.github.io/categories/算法/"/>
    
    
    <category term="算法" scheme="https://missionodd.github.io/tags/算法/"/>
    
    <category term="动态规划" scheme="https://missionodd.github.io/tags/动态规划/"/>
    
  </entry>
  
</feed>

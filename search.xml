<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经 | 职场阳光WARN，渐渐聊出业务场景，问题排查与优化方案</title>
      <link href="/2022/03/26/zhu-r-inteview-skills/"/>
      <url>/2022/03/26/zhu-r-inteview-skills/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9377ad6fdbbd2d52d4e98f49471b5bc72d6c11e77ad3bdbe1a1a19d42a6aec51">307aaa247f9585ea0a0d5e2e8920b3f7e6936e6f3f642784ab480fa42b90188ca69771a846dab9f0eafc07228072c82366da58daef96f577845c53bd730345dd0545c26df8811079fff1760bb2a27ce320e9d9318157104f4acb4545ae88c59aaf314fa58d942c7d9c5c154d2a76bbc117450a5cd77ceff6b0556c638b6539c6f116f96e8bf1f0961254ed4a6ee0f4dbb6c9ab2ebf6d02e6c9663e5258901eedeae50eb5e9976dbcfc9401314b33430a0cfc949b84cd71d183b6faec2d4fbc44fb398d57b3a06033d38fc6b60e05af7a8f0341f8b2c3d533717469e6a42eb7a15711f69e7f92b795fdb0be945eef1065328e310cf8e8991a69fbce2ed92da7578012d0854ebec3680e3ae41a5f9d3076f0e9243805f78824aea1bf79768035ea3c399a672e526657bf8111dbcb64ed5b157f0e551747cffbb7df112d217bf905eaf958726ec27dbff953d2da6c4c534c849186e28fb56f9481657032598eb023c21799bd59709583f67de4f55ebb649699f268ab3d5484b6261b3f2731089ccc11dad05869f3abcd5cf00c63f8b6f76e908e4f4dc81c54a616188d4ccc3446a0285964c83a75c1de87183ece858502e517ae6a22eb4266dc346cf08ab29fd3dfc90e19927299cc3b52f6c5f35ef047f16db097ea7e52081948e296d5ac10e25bf5d99737c7d50f0c1cb2a8682b1d5af39bd64162c832b14b2371429fdb71ffe93924d08e10302cf325a36dffd8665675f8bf259c54d4de3dc263536dc6c99b0caa29cc41db4b41be521ec191ef593265e8b9ca86f17fefdfa1005934144c2df648f24c9e441ddbf43e73cdd288d252b0ef15b6df7f7619ef9008ed23620bb48ad8aa7109575d6448d7053e5cde16c2901e655ee8deb66c704fa4db0c723febc1a40e5ccbc3fcf135e1d7acb2831bb7e8e94db826e6bfe44d368fc76a844b5e7416bfd728490701d4da57fa61ff024d24f27275bbe5f2f4c48bda4f5fccb4100a0fe083632cd3353b862476a0deb8ce87e40023ed33acbdb3e1b0cd94898fbcbbd161ff8acac8bc1e89ef22f0e7cdd34eb4eeb1dcefd98a6bdf3c4c85e38917015a0fe582f378aa1012335c5f630e76168ce1f5909518e4fcf5021ff071f547f68da9041dab31f5bb2f90ec803aa251a1ead45c7713f9e8319ffbac0a1555d18ee77a8f8b8b3aa680a5644f12fe88697aeae61c5c125943998a5c21ca438b590827e222287135db1bb7d6d2b2f603327a5e23ddc5a8e58d15d9c3e1a2247f927dc1434f6964d1ad92a42f208f6db787b07343fb8dc5a8a0a2931e93ac8dfd6880cca8e5628b57fd6eb2358076d3356a75aca0faeea2077b56c48bf73786570dfcc6949b1e60622528bec405b9f7969ba36881768237d2bfaf8ce76877c49247d6d881f86742605d39bdad951cd86a125922c4a3a2de8787111ed5d2922d5b7ced5f98e0acefb4b2f0fbdc5786332326842b7be98701effeee26e87095098498e31c60b740249b6c1753938ff74b0f517c186659bec3771724a23dc5f445db8459d84854e1942118979aa12326011255a013ab617af1a0f714fb0added7116dd341e0f1f6966debc0376ef53c995986c89319c43ccff0ba121c479dd327c6c4c6749e44ec4cc827a0f2a7362ca95757dfdb8e7189bbd9034c5e9880c5a2787f5e4aa5fff920c47d9c0d2a428a0381408715e4c6ae7116478873aadd3cf11b6254ae3f71164794d9e65b4f3150d77319738fff534bf42a602bec9ef91b3f86202867bd54e95cb0aa47ebfd6a0f8620b4dcea3966291b2e0a0446dda20b2d5f9352f3a5a83b82018d37694e357ed7e9e8fa9bd83a1484e07cf1be1a462719bddcaf134b9af914aff4cca6d7ce4c4dd42060f7a8605ed4acf605ab5179125e018519134732e593fb1f48d9fe9f402aacf4c46c9bc605b1f98eedfc7b61bddadb2d3d581d8733c5dfce33e0f5112d83e5e646128e9c21553dff39994233959226eed3cf86baa164c530d2fff64e819afce44984cbc6ab5330b76c478fd14639c2c2b070f67680de37f03e307d7283faa78703d1a585989b73470508acde10bb68a700e19d1e76f945f324987deef69f70709c0151134245bf1f36a4502b1d6666e9859bfdce599aad9edd1a0edf4b5b627136ecb54b5a609bd0705050ad184129afd7d5577ae1e44a657bf81998f5141bcde00b4bd3328424d6b07e49434bd41ed78ea4ad74a28f6323d8f750fc5366bed5b55dd6ca88f7d3b5371ac543371d6646cd93093a6ea56531d659ad95bce11fa26ce59df3026ea3fbe13e91f66865f88ea778f418e9823e6701b91e3cd85d7e2a314095c4f52dbf79d3673b9400d15d11afb62d4c9b3cfade813acea451b1e6ee3fe4510f7a0ee03b32e3c9adf7e7ca64a3d28faa09c885c99785fac32b6e9cf6829a8dec0b6cca5c67c1c78745af7f9272a73f4021dedd1c3667cf18eed2c4b4f7f7a28d40966c4a4575c366945301665b9001d17c67e09b93169de64f8e438fbeb967b15784e2ae20096752deb763dcad952a39688397c4c07c9d6e6af59c277754521c74b0e6b65fcf8d9f1e6aab67f5c6fa285cc0ab3e7d7ead0f0d4328d84861e9620c79d0c10cc903227ce87b0f13b31aa2f93ac2202c46bef5e36b4371327b1e5cf09b9444643126e0cdce9dd0336d2dcfc1cfeee85076fb1dcf4616e3dd9de035a9370802a9c4d41235f90cdafefc61a9380674defa880f9b0076b5f2f3fb0a4eae0a63fcccee67ebe986a26bc589da43213855126ef2f686113c1bdcd848764a6b6770521a148f7711c11acff0e802367ce3c3d8f0bff8437fd610e01dbfb33b27acad8afdc0f4b817b2184f2e37525a626840a773989c095986e067ca9a95cf1d2e9d7e92da7d313857973bbf96b395d5e9a9a4c8625faafcf2902253b670d0d6555909ad3054abfb35ed811c12e805267bd8abdb55bb7e81884cae04b81e50ae0494d3b6388b9a2b2c5bdd22eebc38d9ca9b9392b53fd63d780f470a5f6e4528f069683db918a27b12af9c115aa4df4c84b0fa86ea325a5898ab3eed3722e4946e72addae6bbef93333c86535fbe9d8b23f3657058e80b2f910cc7383931dc3390febfa3e1fa540214d50ece34490829557e8cc7ff300746f0f357f06711be7307bf978cc277ad198326ee2c2e4c74c74674ba05312554f693d471400fa7106a57cb88cf6c7851419de669bba74cdc01b33473600b0fb2ad6da0108fd97a45e90ea2cc6d7dc705729de58d5257b4e86507a0bf95f502b4a1de857835abb0f14145609cebcfd312ceda28e5391b9fbd5c5035e8ad4c7db3973de1fe7faae603148080273ccc7663773572728232548ef3109a85594b5c88012ed143aa5e3ae28750914bc2aee7421b71c54cd7ed911f958c2e2e04d72d6e2cfaa9b05d5ee104c371a217c369233d1987c920ca7f083b5affb2e4a38cafd0f54cc17a2fa8c6d1a89b955859dd2d522f998b0ab0da198a165daa77cee4110eeb161ef5ea377f833d0c6962f08e138b365220fc0f77252f212b827528528c7cf342c0f631503acf6444090a58127797ceccc7a8c7eec77f8daa01d64941c390d275e3882c0be05107cfca0c7c982a938d77e652a3df174c4e13c8a91c1fbcbbf1bfdfa4f529fdddb163f363f6d63dc79b66559e1556e297265b5bc6831186797fdee5f16121c0d57db4d357191b319994a4388032b0e73b960677f7778aee2e03b8c1e3a06b386fb09989b75aeb5a08133b1d9382256164ba1faf3bbf61c1c321f50d0cfc17bd753fc9482f2acd9346ebf5d26d8c4220cb0dc3a032e2faed703f8ad1682f86caeb3aa442d2b0bcfc74d062e21dc153b8f66371719014dc8bdd62e130dea49eae2e52a027159941767f4e22812b007763f77b9780df3bc1c572e4e9e1b75cc2b23fbca85c72ebda1c3f6a125fa30b80413d3da8d92278002e014b63a1fbecf2d83f42b2eb43d5916935818486d0caef6144e167f4c097b0f4893a7f75bd886ba655cceec23557620869da467f507e66fea5af61f67922e3ae938ce35f08f5b07212a1c176f7b363a1808cadfe54af844ae76adbe7fdb74000cd5e6da0584e5e2ba3a36455a7c7d2eab4d6193b3603dd8084551d99a915b8f2c766eaa967be731aa1913ebcd7fab8084b18cf949011940d96e6d4218536b141f311a3086ff1e041cf2b6e91834f85bcfe3e58d4b6dc9e0fb839dada550007f21aa751763cae29cd6744dfb50cc9b2be96b9609d241ff9b62cd6e48f0cd6d58238755d63debb71ac7f4cb5eb3f6eb14c5b02a062eeb3a0613165a584d2f4b1ce1725ad4ba5e0bb5468fc56b4f76aa5d51f9239baa57ed7df2ef55caa430d336165b517691efb25bd9d99871b0e231ba0789cb4e8e0701395ec655c2295e76ccb31bbed0006afd292e3f617e74289e798342f962fde3b055cef4628d1c9da79bd1d78bc527b15ff02dac0974f7ec4efcc0197dce49166ce8ef9ebead005e852b28d4b564ff3d1b37a06daf96a17f4ab171305a67b6ceeb413e3dee63378766f55167a6ab8b06f5d5ca9153e3f51001b4980c23b5cf3acd51e79740cfaf48c08a61165e6b25ad1b261bd361d0f89d2e2e54b745c2f95d76d8ca75a9aa235961fd9fc7945fe6da7182bfb8ad482c488eb6115f589a868df73bef7723fc17529cad5dc775a6bf7f9e046308d372fee6dc310ef411606fc5cf0b9e34e8b6067e62d07708f5ef861f4f8e9e4665399c5f49784c5a9ca5f8329d111395d8e6535a555a670115efcf5a8721f0717ee00b74dfb56a38944ec2d6d02b877cdd28207a0d74cc698eecde93d9f5bac13fcdb5e027ae7db4860cfa7b11c412888fa38be896566e3dae2df6ed8a3f0b94f15591affea16df930509d0f069463aa593b1e7bae04fb44ae7f11c45569dba476774d1a1c1f7c1737801543cacea4119892cdad8cfcd7f7f60b815e4d7b730dbfd16e1ce8c32361506217245861fd4da974d7de90ea52de41a1834d3124660a606e70cdf4f7eced654dfb28d9216290ae90d01c80dc42eb2e5a9deab94383ccf783e2df12790a6a63fa7cada3cac5ca113df762fc8aad055343c118bb43eb4dea2782534569785cbf19c64e183fc7fa4cf7caeea0b7d55d06813008b1f7db48ff0a10f09fdc591b9171ae858c8146d505cfc859739629c5a22127191e4a75414756f3006a2907c8e894c54efd8e2d366dc33f32e6c88afeacc446c3ba559313b3a09cd2a2268b4ae23e18a0f3ff866a48a87e8cc809d93a134a5bd96af2a6a9f9e870be8f0cc7676aacccd860b24c05bcf0809ad0132a56851e8ae1757fb33b47327ef7cc882286ad2bfa5fa3564d2eb551b9f754ea9832820342ba016082b10fc3d03aa42315645c81107fb888431e32dbde2cbb815bae48a34bf836a516808d8e9e3797f4f54ee5ed479a8b912edd6333ff12dba5d2f4c5cf87f69d8e4acbef5b85025bf9d233b136432888484f922043f328c42b3e0d62457a9a6849978b6aa11d273ed58106738e4955af497cc1f1bc06485a4af7789f801bc9bb16e08fc1c65b821feb29596de19bade00dad30d1d61166a6cb99138f3884269b75b3e4b00b29d6df772458ca5380ee7134826e263e0d53a612d2a326b7789f3b753e23de72b016b153700760f5501dde4932e685f0e55ca4f425d64adcf52c1c1937ac1c85c04f738cc082bfa4f3b2e4e9c99751befa8f505906944d74f8a7f8b70207480397874d991dc4454b066c28f52e487177448edd8489fe2b5a75b17413eee545c09c67e638dd0b1fd19ee15cf23615522019b2d74b7510fdbe78b3131dab8afeca61987911d9b9e37eb9b462af30bc859f82e6bdd198a1ba455e8965f895b9bbe8c8eed01067df1e65f1f95997ff0e6be087b230c3176eb36a7fe6598bb4f69a531f565f677f0ccfbb223d170e2e9deb264f4cb64d9e96cb8917615ca40f9349b41757673752dde33b9467d6f4941ec373804b262fccf944c1309065d4849d53ab453d4d79c532ab519ac7bb8e2fb2d125317b43a40d5414bce82db0ccf4dbaeac99a9a658c020b181841e6f07510fc3ca3e67d3cd96ebab7d86aba635b58e7571d0ed2f0d6b637ff5c526ef05ef3553de34a4237244a75d54f16e8de7059ef2783ce8d2983f4b64aebcc001e8b1236a6a1dc77a0f1dd426491c51d360ce453ee317d437e77045f4ccb92cc0ef436602928b76d312c5d0880fabc1b57bdf240ed913d2660594579aeecbaeca5eed315aa011b766d36a949f6e59c48e08a059464c8eaa7c0fc199f5bdfc070f7ca394bdd3d4095fd4f33cd4b3dfc2898d701827579bbb84f0b2500c4ad8d1657b4209db80226dd672a6688545d9ffef25f63634bcb01b550e7255504e2a0fdc53375475a9cbb80d34110395aba41540038e1526fddc649b5982be3fc6eea7f51a167970af5d99efe6f43efdc0f640929456f4b1323b010c2cfc8b40e79c3d9e06d5696c2e94e15ccfbcfe6ea8a8fb57d4d44a9bd18e01ca24559e7be312d6171aea2d7b8fe78131b39892d93fb1719ac4502f35d651d5d29e804285cdbbeec0399e5fe674a2a0aa3c9fab465d25eb51aa25a026c5eee327582fe8e8125bb8142fbeec2865155fcfb0c585f18e2a1a981941a27a46862418bc9fa0ff0c8b3fd0dffcdba8bf640ed767a86582d07152491f00cf36f935672a2fce0b9e51ffafd5c0af1194e4a7b3a66d7b0bb04767713751652225ec831c6954154f0c5934992e100316e8adf6631d494ac14cf886e62999b000e8ba5b18c794e6c45e5fbfdfc1329b9eba3963b7599e3d6ca650b76d8f6a47361a97657fcd9afac1870e8085116b32e6308b32f8bcb076f54057c27312d143e6afdcb53e5ed11a6a0bc6b1d7c585a0dae0b94b0724c402d29197e33505a39ae7c5f01d7c9aee1048fcfd35b06ed270686561d809bb56c2de84b18f4a5431adfa79b45e047375e81e1858c2538ca61721e988a7ecd39515adba7cd8e1d658dba3328d1d745fedf380766f4918d8d90d3735061055486f355aa154db8f715cba4e4b74faaca205937e3219005731b3131707d02a0cbeefdee970144901423bd3f2a43452751d799de7a1a7d9778065c67478eb96b8d55df869a11cf280d5904d5aecc0fa0faf465d5fde071d60b524ce49c34a909f5daac555a86c07e4a80a868dcd05b1634e24a47349d99973589d2c5f1701bea779f6fd50f89e1cbe14ef5b583c235f626060933af8d6ab182ae5441caea5774965b5f4d64381d30f19af96a3f17e72eae4e505d86f0738d3eaca8381c956d6aed7b70f0bd1d58e48df216ce8c999cd2fe161ee33b881ae412664f6b7ce90b9cddaec025b8e591b0454e075161e3268220009add7ed233bfd90b55a6994e134886bfd3f5adf315a75588fcc4dbee3c759ad453479b075300e1f644cd02217ab3e06869e8cf827b251b6097be12f7dd25b53c2107585d8f82700830e1b67e62b1e0c84c9b74dd5c1ab30ad51f6d2a4bbf6be31bcb612240dd8e00556c11e12b9007a89799366c456e1916242fa2ec7fa3ce7ad8504b44bcf1f9aa796bbf18e5ce43a754415901d846bc2a4092362c5e88c9680f78a87f36dc7654466c9d4b093f430516b80471bcc6972f6b52aff13c7007aa6bf6937e1f046acedd268b3d039e3adfbca6a3f6d220f81ecd4c90dad5efe191e35e07e1b578c2c9fec9dbd265d2c9ad0f27e0090b7ff84e7c483fdf5d9df06d8a7b2472600844d42c78cc7567af6a3da7ed6d6f0537550e5c2309b74efb97f87515b726de548eccf84ae4c1aad664315a9be150002ed01222cfdcc3b1d77c0d4408ec9677d471a8fa641be9291d64c56ee32df475db5ac999323e39bdd0b6561840b32549e4b37ed3d355b1bd3636da0de439b18d9fcbfe7631075890fdbf1ec2a4319ae9743a7d748d901938012ea7705e67d5228cbde0739d6a17a0adca295b8c92cf47d32d6e1969549bcea3110b9ede254c0ca86171191fc9ebdff79af8017b2b00d8d3ff366a9bb6864e5de94b396b62651466270627189d7074c33c0f24848f241a41f4231da3729e802ba9fd820e90bd4839f012bec0268e036211c663e0c5ce0a47e0bb277c88c873ec8db1fad4188205ab4df8094d466a5c7b2f50c27b1978a84f854fa98c4923b84a0edc7adce449be37809c0732b38d0d8797c7b7f397d669e20bd16547d64b6784b9795095a3b44b80bd1853c6348036bb4a97b998f54cae47abcd74c715f5463cb1ec393e45da03d7c992f10db8bb3316aa5558c5d078dee854ae070018e1e2b466b78ccbac1fa87ebf9a90a8a7aa2e61bbf202af646612f54f65ef6ef5bce5f2e5c0468220fc52d94f219ec682c75899c2eb6e2a19794c210a124f5bbc0b17709d8820c362f8fcdaf719f921cbd84dc351bdaad411d090e3ec805a66bb2a871b7abd4b0b73ba53560e0dd7f53e1f7f0d167f123deb6e608ee993c6c6200cd1964955cfa9e72e53fa55e198b90b37ae38094732f0b18fe4afecd7c9e70223358a3dde0c6893c704bb49dc8520afe8b16f8c5d4e6cfb25e8d1dd7ee160ff9fe1d35f35be03df3d7a6ddf7a1dd20e78586bc7f75f1a25fd62d8dd09174226f0ac842138c2ca33ee11f99a8aa03df8f2210ff5fd6e107587a4296a60ca823fb171033d37eb67e699c0f360b5c677734d443c3f1203ac32211129d4d36512d8b5a710ebe8e94992c6eeb7c6847eaec5f982be7b9ab9dd5c1e1780aafbf943faeb1f43e31c698e5090aa05055a92adb7e46d1aec525ab463a3a081f1b7a62e81c5b2e37a836e9d0609e85e11f6fd5bb988d591f96b1d3a9b0a6c05d053551f32409aff2c0e6e508bb5e3ce04233d0b79add372c4a54d55ae5acf41092d8a9a95f2b0d9c45b117226ee73915f5faaa6726472f88f588502cb1b0da79139012a40d65ee7edfe565b8fd0f0c7206af5aedf9cdc0c8202bcdc32f8101ae3bc385fa84bfd1392e516766864f0a6cdd91c27ad9138401c58e1052d2ec96c630908bb279e43b52836b9b24bbdc0685d907c743c473b48a2d426214854d03d44f7dba5899fa97bb15cd8a86a04b0ae600fc6cf98466a71cab04aa3200b30778830a6dd3aa4697b8714b0c39c970d06acf5f8a4f243e5ff12d042569c6f0407326955d160e1973035f4b6dd99356b45f950a194999205040538006d8083e13a079d141cf09eabc5f30f5d3009ba55288e2dcc2cc41454de27d537865cb252bdfcc57cd9972be021e6ab05e450498032ac8bee671208480caf64126b982a1ad65827c9eeb7ef1a88aad2468c1596e5de5f58e8b752477c8af8a0170a13d70104b932d2963de974de152401a2a13229611a47d19a929ef01940508e9a63da9593b603f1390b35f6460d7ee4e5909062f786847928a056ba7ee343d2cede4adc682baffe5995743679683bbbcea40de78334d9800539aecc0f34192ff6b49cd220afcf76fa511f2e77de2f549795cd6c8daaeab64c0b9640b4b3ba19af583a7173b353d65ce0fbc56897b018f4427712ea0cec765167ca0c9224ada13fbbd8891e649727d7609ef910510f307c0f8d6ea056104b7c8c0c07dc3cabafa87addb45fd338ffbc3e05f804b386712bd304de9f5704a5be00f1f71a228cfb094913bea56f810101b389a05a6c598688a30f79ce11e13fb9c666eee890585070f22045689707465e0ebbbdcfe5a9214ee8778d35c9601538faeb8f5e7ed5edefcc8a65a02b110fb5699d6c84c5678323351aeccd77d5a84760e0132a730b59e4471d24c7715672799c0b8503223185faf53d304445225953254530e6d01d5fe8f65b2c55f00be1780355529c1a1cb4ffdf010777b73febfb9049c16dc7ea3bdae7ac4144196faa87081c7eff24e82f3f6b2a5fa07ee24a51a544799164e06fa0ffe3fc2de776035762fea07182111ab2ea14b665927cb9e1d2378e69ab3eaf9ab1c180ea53d68916c6ddbedc5e24976ff7504a7cbd458b20fd40d752c7df92b26060026c17db20cf160a9df59875eb66b168f34e0cf2a6709e89a1a2134b0a486636e3e6d92cc2eb492637ed6d2f5593cb5f55f905a1fdceee8ac0d6bc19a0cfb5aa5ab368b575d2da13c3d056ac791a63517b493d0a5559550dba09e683c65838f12f8adf2facd81e67a2077da8a8ddf81d8395f3c7232e63da1f7f5bc2586e253edc4e9644ec85fb0718956c26bbea3ba87e464c27021e355f6f620a71ec2bf33635a51a1af14c408fa3eaa6d758b115f50a1fb781a1e479128867e7389259dbbd283a397cf68418805bc3c21c0fb0d0996d52f57bb92758dcc9c3aea4781629f1ea4b518ac177a11f702923e668908e54b1910bdedfc995a21f3a443cbbd77d52bb599563f22715402862476791b81200e93c146c151968a98e53a3b3a04e05ec4be12082039edff62d80f9a98cd551af5a733afdd003c84b8feec8238e01b02e7bee44761cbfba4b6660d4a932cb11ea1914bc278c2dc841fb560692abe7be6e977b3653b9f30229843e1ae81f233cb9305de1241c1f8254383362e60d4c42ffa913e832e6159c0ebfb564b39995c983e586043c296df4a2ed2f690fe4689aeb73f73911074ab1f99a752cf4571e9ef359c0f474c6ad19f0887b73c079747963ea60dda27f289d6802db4f60b87adc76177374b7eb03a59c63d7f1d6829ca5ab63c364c226604357ea2abe1ae50a156a6b4261711c6c5d62569ea24d27fb85a825f70f339699b5538de53924324804cf2001beb5ce8bf43af416a0012b57fa5a8d74607d34798148e0862d88a695acd9583ca413e929500b14f61dac0a40939ed6f8d49f2dfc0db3c06b7f22806980f3e0f7146101b43ce4ad36c2cafa4ca42351d859976898f2a181eff95fde19fd49ce323329df155892751f3f3b861c5c837f269dbba99cad7b998f629d861cb20887ceb2802713fc21631e0220f554ecd233f546bc0fdb4e9faff9edb1f0a612dcd3217884b43fc5200f1ca1efaf1a227abf6f8932e5fffd546bfedfdda70b3c79ee9087e909a0c678962fd27c3440f9c7a6832753211ffbd9045860136368cd94b7f3a5feb8f1f1950225410fb44592f2931cdbe706382be9e4483322d033d2b90bb018ed8c2d404913b0a760c7e78e15ae7cfa1939716dea27a3359248f244a87df9360cca7cc6a05d736e682ea937cf9f7de77f590eb29cb5ddd91285080c9f826efb84b69ff59da4585c343a3dba9405332eef55c06bcd40a1f661ea436bf00901d89147dd0e339002267a8eb6012e8d6bf720691b705e1b4919990df0e57325e61474a3c185e1f63e329875bcac4eea28c30c591f1ad485c546fe9e25d7bff7e6ace62ffcc0ec91efdff6f8419aeb8511dbfb17137424b6fa129b3655e9eb3be32b0e45751f0b55873fc26430093ce09c9a47727c60a0e7c8db87485788b3ce8e7df68388e5ec314ef1dc1fc98a597caa014ed7cf6834d6bdc87dd1c4610151342843547046729bb0351e9a036c2ec4016461f58fd2740b38ea5c26c6bbc880f76370e1f234b8018a9b19923dc459667c44c97abc6a75b9908875ed91baf1f480035dc304c945ce7def476b194a0ee30040fade88653fe61482c16ab696e80243defcf9645ba55d57482c6555ec75bf180e72f8cba3d9e483e83710fa86494f1bebd3813d710a9ef2110b3c23bf1df38fd6a786a5476bcec19a149e32fc75665775db05b8a52780e399696b2115113ce21b6ab7bfde0458a0d71627f2ff892370d2f14b4c432c21c7d6d186da29c4cda212e86ca143927ebbfd15eb968649689562e7df51713d98be0bdb5e7e0a685a3a9398539cd094ff920d973a3ca9a833dbaec19ebd71d85f209905148c179742cdca5ce2392faf6ffc6780ae4174704c91e469202c65b74445aa3aebf1cec7dde8a429013ed98bb9684dbbb9994d81871fe242ddc06b6e3279f2fac4dd2c5385a3f772c0471eb2ad0b353df410628369554d0624aa4261d380cb20d533a8ac4d3e14dc07d47e40860f3ae6654c66454081c72e68aac16baf4cdd53e0efccee0f04003719a12e28fba902d97df4381f4b6552ba4c46892cdb2a0476d9b8518033b5db7b286fd44715022a4416fae669726d6cc31d06c9068c77d3aac80e5f0269bc068b8e1531cd42200fef4201b34a51af6e12d9dabeffb5f798d9d7ae84d99fbe3254f4b68f48430251ac16e0a37ce6861fb836630f262fc633018d593653e03a119e8503e5d620267e3930ea64d98297151c8d069d3b1d85898deb73a68c4399cea84f94f0c8889860516d640488009cc5a0006795d512993383d8421560b62a540026539ad779f2b61c19a4a71d98c5b1fc4de20c0c13e6447fe49dc19fbf174a82d0312ca0e140a2e99a696001bd3cee12d430984f8aca8536124d027a1c07fbe86b7c00ca694572f829c2988996862160807c5657a576adbc3f91d0ad6bce458c8c560b7b156481eff84bfd4ef6c6159f0384ab7a36ce28322be76cd342e69adba8e9b81b294eef29398dbf8c66127ffd710543188475d3d7b98d7cbebf0b14dc8f4f2a91cafebbcbf039fca0607b9727c71106ae4031e32826b1556fd982db3f34b377377a6464a8d36d570191d6d949ebd38561cd6a61eb38d003c6817080d02185f43951efe1fe0a0a289ce62f37cbdaf3143c8edd3870ed84582351e14179ceabe0c54db313665477c07ce521a3e08053a14295bd70107101f94403cd009a31a2470974cc70d1095f79ae6e9963af9975bf1ba2fb6b23af038ce24acfc07623380ed356f1059be730f05b553fadafbbe3a277585648286297ef9e9a03152363b8b7bb342033f07f51f1d76687e248688cdeddb0a96ab0ffbe8c82e99ed2a2b6f61bcb81fe71f5f351d4908cbba274fbe6dccbc14bc992937af5a1d390a7623903016b503aa5d62cf784d1e64a4be8158cdbd438cc93dc7f3ff3007672837aaa33bd8c97acd168bbc3dd6671050719f8a00453462c55bb0af7d15bc6ee08aa897840a168fdfebd62ff812de8d8bb057e94d418e54244bcfb5a0c6174ad1de8ec0ca37cd394088dd5c8a4d6fabb15b53dc39a552b951ddb9cbdae87d62ae53d4b3ec6f965f7cf5c8dda9fe50a3e6704ac00e5d1b3809c843df363ebbaadd7cf60cec3bae62e40def933c19bab7c7306c806236ba97195f0f5a0767abbe58c7f713d6fcac58b7c7b3c7975c5ae49186dc996e29c67df3d2b2555c0dcbffaace8e1e247209bc51cf2fa1503b304b85f8c8934aaba9b60cc47d6013afa3023f786513d76cc8ffe4d8864f4ea327fc5ab02845c600cb6583e4a2754a2977b330ea03b7f75255d288981e74aa26f0fd0c6ab66eed599c3241ab3ec31b9d7730f5ab79d245b80d0aee5c2241392001599f6ee207345afced6af881b225b91e833f01b2780e3a86d57646c741e07a728aaf683f406997a0c9a44c69684e9a056d29dd778c1f087b5eb08d6c5134a26b54b98c8b7965d520975f8b5c7d9226e455a8e9a3aee184d8ec16db99180c64afc2f12ae98ede6effb9badc9b48a9ff24c4158a02a35b88095c1123323eabd3eb5088b458a9d968e23b15ae823282484687ce8122d6a37cbff039bb2e408f2b16d1b8ffad3e6fb31737542b156117bf35707064a8bee2a9a105863ad1823f2add6afdd6cff18ab6cb1ad04f3de10dabab93d514f2e3a26db8152f42319bfaabd25d38d434a2044caf883425895129531f046ce1a9c790a5d558164a54ecc5180a12f3fd0015656a80177ad856fd88cec2dc1958c225804ce5e998af1708a1901d96ecca8d6ba5f3f62fda99c9fd2e4357bf881075366463d63f49126a5bf3f73ed88b21b543c3323595f95b1919442ed3b5adb71c134c3e5b7f1ad0b6aefd58389aa0a7c73e77e5dd940039d2b4cea5e5764c246f7a9e7329d6f35ec9bed76d2592b5a0b64bcb9d020639d2d796672d373d24b526ed2ee4dff7b9021d87565a693cb815f925c59a504d9b21908d33cc2337268ac3848c6e26c6e09a99abe204c347762db9d858cfda963cbb633ac4558c5128e331e00e1cf2401eacc873135e7287b2c5838f39fcba9180335b83fe1d263f0db0fe78f9c7da86419b23d6a6cf1e1c0ac798df009e4462f5bf88a4daa0ddb14cc31992e9efc0f71a86dd662dc79ef675a410406636b600c8a11bf044bb9e65e127f79efc01a8f36b5be9eec451887b2866a090d1d71659810d24fb96cfdec77d656e883205d52f90771f5f9479da2798ccb00822a3adbdb4ea56e8775e0b01a5632d9a015388dc28a14dc46f750decb98b3c5e830d56bf1a81ed2f93f7383889a0dbb3106e56ac09ed3f1864bb7583025132145246e8073dd25711e89543feb61f0896be6c9f0870042581b5472f0a5953906eb9f306221279ef8d1944725e8da245b5d4ff60a72d333986e2f8088a25772fa63d5c64697b57c24a134bc637252598b90450e7ff1146c1ed85d3abac566b340258526926dbf6e5bcff600a6a2cf260a0508944ab41754f91c10cc27df766a978eaff2d3507e1d38c4911d2b3663104558d7c29c55cc9940ded272d3c54ef440e9b26d40e322045dd9bccfbc709f3a47481daf75b880cf1528b2f8b13547564b79daf012d6bc077e23fb5e1905c7a08fc7c85df9653d94d584323dbbaab6ff64778e067a60079cc76f0a738951d45e25cf642c56e4496b70749187f4fe7e7884b8ed1bfeaa1b667b7a1f09da09f30002d65e4b8208b6a0c389affa5de368deb088759b6eeee06f90123064c73c54ecb31869a28845dfc1408e84277efcb586c20799ac61c94fd306d2b58c3e3b37d96f571f41053646a193bc19d07b719b6d9455273f5189abc0d6251bc2f81588572347c45af5219a48b77b89aeedd9f6b1d6bd428249ba6b1d88532e1a656f72168492eb479d386a69ac09571a78e02a85c62459135562fe279ed8ce1aabe624a360f53dc73f1fad50b49e7e660678ff205479e0e9e905cd9e7444fc75f3ba939fea2071633d4be2e4b1cb4b98eaab6883f49048bfd2c61c642f33401739757a7ed2411997da3a0eba4149abedef5c267c6acd4764c29a6a757ba6c01dc7d73b2040c3600d2dde87bb09ea1c67b98f067cc6ff0b4ad087789ea960b8b3cd31aa65a35108ff5848c95da785742e6c8c325f9037946065b234c097362b1d0f2b3b02e1a91e9e5607f2035b4fbe4c5a0cd2271a4a29c0f8116cf1ac4b7d6de98494a7554b814965020dfcfe01cbab5ef012d2b8cea27e75ff10ab237c43cf715153a2b1a966fc794801ca41f4aca1ea59299460deba10d311b26111f96b1da69e9a2aeba7661f02d0b33260b11a812e9d94389c865eeea94e2060a4bbb4de71631c496fd5d8d66a0d16e8bbbf024e8bbdab4372154a7f6320a56931e72bc1fb516fcd668b0ce012a40ec4059135681309471a1998baf4ce444b22a864c72ea07c254eb37d42945fbca73385ee353940fb900c0a975f25aef836534df3c580f2ef9cfad9ac7a4ce40920f1a2a3e52188c631589ebaec8da0e95ad0b08969a70b1b333559da4f184d8ec56223aeedbe40a557e88a01a959c575e95b0708279562a2decb86b8e89bdcd7feafbc94a10cffee396efe112b7b201f830dea7c858998ae8ce569c42794a9defb1166d862c8617ccf19bc30ae6f40fbfabaa5c81353ab4ded381c8a08b29adb628dda117867fa1ae2cedbb5b7dbc8b5803161bd1ff05bb2049d456f4a0f6099e7d3e2d2777b339992eadb4bbc3fa62729b0159069ea1a99227f6ab6e94b27a9a87b2c38c0549f2d928ad9a7f45e7469b596adc87014c6fcefcd761753c8abd50b5e499650952b9396e61ac6a0dc9eb9dfcbe4dbcfc8be266af9bf9226871d9a5330250babf761d9d6cfe6d745599aaa4ee1812cd6242a59dced889a8be09e2d30158bee974643c566e0e5aa1a0c1ca35c4047ac64827bd59d7ff7447e7d7251943c5b3de2d6d0a87d159ec64b12c425135439aba561b96a9c1b8f0375ce87f501a4f6db07095912b3939b0083392c2608f007a549a2a5056384840ed9e64092a9a21a239db496dba56bd94906038dd4750d6511202e28b5e86f1a06f375eadb333a670b9752b95f09547e4acd330a49e2affafaaa1c6a654783b3616f87c630762e5286a62fb20f7d939894a75a158b98f1a4cd93c6b60fd73b8e96ad1918aacaec8142f4c35b0f4f0ebb5e8ec8dbfb249b3910b28518caaed456dae5365df5cd866e6668b1cbf6f5f26be8cee80ce5350196947e91d00544ba12ec732d671b4cf9dfc7ef3404f35857716484eb7788d64a47071c789482c3a11f1bc0a69e73d2f4a68bc50741385bc7ec42573245065e2bde3de381a60e589be54340472c75f13649308bff9f71237a263553df7436127f58fffe04fc45354d8f61181cdf9a06f644180d73734f777e86294934797e46a629476de791f6ae8d7387edd7ff3070b1b54690922c72e72591a640fe91e50a30bf325da88cecd9989526a0144abd8a7be49d9f97fb757ec8c112895c1cf509408d1b1b6a137ca4c315997c4ed589038022ed612a5ae975716126cd12f0d0bbc67f945c409e128e09f83948ae7020618ccffbcbca5fbe2100dcef810982d14382a309306b5145987da4fb71b289e7b73e277d97e8addd0f30a840c1f107332a717ea48d6c674cae319dd60c8ecafe0f203a3f6a7417fa23ee8ba3374ab3d868bf05370fa7ecf49203ecf323ea0175eb83468af5c5f99431918b4a4ca848bba398ff36660cb05246fdf0f2c54d4d7e93a97eccee4b479af68793217a6dc314bdf50a6ab4ce6567a083626021a10eb6cb0e9548dd3248ed188d5bceb52ddb9cc0c59eff798f5e5ceb38218bc4a3762620ff8d9ab5efd0a8950c74d085ec2cdb3d6ffd694a6bdef340f14b35fa1f9b2325447c370f26c706fb8ad2ea1666bcb88497e21f3bc764facf002ada97ccdd52f6dee047dcbb43b88e04bf46666f658ed374e819bd2f8e6ffb4dce96a2d710e079b4c7f98e7368356980ccf5df73356ccf398fba066fc623ba3d2c6dd370692758ef26e02cc05aa208db54b09172c2989acae15d4152b6538892d361b37ab15c7d73f260461e364fdc783ddb4b406a63ca1c53b0ee3daf532e4a8735cbca15ef4fb221e6e556603b2a50dbb674c64ed61e9b41e20153a789563fe2459d204bdcaef91fee4e8708584c25f4dc8052063338fe48b1d1aadfb5e964cc25637b01a1c7e86f22614efe15372eba5a0c66406c66df3700a718da5cfecc21dc929cf935cecb26db827df0994d1b82f0b22154449d55ec4e6ef9fa913f3912dfdef7cdf13d91eacf1d8d93980657f287afa94c1083f110998bf18a4b3d0640d781220ba99d6ce22701dbcdd49def017f27b1b5a5868c7130fff81ebdf93e3dec0bed439dc63955be1e2f4e8ccd1631560e3781162c5101ed1c19193865b176dfbec5b8112bcfb61397054350299de2adccaed77ce80b9e0b827d9544b569056ac09e2fe5c8828f3098e289989279791a5b9b2f9037356274a3ebe1ac8e50f3f6b41dff14b5de4448054caab6e879769ff037987f12a13c0357702dd13a719528dda1d2c0e7fcabe6e2caf6ab451aca4f698c85990725844ff55fa64aadc0f4d17c6e847acb1d0b0467d5721a1f0ddc048cb30ad95cc92c57cd90c2c9fbe4163be9367451f47e8a4d203542765d9c3f1eb1958a6af3ff6602d9612c81ff332f51cbc750173b7d7037c7d8ec75ebae9973626a0788ae86e28ed6966274f902565d7f4be0e31c64c7c6c55e017946c4bd27e95d22275fbb4fd512aaf0572e0e8f8e31a6ec9fd3750957844f901ae4407e5e324b6f5a9ba0f47c6d424fb1ee7e764d208b681f389e85baeb5e53065c7339523016f321ca86d8e2080edc6664894afa8e4c650fcbea803e2c58a5e0cdff6e3a259f2d361c8269ff149400b9437f7243dcf7cb7e92aee772ed5935b0ce1afdecc1841f362bde7913c020c3eb3bb5cb52fa32aae48b84f6c738a6eb9cccbae70ba1f703a99ce4836ecf3880ad7f1a3ab8d6e36d70718777c5a0fde6f56836c976e0f5d7b6e7eff4a3246d2d723b4ff67dbc568cdf35f47ed8b99d9651b10079e3461b044dadd504ede7af1c6f28a33af0e13e92566d715866a21b1fde83955aeec946eb143ffa74ac427b1b3315f1a92ca3cefd7d5a1a8ca8e80d42ef9aa5dfb11c96b6a24e04cffa9aba52439804b1e381714cd1b5f45fc97d46bb2a5854bb246f28bb7098df1f42c22a15f927053c72523a8f794170cadaf33f08900e870c2d1a204270e2fe83cd36fe2460675dc1542fda9e4203adbe2bd6b9d29e851b21a280890f2a0dbb8f700d033f23eb06f73ace44e6efd0f16afefaba628142fd214bb2dae5a644a5dcbc91397579960067124f867c40f1cc9529df9cf818ff2fec61fc24ef42b243b1982a7ed8af174b70a7c726ab5f21075178fd75ea0d3fa81464f38c3b4e787f927097d77549119aeb70d7f28370667acae34ef2209a6ed00e39568604cf8a19c14cc085772eaad8b619a3a248f39d3c5f51d496d116fded2530b1a8528dfde38df36378bab151eea05edbf9d2fe96b752face37771af828b23f6cdf4817aec5c0a3065a8362bb831afe4d0e24fbd9b0c8b25775af60c9237421f199b77e660447a88ead6fb899b93a5cc0559b09f1af00483de1f6d7c13e07b1a5c6a095e49b097ade1bca6d02ce7e2197cf23f0ebfb0782df1a96682a85dd423da16aaccea6cab4998e38da36c47e54661c4723dc1d3f7dc7aafcd62667ed4cf302b6d22ac6dd501f91d5a408f2200076a397114d6a3dcf17392399ae09f8882dd2678a0229e61bb7a391b5b417fd94340719cda26ba21364511a74250f5c993a1a28011ea9d27ab8c3d7e62849e7c2a58734dec3a5a76b63b18d02aa1224d78eb5384b97e6723d7fdb07c59fa620c83daf068522e88c5ac02dc4b35878a8767a16e1636a31a7c6417bad7a782513830442bfbda7116de63a62368273be24937f70d3a484c544ee52bed08a02dee596892aff3c613f912bce8f4c83105c98655f5735b292c7b92203b31c4c3fcc8647c09fa06a29aeda186df0556d1d16b07bf7e7425ac0cd580984b11b7fd3430f4bec46dd94c67e66280e7ad1ccfe398f71414c89144da2f404e7151ffc1adf4cc9ab5e56f9ed72578e977dac27c98627e8ab0ae136978e6e9a68a77990b23f50fbdb78eb007120a6a27173ceec22949c01edef450a81fc07aeed0212d659c082313bef2b54f2e87e0b93d6dc74ab968441ee0a4fcc8e2f7e1970593284d9f106bc4152dbcb98a45a8c74ee90ff5c16fd4dd03c0c06efc86e3a561fdb364b20962dc2f4c3e532c1b87ec89d688baac536107bbf277bdbd3037a8480e52695de3c9866b5d74a75dabcf523fe5d481eb198d67fd33ddd0b976f2a471f51d274ccac3ab007eecff589deef1bdbff9a8a0569d8f40110c9d3c882fed67bf77a43bcc3d5eacf1c70c457f9ce4061ec9f880812f3c503332077f25ac2fb43934beb0c009b44f34a4158e25ee606aa005e1e853b4bf7d1b6ffe18e33868963436781056ffab98f8d5b62da32ee2f1e46eb960bdb5337d17a20506dc47c27d74094164eec8a5c01469778fff93f8fa4cf8c8dc04b3b08be2b29098669dd9fb97298b1ce8078f57dc5339dd850fc807635072ceb60baf01bc8263289b7eedcc1e9417e201feaa19e09603b8a6ea25ca1c0f01a19ee3a9a378fc8b39524edaa4eeae2f2a02bd26a52f061a40dc301180dc303d4e3e60a07049eb9c71e5e214f88809b0dbf6fe8f75303aeff31031faea86cc1345515181f7ddfa7334485afde8085731ad95bb7feb80b32fab9e2e0a13050517c568e5bfdfaf26ab23d4b9689869607e26662a3b948647b322421b9dce279a9f1e60a3ce275e66f4b9def3da387e4a5eabab5705ddc09f9f7333b658a4b4737f09039f9210ecf77004bb9ca682ce89ed1ca178a6cbf6943ddd4c0daa7faef7e9ce9c31ec80988814a73b3a67c2a884dc9c61c2b595aa4fb334e0b805b801c58bda8d3172976725ccbfc87a41d2eba3a17b1d90adef2b9c7eba31e0840c668e1f5d741fcdab05b286e658be165c0b238f437bb89bb059a9b672cb1fe3df52c406d7f2b1589a7e6e22981b01a14f1bfb1e806ee74d6667b1a5d23a3650053ee59c2f40f0bd3bffa580d141afd3690f508ab5044fc91cc14d247af23d1b4236df5844e5e16635691f0a3fc34643f12b2e851a56cf6350603f5f8a231d57f2b97757fccd910a3cfc60117360cb2e3f4f695d40f99d326c52a35e6281914fd5a8c1903b5a1759266b005a6a942a2f671b3629cff94333e423d4d0cf4c06f6ad81963ad38562a95245db9be38508e92ba776e19e02ca96303d9a2dad15b0b299762a3b40cc68938aa0ddded6766dbbf36d201c9c6aa55ddbc0775761cd7003e0b0d5b8e2482e775d4f3f55636bbbb5be3fdbe1735c1535d47bcfc1b4f09079b552caeecc33adf13844eecb4d9e63b4a2e723662b079599d27a5e7d93aeb2dbf1b013536bb8963e40cb09197a35744ecd1e957ab4abea713e48f9748c21c225edf55f591081c5d600bc809bf920c4b5cd7368b833772fff19a57233962297168f1903ea642e47e989e4383e843487d4619814dd158f1c7988bcabdbe30f09eb6953485dd1423591c6c1c2a9bd42078ec084a58d604a24978da49def83f1e5eee3452392159fe72b45836b0d15dd21431ce8f096f856ca173dadd5cc05ccd2fc877c5c435043632603f60991454fddf6dcc83f4a8633a36dd2802cec05910d17ed7ad040f7a263f03d244692be27d45e8157c5cbdeb01088b618ad1c87af52f2565cdd7a18375ff34e44eff88eb109d7100d322f02e3cdd6b4fcf77a377c8d7e0e4d8cde4a58894569b0357f2df5f12af43751f3ff80112bbd43c6a5e4d771929026579cebd692a1255cefa945322713b967dc2c9ef75ae4bed1a9f1e759bac01b4276bdfcc0ca511a1b38faf1303a72e9d31d2991a3b17f3674d04449056d2567a71573551a9785eec7db4ecc0bbbf60b9aea2f2ae91c30870edf6824f5b4e38d2cef9abd2556b64002ece85b16ebfca650e31ccc74217cdd2bb7e7e9995ba3df08266b3f9d04a09677c21a3354bfbe28545635f8ec4880b4fe13ee9f7e57f16efb58c3292f1c318e81f710009c23a80395b4f12549c4cab498e679d67e8ae9da7eab9777096a2d3275c7f016cb7c82c3fadbec66677849ca3569c23fba6907b69c81476719ccf0ea80b3bfcdc79767db318221c582c3aefbd3636925a46d693ee18a4853fc8b3aa55ec4e1353e28c8fcbf9d6c6d7b231ec2884bdbb1009904d341c1689cf55aeedcca9e72c2290eb04a4b903e563da20980148acbcb5d1cdb525f7908340e1679dbaa0f6926a109baf1f4334434f4cc4f035ae077a2044ceda92591ba6e4cf870e5ec5bc9b6a7d8cc3ea1bb16ee13e31e824b3bfbfa98c40268a8d4a3a4f65c95f7ae57ca5ec35ed777120abd57a76b2bf55be62f214fb14f034173d5d1d61889e9d047db73c39e180f4a25a13a541b50480e22d89a114d520a7455dfe0a1da97a6df318349f5935301b02106f1d561163fd1f921d6cab1da938bb7abb39a888038c4f28521f0bcc5bc076263933e60fcdd6f73f26430336854827b266a6f137585e813cf59872129bfb87b94f87e24247698cad12af4617567f57b0484f5484bbf2c919ad5f2b014447b4be404b1a65c13b7a17137fe7923df0bbd8f213d1df0d851b6a642974d7d7baa3e7390930b0bcd5f2e4b3b7a1ddd017b439c1031a3397134010b69b1aabf6468b6d0a2dfd1ed1cdc22c1bbc1f78b233ec951dbf2d70feb2932dab8c121f8eb0ce4404cb8df145ca7d0166239cb47de10e9cba67bddd9773bdeb617160be6b514d619a3a1fe272d9e1eff5c15f7e2012c83ccab44a28d0abde533055e07a0960dca361442e758a3ec1cfbae69ba0cebec4d10e1e037d77a6a602f111392b793806e760f6800afdded2c83bd41976427fab5ca948077b089bc927ba435d68a7b73f92375d94eb33dd1c78e342976da6d637eaf4183572726c9a6a313f2e3d686e17126460e454995536c2c0abdab06eda4b1536a238bc0e11d800b7a5916c20e07e1826fcf3d67f028e9a96b79bac9bfa989a14282771b41bc64ab8f8810a4416dbb58d486b338c31ac802aeed7935f82a8bec780312deef9106c308120a36c9d565cac79f4a0f6c93d756cea185280dfce901619bf4cac89c14bd1f2298a4f34c20e3177e36e3075a20e3d4f0a791fcd629db0812f4988bd8379f3948035e553785a94f7910492f7c5ce9299381d2b8f3c3f8e117d30ead004d6150d0d86a3058b0f1ab3a9668e2c234295da53cd94f922585ba2e5be67c72915553c3d344e2d41eb354e74359fd2766f6cb807fe29edb0b9a194f0ed58892cf9508900010e607b7819033589176f6210f46c82ab9493821597ff99071d699cc128716b66f99e4f30cabc44c9ee0aa8cebd66ae385056c1ecb1577e2a6d04799b1dd1895ad1ec411bff23c90e4a68bf001842b6a5576083606c30140bca60010659e31a3f763373e95fa54ddeed4512982de09ddc88d80cc083ed1722d3a9e4a9654e3f36fe2ee04ed3f342fabe0fc8a68c309b4fe575693d77afea561ecf134937b62b2184d6af9b4800a40d2519594c54f8b3b2bbce44c274cd2038634dc4ff8490911e56febca4283cd7cf56b12f5177284126ada27331bcf28cd9325390061eadcafe77fb358d1166249a0b1cc81226703100c774d442b65f8d41f1ceeec994343742b6a920cb7e9c4eb3c74a80cdf9a96a1188b7dfaac10cede0110eb706aa6dd184a2468b496833768fa63dd1f01492b029e32375f5c4aa4b7e32e9b33ca8645455d3d1f5c8098c3699bbb37e2a572d4ce97b87450f64ee01804e46199ed0570afb0761eee1c0399a13b3d7782ff62f67b4abeffab8fc8fa42fef31806a260f7517c5c4dd146a5ad88be95d229a28f7355a1457a90c555ffbf00a987f617b620c0f6126f02761e5154baa9bff606e2dbdf0a2abf14206dc326910df7af7ec6dbd36f25007b540aec7067caf4def18063e64b2b46034204104e2722115d911717df5c239cd7396a8626f9133a1426b57800d2f2ac31855269b436aa006692d7239d4c07073635835828697c2ac382822c07159254e80cd4f9474df9a5446fa90ed2ca408be3d3d52b189ad1dffc21dde8286ffdef8d35c2c0cebeb386198c2a7287a340a48c5fbb6ed044b697140e2402a198fc5ed2da6db1a3cbfb93b0f81e02ef01bdf6510bc767a5fd9457025f121610273f8f0342026b20aac8467a3c03e5b5c85b225fe421d6229979f823f95ab09308e5e1a0584b44f374ede03c700f9974b1b0ce5c83b19b79cccda4d0b150d1d104912a54d12bb688623f58d230c193ecdf85466ce6f55d073855780a4bfd75ced3cbeebdeb1fa907fc4e91295a35fb40baf1f2531d13095af3e398dbf715e520e079b44a601f6b58f1ae8aa3fefc28c2af9a0f252f8bd64fdcbfac072381376451214d26333d43bfcbbdc65f2d5ea0475e17ab8dcb9bc1b3ba58b5b2520da8ce129bd1a5d01383684466570efc3da832589cb39be0876ac06cb18edbd206d3a1a7dbe0f845e2e7a013952fc2cd47c31851c185f6248aea9498b73460f8981d11727ecd850d6d9d96557a65c867cf5459d106c4998eb2e646d4696fd93b793e577133c6520d26263bd235835503eecb6b3f9ad7aa512d54835a89aa26c4f7271b124f6ce363cb2aec49bcb3d138391b125609912a9708ad191f167b3abd6f58f87773c6306df770980305611128270878a79db4a6d624b8a82e4b16450582335672b32a9a8aa3e496c2c2888ac8c4b6ddbce3ad843cb88645d0de4ceaa59df36fa63a2f45ea5d4c5645357e7dd5ef729f142bbdb941738ef7f98f5f27b459a64f952ab60ea8e1ed445ec49bd670116e3290e3ce16e3d416d3886f1119ff3c21c5d09dbcd721256387cc01aca1f89091e63cbc5169cb8e75cc6bc60507d5ac4e4765e3ca1ef9eef6e35be3342e84a6dcb466eddab0656572782de763b0aa40e079a2e0bbbe634d9cc133bb8155e41e8b09ff40e5022e818183c47b13d4c7e1972c677b50c49745a9882e8668d05812cc67fcfc1bcc46134f5f234d6064ae1952ffbddcea57032c33d2c82ac9053fa62541903a21dc4ff28c33763b5f0bdd089d2c21c1054a59fd8a133ea8f533c0edccea252cc8a57c6d26230ef35cafb5bdd93c797ce92bbb9fd2d5e14b464ff7efb54253e4249191fdf8909344b34e1d3ef2b9bd670d3eaeffdd31e7d2bd9f05b7b00224f56fa1ba4184f850a80e56b6d03afc311537745169001b7b3fe2ce5cefd16607817774da9b67eee2f059dec11ef20e207e855bdbc6b8f39681c6efca5e8c43cc4c79a86c05fd32bfeda235a5a10130cbd8c2dccbce36ef8933422a144506192e9d0f9ca0feaa26d33586b44b3a8cec4056ea64c17d326f623894ca5ef0e7ea916bfd4cfdd41cdf8327a2108795c46897257a29ac8c21c484579c68ab5ae68558c24007c6a144dda651b4828f7e4bc78b15fc0f4c9847dac39c42cbb6a227b202910d3805141cb1d5aae38b023768dca6f9207716075f5b0f7b467aed065dc92c09ebf947872332153615b27f76b85b74a50177802ca480cd7d93929bfca177ca136c676dd4252241725f101b922e106a4e7dd2597ff815de2e36fcaf78c7288c25b7ea9b24b4e5b80d9e6dcac1292a0685d6737ad0cc3f6464e9ad888ec85028b7235098fd0fbbb05af151e38dd85803f28084dcad39e5fb1b6c58b76194b0a2f15a3ee59b8470963c2c0bd5a45ecef84adc33c80a93fe310bfe39de5becd18053d791ff40b365cb6bfd5e30591e0c97d16a75bca5b7a3cc78f8402e18bcab2ddecf892866bb32fd3e468a6158fd04bd9898d533e4becfad293d54d8a38b36cae983c0d966d76c43398478c0bff939f7357ac712d5f0eadec5a3a7745efc512652be9a9c5fc32f992d751c5e67398b005600d28cabf7e4df16a56f068c31c7e60671d553606fbed0ca477e92f293726a73e8a2bcf7692c4a61250d2570fa75086aad0eb913afc161fb8488cb6bbf036540289f93ebfb99cf35e5a57d5c743e0b7df7ad5e959528355770f660a7e2e5e27af8d421d3bcee1c7a2dd938e4eeaa6bc465d73d51892ccea7d38ae543289aa1625256c29ccf74d5f9f61953a88cb4cbc7f8eb15cfb15264e6c5e6f22911207a6855e23b752111648b3c510a7e7b1ed447aca20ff2d2528523c55c491fb9aefd47e2b9c4b45c3b317d2effe450f6ff3beb6bb712dd3e5ae676a4551c8ab4cf9fe4cea5f0425cc65b263c0c7ce625a3268388c38fe9ce3057b8204859fda739facf1e6e6283f5e811455fca9ac7f3f1d0040d35b187524490bce15bbe28afcc47edd28a9e40335535518875d948035328093ebaf154dc0b811d3c9d5d8269b79225363443519d42f6f210ee9879476ddebffc7c8b321e099b05494f7ad4dabc0dd370feb3df1f66dc380d124bd734e7f603da6caf102b60d04bf3a72de9853028598c8d7a91926d644c756038ff686c787c09d0003c508a997cb58bd295546b7542147d7d0e0aa06f42f264caca45ba2ed87e293a674977b76ff3de7cbb61d8ec4b204634cb7f04d7fb3ee4428cc8c9eb7860622b7dd9dad3599191db7a718d9ba793a944912fa4c3cfd55e34cbb3d5f62efaaac5bf4d8dbaba8f364cfdfc7b2244f4e529895115818777f1f1080a2bb67b0c06c0c160c56908d90c05a51f443eb9e0cb04cddb6cfeefeff7243fd61f56500ee929fee2f521fa9636e06b4db9acadd0c9110b364286af72a644c6c8ea8e9a7de3e4fc46475955c043b7b3da7c5fec1f474803bb7e06b395be017b68c66a52524e55f3eca9cac3794eacaf0825f2b32f818af359f749c6fcac192713e4cf50ecf360a44dfde4881e1fc29633c682add3311a76b2a8de48acd4ae4c1315a9f32ea8c9f56c3cb818ea671de5dfc149034a115660638015d87030cd4f1de47a53ac330b66bfc1b4fd7a875a7fefeedef97304dc5b726c1b714de87e6a2b380c03c2c498c6524ce7cdff72a536f08bd2ad3c4e1141e3177ead9e579b42d4b5b557b1a9c71b5737fdb78860bbef6150b55b650241b57c097a34e8e9e518eb0d81b605223f0c26ece8d8f5ce77ac4449d78d0915650699f12e8fecfc705514fc3cc62928ed708e085d4e45948761c6edc2af592548b240111fc2fd7a061ff7f64b025dbfab0059abd506fdda34208f744b300638cb16695c336a91c316da692c2bd0b40b95a6bc79bef8344ca891fd719edab30e7d4ba784d28ad1f7d11a9270169d84a2c8e3a97483118c9330c8da58c3d95ec8ebc4d2fb5da7e5e8111f74ae456ba19cea8c3ea2768075e524b538c7ae747e6469c4a240aee3790ad1e0bc82fdf80e2642338796b996c2730365b70ce722cb5151133c4e40af19a18d65f7975f3fa56bc63ddc2c820095ffa74fdf4aab018cbc60780a84b7a787bcc3c7a9a3bc0cc8bf097473e8463cd7ba6923e009975d9f9fb92c42e2dc1b493cee74cf522ec2098525a87687d82e2bf206908db96fa517bdc48b09751340266dd7004fa34c78f5096f8c53d2dc99341df691e8a00a670a0aa47fd79a3ba4f8893a9411966f6243980f95ec7970387ab5d29d812792f015711d0372282c41de4748c54cabc1f6a83120fb05dbe4a740ab5365640a3b21d7d45f312bb34be0fb6d870f57f89a29c317dcfde896fdc059826f604d64e2b0e4e8b179f198164c4bd6ea2d52ca81e4ff953e4a87c14a069440c97932712b3da5e28f4ca6b58050914615fbe2e5a4de1839c53536c8b4a645968f3d220fd13d80fb12fe98e7930937003850b20b7a0e6ca14ed093c56625fc0ed3eb97a25ea4abdf3597d39ce610ec9064012d2bce1b8f1aede0ec9ce81aa2cd1ddd3076cc3e8bcce8a5dca0fa5a2da60ca8bce0828afba497218f6049535b23d7f02ff6fb4bc5d3e88c25e4f227f1fb760c5db76c7778daed56a9a27e975a30f024910e9dcb5f67a7e205ad99ead2a5e091a8a4723a35bed1b75585329a3b62d5cb53a599f2ec10768df9f098591d0a7a4c9c647dd914aeed444784f7241c2ff65e1268c07c696365e98d0ebbec1fa3ce4b838833866c0b944de3534301b89172a20100bf4117e92263693876861657c5c8ca3b2bdb132f48bc1c2f99bf747f8008ad3e4e2fb5557250e9d6152f21e087e279b0b5bf9449126f33095116a131f93623b334a5c5714799ebe9c8f26834f2de247ba7281f784765c141a7aae3b25572446fb19d5fcbd126455e8468de0a41d777f396505a48b655278180be5806595482f8b4c49a4fafb9f8b59771a288c6fbe49a71a4c4db7ebd54d091320d9b77ba42c20e61808e96c55fb3db6f043ba796c3fa5e8453341090c8e48a053c3e12a57caec72fec6397cc9a730617798d9d885e3ceb5632b51ae89ab4ccb00055f7d3aae9306edd77ca1e82fdd7bfc377759026aebf4238f3225c6b85e5a7a5087b4bf4f46413cb6a3ef6fbdb2347d0cc96a30f586e5e1df59db7bec4301ea03e7f4524e94df74477c5e7b6150fad3d9a3807dfcf84903fb39cb5bd67799b924e5aad92dfc5afbb6b1705135de3cc3812c0e5d6cdf9eaab06f9d971c923cd78411f13a424e764bc6b2619e7c4c0ea1b02d682078163ad242966eb8ac0a754446b38df361c038d5e0647bc8fd7ed2107346c23fbc5d544e8c6983ee25a56a0fed29581b3a2afad56c19710cd60fb80bd8c29e64e6ebd35a30d25ac518122148768b4525851dc40abcd1e4bfbaf832fa3b20ac35a6d9872bff61c4077f9bec9ca2766ac510bb171766b9f1154e178d15630f04ea68f2a7814872397a1bfc33555823732366e5ba231361d1e67871368ca19b8747b6b13d9443b27dac5e03eb3d6801eddd7bcfd632a5771f7a30f486471b63518b7a74720cd690de30b43f378401fbe4077cd364a062fc7983a6fddd2b478fbd8f888f546fe458c9afee0bf4c4b4045e98a5a579a4b26256c115f88721d5ceb189cda427367e92ffcf33b945201a179ec0651621981ea58c99d7baa0498acaff9bd9bfa9c0e82ff72aacb5259afb32f9383c1b2e64514ea4f79570824ed9270e41bf7608c1b27ffbb6b29dcd434e3e213fca8d9f02d403581f42c3980b58347dcf97a1d917a76143380a67f7b461a45a4f0415b509af5c3aebc174379ca12599f60641dc98d3db89a61cd0db7d746f2a44cc94d0ca1781e4fe9bd008cc6a228624cbf3924e5c6236483c96b714cfa405a338f205bab19698a24c31ab9d0c491f946c84687f86f1a536f9efe078f11c44e3444452b5302ddc3c72f07549ec9cbfbf87be5dfecb2d50e37b504ddd117623d46f8408d7811a87d7796c754c1b8c14b316bbfe19e116f7198a5772986a40370519de5766124384f7fce348108f0cdc6aabc7252c71cc1770c441600606fb9973e9ba72992b05a2ccfbcebe48e3cf95e5318cf33b58c79d414c3d0660553fd824f6758099d172b5bb7ce22db011bc74932fb4350b206be14ebbf029f9ade6901396174a7f4723a91bbeaafb4f6b89117b7b6d84cad1572664bc859ad663518b689b33aec9ce583d1880764d3bb95e4cb5f37c11485ce264532d3b67ada9afcf73e53b2deec5e921ec1c847f2213d30aebe39e5d14b8b9f2d87b409c2aa064ecf6ed9cf75664c2bc5e55fdd00ca683f374ce6870f95eb8cecf804246a5adb61eea1b0afb1151b82ed0c59caea7c683e787a34e235448083a2327ff238d9fa4fe39c4068aa3beb4764d26649673cba80b6a033d390b5894d06c3675039f64d3ac10789aed6ae3adb9c60f1046be543ecdb20875169d01843de87081e2b22adf3064c77f8bc842c2986b74c3bea664bec07008364914dca4a19f6db8ab49aaa90898f4044d61cb8700a16d81abd4546ff217118708de77745bfe3edd4b342fba87722547010b8e18de7a66fed4d74c56cd6db9f4a1a250964aed7c533bdf5a075bea4bdf1ddc990c46768a63d64fb45e43054d1dd1adf07aaf83c21eadd6f81506e40cbd639227c990d9b7cbe6d47c86bfd84e3727317a9b5ff267f23727eb7ffcbf0d064e8d68644f198a38c58767b144d2e1ed4e856cdcefd145b8ae0a7bc3eb4f089baa48276abe3b20cad0924dd6991de3b2fb20ca946331e9a00ac400b30cb878048fb1e53c1d468b230dbe64d0c8da25f084366f759f97f96d650d2bd0a0401131189b5ab1a77c06766420e93b3530abe4dc044cece2a54b02d4eac8c09a863b8ccd448d17766634a89763e1978670c49e2ab9b5a19ca3d05438f2781c2c7f8f0ca2b49306b2a688b0dccbf72d0ab500e861b1a5cbbbe75494fdc1a0ed9115b365ad7ba711cecb72ee2c028420b9d45186df642fd3c423242afdc92071c147bb5af35545a814658b46115c989de1f2df8a6abc7116ac217c08b8cfc5a22407642929505fa09af2a2ec98ae5c4a64a6f8d62965321eae9d9dc7f9e321d8c71c204ad7572f75935d4578bd47047f0b0139b52df53ad1bfb63975f940da093ac13dd284937d6a1011f0d290ab8ac0e3792245b130df833967e573ddfedb9808faad7d37779b9b8ded26e101d3d0c32e1df9dbeebcaacd93118e3f1eb38c9564f5cb9ceb7f198369eab4ef654564aab78b80cca977aa5eaf33ff3d5d0d4ae50202e573628ebb6d1c1e9df0d0689595a198db728de46fd9a9567f3d178e7c6f7754935187a877ae24dff5c6d9e35c552af4fde195db134cb0c0b512f13b05e54cfc21e8a59042079b7ed75e808b70f5fbef98b09f06d31f444ee28fbf63f922e4905c662ce98996242f5bd027efbe3ccb5ebde5640b64a0e48f6a7862ffed4a69c703daf5b053b5405411deac6ac0093dec54cc3f68ad3551288755b488d02e1ed82e47817249d4ebd88e2edbcafffb14a47995298cf9d6742ecebba06cdab9efe7142b92a6591de1d715426ec94577bdd47e6cd2acf176d14109d4594ec230feef219031504f4d7e80c029c807c9e8981bbf9fb50c34fa07a9e57274c5149041dd265c43c4870db63c749ac3a22683b0accfcbd4564cdb6ab298570976f352aefc29b9a5b0db4e0639aaaa6032b1fd7a5e215c3ccdb3eef3624782b764e51abf2b88a8aaf0649cfe180e8ba5ea08e816cfaf606efc121bccaf7664915739c20fee29c5e1e214d7e60e580d94e88d65e64eb35423caae98fdf531ada2c7e779c6ebb09e909c85db3698a8b82140234ded9d965fc2052c96fb1c3ad5c90fb6034ea59c1a07fe17248a07d97118a8b402a6d2777de8cdfa30fa1d551fcbd02a4ff61b991da7b6fe807ccad6773fd50ed3aab336a39d3758b0d8efcb32170f2bf4876231aa96f0e02bea5a0bdb3751ef67f86a3d1ae286d88a7675ff932c0a6bf5f3f88c8df3d6a0a58e6814ee2aeb073357460792fefccf05b71152318ea117a816c50c46c717c474fe288abf6a22d73a0c7350617ec9e18f20903a9b5e9a3310539411193eb1a6bb19bcff2f235efb0745c39048988b51f3e1041599ea9492eaf60a32a129e5cf972bd3d30db2c926f291d197fd6a7ebf2bd7dc554cfada235a381b6becc738ab04c6ac25d5ec9a63f7137e96a55bb4900d10652d6a11673478931b182d38655b41761cae84244beab036fd64b6639365faa2b6cc192159d883ae0cbe9ecccdd84b546e445f70f0089a97e2f8469486cb8a9cfa6bd55056a5f6764f6a0585cd5383b49552358d7a5c796ec88101170429bb21b05788e5852fef3d79bfa28e0ac09f3cb35ded504ade21ec92539075a65b2c6204fd3611d30f0c4b0d2f62456559dd49786d5e74788104be220fa538e150e4a628c47437cec2aa9d2ae05a54ae0afa106cffa5c6a28bb1dc2f611444a5d12cc6e597b7748622dabf27063d30ae9b2a2572d760ed1fd84d6f7dd6e3cdfa34aabe3c56fac34a1e0aa7c7d002fcb6ef8eae2d011cea49d1876342048908b3d83b239827d02dc695a12cb15ba5664fc907199fd42c1f4484e12d34bb9aee97cf1d1708e8d82d9b52851146f43a0fe2a474c108ed14a74ef3383d9a31cc6020791f072c7d33b2665e25dbc9feab53558494ee7196d3ea7db50457c5324f7f5f75dfccd552108a1cf450812f1e3027d92725167b3a5d1ad380f7b8407fb88584df627c64d9c96f94bb8e194bb6b36d5ea89d03dace6aae5b7cd190d7f7f8b185bde0e735530f1eb7cbb8ea127d145fa8cdda279f22cdbbae805a1319de369fcf1da5608b820441d822fe0c26a8a0230e702454e7948abffd3a40742af05f9799af2403a35d30994f06f7b1de7ca1e33aa94b0e42a94da72db80a9a9813cb066ebdf22bff729f10afcb74ca5580f598115adea20a17983d2fd0ab28ce9c2745a08d7b88798248ab004e640f5a125e7d18d24e448753468f11169fe8498dc6dc2610fb2777566bc7940f91ca42896afb84d3f1e173029f35ae7ec1beedaf647331bf70ba61d36179b71c39fdaef145e1015b4d01bb6bc0306a113913a15c632f7d03c022a62340a57825ca701c811a526fd13b26de326a567ea4ad2b22ef1f6b687dd881fb8ab748ffaab3e14156d8cb99c8fc1c5ffb228ed5dddb43f6baf7bb35d1457ecff7eb5c1d363fb2b9953f384b48112c21a880688a687a8bfa1a43d5ef516a8a16d21aa3b0d9156018c726935ddd032c724dcef16272389dd89e65cfefa0853a5d37ebfcbcdb6b80ad9ebbc485b62baf41295997968a3cd68e7e084290490117e24d6dfe1717bec588545d91c31f81d550744eb1918fc3c82dc295e3a46c16b9e29959bf8a3194beda64140bac98220b99c2e67edea5dcea6d8d39277892cae00d0d598dafe399286ff07905eda2c86a9611b6a9ae7549d04d8db37caba1dd055db708faee615fccfe3a19d2f27842f23e6cc2231cb21023dff18ca9f4f9636c1a169be20210e1fa480650794f330ccb77af92d732302c6d103a73db8d0dcfb719fd5a3a664d0c2955ad92dc95fe7aab8859ffab407fc83b876b33634b6a616422f8903a54abccb5b0f8b08f37530c6303e39fe6d745214050c5383e8a8eddfbffa9ce04632124bff43f9b8758b57a9ac7d0b1573d9f0ceeed87699c410e2ab51c7f9d47e266e0f585abb8747feb6576a026719c54c0ef68bd948149848d950ef2b0db7f9a15197b2a2e64ac29746f5f2e512b66113ed54caa60fc4d854b6aa30d42a49dd5aec4b2a1c477e1a5c5061711cc5c8bad4b3b2f3d397a345b24b8302748f146d3e63be9ab9912ac480a152f7aae3e2a6edf9ffece1bdf90e15b7025c2fb46252a305734f73554de979ed9fecaea87b69bcbe45feb3137fcc67c58fbf269635b00b21c73f59dd865b833628899dbc756a08229b85aa7609e430d98b05642a9bbf8ad7e90ae14af7623093cc481157cfe35ab9e432fef31aea84d8cdc5f15335ff45f0a541f4d9f45d90d200ea1efab286d36c5b95134e404399acbbd9294be3c3b37f98ae0a1623a03a1eddd29d17a9e7dc9857ad373b2cc76cfbca2c75a040075cc735ee0d30d60a664a0b81aa347302643b3ad828a035672cc77b6bd5d8aff03b3bf9385313c7eba268ac8108a1c38d19bd020d8884427387f895028e9346ce2ccd74a07d63164d8248a83ee4d100560c4a606c58a00e37a9c159258d48ce0cca592336d8f3a5c795cdb565f1eff7252c7a6c1183fc236e3c81ec72a4765cb370240f8ef75360827903e3f55e9a9c058a9c06187d81256fc00ab08154a005350b416f6150f49aee7299556b338d940c366cfeaf74dcf0350a632cd61a20aa555cc812bbd44d124ddb29803151cd254b4cf52a3a444d04071b167fab777c7f3967caec586a154b9101a4451dd0809a804309b4f57cc81a2cbc22be776857b7da2beca2f0ea23a6d7f33211ef66b7e2258eae0053ab0ce0255b39e6a65d63674a9381adeb714ffe3fb852140ea99fb3cc14120494484bdf6206ae22a9b6d4259818782b848349ad19f9107efd8464c4a81fd429756e729d6b85666bf4bef7dae1b9980cac507a56f41299ac9b7baf5bd55bbdcee053104401cc9fd617713668154c81aa24c78be3605ac0b7e6b0e483be36e9a36e71349fb34a8512c09f8ab37fcaba3c9aa094057de4f925bd35bfc9c7937a43053aff003ff16ece769000b027edf1efd9ecc50639fba2c983804e5016963750fef5e6d9aff726e40827978550938668972f90f2314d4dbd9faab9d283813bdc3c3ec1bf2862a4e77170950f4ac6ea750027f97b6c1aa9e3d4b6f6797859b493a91e9055c80121aa3da7049f54090a9959170d5936ff28f3e5a4124217a97e7c3ae37c549c919713a4f80a07f911a5a8ce531292d73b003c55122e3bf59441603d133bd1690cafd13ceaedbd9dde1a32b77f5a02e16d727e9c16b52d1bc475d42ada24d4f450c77d0f06c896a5343a7e00402d4660e3484b95886a1fb83577f288d08d55817f6becaa562b7206fcb9400d9b083982f8875e722f5469b636062894d22edb11e93b53d98c17271d0d8d0125ba93515a00d41ea74f03c12b840d5edad2c67c15187a5e6115398e5139805916de4f974ecff292f942288a76ff18a61166999ac39cacd6faf1934b09f7dcc1603e482784cb78e81880a6513bae80fd92e67834a59fcad40ec89ef5cb6d8385f1c54bb38f606cc4ed6f7a71f553ce77b0f10ae7341ec538400b6863aa170f041758a982d0f08f80057bea85bcbb1ff886e6f036815a170bf3516f86b7140312a50194b3d3353b7ac9c54ff7610a7f46026a71984ef950de18bf1fbf3c12a2263e8027d0399c5bbc732c06add95b5e084b288b29143a4585909021785c6f68e217e7df67ca56f0c4d4ceac26c9bc7225fff70baa71fa0d7609eac9c4a22ad8e993a7dbd1ef5f8f6d944cffbea52796b0d04846d96ad9bd3a74667ad16946de0fc5d8a08675a62d86cfbf86b68c80d7161dc784a6ac3e766fc3f8399376687a799a5e4f06c62c74d84faf9be46bad3e76c39ecfe8d5ce23dd5faf87d1e906dfae03aba397e17c85ade79164c3ea19276ff0518a60ea3bf57e1091a205ee3780e5172de0d7d3f720cda00cf604c2aab2cd483d93861697ca16fca9e22045e89d59bdbaedb625729d0eea64aebe29445031157c5769408b0f244807ba97e71a7e8b3d83d5ec04dfd4a21d363d4591a9fb53728193f9d0faf8131317a421db5754a906d5487fb79a359fb3d9be2dc26b42fcef9ef560105cfe98bbf4cf5f1b4f02531e2b925acfef86b9711ed875aab07ec63c43605b2457006dbec4b245b5afff7b79547aba630d9d64f49ead66e670625741ba3b8334590a199d6aecba9c9e5ec661d2871b1cc9f84094f9c784abd23b67546fb6be8cde4157058d09f15508c167d9771cf3f96aeb1a6cce060df20d83ae3b619fbcf0ffccb2cfb3a4060cf4f4e349179d5f671c622062a5c63a07b1c9f8d0ff7996f676f23640a3c5c4bab173e64a79b6816b4b1e8fc76ada4c5c3541704138c16ca57e105af5cab0bd166b1455825b04f2c2ac010418e9d1e31084f450eb67b6ad9edcdbbcd11ef3bb1aa33e9e46c50d4a2848f8e342f738a3b007d8108e6bd8fd402040398b733c9e5b7f321615a9a92753c1c0b4e3620ea83c3447d1f04ecf9eeaa52b85b187bf128edc1c321e605cefbfe24c812e6cd89c814dfc89ec6b9d5ccace46caa26ab428418bed7181a9d9886d1110dca6c25dbcdfa30c2b9f30d0ad3b0da18fb0b4e49c552b110174afd23572b866feda0e6fbf93c1fdeb6b505f7ecd2971f46b432a556742e808c3fcb7a53dc2d164dd37fec2c909b4bf10273613a884fa0281e00ddaf5f410a0648abe447ce13f14d964374543fd4f34dd0569faac117bb79903118fbeec88634f0de9a8ef64d14bab7f4ea80dab05b0bd1a1b259ec46c66c990ad83b28939ca6b430e3b16d6d0da6214899fed2104cdac1de4e6adc301bdc75a23ffd95e094f50e13ed3d5e8f47a16c3df04275a5f3a8e446697fba89c4f3d7a9a6760a72907ea61510fc218d29b6eeb49b2c75fbdc96321bdb39a2a21d1234978204b0fded761f078820d3b0575665148493741c1b4f37f9afaa2600bbedad6dd8206c35d7a9517cf4adb6f622a2705c77e7f5f8462d75669d1c3bca9194f208b3762201ba953861c7d7cadbff9310c13ad89af1beb644b78386b41ddf7c8b5ddeab3c96d0d0e70867a862cc8ea2a32c7f5293d27bfc60e71adfdbd896c002b0a8fbf72072bb589b00f6dc076d4dabeaf568ad11daee6ee76ab7c22cb2157cf712b18b7406ace2970d6fa2aeab56952966fb64745bb16f006873f98ada83da9a490c8c6ddf987cd6203a15159ad9ad514b75b4ca072e654140bf92732caa720a7aa41baddccb55896417651dfb0a6ef8c78b638e5e996b5fbc21a95f19833c2fb9f442e7ec0645a4c65b38268e368386159b295a8206dd2afda59b4d189bdf3b2513a4e7e523b011f3ed330caac5006954a7e1f2fd46823878d5477097bc0f111ca23a9985c769a7d20341e536c0d40d0349665b4a1ba829e7e621b511d7f521aeda4623720f2fe2d38ca57f7b39e28555b6c5acc877c859103281808a4ef686c9d912749c1e67d1869d6c9abbbfb1cc1c076f94cfaf87bdfd6f3b0fd6e06040e2a9a80c37ab986a3152cdd1cb7757ffd8e6461f3b72e5bebd2527d3f4019ac8c629a39d823b3f72226f0af53a5b5ff64f68189c4194eee50c1b362f51688192525a91da97fb0040845efd21b4268a6b2df57f5ceb4ad7686fbdcb4a4a0276fedfe01c00dd77217d4e842dfc1be23cf60cfcdb0bf1c206afdf5f1f4a98ebbf06f300e264a6cc97bb72d59726d81c37618fd1c82e6aa0f0027dc6442fda6787722614e499bd3a70e5eea3980d6fcfa38c439701b2018b4f377518ac9663cd79ed0cc1c1c8d4cfbef4a98c7200273ee523de3bb5f8fcf8fd036d9be9371c69a76483c5e509d6a508003b9f734ab4b1515e691869c8e830957670cc4e8da492b032f2106acd71237eb4c5662895b2cdb40312ae8565299a41dbf573f51f096741a4a72e0fdecf319ec1543a6761f18ff92f2b11e1cc0d294c198c919bb063fd35b1887412f3dcaceed3133eeba3e87ce3c9cbf3416670096bc138fa851bf3412b5acad4209e992202ed53ba9cc0e215d618d4f09ac4ec47eac483eb2b809ba113a1168cbb66fe322ce115d5ad96a9ac1e7b16a774178617a012b21c476f8a22926f67987d83d1c01c3574eacce71d97c766bb95fdb04af38ac275f28a86e8a23d6553acf5ca6cb6ee1b53cdde4fa137a43704a567349afc736d4645b17fe5f7918938fa03b2d78490dddb2733e2d0828142a556dc212a20b682f9bb51bbb1cc0b335b489adfc3693b81f7c5b211b0342fa54fa47a56ccefa793d16993fb04feb4f4d6605b8a29798afcb64b264400a45c7557ef94e22d62dd216fadce2cc971b18086f5f032f2696e83c8efc55316f5a351c8d22cf65d5cbd5b6d8106133cf19acfc29a0ed8e4b9844ad4f8da542b3946904536cb731c34449e65bfd289396dacbe2ede9e237b7fbda92795ee837e00c73c77d6401c6f2df1632cbbefd6408e10279aafb9ca022b293a408ec964b3dd2d5409039518fc11877145eb4c9b788d52170e91aff53b4e28925f9d7a848af799d241610b100a8d86f187aaf687bd0ffad1a57c3e6124c05690fa83798558d7db835fc83fc0e2676d2e511c6230824e8a7723834ae10c07b7848d920ca03ce1c99310fb9adacbe97466782d21820f87beb03c96fb6384899450863aa540cceea960d0aa9546522e2af30988802d5bfcdd3f738bcd4d0c1583537634cb2daa651307cd5b3e03741656a154c2d338c00eec3d809d35a1a039495cc61079499e5570079eb3a68f8a27b890c0edfa7c7d91f5ba1779292acbdb2f343afb33771aeaa33772dfc4fbf36f4dc4110f8f2c41bee21a3a6c7715c980628174eea451e6994c9c57621223608ab3d2428549ae5d022c954259856e03656c39b62fc465e91dd27fe63c7dc7b16d0918dc0a58bcefef291d3e39dcb1d37304f0d31fbbab7af9c0728dcdfb346796e9388371b52c14b1db8180b30c593468c25551ab567b93dea712de40031493e826353c789cf560e12e4be1aac0cf5dbaf2ab61fc4c8d7f19604c0797b0bc0139cde36317aff87827f5ae05155cc7056a7f176780b15b036f7b7bd8c67790ffc672d12195c5ecb16c614b451aaa356cbf7cc5db4f1176f95adf555b786c6ffd339a1e85573745b278a4efbc0a20e4e55e685c16cf31bd5a96a7479dc37598a11e77559e3618800157a3af20632ab9749ae5d4628624d7b44711cf83591ef55b12493fde3c9c48e4f6678c001509151dc6e904618090769fed860650a46fbafb52efd25ecf0a0d66375376afac82d231f305b39a91a283310a5bba6192249a9205de30e79ec4acbad513ddd6486588c1f85e7ff679ad2afe896a2b1c9c56b6c790b265344355c6956e9e42871b6c95e0f1bddbd0675a261750684afeeba91635a7b31d9d57b29b290168c6eaef3fd3d2b3c20c2c084dacf1240e973797072601e01cbe3bdfe63ce1ab4032abf9bed4b97f0b8d24529b12bf3ed2f7e9562084cd86de2ab99bcf789277bc5d119be257f79d8687a5c52c7725bc9e99757d0cad940d93c2d80ab3e9c4253b49ba790e58c6f714a316cab71236278c50051a55f54f7ddeb2dabd0d05647fdcaa1b17dc211e7de56ceba28454d1198f1c84504c1fe50a42546126464d884f2015eb9755ea52e32ffb7b94bcfa8a930daa44a6064bde97ecdf95eb3e97474ea6bdbafc8668edb7cafae8924bd295d0916c5722b2f003e409bbc4d627bf1ecff55c5f7fe766de6ecea2b25102071658ff52f93068f7eb5d9faff0f471cf3110e3c65a4a02a50f6bb02f42195e84c6279ec46c67cbfd909ce0283ed70ac8b06fe9b74e47b66d84ca98f0d99b96751d643cb5e6c53286e964d4cd2986832e249776d7b9f85867a78616b1fe3cef728fc678b9eec79fbd24cae2dfb189a30efeffbf1c899a6519ac9ce140e7d529b8d5d235a3f5690db45592a66c4254b182c7d3db0fd9053a228f48287d25f17a2413ea79807a084e96fe9fa239980e304d6f098b300f54bf4509be0a64f79a1cf66b74d64e2344a922ee8cb703dc7704d20a9eebbe36659c3ad6f4b7c0b8d2e811d01aa6f52209ad6f1e8d719e395d416761c1b3fd25a40890f80219b7a2cbbaddee1dbd98004ea4a6a4dd85127d44cf54ad0232ac62287c97c27479b4fd0ebcfbf2414734e7adab4262ce963a86d8ddfae3af9ffbd2418ad4659a8289b36bab7cddffe58cd6ea9897dd25f8f566602b6f8d5dc386e8ad3ac236d6c00c98acda428dbcad314573ac8ba6e5e8af7bdc7f0f828b07d085c825144fbfd0fb1de00cc8730bd4bfa1bcf42904391dcf4ccf4f4228bd7e1f41c08b8f5b46a4a9ed9f88cc6c98ff9f06b257e6e0d3ddb2bfea5cada0fe92103bdb310eb09920ee88696bfb839e788ed587cbdbad3e62396394c2543824ef9fbf4e7c109a250246e5eb0746b9ca2a8ea6cc87529a1507e4fb42e784ccf3dd97ae40a670fd5628a0cfe514cee5b598af46f1781f926701d8df9d95ef1284daf9e6715e55711d6c3e79178f3863259bcc22dfa1307ddfab745601e17baeba8b56aa5d286bfab7097eff30374170541727f7cb528f8d88bce3a7c8e696c8d6df4c2254f8950d6b09d6da4b1657e6b75edb373d66edd74836a353158cdbb4d9caa866d4b76af7ee28619ac5c2476af0851a740e3a2da0cb9183947e8672c37622c7c3140a23d1932291c4ffd7b3ecca4e9b9291c5af10b916c05fd32bd391616cfe0b83a2530284db8ed44ba401af8f3a70fd88f974c045bd6dce7da7df13caf71c26774cd0726ce5c7841d334ebedc46f501cf843174869d16ee510d33038c3d298a99de56a73091ecadf8189eb1a567131f088de4dff8908ab195c99fc2d2c8d8dd1c9329ccabcac460e605ffc25c26625a248105c85c172ad02bdf006f95a97a48a9089fb4ed6e73dd4a06de490552560f15ae155764aa9488ec423f481abb2414716546c7a2b057705e37707fa20fd793d19a91aaaae80576abf95885937eb382f4b073b0a50652878f9dd362bd3fa9bfef7ad0e6a7e58c8baafefc846168561af347a80d45da4a31ba0f0c6dfd44eef24ea6616e391d5e5340868cd25353b68fc5eaa900cf36baeb165eff0bc0ae3cf0a316a83896f58da1b86738c55b557a057e0132e1e386ae15892f824c03857c4d62238bd19158fd8d149c295beec2d09952f9a798fac070938007ce33839492579721dde69c972957342c9dbe804d434f3615d702aa5498a2d798f33b7dfa7f462e0b2559a376b1f85790a67c781c88de90c90f20f1f76aea1eb11430c35536d98c1329ec4726fee0bfabcb595500ead6aa7a964bb5d0d364f21fc34462f259ba20ebbe171753f6f4faa03ed1ee63ca4e3f00379ee766572e7b44aa373777a5fe9e13238cefc5ccfbaf3474b08c5ad826697b40a2a94dbfb61ad0d0195975db1f82b0d41502aaf6a63f6a21fc64f7b5e6029708a28f04e30b46ec95c75bd09bf8daaffecfdb41427253dfd4db0bd59535da039cc37dc4ff880ee5167a01aed7a233415c6b20364a6a77289fd1f1e6ebc52a8ae72e07119c2e838a7f56c502cdd6de6c3654f450221689eee5ee33c79fb4bda29fe8ff6532f4847b960e3789d7a495471a89f256e37f40061a32f1710b46ed800e09d9d361160773e3902b1b9e0a906a397c07f5ce69a8a89af23bd34c4c8fa9cbdbb8b5a306f3416b02633c070a76d8ee6bf76aef90fdf7c5cbfacc5fc117da770ebf05cd9ec16670b4847005daafe0958a39628e8d5b6b78083c047a960a8c08ed3523061f5a07b40fee65760aca82db83e87e3a7688089aa528fed5ecb0c5adfdd2c7d2fa3f385264baa13b21b9e0927a7464b0dbab770bdaecabfe0dadee321fbfea00436199f1e2443fa9eb9215f4fbfc0ae6b71507cfaccaa4076203824845dbb3710cc312543af7b37c7bcb0fae39c16ad394535351f635983eee69ee3ee2cb3cdb48aabcda013cce7e392e729b42a371b2ee81b1ddc21ae647a9b8f790c04ac0422c108a3f3e1a340e5045fbcdf919d5609145c5c213aba99dc0df493df64d0424a888e1de4aee8b480c96d47efa0225f442a33b2130d4d5a23560efa310d79b78f83680851ae0f516d3b1d6f9c76575c24b80469cca532c437d7801bf23413b121808d861d78caaa41db27455cfdc5fb3a5826668c2b00c4def1d2b742d0b41786f2eb0a1acbb43ab2df83db6b92bbdbdb30bc0828e1587cd6c2555e56b7b75dce67e76e6eaacf99355dc5d36cd507acd13563fbecc018aa00c8b73bc8f61d0f04b7c31150985ef60433e265769f893abe1d9079f0088adec088c212a1aec82ac068bc1a992749f07f7155fdfe51f7c6a1cca833ec1295af2d39ad1b1b78b516712b874d4ed19315f1193b959b3af6821addb6a984ef7accad43010287d46ac7507666ddc6f688b2a9b60332126a4437684f0b2372116414134cb61f6830b9cc1aa7eab088ef30aee8d27b91677afc69fe902fc62900e314f43b8268e0886312eacccbe39f75a22ec05eb8ea2f2bc973e1943835bb9f7aeb278a468bda21284b32af5ee1ed82c19f70d0630a877ef021b7dbf3f4cbce79d0ff68c90cb2eb41cca298bf7d4615334a256906140e1536d8f4e1c5d7ff210ef3fd08b28b0e5fa9ac55decba3eace4f0d3454f921bbe20b1ea9a92555fbc51524124ed94c57d08e7f8b2b7e22021427267b0418ba070e429501f2bccfabb2f720c52702c7d4d59342fceeade80e31112bb3566a8a24aba7ee5616571e16fe9048b7a9472fe924636e73b2658ef134a09112d73ad930e6850356d4d1f01f785291bbb50eaafeca9ae7bf512245d99c804889b21eaca541ca419147fea6e6da49db820c9b5c4ff8be919f96de574e5770f5456cc8897d2f4c9aeeb4057307c4b622227e70313e89735225ae87078b3c1bf4b5ed96b9ffb9ef4d9a7a9930c3a15fb4cb64065a551ce3d633f36eadd59cf4d7950b0d23d2860c6d482c9169ac39a4492823ec63649cfed6c4d0505b521c4a6b024e9c1bc3d7e5ad6d41329542eb9d187a291f36192ab4a4fcde567962896bfb52d740d5888ab7221d3868231f62eb4baf30e0e95c9b5b3dc64b463fc00bcaa500532f3d5bbb820882b0d252c5dbbf5aa6b1452bc911290641ecfd4ab0736ef453a553e03e7e1063430d6c0042618c37f86104a07fdfe53fb03d96a85884643768e33cd48dc5aa906e94e32c29f3b82083568199af62bc9fc99381f5ea0fcae40be3249e837398cda0d0d1173aee9a2225ddb4d16822b215bcece54b8f502cd5eafc8cf6020726070585c072c60122a2567a2a69347e61882f441a19a124374c64f6b759314abbe26b3b50a2e809ec031c983385d107b69ff65e2e722ce4b3813bfa879fe5e35fd99b7442f015f31c4ebe0a21355bc4020203e70c233e5a6a9a41c8a6c77b7ea910b3741362e27fc831d93bbce5f385934baf0d4ed22fde6d37a2ba5aa1b96eb727e5f564fe3b9990f3b5dafbe70a2e2ba04aa6cbbded07a7f54d6087fc6a0755c87d5660babbb58da62fb7566d1cec3ededfb3d9bcc57cc78e4b6ecab4d4975b9fb6f0db93c7862689433762cf323f102619abb20f0f6052aa566ce497e9a5e727999244aa59a6f04198b406b977e1f52171fcdcc12bf770f89fe530fbfd4f614ba5460483622603fc7d37b2967dc2f3d4491a67ba7b3dd8589e2f8c4dd966bd5c0debfc03e393da66c196585d053542b6cc00f58773715034ef545ecd114dfb59c0b0ff77f810ad2379f1047e652c9103453895756f3c5c7d403f5ea8bcaa1a033952386cf9520b7882272784e3b0aed9a3f1860ab9fd5466ba9300b452aefdb283dc2a057fb67a23b94b6696438a00d7b013ac46227aea73ef028ca6a4f1abb5272cc0eed9d454181b04c156717f68c493f240476e4cc5090fccfa2541810ce224e831327ca9c84139f197e2db8b5102d7bc1adf2f706c3528e9457dce48dcf80d74718995f50f6fe560ebfd1268003a94b1027e5df86b1b763a2d1e1e13f0b666239684c07338b97035fe07161379e3d1c7b2aa6ddc8cce18b82326050324097761ccd7e973b56913d52f2efaa3faf5bb662db66ed4ed7edd7485de12ca4ecce078fe31c12b9c6ce2ab5e2c3991c72ed95b2c681c5daf58f16b1d424c6b5afe488c6aae0aa2856dccfc4256e50f2da3e39008f4a23d974f22264447a1aaea2512906e21cb823775fec9c281722c0ddce1edb9174e14b5139d36df91d6af5cd6784d9430b5b0996a9b652b3442a4f1a576a8e5ccae5b337ab4c0ec1ee99901b13344d2a947a9678637513fcb10e5b8834d22cb027635da36b7b7667586e790a498ad49d58f637c5505560de5f59643b97b3d90bc7335e24eb65c106aca58047ef2e4b6753345b3bdc53ea02cce37b9637b8301f4927cce976e9ea1b59f3a577a89c1ef039b76379b21894ae72478d7c3f9a54d6ac79c91ab910044d18e6073300bbf26af4ad662cb84c1941716d581243a350c6aa24a7e0bf38ba8b0f119a4b0f5cd992a4030dafc33798e56f1711692d857f302c76497109754ba1bd8eb7688bfe4a7232bfa706356f8c90efabc4cd5a56180ee1c14b673980f69179cda86ede3fd1b6b4b1a1aeb8c2bd48e378b660564d82d478eb5a27a7ac959527bd145af9ef27ff8b9f777129a3fa897c73cb09089654d90b4d713afe23b15f41dfe73199d16882b910dd3921630d516facb3ce503decd2c58b3a4cddde790ded8b0e2b5e4d1ae3a553199a59168b54638a3ee23bc64e09cc186c9268f91e23ac59dcbab749669f21e22e91bd419da71785fd5431020929241bb19a155788ce884e3a106993c36621c53a044f9b60e1ecac4c9c94c5a480664216ed50592f3d7ad67384c2b60bbc6ebab6f618874df130097d845fe35dfeeaeeb0eb29b8df8ac54770de538db24e0f8c6019a7badd4bf7fede7ad1d31a55d0941931f51ba042697ee0d08910f8492b708c2e2f73d8dddde74e65a604a1824948d68832d4c4e3461b1a62b9c6202601c20a5562fb69a5da75acf1e39d384fb880ef2b46512bfb78eeb279ac70189401df84520ac311ec2faa2d51d9660f0420beb250b21c9dbd9d8d566510b7d1f934a507c151c14ee4be6c5dc2713ec643ef2a28c20a3718770314ced646a48a62c23be8855f54d269815ae777f9bb73d1a81b2c1b9d0e2907a375c29b6209093dca061400b0be0a6225a652294e64113f4f8c738ca10f0042623fda9595041f8845d3d62b2094e54ff4ef3ed02af878366fdf92300f292d0ffa3cf679c5c4b95fb21d2b0e02761d8636419c11f342884ecb8a45e950c086327fa7c749819374ded9869416a902d752758a54554c29525e435d8852fd6f070fe2e8183ff0703324a51a04bbe0e54097bd9e67da4a527712e45c145c67ef9b382ef566437eabeddc9d3f9543ceebad1b25e8f2822dfd894d42779e9d1726da3a5ad13e1c4c809d736c67626f90b9239e6eb05a163efc399d95ff28ed35abeb39243df44f0f2b8c36128c8ea59eaa6bed9cd306135d6ec5007326317d6e28f544294f0add067f9f5c1c1031e3c4cc9f7f919a766cbfd3593ba41fa25f20af6eb3c6609dce23290c8384bc028c405dc5e4f8a8b4eb9196f34257d022a84958f504852b5b5544e02e43d66ed88f3c865adf7cdabba14ae993403b6ee0dd1b5dfa7217b732dd55795411e995064595682349af9bbc56cd75a17bb81e0c11485ae830b87acd7a584a4a9146d2184704dd914c07544ca3763ce88588230542681124392d77e24d2b91304f292d432f677c57fd3c9c37f681559d675b3b4d4eb26fb03c7c2949aaa47310baf0bfd43a076af02f93bd568089de01c195db4b081302a2fa1942bc893d9068b2b336e5888491032b9ba26c4e67a66b4999eac34d95eb0080a85bd8056088cd99f53876722ae835bad144035c702a73d98131e99d7a85c9ed81d58f5210f7acf26315ccce95f14d9332012461f40f62b9333a00332a7c1eda88fe787b8cddeb1a1b55bd58e9393b51450096bf844054929c176e2ded51dbf7740fdc668f5438c0819442ef24b5ac447ecebd1bac0306e5835cc69630a80139b701480b8426719f8922654620e2fd01da7e7ac5d9817e521b78b88a7118e8bbe539ac9d9a639cca554dd04e37b163bd1920720f1ef89152e49192b1b0d6595796ecb86f80dc46805f1d42063b70900b81047c389d968f6de5d5d0e900fc19836402f353ee92afd786dd09e33a823630878ede8d266da2105d6f706697e0a36c9fc364995b77b63afb04918583d6d96dc9902521a8d16faa9374230822173abad142aae8674d05d294f2f661b78d863a6ff40dff8834543403b5c16767ef267d7f8ce5bcedacc8535dd81a0746598cd38ee610b0b1826d12103ade951bbb0df34d5cbe9ebe97dc320a2c3dc3d64d72ac117ec4bf59a59d32cb8582440c1642dbc7a24354f4b18d9143bd70b3c57d3d243681a21a3fe5bbddc50168b0696ec580af0d47b6176e89d3cd551fddf30b4b37392108bdafcd776a89f5e4852710359f8d2e5008d4f923789adc377d97efb98d47e4df58330c2ab59aa89c73186de87308b3ed0711366d34c10d4a5cd5378f71cef4a50448e53e3975ee00e38c02b7681c4bbd95d3e1874bf09bcb640d287771bd2cb10b0a7006b2a07b29531a0e2213d0f672509c70badfe8f54407ef7cca1b7a3bfcbc2741059a3ffdb1a5f2fe0354c98a29b3510a3bc0dc210d95f7c331cae99a5154e36ff44ca683a4bff5c6b149974a951f8313e1fc34ae1e9f6f19fe29194994ef860e8fd046c1917bf391c23870b276d310d0d76ef0662aec37a7a0ba8810ed4674e2566ad894c53ed22235ba0019e07a143263bf8463d8ed6b2b86b3ff748e4bb421941e80247d8e91e1acabbf8c602293fc26eab6559373823d9d5a41cdcde1faf4a9465194d4752880c06b1ff7d750a164d21effcc5dafa1aa33565b9a8798f03b183d8d2b4d9fdcae147e27ea9fc20f27344e870d6956756da9b1e1986186447a6639550d4f9c73e58c7e8f8d03e10fd10b75330d7d705d9699180abc6626c353b3652c1fa5fe3a5b0e83e6fc5c28cdd3f65354d2586bbed21f27f91942b240a45ccde3150929d9083a56e042662fa6c8ce143634e51faabd9c1d174ffd459ca4ab52f813b86636d9322a142453d7bafadb34f90d98c05e8dae67c6d4be33d21ab8619f791cf33f966aae0454051b3a59e05667bbd8277ea46d8be26fadf4310c10f7f6e76b3ed3457d3c6e188dbc16dcc54eb34ffcbcfde546dd7c30cc4b3a9b3e3e90b493095052b9425e6030f076c81ab7bd2072272947bc1d130890eec5e4a57f2c33d1cf649867cfd997b5603a9351629cc89419226cf34fe727b87d3c116d5938b635823333819f473215f2babcc1b71f4ccb95158c0bc229af13e0a234a2b166e8f4b4deecf00c263a5c28db28855663f4a4b5401f71014d392faed19b57ca3eb8664cb566e9cce84fa8231149bbb1a7ad71a095797594f6ad7547917707e137d9b2ad0af423b4bab7aa8a75d277326207d49450cf3cfccee2cff702161c21586077c6fdb6f49b5c26b24ef7d825490d0279cc2b52d710b85c5c7591ca12d74b5b88e1d77a124a4158b47024af0855379f985c855dfd3e20c41b68a9385e9585593c918c606e4124596b06724dc83468493bea0567ae817f3e336d898d6b3ba793eaa16dc1b98b90025c27655add22f6122ace833c1373c948df309ebe1619e2fa09b0c7b10d87d7be62d352b17953a8899bebdc7c8fe17ac825ef1188aa7b7ea3c86ace6c10384c8a4b81dd66998a60dde786dc74988a331c6b4719037e5a795badeab6f5656bfe0e047e3c9fae1cdcde4165e848cf92c343c3c22768ecfd4e9190dd09ea4a3a1ea90801ef33209d493db580fd893be6fb74ee2e79faa1c7b6d21f04a70aaaf975cc82290664559392b9f1c3385e75813fe17d0141b44e164fea4eb083093d7cc51a39e9e775f6cadcb6be1b3db6d5451d72cd5aec6bb98b92cf79cd5927174a8e5ee3edae147a74a3d7c55cfc1fcb409396d5e911c9f54f7171dfe9ab6f48db045524d4a3c52b3021b26ea665e2b4d6331994d61f95f269bfd2c15795494cb3e0d1062a252e3e3307791713717d392da971208690cd44fba048b025c94a2920e3db260c0e1f7daa6fe8b388eec94a1b591fe25d465d13a218bf32c654fb70989eb485262f9f57de8bdaedee1f7f578799ca7cbd03fb5114b631c0ebdffdcf7cd40deea04c8a71c0137a1d68f91da86ccdb11af2861a6f742471bbd92cd47844956de3885e87cfbb9d2166e076e0b37de2556b323b425c7a85528332074452b39a929c6355785ce65750a18bbca7a481f0cd8b5c712d3f24fc2190477097645d9e53a8b1249b4292f5924ad5e4d092f479b0a96c3b5a29d81a16272d6469af48a979966652309a604cddf45f80c16abca718deb378e131126ac2ec36837b52f7dd2513a14928e00f07076076a69bf06e074c12af1bbc3563be4cb6be152c57c2b5dda10979ecac25e1c7bbc63c61a09f33119985d4ed93dd930b29a63131ed2847ba1452d17e1be6e8df6c56ec18d07601818af7209c45852a29be9308d9b6a9fa319a7e1ce93b1a765963d75d6250744b0ad3c250229294497289fdb2825ee6f0fa76afa300f49a658ee229efd99cc7e8d78e81387720b666a1ed04d544ab92f8c81bf44586ee6bec8e83e217eb35a0057a18fb253ef1f28cc36af701c3a999ec066422ee1545ed6b4095e3b3d7d70753306d703d7216fa0ea5d06069e28d217909107e2295a91b3053032d262ace29786543e6898264ff2b44aafb31048f19f209d1a84f0560dcf38e0e0e599e8d1acb93d1e838c88769279ea5c388f694340a1229156023d99e9abc4bbae266a7193943cd7b19b6070d7d1bf42cb51081b2921205c79270aab9d3d92e4afda1ced39a232d8c444b949fffb43ffd38fde645b7105325b9bc7929163353ddbf36f34f93b3f39db3979ab2c292eb7ad80bbff10dd527a0cff544ea3138263bcde074ea2ea5397b6b2e8f695b68414006a251eb6d113fa4d13fe34ba0d68fe2ad96db72c79729c36fd4c480c4fc8b18a82d1f2bc40252c73581b917f91f764057e59d133a92fd6b6de7b0a92bb089de189397236686964b833094beab1ffb2258de26653482cde39da16afc880bdb771cf1e5f684635ef9fbd86db214055a5c360388da9fe24f9623d4721e83bc31ea8437fa80e810044a2655d8cf4251c10315016e8fae2ed750a12df54669e7b6b9c42e5d159fc29c04474053b4d3dad728f69c3e14eea063cd07b9e888712fe55a380095a3dafcddc9d08f723274d701da1ab04de1874b117a9e00432dd78bdaa260141969f1d62a5d8fc2bf280399eb39b3ac1c0815da0fb091d49803f619003c92b1b611ea1aa19d311f585de99f410e4f3dfad0f9c07389c6a0487abe3360b0749043eaf2b18987effbe22fafb425297dcd48fb50b01248354051a56c3b85e74874a7fce3a040fe50bea7bcc11f91b263e8a00215c5d229c090c74480566d3bca20dcbd240428fe7014bcb95be08999a57decd5c65441965b4e3637ec3480867d536fc75dc06a297884eeed8ec0a3ed66ce3703e684a9d8426881045537870d14802b3d5e2c858b5aed78e84b1186e6c0df43660006a957d9774bf19f6a149d3382fbc5b7b7ad6f5a3e40c438539c66269dd098f5b812907e43921373ef17be01c341634bc3d3eb18af48d15e5ea09c0dabb94239d0964a0a335f551f67c185e7d229d47b686693e386d876ff47db61cfaabe1e6350a6c7cc3ee1573023ed9c9c5980872aaf702b6f9672fb28b3e8968b6edcaa3e1bdfca52c1bd661fb4715b8b218c765e0c35b7be93bcf6fae2c4f4728b4d5977b966f30c95f5bbc7690995e5ddf91f28049ed7e1bfe9200f3843fb94a725dc40b0301703f9c29e55875baff553e3e708c7e8764c2dc1f449b92d87ed649c36229005cba255357d9691f4a6fc32c896ee82df33601abffe8f7722c7698c9b71cdfe3743679cca5ab5370714e6fcd7f12a431e674ba8d3f7631d8de6dc5bc3828b86d0dcb7ab72c218993ae7cd95f324f5609d89d20259d561010d43b7bff830a39b67f6fe6e2839f8a604f111a2e21f4d7150f3b50a87d8cbcfb46b593b94327ef67035002c0f78366b7bb9209f252ea045ae363d037d04eeef2ad8b47b7ab83fccd5f606d43f0b555896b21b2c44c6cff391991c2f1705089653fb1e35e81e7075c78b27bfdca50232a4dc4ed968ddc274dbb54c6f201eeab8250ab8beb141afd521d2f61bbdb71c25e00194fa437db3e678753afb94d51fbcc5cbb6c97049b1e0b450b32c9ddc8f183b1c89225bbe239a7672abbfef19aa03f00211ad7cd5ea08a32ea5846b7144e39ca13c26555832b26b14822cc2783bd3b668f7df28569b820ac7e44f430470caf54667859f90ead2e0018eedd1e6df4b00ea706b823fc38a8bd4da81eeb6a1edb500901a517d5d08e3dfc3bf9782a25e59f80306dd93ab9754e7e74ec4337f7e42fd6a9d7d506e0b1b1e1d7633756b1304a70b4df483ac257510c69380fa32f7cdf03dd91da827383fa156347d94e1323d2194a01009e9a8d7bfb5c309519b3643dea57151025df3ba2b2ec6eee131943338854996dad5854779ae84f9a035649a24435d98b6121abd90903ae7e2a53406174954ddeb83f05ad08fd70b8580c04e9a292d3dc018886accad8b9fdef3d738c9c6f4047023cef6f2dd342ef0a3283cb19a03971d56a5f0d45003a00192f22279afbfa515acba7f0a75c3b0d5b44fedb14d3f83ee4ee06c4c1b102c70afc49251a06826d96ec67b108481cb7dd63ffd8223911fe581acc5df0764ce1bdce3f0c05276332589280444c7ec6dc31214100fc6b8ea58994bb5c0867c22dc0e9377399bc985436970e94f7dcb856e6a2601b85795a0e0e205b7bdb97701ce7d382eeff0c8ea18dc21c384d8178f186cec06a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程 | 线程问题排除，从Dubbo场景下手</title>
      <link href="/2022/03/23/concurrency-troubleshooting/"/>
      <url>/2022/03/23/concurrency-troubleshooting/</url>
      
        <content type="html"><![CDATA[<h2 id="场景一：关于并行流Parallel-Stream与Fork-Join线程池"><a href="#场景一：关于并行流Parallel-Stream与Fork-Join线程池" class="headerlink" title="场景一：关于并行流Parallel Stream与Fork-Join线程池"></a>场景一：关于并行流Parallel Stream与Fork-Join线程池</h2><p>假设，分布式服务中（rpc框架：dubbo），有一个微服务接口，用于批量处理数据，如果每次消费者调用都用了批量处理1000条记录的过滤，假设一条记录的过滤逻辑需要耗时4ms（ 涉及到redis缓存的读），如果有40个请求并发过滤，那就是40000条记录交给2个线程去处理(cpu核心线程数)，你猜下结果是什么？结果是，服务消费端报错，一堆的接口调用超时异常，导致服务雪崩。后果很严重。原因你猜到了吗？</p><p>40个请求开启40个并行流parallerStream，40个并行流parallerStream使用同一个只有2个线程的Fork-Join线程池(2核8g机器)，意味着40个请求争抢着执行任务。</p><p>假设一条记录的过滤耗时为4ms，在串行的情况下1000条记录应该只是4000ms。但如果是400000条记录争抢2个线程执行，我们转变一下，假设每线程每200000记录执行，由于是无序的，但可以想象对请求来说任务是被交替执行完成的。什么意思呢，比如当前执行1号请求的第一个任务，执行完后切换到2号个请求的第一个任务，接着3号请求的第一个任务，一轮完成后接着是1号请求的第二个任务…所以，最坏的情况下，一个请求需要200000*4ms才能执行完成。就会导致接口调用超时。</p><p>总之，不要在高并发的接口中使用并行流，直接使用处理请求的线程执行就行，如果有需要，那就全局创建一个Fork-Join线程池自己切分任务来执行。</p><p>刚刚说的例子只是40个并发，实现项目中都是上千上万的并发请求，如果这样使用并行流，服务直接崩掉。</p><p>假设用的dubbo默认配置200个工作线程，那么是200个线程处理业务逻辑快呢，还是将200个线程的请求都交给只有2个线程的线程池处理快呢？毫无疑问。</p><p>总结<br><strong>那些耗时很长的任务，请不要使用parallerStream。</strong>假设原本一个任务执行需要1分钟时间，有10个任务并行执行，如果你偷懒，只是使用parallerStream来将这10个任务并行执行，那你这个jvm进程中，其它同样使用parallerStream的地方也会因此被阻塞住，严重的将会导致整个服务瘫痪。</p><p>关于stream的并行流parallerStream使用注意事项就说到这。切记，请不要乱用并行流，在使用之前一定、一定、一定要考虑清楚任务是否耗时，<strong>有i/o操作的一定不要使用并行流</strong>，有线程休眠的也一定不要使用并行流，原本就只有两个线程，还搞休眠，等着整个服务崩溃咯。</p><p>除此之外，我们可以自定义线程池，让Java8中的parallel stream使我们的线程池，而不是使用公共的。这个技巧是基于ForkJoinTask.fork，它指定：”安排在当前任务运行的池中异步执行此任务(如果适用)，或者如果不是inForkJoinPool()则使用ForkJoinPool.commonPool()”</p><hr><p>Fork-Join机制<br>总体是归并算法。Parallel Stream实现任务的切分，并将任务提交到全局的ForkJoinPool线程池中执行，注意，是全局的线程池。关于ForkJoinPool，我这里简单介绍下，这个线程池其默认线程数为处理器核心数。</p><figure class="image-box">                <img src="bea5e8778c41184aef2118e63bee7c99.png" alt="img" title class>                <p>img</p>            </figure><p>在Fork-Join中，比如一个拥有4个线程的ForkJoinPool线程池，有一个任务队列，一个大的任务切分出的子任务会提交到线程池的任务队列中，4个线程从任务队列中获取任务执行，哪个线程执行的任务快，哪个线程执行的任务就多，只有队列中没有任务线程才是空闲的，这就是工作窃取。可以这样理解工作窃取，比如有4个人干8件事情，理应每个人干2件，但干活快的干完自己的事情后可以去帮别人干。</p><p>正如图中所示，一个任务可以fork中很多个子任务，当然不只是图中看到的只有左右两个。假设，每个任务都只fork出两个子任务，如果负责fork子任务的当前任务不做任何事情，那么最终将只有叶子节点真正做事情，其它节点都只是负责fork子任务与合并结果（假设是有返回值的任务）。</p><p>如果是没有返回值的任务，是没有图中“合并结果”这个流程的；而且，也不是必须要等待子任务执行完成。这些都是根据自己的需求来自定义使用的。要灵活去使用。</p><h2 id="场景二：避免父子任务共用同一个线程池而产生死锁，线程隔离"><a href="#场景二：避免父子任务共用同一个线程池而产生死锁，线程隔离" class="headerlink" title="场景二：避免父子任务共用同一个线程池而产生死锁，线程隔离"></a>场景二：避免父子任务共用同一个线程池而产生死锁，线程隔离</h2><h3 id="一、问题发现"><a href="#一、问题发现" class="headerlink" title="一、问题发现"></a>一、问题发现</h3><p>线上监控到大量接口报错，定位到异常机器，将异常机器隔离后，线上服务恢复正常。 拿到业务报错日志如下<br><figure class="image-box">                <img src="Fm3SIGw53R6pntywivFSPmwfjscg.png" alt="alt" title class>                <p>alt</p>            </figure><br>异常信息显示Dubbo线程池活跃线程数已经达到最大线程数200，说明线程池资源已经耗尽。</p><p>经过排查</p><p>线程池资源耗尽，猜测Dubbo线程都被某个耗时方法阻塞了，或者线上有异常突发流量。<br>查看线上监控，发现服务请求流量正常，猜测<strong>Dubbo线程是被阻塞住了</strong>。</p><p>先抛结论：业务线程池的线程全部都被阻塞住，导致使用该业务线程池的Dubbo线程也全部阻塞。</p><h3 id="二、进一步排查"><a href="#二、进一步排查" class="headerlink" title="二、进一步排查"></a>二、进一步排查</h3><h4 id="2-1-Dubbo线程为何被阻塞？"><a href="#2-1-Dubbo线程为何被阻塞？" class="headerlink" title="2.1 Dubbo线程为何被阻塞？"></a>2.1 Dubbo线程为何被阻塞？</h4><p>通过<code>jstack</code>获取Dubbo线程堆栈信息，发现大量Dubbo线程的线程状态都为<code>WAITING</code>状态，阻塞在<code>CompletableFuture#join</code>。<br><figure class="image-box">                <img src="Fqw5SmQ9cqaqcqLOOgCiQkIsR-66.png" alt="alt" title class>                <p>alt</p>            </figure><br>找到相关代码行，简化逻辑如下：<br><figure class="image-box">                <img src="FopwPXM2xmJyFyuyXYi4Q-fbcw5_.png" alt="alt" title class>                <p>alt</p>            </figure></p><p>业务代码中自定义了一个<strong>线程数为8</strong>的<strong>固定线程池</strong><code>executorService</code>，为了方便表述，该线程池简称<strong>业务线程池</strong>，分配的线程简称<strong>业务线程</strong>。</p><p><code>method2</code>通过从该线程池中获取线程执行多个耗时的子任务，并<code>join</code>阻塞等待多个线程执行结束。<figure class="image-box">                <img src="Fh48JT_OqLI3zscmN7HbzoKU80sv.png" alt="alt" title class>                <p>alt</p>            </figure>当接收到一个请求时，由Dubbo线程池分配线程执行<code>method1</code>方法，<code>method1</code>调用<code>method2</code>，<code>method2</code>从业务线程池中获取线程去执行子任务，并阻塞等待。</p><p>Dubbo线程都阻塞在method2，那么说明method2中的多个子任务一直没有执行完成，导致Dubbo线程一直阻塞等待。</p><p>那么method2中的子任务为什么一直没有执行完？是因为子任务执行得太慢吗？还是业务线程池出了什么问题？</p><h4 id="2-2-子任务为什么一直没执行完成？"><a href="#2-2-子任务为什么一直没执行完成？" class="headerlink" title="2.2 子任务为什么一直没执行完成？"></a>2.2 子任务为什么一直没执行完成？</h4><p>分析业务线程堆栈信息，发现8个业务线程都处于<code>WAITING</code>状态，阻塞在<code>CompletableFuture#join</code>方法。<br><figure class="image-box">                <img src="FkY80sk5gNFDgz5GJy4YIvoJivp1.png" alt="alt" title class>                <p>alt</p>            </figure><br>通过业务线程堆栈信息找到相关代码，并将代码简化如下<br><figure class="image-box">                <img src="FusLoS8DAO5NyfRvXiyPMRMbh7h0.png" alt="alt" title class>                <p>alt</p>            </figure><br><code>method3</code><strong>异步调用</strong><code>method2</code>，两个方法都用到了同一个<strong>业务线程池</strong>。<br><figure class="image-box">                <img src="FtgtVTo8q5NlH1qNJU2i801_fwKB.png" alt="alt" title class>                <p>alt</p>            </figure><br>当<code>method3</code>同时收到8个请求时，8条业务线程都被分配给<code>method3</code>去异步调用<code>method2</code>后，此时因为业务线程已经达到最大值，<code>method2</code>中的子任务会进入队列等待被业务线程拉取执行。而此时业务线程又都在<code>method2</code>阻塞等待子任务执行完成，两边就陷入了<strong>相互等待</strong>的状态，因此业务线程陷入永久阻塞状态。</p><h4 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h4><p>结合以上分析，父子任务共用同一个线程池，父任务（或加上一部分子任务）拿走了所有线程，导致另外的一些子任务排队等待阻塞，原来占有线程的父任务又无法释放资源，最终业务线程池的线程全部都被阻塞住，导致使用该业务线程池的Dubbo线程也全部阻塞。</p><h3 id="三、解决方式"><a href="#三、解决方式" class="headerlink" title="三、解决方式"></a>三、解决方式</h3><p><strong>隔离线程池</strong>.</p><p>在真实的业务代码中其实远非简单的A调B，而是相对比较复杂的调用链<br><figure class="image-box">                <img src="FvZJSaM2bwgILrlCNV86jzprICMF.png" alt="image.png" title class>                <p>image.png</p>            </figure></p><p><code>method3</code>发起异步调用，经过多层中间接口调用到<code>method2</code>。其他接口发起同步调用，同样经过多层中间接口调用到<code>method2</code>。</p><p>因为经过多层中间接口，所以不能直接将<code>method2</code>改成顺序执行多个子任务，会导致其他调用<code>method2</code>的接口处理时间延长。抽出一个顺序执行子任务的方法也不太合适，因为涉及到改动多个中间接口，改动相对比较大。</p><p>解决方式是<strong>隔离线程池</strong>，将提交异步任务和多线程执行子任务拆分成两个线程池去处理。</p><figure class="image-box">                <img src="Fofcf3BfLDV7Fvm2jyHDBTEJgaDE.png" alt="image.png" title class>                <p>image.png</p>            </figure><p>拆分成两个线程池之后，无论同时进来多少请求，在<code>method2</code>陷入阻塞的都是线程A，不会影响执行子任务的线程B。</p><p>将异步调用改成由一个新的线程池提交，这样影响范围就控制在<code>method3</code>，改动也比较小，可以快速修复上线。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="Q：CompletableFuture的默认线程池也是共用的线程池，为什么父子任务可以正常执行？"><a href="#Q：CompletableFuture的默认线程池也是共用的线程池，为什么父子任务可以正常执行？" class="headerlink" title="Q：CompletableFuture的默认线程池也是共用的线程池，为什么父子任务可以正常执行？"></a>Q：<code>CompletableFuture</code>的默认线程池也是共用的线程池，为什么父子任务可以正常执行？</h4><p>使用<code>CompletableFuture</code>的默认线程池之所以不会出现互等的情况，是因为提交任务时，如果内部使用的是<code>ThreadPerTaskExecutor</code>是会<strong>不断创建新线程的</strong>，不会因为进入队列阻塞等待被执行而陷入等待。而如果内部使用的是<code>commonPool</code>则<code>CompletableFuture#join</code>方法在进入阻塞之前，判断当前线程是<code>ForkJoinWorkerThread</code>线程则会在满足条件时<strong>先尝试补偿线程</strong>，确保有足够的线程去保证任务可以正常执行。</p><hr><p>具体来讲：</p><p><code>CompletableFuture</code>内部包含两种默认线程池，当<code>ForkJoinPool#getCommonPoolParallelism()</code><strong>大于1时</strong>使用<code>ForkJoinPool</code>的<code>commonPool</code>线程池，反之则使用内部类<code>ThreadPerTaskExecutor</code>执行任务。</p><ul><li><code>ThreadPerTaskExecutor</code>每次执行都会创建线程，因此不会出现任务等待线程空闲的情况。</li><li><code>commonPool</code>是<code>ForkJoinPool</code>内部包含的默认线程池，在没有指定系统参数时<strong>并行数</strong>为<code>Runtime.getRuntime().availableProcessors()-1</code>。<code>availableProcessors()</code>这个方法的目的是获取可并行执行的线程数，这个数值跟主板集成的cpu个数、cpu核数、是否开启超线程都是相关的。</li></ul><p><code>ForkJoinPool#getCommonPoolParallelism()</code>获取的就是<code>commonPool</code>的并行数，我测试的机器获取到的<code>commonPool</code><strong>并行数</strong>为7，因此使用的是<code>ForkJoinPool</code>线程池。</p><p>而<code>ForkJoinPool</code>线程池之所以可以正常执行，关键在<code>CompletableFuture#join</code>中的内部实现。截取<code>CompletableFuture#join</code>解决此问题的关键时序图如下<br><figure class="image-box">                <img src="FlFAmQVcbLvo2IWZ9tGBIu3vP4ee.png" alt="alt" title class>                <p>alt</p>            </figure><br>关键就在于<code>ForkJoinPool</code>创建的线程为<code>ForkJoinWorkerThread</code>类型，而<code>ForkJoinPool#managedBlock</code>判断当前线程是<code>ForkJoinWorkerThread</code>类型时会调用<code>tryCompensate</code>方法，该方法在特定情况下会去补偿线程确保任务正常执行完成。</p><p>截取<code>tryCompensate</code>源码如下：<br><figure class="image-box">                <img src="FgRUWhk-YB7dch3QmwJguMBlVTak.png" alt="alt" title class>                <p>alt</p>            </figure><br>根据<code>tryCompensate</code>的源码可以得出：</p><p><code>tryCompensate</code>在经过一系列校验，认为当前陷入阻塞会导致任务无法正常执行时，会尝试补偿创建一条新的线程，确保不出现上述的互等情况。<br>普通<code>FokrJoinPool</code>线程池最多会补偿到<code>32767</code>条线程。<code>commonPool</code>最多会补偿到<code>并行数+256</code>条工作线程，超过则会抛出异常。</p><p>因此<code>CompletableFuture</code>线程池可以正常执行是因为使用<code>ThreadPerTaskExecutor</code>时每次都会创建新的线程，而使用<code>commonPool</code>时，在<code>CompletableFuture#join</code>进入阻塞之前会去尝试补偿线程。但是也不是无限补偿，当补偿达到一定次数后就会抛出异常。</p><hr><h2 id="场景三：线程池参数调配不合理，导致服务积压"><a href="#场景三：线程池参数调配不合理，导致服务积压" class="headerlink" title="场景三：线程池参数调配不合理，导致服务积压"></a>场景三：线程池参数调配不合理，导致服务积压</h2><h3 id="一-问题发现"><a href="#一-问题发现" class="headerlink" title="一 问题发现"></a>一 问题发现</h3><p>某日，群上接到机器人警告，然后打开监控平台一探究竟。分销员系统某核心应用，接口响应全部超时，dubbo线程池被全部占满，并堆积了大量待处理任务，整个应用无法响应任何外部请求，处于“夯死”的状态。</p><figure class="image-box">                <img src="p1.png" alt="alt" title class>                <p>alt</p>            </figure><p>以各种姿势查看应用的各项指标时，5分钟过去了，应用居然自己自动恢复了。</p><p>猜想：流量激增，内存GC过慢，慢查询SQL，线程池阻塞，同步锁问题…</p><h3 id="二-排查线索"><a href="#二-排查线索" class="headerlink" title="二 排查线索"></a>二 排查线索</h3><p><strong>QPS</strong>，的确，对于应用突然夯死，大家可能第一时间想到的就是流量突增。流量突增会给应用稳定性带来不小冲击，机器资源的消耗的增加至殆尽，当然也就响应不了新的请求。我们查看了QPS的状况。</p><figure class="image-box">                <img src="p2.png" alt="alt" title class>                <p>alt</p>            </figure><p>事实是，应用的QPS指标并没有出现陡峰，处于一个相对平缓的上下浮动的状态，所以不是流量突增导致的。</p><p><strong>GC</strong>，JVM在GC时，会因为Stop The World的出现，导致整个应用产生短暂的停顿时间。如果JVM频繁的发生Stop The World，或者停顿时间较长，会一定程度的影响应用处理请求的能力。但是我们查看了GC日志，并没有任何的异常，看来也不是GC异常导致的。</p><figure class="image-box">                <img src="p3.png" alt="alt" title class>                <p>alt</p>            </figure><p><strong>慢查</strong>，当应用的高QPS接口出现慢查时，会导致处理请求的IO线程池中（dubbo线程池），大量堆积处理慢查的线程，占用线程池资源，使新的请求线程处于线程池队列末端的等待状态，情况恶劣时，请求得不到及时响应，引发超时。那么，看出问题的时间段，比如看SQL执行耗时，并未发生慢查。</p><p><strong>TIMEDOUT</strong>，在排查机器日志时，发现了一个异常现象，某个平时不怎么报错的接口，在1秒内被外部调用了500多次，此后在那个时间段内，根据traceid这500多次请求产生了400多条错误业务日志，并且错误业务日志最长有延后好几分钟的。</p><figure class="image-box">                <img src="p4.png" alt="alt" title class>                <p>alt</p>            </figure><p>这是怎么回事呢？这里有两个疑惑：</p><p>（1）500QPS完全在这个接口承受范围内，压力还不够。</p><p>（2）为什么产生的错误日志能够被延后好几分钟。</p><p>日志中明显的指出，这个http请求Read timed out。http请求中读超时设置过长的话，最终的效果会和慢查一样，导致线程长时间占用线程池资源（dubbo线程池）。翻到代码：</p><figure class="image-box">                <img src="p5.png" alt="alt" title class>                <p>alt</p>            </figure><p>但是代码中确实是设置了读超时的，那么延后的错误日志是怎么来的呢？</p><h3 id="三-定位问题"><a href="#三-定位问题" class="headerlink" title="三 定位问题"></a>三 定位问题</h3><p>既然是HTTP请求，以我的经验，大概率是连接池的配置问题。针对这个RestTemplateBuilder工具类，将线上的情况回放到本地进行了模拟。我们构建了500个线程同时使用这个工具类去请求一个http接口，这个http接口让每个请求都等待2秒后再返回，具体的做法很简单就是Thread.sleep(2000)，然后观察每次请求的response和rt。</p><figure class="image-box">                <img src="p6.png" alt="alt" title class>                <p>alt</p>            </figure><p>我们发现response都是正常返回的（没有触发Read timed out），rt是规律的5个一组并且有2秒的递增。这说明，里面有排队队列，猜想是一个池。 通过观察跟踪代码，成功验证猜测。</p><figure class="image-box">                <img src="p7.png" alt="alt" title class>                <p>alt</p>            </figure><p>这个工具类默认使用了common pool对象池作为底层构造的连接池，去发起http请求，并且pool active size最大连接数仅有5。又是这个问题，池参数的最大线程数设置过小。</p><p>还原下整个事件的经过：</p><p>（1）500个并发的请求同时访问了我们应用的某个接口，将dubbo线程池迅速占满（dubbo线程池大小为200），这个接口内部逻辑需要访问一个内网的http接口</p><p>（2）由于某些不可抗拒因素，这个时间段内这个内网的http接口全部返回超时</p><p>（3）这个接口发起http请求时，连接池使用任务队列排队，并且pool active size仅有5，http请求耗时为2s，所以消耗完500个请求大约需要500/5x2s=200s，这200s内，应用本身承担着大约3000QPS的请求，会有大约3000*200=600000个任务会进入dubbo线程池队列。</p><p>（4）消耗完这500个请求后，应用就开始慢慢恢复（恢复的速率与时间可以根据正常rt大致算一算，这里就不作展开了）。</p><h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>Q：对象池是怎么用的呢？线程池是怎么用的呢？队列又是怎么用的呢？它们的核心参数是怎么设置的呢？</p><p>核心参数的设置，需要根据场景来。</p><p>拿本案举例，本案涉及两个方面，（1）发起http请求的连接池（2）dubbo线程池。</p><p>（1）这个pool的场景是侧重IO的操作，IO操作的一个特性是需要有较长的等待时间，那我们就可以为了提高吞吐量，而适当的调大pool active size。那调大至多少合适呢？可以根据这个接口调用比例情况，平均QPS是多少，峰值QPS是多少，rt是多少等等元素，来调出一个合适的值，这一定是一个过程，而不是一次性决定的。假如是一个新接口，不知道历史数据怎么办？对于这种情况，如果条件允许的话，做模拟线上的压测。根据改变压测条件，来调试出一个相对靠谱的值，上线后对其观察，再决定是否需要调整。</p><p>（2）在本案中，对于dubbo线程池的问题有两个，队列长度与拒绝策略。队列长度的问题显而易见，一个应用的负载能力，是可以通过各种手段衡量出来的。回到本案，如果我们调低了dubbo线程池的的队列长度，增加了适当的拒绝策略，并且可以把长时间排队的任务移除掉（这么做有一定风险），可以一定程度的提高系统恢复的速度，实现fast-fail机制。</p><p>所以，我们在使用一些第三方工具包的时候，不难发现，对象池common pool的广泛应用，多多留意，避免因参数设置不全。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 高并发 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程| 深理解volatile+锁升级+DCL单例+线程池调优</title>
      <link href="/2022/03/23/concurrent-programming/"/>
      <url>/2022/03/23/concurrent-programming/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>一是保证可见性。<br>二是禁止指令重排序。<br>可见性，是让其他线程可见，一般我们是多核CPU，一旦volatile修饰的变量被一个CPU修改，修改完的值需要立即推送到主存，推送过程要经过一个总线。那么，我们说的可见性就是体现在总线这一层上。因为，我们其他的CPU一直在嗅探总线的数据流通，在缓存一致性的保障下， 能够嗅探到数据的修改，然后，如果自己的缓存行有这条数据，就置为失效。<br>如果下次有线程对该数据读或写，那么它会先从主存拉取数据保存到CPU自己的缓存行里边，然后再做进一步处理。<br>就是嗅探和MESI缓存一致性协议共同保证了CPU层的可见性。<br>总线如何知道volatile修饰呢？关键用了lock 前缀的指令，有两层含义。一个是将数据的修改推送到主存，一个是lock指令过控制总线的时候，其他CPU会嗅探lock指令，然后置缓存行失效。</p><p>禁止指令重排序<br>首先，它是禁止在编译阶段，Class结构中方法表的属性表的Code属性，存放着JVM指令，在编译期时，volatile就完成了一个内存屏障的编译。<br>对于volatile的写，写前加入storeStore屏障，保证写写顺序，写后加入storeLoad，保证先写后读顺序；对于volatile的读，在第一个读后加入loadLoad屏障，保证读读顺序，读后loadStore，保证先读后写顺序，StoreLoad这是个全能型屏障，开销很大，同时具有其他3个屏障的效果。执行该屏障的花销比较昂贵，因为处理器通常要把当前的写缓冲区的内容全部刷新到[内存]中（Buffer Fully Flush，一般不会单独使用。</p><blockquote><p>引申：<br>final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。<br>在 初次读 final 域操作的前面插入一个 LoadLoad 屏障</p></blockquote><p>特殊情况下，可以保证原子性。<br>如果是单条JVM指令字节码，可以保证原子性；如果是多条JVM指令字节码，不能保证原子性；（建议别深入，怕深问到指令出入栈）<br>如果是对 flag = true的读写，可保证，因为读和写都是1条指令字节码。<br>如果a++，不保证，这里涉及了3条JVM指令字节码，iload 读取a，iadd 进行a+1，istore 写a。</p><p>下面这个其他人的答案，有点含糊不理解：<br>read load use 作为一种读原子操作<br>assign store write 作为一种写原子操作<br>主存值read到执行引擎，执行引擎值load到一个栈存副本变量，栈存值use 到执行引擎，以便计算处理；<br>执行引擎值 assign到栈存副本变量，栈存副本值store到主存，主存值write 到主存的变量，以便共享；</p><p>原子操作避免 读过程 或 写过程 在中间操作被打断。<br>虽然use 和assign存在 被打断的可能，但工作内存和主内存，可以依旧相等。<br>    因此在多线程内，适合flag赋值，不适合a++等非原子操作，运算结果a会对中间加数a产生依赖。</p><blockquote><p><strong>Java内存模型即Java Memory Model，简称JMM。</strong><br><strong>JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 是隶属于 JVM 的。</strong><br>一、JVM构成：<br><strong>1、类加载器（ClassLoader）</strong>:在 JVM 启动时或者在类运行将需要的 class 加载到JVM 中。<br><strong>2、执行引擎</strong>：负责执行 class 文件中包含的字节码指令.<br><strong>3、内存区（也叫运行时数据区）</strong>：是在 JVM 运行的时候操作所分配的内存区。<br><strong>（1）、方法区(MethodArea)</strong>：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。<br><strong>（2）、java 堆(Heap)</strong>：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。<br><strong>（3）、java 栈(Stack)</strong>：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个<br>方法从调用直至执行完成的过程，就对应一栈帧在 java 栈中入栈到出栈的过程。所以 java 栈是线程有的。<br><strong>（4）、程序计数器(PCRegister)</strong>：用于保存当前线程执行的内存地址。由于 JVM 程序是多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程私有的。<br><strong>（5）、本地方法栈(Native MethodStack)</strong>：和 java 栈的作用差不多，只不过是为 JVM 使用到 native 方法服务的。<br><strong>4、本地方法接口</strong>：主要是调用 C 或 C++实现的本地方法及回调结果。<br><strong>开线程影响哪块内存？</strong><br>每当有线程被创建的时候，JVM 就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。<br>Java 线程之间的通信总是隐式进行，并且采用的是共享内存模型。这里提到的共享内存模型指的就是 Java 内存模型(简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。总之，JMM 就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。</p></blockquote><p>比较：<br>synchronized  一定条件是重量级+可重用锁<br>作用到普通方法上，静态方法上，代码块。<br>普通方法是对象锁，静态方法是当前class锁，代码块看它的指定；</p><p>对单个值读写，<br>读多写少，用volatile，缓存行直接读；<br>读少写多，用sychronized作用到读写方法。<br>volatile锁总线，CPU嗅探，伪共享问题，总线风暴问题；<br>sychronized只会线程的block状态，有用户态和内核态的上下文切换，有一个线程执行的记忆，这个过程耗资源耗时间，所以提出CAS。如果写过程短，CPU执行非常快，线程blocked会非常短。</p><p>总结<br>重量级锁能提高程序的吞吐量。</p><p>volatile挖到操作系统的内存管理，可以看：<br><a href="https://missionodd.github.io/2022/01/26/distributed-volatile-series/">https://missionodd.github.io/2022/01/26/distributed-volatile-series/</a><br>Class文件结构可以看：<br><a href="https://missionodd.github.io/2022/02/01/jvm-notes/">https://missionodd.github.io/2022/02/01/jvm-notes/</a></p><hr><h2 id="Q：synchronized-和-lock-的区别？"><a href="#Q：synchronized-和-lock-的区别？" class="headerlink" title="Q：synchronized 和 lock 的区别？"></a>Q：synchronized 和 lock 的区别？</h2><p>1，基本使用，关键字；接口<br>    lock接口有6个方法：lock，unlock，trylock非阻塞加锁，trylock(time)非阻塞可超时加锁，lockInterruptibly可中断加锁；<br>    Rentrantlock 实现<br>2，隐式加锁，显式加锁<br>    lock在try里，unlock在finally里<br>3，作用方法上多种方式，lock只能作用到代码块<br>对于synchronized<br>    普通方法，静态方法，方法块上有什么不同。<br>    代码块反编译同步指令，monitorenter，monitorexit；<br>    一定有两个出口，正常和异常。<br>    方法上会有ACC_SYNCHRONIZED访问标志。</p><p>4，lock 支持非阻塞式加锁（信号量），支持可超时加锁，支持可中断加锁；<br>不阻塞，少一次上下文切换。可超时可中断，更灵活；</p><p>5，从底层原理，synchronized一定条件下 采用对象监视器monitor，lock采用AQS；<br>lock  新来线程A，state变量看锁对象是否持有，如果被其他人B持有，则加入到双端队列CLH尾部，需要CAS。<br>      之后，B释放锁，通知队头线程C，非公平锁下，C又与新来的线程D进行锁竞争；公平锁下，C调度，新来的D排到CLH尾部。<br>Object 的monitor，新来线程A，看锁对象是否持有，如果被其他人B持有，则加入到同步队列EntrySet尾部，需要CAS。<br>      之后，B释放锁，通知队头线程C，由于非公平锁，队头C和新来的线程D进行锁竞争。</p><p>6，synchronized在进行加锁解锁或通知等待时，只有一个同步队列Entry Set 一个等待队列Wait Set；<br>lock有一个同步队列Entry Set，多个等待队列Wait Set；<br>创建一个condition就多一个等待队列<br>7，锁竞争，synchronized只支持非公平锁，lock支持公平锁和非公平锁；<br>对于在排队的A线程，新来的线程B，AB竞争机会相同，对A不公平；如果A总是被插队，A总是在排队，A就是饥饿线程。<br>对于在排队的A线程，新来的线程B，B在队列末端排队，对A公平。</p><p>8，等待唤醒机制，sychronized与Object进行配合，使用notifyAll方法操作；lock需要用contdition接口配合，也是wait/notify机制，只是方法名不同await/signalAll。<br>如果线程获取锁，并condition的await方法，线程去哪？<br>在await方法，线程加入condition的等待队列，不需要CAS，直接加，此时持有当前锁，说明自己竞争成功。当调用await后，它会进行锁释放。<br>场景：线程A获取锁后，调用wait，A被唤醒，继续执行释放了，A经历了什么？<br>当前持有锁的A执行await时，加入condition等待队列的尾部，因为本来就是在获取锁以后的操作，不需CAS；当A在队列头部，就是signal被唤醒时，如果唤醒成功，则会加入到同步队列CLH尾部，需要CAS；A排队到头部，被唤醒，看公平锁还是非公平锁，如果是非公平锁，可能还会保持一段时间饥饿，如果是公平锁，直接获取锁，直接跳转wait方法释放，直到把锁释放。</p><p>非公平锁，插入CLH队尾时，需要CAS竞争，通知CLH队头时，也要CAS竞争</p><figure class="image-box">                <img src="image-20220305082139330.png" alt="image-20220305082139330" title class>                <p>image-20220305082139330</p>            </figure><p>9，个性化定制方面，AQS是使用模板方法模式，可以自定义lock。<br>lock下的读写锁ReentrantReadWriteLock，能支持并发读，是共享排他锁。<br><del>AQS的可重写方法：tryacquireShared /tryreleaseshared，tryacquire/tryrelease等，不展开了</del></p><blockquote><p>每个对象都与一个<strong>monitor</strong> 相关联。当且仅当拥有所有者时（被拥有），monitor才会被锁定。执行到monitorenter指令的线程，会尝试去获得对应的monitor，如下：</p><blockquote><p>每个对象维护着一个记录着被锁次数的计数器, 对象未被锁定时，该计数器为0。线程进入monitor（执行monitorenter指令）时，会把计数器设置为1.</p><p>当同一个线程再次获得该对象的锁的时候，计数器再次自增.</p><p>当其他线程想获得该monitor的时候，就会阻塞，直到计数器为0才能成功。</p></blockquote></blockquote><h2 id="锁升级详解"><a href="#锁升级详解" class="headerlink" title="锁升级详解"></a>锁升级详解</h2><blockquote><p><strong>synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁</strong></p></blockquote><blockquote><p><strong>无锁，偏向锁，轻量级锁（CAS）都是在用户空间完成</strong><br><strong>重量级锁是需要向内核申请的</strong></p></blockquote><p>简单的讲（简单概括这里可忽略不用看）：<br><strong>当线程A启动后，获得了对象的锁，此时线程A的线程ID将保存到对象的对象头中，对象头中的偏向锁标志位变为1。此时如果第二个线程B想访问这个对象，线程A、B之间就存在一个竞争的关系，但是此时偏向锁是偏向于线程A的，即A是优先的，偏向锁将会升级为轻量级锁，以此来保证持有对象锁的的线程A运行。此时线程B将会进行CAS，CAS也叫做自旋锁，B会去检查对象的锁是否还是属于A的，如果是，那B将会继续自选，直到对象锁被释放，B马上就会获取对象的锁。但是假如长时间无法获取到对象的锁，CAS是会消耗CPU的性能的，尤其当许多个线程竞争同一个对象的锁时，CPU资源占用会大大提高，此时锁将会再次升级，对象锁将升级为重量级锁。此时，所有竞争的线程将进入阻塞队列，等待cpu的调度。</strong><br><figure class="image-box">                <img src="200B5CB0-C1CD-4BAB-B6D0-0F9571CA6BE7_20220306170653.png?v=1&type=image&token=V1:3a9aOLmt56Y9r0-FQjdOX46UTQordIh0AVMM9wUpw3I" alt="32位" title class>                <p>32位</p>            </figure></p><figure class="image-box">                <img src="7D5886D5-B82C-4991-BB30-A941167F9C49_20220306165657.png?v=1&type=image&token=V1:-L4TERytUf4m7oc5qmaAP0u8qsvL9-ami3kxpq7ZVYc" alt="64位" title class>                <p>64位</p>            </figure><p>看图，具体展开：<br>32位系统下，<br>当我们创建对象的时候，它对象头里Markword有25位hashcode，4位分代年龄，1位偏向锁标记，2位锁标记位。</p><p><del>对象头的其他，32位的指向元空间的类指针，不一定存在的32位对象数组长度，这里不展开。</del></p><p>如果对象进行new关键字，对象头有无25位hashcode？<br>仅仅new对象，如果没有显式或隐式调用hashcode方法，该标记位并没有真实标记hashcode。就是说，只有调用Object类hashcode，才会有标记，比如存入Hashmap，否则是0。</p><p>分代年龄，没有经过minorgc，就是0。</p><p>偏向锁位：<br>无锁状态，偏向锁位 0<br>偏向锁态，偏向锁位 1</p><p>无锁状态升级为偏向锁状态<br>想要成为偏向锁态，markword中无hashcode记录，这是一个前提。<br>让23位线程ID+2位epoch 占据了无锁态的所谓25位hashcode位。</p><p>锁标志位：<br>标记是什么锁状态。具体看图</p><p><strong>偏向锁：</strong><br>单线程操作环境，不存在锁竞争，偏向锁有一个非常好的性能，<code>偏向锁</code>会直接往markword里贴上线程ID，表示锁住了，<strong>每次只需检查线程ID是否偏向自己，好处是：没有CAS自旋和操作系统调用这些耗时的锁竞争机制</strong>。<br><strong>如果出现其他线程竞争，也不一定升级锁</strong>。比如线程A在对象已贴上线程ID，线程B发现被贴上A线程ID，就会检查线程A的存活状态，如果线程A已在临界区外，线程B先把对象置为匿名偏向锁状态，<code>‘宁为玉碎，不为瓦全’</code>，再准备CAS无锁竞争，如果竞争成功，线程B把对象置为偏向自己。如果竞争失败，比如线程C进来并且CAS抢到(截胡)，C正在执行同步代码，此时B仍不放弃，还要做一个更高级的争取操作，线程B会进行<code>偏向锁撤销</code>的stw复杂操作：B线程挂起，等待线程C到达全局安全点后就把C暂停，线程C的栈会被遍历，找里边的偏向锁对象记录Lock Record，看看线程C是否还锁着。如果找到Lock Record则说明线程C还在临界区，否则线程C不存活。接下来，<br>简化地说：线程B撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。<br>具体而言：<br>如果线程C还存活且线程正在执行同步代码块中的代码，则直接升级为轻量级锁<br>如果线程C未存活，或者未执行同步代码块中的代码，则进行校验是否触发过批量重偏向：<br>1 没触发<strong>重偏向</strong>，则撤销偏向锁，将markword升级为轻量级锁（无锁状态），再进行CAS竞争真正成为轻量级锁<br>2 触发了<strong>重偏向</strong>，设置为匿名偏向锁状态，CAS将偏向锁重新指向新线程。</p><p>那么，最后就会导致3种情况：</p><p>一是对象升级为轻量级锁，但起初只是锁位标记00，前30位置为00，没有指向锁记录栈帧，此时算是无锁状态；后续再CAS自旋竞争锁处理真正成为轻量级锁。</p><p>二是对象重新偏向到线程B。</p><p>涉及到<strong>批量重偏向</strong>和<strong>批量撤销</strong>的操作。<br>除了对象markword有epoch计数器，class信息中也有epoch值，class的epoch维护两个阈值，批量重偏向阈值是20，批量撤销阈值40。</p><p>比如：同一个类创建40对象，线程1对40对象进行同步块的初始的加锁并保持执行，线程2对40个对象操作而引起了偏向锁撤销，首先会把前19个对象进行偏向锁撤销为匿名偏向锁，每次撤销class的epoch会+1，之后达到class批量重偏向阈值20，JVM认为class偏向锁有倾错问题，触发批量重偏向，后20到40对象通过CAS直接偏向线程B，这就是批量重偏向的过程，这里class计数器没有增长。线程3，执行20-40做锁撤销，撤销class计数器继续增长，达到class批量撤销阈值40，JVM这个类的竞争激烈，标记该class为偏向不可用，在之后创建41个对象时，会直接把锁标记置00膨胀为轻量级锁，这就是批量撤销过程。</p><p>此外，触发批量重偏向阈值20后，还配合一个time超时阈值25s，如果超时未达40的批量撤销阈值，重置class的epoch，下次重新计数20-39的范围。</p><p>三是直接将该类置为不可使用偏向锁。<br>这个就是批量撤销开启之后。</p><p>偏向锁升级为轻量级锁：<br>先把偏向锁标记置00，线程ID+Epoch置为00，是无所状态。由下一次争抢完成升级。</p><p>下面是流程图和代码，跟文字描述会有出入<br><figure class="image-box">                <img src="image-20220324153550084.png" alt="偏向锁" title class>                <p>偏向锁</p>            </figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BiasedLocking::<span class="function">Condition <span class="title">revoke_bias</span><span class="params">(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  <span class="comment">// 如果对象不是偏向锁，直接返回 NOT_BIASED</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  <span class="comment">// 构建两个 mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span></span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == NULL) &#123;</span><br><span class="line">     <span class="comment">// 匿名偏向。当调用锁对象原始的 hashcode() 方法会走到这个逻辑</span></span><br><span class="line">     <span class="comment">// 如果不允许重偏向，则将对象的 mark word 设置为无锁模式</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断偏向线程是否还存活</span></span><br><span class="line">  bool thread_is_alive = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 如果当前线程就是偏向线程</span></span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 遍历当前 jvm 的所有线程，如果能找到，则说明偏向的线程还存活</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果偏向的线程已经不存活了</span></span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="comment">// 如果允许重偏向，则将对象 mark word 设置为匿名偏向状态，否则设置为无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程还存活则遍历线程栈中所有的 lock record</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = NULL;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    <span class="comment">// 如果能找到对应的 lock record，说明偏向所有者正在持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;owner() == obj) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 升级为轻量级锁，修改栈中所有关联该锁的 lock record</span></span><br><span class="line">      <span class="comment">// 先处理所有锁重入的情况，轻量级锁的 displaced mark word 为 NULL，表示锁重入</span></span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) NULL);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != NULL) &#123; <span class="comment">// highest_lock 如果非空，则它是最早关联该锁的 lock record</span></span><br><span class="line">    <span class="comment">// 这个 lock record 是线程彻底退出该锁的最后一个 lock record</span></span><br><span class="line">    <span class="comment">// 所以要，设置 lock record 的 displaced mark word 为无锁状态的 mark word</span></span><br><span class="line">    <span class="comment">// 并让锁对象的 mark word 指向当前 lock record</span></span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 走到这里说明偏向所有者没有正在持有锁</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">       <span class="comment">// 设置为匿名偏向状态</span></span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 mark word 设置为无锁状态</span></span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br></pre></td></tr></table></figure><blockquote><p>注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</p></blockquote><blockquote><p><strong>批量重偏向</strong>和<strong>批量撤销</strong>如何理解，我用转岗问题举例：<br>有40个员工（对象锁），3个部门（线程）。<br>1) 线程1: 1-40都入职部门1了（有偏向的线程1了）<br>2) 线程2：1-19都离职（锁撤销）后又跳槽到部门2，HR们看转岗一出一进麻烦，改为以后想活水就直接在员工档案上改部门吧，一年内一次活水机会，结果，20-40都快速活水了（可重偏向）（Thread Id直接换了） // 到达BiasedLockingBulkRebiasThreshold（20）次数后。<br>3) 线程3：不到一年，20-40又都离职（锁撤销）后又跳槽到部门3，HR们觉得转岗频率太高了，滚蛋，以后都玩完，转岗门槛拉高（设置为不可偏向状态，正在运行的锁对象会被撤销）// 到达BiasedLockingBulkRevokeThreshold（40）次数<br>4) 以后新入职的员工41，就规定了较高的转岗门槛（new出来就是轻量级锁）。只能等待各部门主动去要你。</p><p>PS: 活水是指依靠公司内部的转岗机制，实现跳槽换部门。</p></blockquote><p><strong>轻量锁</strong>：<br>多线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 MarkWord 中的线程 ID 不是自己的线程 ID，会CAS尝试获得锁，如果持有锁的线程在全局安全点检查时，不需要再使用该锁了则获取成功，程序继续执行，反之则获取锁失败，撤销偏向状态01变为无锁00，升级为轻量级锁，即自旋锁。</p><p>此时，将锁对象markWord中32位修改成指向自己线程栈中Lock Record的指针（CAS抢）执行在用户态，消耗CPU的资源。此时，锁标记位00.<br>JDK1.6引入了聪明的<strong>自适应自旋锁</strong>。能减少长任务的自旋次数。<br>他的自旋次数是会变的，我用大白话来讲一下，就是线程如果上次自旋成功了，那么这次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么这次自旋也很有可能会再次成功。反之，如果某个锁很少有自旋成功，那么以后的自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p><p>轻量级锁的加锁过程：<br>线程A进入同步块，如果同步对象偏向锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，里边存储锁对象目前的Mark Word的拷贝，存放拷贝的地方称之为 Displaced Mark Word。然后轻量级加锁时，拷贝对象头中的Mark Word复制到锁记录中；<br>之后，虚拟机将使用CAS操作尝试将object的Mark Word中的32位更新为指向线程A的Lock Record的指针，并将线程A的Lock record里的owner指针指向object的markWord，意在完成线程A与object的绑锁。此时，线程A持有锁。<br>此时线程B进来尝试CAS更新，<br>如果更新成功，那么线程B就拥有了该对象的锁，并且对象Mark Word的锁标志位置为“00”，即表示此对象处于轻量级锁定状态。<br>如果这个更新操作失败了，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。<br>此时为了提高获取锁的效率，线程B会不断地循环去获取锁，尝试CAS, 这个循环是有次数限制的，比如10次，如果在循环结束之前CAS操作成功，那么线程B就获取到锁；<br>如果循环结束依然获取不到锁, 则线程B获取锁失败, 对象的MarkWord中的记录会被修改为指向互斥量（重量级锁）的指针。之后，锁标志的状态值变为10，然后线程B被挂起，后面来的线程也会直接被挂起。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。</p><p>此时，线程A的displaced mark word和原来对象的markword不一样了。</p><p>解锁<br>也是通过CAS操作来进行的，如果对象的Mark Word仍然<code>指向着线程A</code>的<code>锁记录</code>，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word<code>替换回来</code>。</p><p>因为线程B把对象 markword改成重量级锁，那么线程A<code>替换失败</code>，那么就把自己栈桢的Displaced Mark Word拷贝到对象头的<strong>Monitor</strong>对象的header变量，并且<strong>Monitor</strong>对象的owner变量指向自己。保证displaced mark word不丢失。</p><p><strong>重量级锁</strong>：<br>CAS发生10次后，轻量级锁升级为重量级锁，把锁指针指向重量级锁Object的monitor。</p><p>在Java虚拟机(HotSpot)中，Monitor对象其实就是ObjectMonitor对象，这个对象是一个C++对象，定义在虚拟机源码中。</p><p>回顾Monitor机制。<br>场景：线程A获取锁后，调用wait，A被唤醒，继续执行释放了，A经历了什么？<br>wait，A加入等待队列WaitSet尾部，需要CAS；当A在队列头部，就是被唤醒，就会进行一轮线程竞争，如果竞争失败，会加入到锁的同步队列EntrySet尾部，需要CAS；当A排队到同步队列头部，被唤醒，看公平锁还是非公平锁，如果是非公平锁，可能还会保持一段时间饥饿，如果是公平锁，直接获取锁，直接跳转wait方法释放，直到把锁释放。当然，synchronized是非公平锁，公平锁情况并没有出现。</p><figure class="image-box">                <img src="image-20220305082139330.png" alt="image-20220305082139330" title class>                <p>image-20220305082139330</p>            </figure><figure class="image-box">                <img src="image-20220324082854210.png" alt="image-20220324082854210" title class>                <p>image-20220324082854210</p>            </figure><h3 id="synchronized可重入"><a href="#synchronized可重入" class="headerlink" title="synchronized可重入"></a>synchronized可重入</h3><p>synchronized是可重入锁，那么它是如何实现可重入的呢？其实上面详细的过程已经说过了，这里再总结一下（之前的判断逻辑就省略掉了）：</p><p>偏向锁：检查markWord中的线程ID是否是当前线程，如果是的话就获取锁，继续执行代码；<br>轻量级锁：检查markWord中指向lockRecord的指针是否是指向当前线程的lockRecord，是的话继续执行代码；<br>重量级锁：检查_owner属性，如果该属性指向了本线程，_count属性+1，并继续执行代码。</p><p>总结<br>synchronized的执行过程：</p><ol><li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><p>上面几种锁都是JVM自己内部实现，当我们执行synchronized同步块的时候jvm会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p><p>在所有的锁都启用的情况下线程进入临界区时会先去获取偏向锁，如果已经存在偏向锁了，则会尝试获取轻量级锁，启用自旋锁，如果自旋也没有获取到锁，则使用重量级锁，没有获取到锁的线程阻塞挂起，直到持有锁的线程执行完同步块唤醒他们；</p><p>synchronized锁升级实际上是把本来的悲观锁变成了 在一定条件下 使用无锁(同样线程获取相同资源的偏向锁)，以及使用乐观(自旋锁 cas)和一定条件下悲观(重量级锁)的形式。</p><p>偏向锁:适用于单线程适用锁的情况，如果线程争用激烈，那么应该禁用偏向锁。</p><p>轻量级锁：适用于竞争较不激烈的情况(这和乐观锁的使用范围类似)</p><p>重量级锁：适用于竞争激烈的情况</p><p><strong>锁优化</strong></p><p>以上介绍的锁不是我们代码中能够控制的，但是借鉴上面的思想，我们可以优化我们自己线程的加锁操作；</p><p><strong>锁消除</strong></p><p>锁消除用大白话来讲，就是在一段程序里你用了锁，但是jvm检测到这段程序里不存在共享数据竞争问题，也就是变量没有逃逸出方法外，这个时候jvm就会把这个锁消除掉</p><p>我们程序员写代码的时候自然是知道哪里需要上锁，哪里不需要，但是有时候我们虽然没有显示使用锁，但是我们不小心使了一些线程安全的API时，如StringBuffer、Vector、HashTable等，这个时候会隐形的加锁。比如下段代码：</p><pre><code>public void sbTest(){    StringBuffer sb= new StringBuffer();    for(int i = 0 ; i &lt; 10 ; i++){        sb.append(i);    }    System.out.println(sb.toString());}</code></pre><p>上面这段代码，JVM可以明显检测到变量sb没有逃逸出方法sbTest()之外，所以JVM可以大胆地将sbTest内部的加锁操作消除。</p><p><strong>减少锁的时间</strong></p><p>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p><strong>减小锁的粒度</strong></p><p>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间（如ConcurrentHashMap、LinkedBlockingQueue、LongAdder）；</p><p><strong>锁粗化</strong></p><p>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; 在以下场景下需要粗化锁的粒度：<br>假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p><strong>使用读写锁</strong></p><p>ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写。</p><h2 id="单例模式的原因"><a href="#单例模式的原因" class="headerlink" title="单例模式的原因"></a>单例模式的原因</h2><p>双重校验锁DCL ——double check lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.懒汉实现惰性加载资源。</p><ol start="2"><li>volatile修饰，设置内存屏障。错误说法：<del>强制指令执行顺序，先分配内存空间，再创建对象，最后引用指向该对象。</del><br>正确：在这行代码的new指令前加入StoreStore屏障，在new指令后加入StoreLoad屏障，保证new指令内部的三步：分配内存空间，创建对象，引用指向该对象的完成，才有外部读操作，也就是if空判断的读取。<br>总体效果就是一个线程对volatile的读，优先于其他线程对volatile的写。<br>挖重点，StoreLoad是全能屏障，总线会有Lock前缀指令，确保写操作的主存刷新以及CPU缓存失效。</li><li>static修饰，定义属于类变量，保证单例</li><li>第一个判断null，过滤synchronized锁的性能消耗</li><li>同步块，设置临界区，同时间只允许一个线程完成对象的创建。</li><li>第二个判断null，防止多线程进入第一个判断null，而导致多对象的创建。</li></ol><blockquote><p>Q: 过去DCL不安全的原因？<br>JVM1.4前，允许指令混乱情况。final：一个线程构造函数为final修饰变量赋值，另一个线程可能获取final的初始化0值；volatile：只保证读可见性，不保证写的顺序</p></blockquote><blockquote><p>Q: 不用volatile，先临时变量，再赋值到单例变量，是否能解决指令重排？<br> 不能，JVM只是潜在的reorder推手之一，CPU和缓存也会导致重排</p></blockquote><blockquote><p>Q: 新版本volatile如何保证DCL安全？<br>设置内存屏障，防止指令重拍，其中store-load屏障是保证读写顺序，实现volatile上的happens-before语义，即一个线程对volatile变量的写，先于其他线程对该变量的同时读。屏障的结果就是原来只保证volatile字段本身的可见性，现在保证本身以及所有相关字段的可见性，代价就是造成访问volatile字段的更大性能开销。</p></blockquote><blockquote><p>Q：是否可以用final实现DCL？<br>能。<br>a.对final字段的写必然先于其它线程装载该final字段的共享引用。（final字段必须被正确地赋值后其它线程才能读取到它）<br>b. 构造函数执行完毕后，对 final 字段的所有写以及通过这些 final 字段间接可及的变量变为“冻结”，所有在冻结之后获得对这个对象的引用的线程都会保证看到所有冻结字段的冻结值。（所有线程对final及其间接字段有一致的可见性）<br>c. 初始化 final 字段的写将不会与构造函数关联的冻结后面的操作一起重排序。（构造函数内部，对某个final字段而言，它的冻结点之前的操作必然先于冻结点之后的操作）</p></blockquote><blockquote><p> 再来说一下final域的重排规则：</p><ol><li>写final的重排规则：<br>JMM禁止编译器把final域的写重排序到构造函数之外。<br>在final域的写之后，插入一个StoreStore屏障。<br>也就是说确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</li><li>读final的重排规则：<br>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。<br>在读final域操作的前面插入一个LoadLoad屏障。<br>也就是说确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</li><li>如果final域是引用类型，那么增加如下约束：<br>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>就是确保在构造函数外把这个被构造对象的引用赋值给一个引用变量之前，final域已经完全初始化并且赋值给了当前构造对象的成员域，至于初始化和赋值这两个操作则不确保先后顺序。）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: DCL是否是实现单例的最佳方案？是否有代替？<br>不是。DCL的目的是懒加载和提高性能，但现代JMM加强volatile保证可靠，但副作用是性能开销变大，且加上了同步块的开销。</p></blockquote><p>完美方案：<br>推荐通过内部类实现惰性加载：<br>有一个大前提，JVM保证类的加载过程是线程互斥。<br>第一个调用getInstance，instance只被创建1次，且赋值给instance的内存已初始化完毕，避免reorder，此外，该方法第一次使用互斥机制，解决同步块带来的性能问题；<br>当然，只有第一次调用getInstance时才让instance加载，所以是惰性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;      </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             …          </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonContainer</span></span>&#123;</span><br><span class="line">             <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> SingletonContainer.instance;          </span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/doraeimo/article/details/5714239" target="_blank" rel="noopener">https://blog.csdn.net/doraeimo/article/details/5714239</a></p><h2 id="线程池参数调优—雨露均沾，保绩效"><a href="#线程池参数调优—雨露均沾，保绩效" class="headerlink" title="线程池参数调优—雨露均沾，保绩效"></a>线程池参数调优—雨露均沾，保绩效</h2><p>通过压测，符合最终场景，调整参数。<br>如何进行初次压测时，线程池参数配置？<br>分两种场景：<br>一当前服务器，只为当前线程池服务。也就是说，线程池能够占用服务器的所有资源，比如Tomcat的IO池，并行Steam流。依据处理逻辑，是CPU密集还是IO密集。CPU密集就选CPU数+1，IO密集就选CPU数的2N+1，N越大，可以加2加3。根据一轮压测结果，做一个参数的合理调整。<br>二是存在微服务和多接口，比如一个场景：5个接口：2个重要，3个降级，高并发压力下就会对3个接口进行降级，保障2个重要尽可能分配到更多服务器资源。在一个重要接口里，需要创建线程池，提高单接口处理速度，这个时候，不能只看CPU核数，线程池设置参数需要具体一个依据：<br>首先，一个真正高并发项目，它的监控是非常完备的，首先拿到线上高并发压力下该服务所有接口的访问比例。比如刚提到5个接口，2000条请求打到服务里边，5个接口分别<strong>承载着不同比例的访问量</strong>，比如2:3:1:1:1。比如，在比3这一块，它有资格至少占用服务资源的3/8。它不能太大，否则占用过多而让其他线程无路可走。<br>那么此时，基本可确定maxPool<strong>最大线程数参数</strong>，占服务器线程资源的3/8。<br>至于整体服务器峰值最大承载多少线程，参照CPU核数以及QPS来说。比如QPS100，相当于1s内服务器内当前几个CPU线程能承载起100个请求线程，因为处理速度够快。所以，要衡量整体服务器最大QPS，即当前服务器的<strong>同一时刻活跃的线程数</strong>。当前活跃线程数可粗略理解为这是基于业务需求场景的资源数最大值。再根据3/8，可以确定接口最大分配线程参数的值，100*3/8约等于40。</p><p>接下来，考虑<strong>核心线程数</strong>。初次压测时，设置为与最大线程数一般大，看能否撑住。撑住就尝试调小到资源不浪费，否则撑不住，要对任务排队队列Q设置，Q是存储排队的任务。Q不推荐无界队列，这相当于最大线程数失效，违背设计线程池的初衷，而且高并发导致Q的无限积压而OOM。<strong>Q设置为有界队列</strong>，这个界的依据又是什么呢？在生产上，像抢购秒杀都会有<strong>一个高峰访问时段</strong>，那么在压测的时候，需要模拟一个生产上的高峰访问时段。比如1小时抢购活动，就要至少持续1小时的压测。在无Q等待情况压测，大概算一下在分布式环境下的一个节点1小时该接口能够承载的最大值，如进来10w，只处理8w，失败2w，2w适当上调50%作为有界队列上限，为了访问节点倾斜的问题，如果均匀可改为10%，如果有节点<strong>访问尖刺</strong>就要调到尖刺最高位左右。要知道，实际的队列上界一般很大。</p><p>这几个初次调整后，<strong>开始多轮压测</strong>，看是否达到性能需求目的。可适当调小线程数，避免浪费无用的线程资源，因为，后续要涉及接口降级和线程池导致高可用问题。一步步调到最好，这是最理想的。<br>但往往可能，没有达到预期，刚刚已经给3/8最大资源量，还不够。第一点，<strong>再次调高队列存储上限</strong>，前提是业务能够接受这种等待慢，先不要想增加同时线程数，而是通过任务空间缓冲，保持当前接口稳定运行，且不影响其他接口。第二点，不接受Q过大，想尽快处理任务，那么，要从单机单接口的<strong>代码的并发性调高</strong>，从吞吐量和RT入手，比如，DB访问是瓶颈，使用缓存；第三方接口是瓶颈，使用异步MQ处理；秒杀业务，开Gzip压缩和做静态页面。第三点，已竭尽所有，<strong>只能线程数适当调大一点</strong>。但不能太大，如果以当前接口利益为中心，而毁坏其他接口持有服务器资源的权利，这是比较糟糕的。所以，在对重要接口的线程数调大的同时，要对其他接口做<strong>降级处理</strong>，相当于降级接口去牺牲它的服务器资源，分摊给重要接口。<br>但其实，这做法不要做，应该向上级<strong>申请加节点</strong>，通过集群分摊。<br>因为，调大线程数，是让其他接口冒着风险。其他的接口设置线程数小了，很有可能走到抛异常的饱和策略，这样，它抛出异常比例升高，造成接口的熔断或降级。<br>这本来够用的服务资源，由于设置线程池参数不合理而导致异常熔断或降级，AC，年终绩效没有了，必背锅。线程数调得过大，这事更大，你占用了额外的资源，导致别的接口的请求积压。</p><p>至于，keepAlive空闲线程存活时间，只是复用性的优化，根据测试，看有无触及阻塞队列阈值，如果频繁触及，说明业务总需要非核心线程，适当调大存活时间。一般默认即可，因为我已经确定当前最大线程数绝不会影响到服务的其他接口资源，它的调整优化作用非常有限。</p><p>饱和策略，大多数业务抛异常，记录日志，熔断或降级处理，做重试机制。</p><p>最后，理解以上这些，那么我们可以合理配置hystrix或sentinel。</p><h3 id="Q：线程的状态转化，源码探索？"><a href="#Q：线程的状态转化，源码探索？" class="headerlink" title="Q：线程的状态转化，源码探索？"></a>Q：线程的状态转化，源码探索？</h3><p>待更新。。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 高并发 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经 | 基础面+调优经验，高P7开发一面摘录笔记</title>
      <link href="/2022/02/15/p7-interview-skills-1/"/>
      <url>/2022/02/15/p7-interview-skills-1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c1d1510a5578db9e7edcc0b00be840478e188159fe255468671daa52e2827a97">4c4fd9e09482e311844f0584b2bdee0d161fcfef30e9a8b92a83c9a32f76ed99a51d410634b1b86465e0e778f89cffee3c787293e7ff8765b198fad469bb10aa3c1af01d96212ac6cbff6e27374b8cbaa4a788480a097c1b946965558080bf1a96f4de104ee59de94a0195029c45381ad9f57418ac3abc9dbb72b01a98161a0b0b7354ce9a872706420cb4495ca6ad3f25e48f36cb6265667d6a870a78c7f8bf36c83dc2cbd5b27ff64176b19708ef894d286d2972e2e396acbf8ea2bfc44e1d802a73a79240bf6f4b1efd532ad3539e675f0d99eb40de403ef28a7afc48559e34b0b43c02142be37cc10c83af71ddb7ebda5e575277abff9eeb0ba4122e859f48556db71b77ef5bbc6d4e81bd8f2bf5d3282a8a70fa8dd6fa989c5cb995530b30c0ebe78d1f0d41a3f94ec6a76513b7cff838e21e0c64745802f7049ceac0c9c7952d1624c921ebbd0b938b00c54fca17cd13ac9076b665525c7e21a3613e3d44ebc40ffd3c5873f2b74b87bb7e68bb09d3edcb20d5a7c1833d224eeece2dede7a77908c3bc0a0b9f8e8dfee0bc6910201cede860826322d7631d127c44df20d850acd0380d67373e2bd74820a30524f710f5ba71919e26bbce948ecf809857a6659ba5d0474f8d34e9a80073ea278ffff4a11849718468d920e086f47c551c2a555e8483470b430693b9d7139925354bfe0798d6cc811fa96d4fe3e563d4f42896fb6219d8ee977e759bb681f104847a24ab533babf131e6ff2a321c99e54cf04584d1584cb21db1833af78d6a34dd920e10a0282d1e430703e7c7a502a039bc90421791360ef7c4ccb635b012346c307b1bddcd58cb0cfeb359aa6f663bfce2a5ec61f23ecf70466038d6f2d64555eb421bcdc562a8fbde95a98e18daf4d32a8cf0e6cfc32ea73dfd6702ceecc7c85cfbbf83b11764c91eea5534a19692636af8ecd43bc193b5aa12966d555a17525d276592c0fb139b5fb7870bf8b75c906af0355d2b51d5cf8c01b03cd7fda921c3ddd98027dc0b745d80a085118823aa264430c3e03d53afb407a7d59040dfb0b0ffbbfbda256a391dc506961bff9d2c683193d243ec88616aebb9e834042150d983c4d80fc2a932c08897da09726af466ee7104c9de1d6b587ea296c2ab79cf66c9c8ef5872cf07de3bcbdc0cc1aebc05f93e1f685fd1c9c3665f182175eba38e1b6be4c460cc3651bf4ba658902fb6f78faf6aa1dcf5782086fa30248c9ef621b79799466ecb4dbec80d6629a13fd8dc8977776f81e1a834b608d3306530458e67adf4a36ab433a19e1e3a5c9ab4c90f9c96151ace68a7444bf8b6fb43f63e8a4f13988b8207898a0c9d5f2ab6dc5348fe4f90c2b36439d6dee5c78c9ea27192eb0b429bd2585c20f751869173439cf31283de166b3fb2becb3d99da358885c922693247547d7ed6182978ba5ed767f5f4c212c4d85a931ccb558cb9ded6cc689d461491724f75b6798e59206eaf035f929d7548c7d354943e826d90d33e14d5a8e53161eef31a3e887013f4cf18921f60d509380b554d7f244765468b0d7aff6dabefb4568a48cfdc0ce6b49a6bdd53ac0057e180bf46517b8a062646fe02300b49955039fe43bf8e61ef5205c8cb3260f2b9c0b3e53761d608059d090f097da19a8a92398ffc6a8768001c89b4466cccb0f223a331e750d3e0dfc64dd165541d23a34a103b147422e1a554996a9b0d8f09174c6df2c08f1ecc12509c44e0ba94113cb70cf6e5e3968780dc329d7865ec57c3baceb33a58fe20ff60c466561d8c12c72555e23ace7a9da8b55b36b53aa394f12b08a907651261524c8a72616488e2433c079afc70e6171c4be1f356454256995cc0110a9cdf00485136220297aceff192eac49618bf0e8a12f140105478abb15af0fd67b7f9997f65c9b17666b2a7e4e4b28f1cd1cc26bc4234bad7ae6013f00b61a4a9afe0aa11cd58fab000f370336c1b20d03a6f8b17c698d14f0387db6a2c0040f70436bef8e220e61f0953907b5a2272fc8adc4ae5adef24a73af273acf43b849e1465f1148d5515c84f461cddc32ee41662ff7da07efe1ca4a9c9a96e6343083ea10cf185898c0e132433b791aa150298cda3becde1f45e3e0ce493f81997f5623c93faf43756824840f4daf86cd42e7121441c791487896c9bbde7cf81478c509efcc5bed3775865ce744d5008db25866782edcabd0ed1fb7638992ba161f3b2606657dbcf00337d6469c53c5fcda2ebb5696946661ad0e19cc9bc957dbd14ecfbbdec4d206302ca6f3c4dace7c1ee429b0a81a7f4d053f52e4cac470b1cd34e636ca5de3481dfbca2d5b9bd04bc8d583a3ba49ea7d2672fd90c6200042d5aa57debe42a3e1c06a9e6fad6e04b7db01556b6622b455ac6075c52e93ef92948d564dcb18d25f3696acd51ed04978821cebd23ba9255ae38fa2e1f46a2438ef195d7f593fe637f607d4bb58a4de067aaff6b4f5a2cfe01da793b4258fe7a2a75a04eb66bc715bf12080d29709037aea2018b86e2b9cafeafbd02c6d3edad69756c1af0fefea1afec834325c4c98001ce788b42e81d7dd0ce2fecb04d96088c9b49cc33678beeb1989d41fe6f05c2a11d9169b921414d384e56169afcbb5402e6a5875b46d94bd090b849f1d7805f0bc1b76055d8e0d2ca936b9f953ec52a63b071b6310b82a1ebdca65c210c0c42a105d1c21385d11c637bcaea24f497464f503441dee5ea71e412d7073816dd9a4c1a76ef44368db79c698ec4b8b49a91c404c132dad4bd91fffc50d30f830e45fe53516e37c1ea8abc0a90bf625713b854e5e530ed94e693f18bd675902ea63cc060f8e7bab33f08839813794b79432cc7c20831d25df6d56fbeec6c7df7de2091219785483b816bb9c1b260f2bd0fb05960f2f76a5377eabfb434552e4a4316471707e8d78c26f62bf6aabde0082db371146a9a389dfd81ec45b771bcde9b70a4fe757a209fb6878c6eb342ec99481cd1b505ce54700ac883865b0e83119f566d68e8da5300ba26d8361262cd917514ac1f26091fe4fd999fcad92344da34abf1fc7b1a812bc530d302c66b3a92efcc5ad52d9b3d4c6f880fc012efbfb05f3b852584812843e002a4bf5f9b6f4c9d5f5cd7ccfc89ff5eab84ef052a52ecafbe9d49caea2852b923e7133c9f47a792b1cad7b4361176e63f4ba1b490e900e58837a0cb9b01748265e820658c5c662457a59f60c8b3d669f92ed75b39b9f17e43d0c27a8b01cfc0c3bbe867add249aea2bb7e6fd6b92f919d343c3ac97aa9769d212c8198d0c2a065fdae259e7b60949643120d82d4ebc941093e7fa41af9634ddd38b33ba54c0b1e37ff60b40b268a511e4e0aa35a6bf67299391230cacefd544fadec0e23a69df1e1ff4142d7720c049b7373b50772af7937b93f1ca312afc8ca73fab654e09f725c8cfc559d373410cc4de947ce0fdb0c524a60272610f7623cad3c6f49c3de06aafe6c9d25a27e491d8f4af0785bab7c904e0bdc73e90fcaedbd9a4e3fdd3876a430e9a7a112f9a6dddb197839caef3745eafdb3eac8d148f9b9639a51e45c8f563bfe9e22401ddf7ee00481e6e5a1da879edde0d812677c149be8ca64f3a2737de4ef364ed63dfc682b0f6c42a4d9ac7741646f5b3c8e0f97348dbd2d535e6bc5bd4a209a140dd589ad2028dc796bef9e7bb0804262aa072f17a40d767ba3e45205cfac0aa6e4484af732bafd4938fc285d8ea5822a421cd3cfa4f1eba9848741a99dde34bdf756a01327b6c675efcf93ad9fea0b3900e1278626cc3a400730e7d00bcc1a91cdc940aaf5f146699d3777cd25118e6b931a45d8a5e96a3784422056b98d1136a5f008165474783182136bbb8164838451acbbec72da1463eef512743124f6e7f41e975c8a7a792031e0a735efd423bbcc1a1c333a8c9285c41c5d7cacbe692cc26a90522312943fc8f795ebd509aebab57ed8f6b9631f85c831b67795f55198db958afcecd8c2d909afe95c1d45e5a1e51fb9f4672297c9b9ec2e17495c094d3f68b5622f1804e6bb44a0e110f9a2b8b2c302e6225b33fbbae09c7897ac5be3872833bb5671a6b4f7bd98ace886bb975d195f2e499df63eafb8ae4f8b13f447e14065c5df7d2163475a4c3df3a52081d4dfdb744ea4e9c40fff697d6680534cb023421ded9ee0d50d8ea8f098802b520b5d2c6b090585ceddca9266d84843ea2c274e5d5fd96cfb496f31dbce22279e87c04375d3d3386a9e153f81298499ced38dd198e4b0eaca428a83175643a45aca886199e8a593b0ae3c4a1a9275454aa1740bea03fd1a2b072175f3a87fb9be318e84648272a66cae9506e2dcd4988130046ddc58f3ce5bcdb918f79d2805ef1a6957f7b397692b4c2b7438762af1e79dab3d9fe41338a379cbfba24b473dd36277b863f5cc265e18e830b6d3299a1ff7f781800ed5b5715249587b9a6fba2a6035d76b457786643690287330f6991168e73bfb8febd75aade67f567ea220499b2910ce1ed5a87aade99dfa67f9bbd0d59f09207d5356082220591ae9212eeb33e0966c0d6d21c4ad6f5fc337923dc153633650af66a9bfff06f6e3549b6753f180950b2cfcfab6973d3a662c72cee033686a0d8667facf8e1f2bb52a1859b4c4c9143e0ce4221a75aeb8c75ae20af5a5ec440d0fae88ea44280727e138860869a6ac31f12cc8701c8eb016cca414cd0034ce69c4d66badeced0ae7b39f307977cf97dd748e2c425239601215de8593e7f355be9b4fbd6426f68eebda0c12b643fd12acc9e357ed290d88e886a4df7d9b85ec028142d26314d97a5c22bd3dc444256755e6a41333dc736e1776aca9100e5b6f1ea0ca9d2ea8c068fd925bba54db540a01ff0a43d0d55a9e2a1ff8572c5ca5096dc7794a8f45a65e3f317f76db9e49f138dfaea2fcb7123de4a89b8cfc04482ca7e3b43aa67a91f72c075e2f3a704743c12ef4df8f12550446e39c11f8fe12e283445f5f6fe0fa033d0172f12dbc1f93b3e449a77ddb77ae7077c6628c3906549e5e0484910a918bfbc6c2fda21e630e5d7a7d5c50414fab6ed5261b79d9e8bacef96dfe7346c410d2567623c0cece41c30a9025e9330bfd12fe8296a5169dc910454b2a2b22fe200ea750a58e8d26ce8b5fad8096a8e8322b8bf0dd65cc485d18ab4fe028312fb16a17d424dee49c5cba4b02a68b907af39966aee7964e5c0a98a1a88989f842cc918f599df39e63c16dc635c7e843b67ba45a1feda1cab7102f73da4bc578577ee1e6f6c6bdc2fc7d335e093a1c25035b996207877ac0ab3cd3a4b289e4d395ff482dc07dfb1d3497fdbe0618caac20bd9071f8c5b1c27a927e17fe579791d25fd28e7344b7d8403cdf6a8218a4dc04bb3a253a94f4d21f195e4842f8bbff7550cd4215ab21fedcc6732435b35c9d624081b020df263cdf973fc203930d1091d6414a6507db5618a0fd7df4b85a5922042b8bb88d402f915b0aa5d80f8a6a2ed228e196c2c4c9ced70d8dbec603b73d46d55828b1f53881637619b3857fc45d7c132e456b518363da8832f0888751e4811f9dd5412bd198b25db43447a11fb56f12c6b0731fd581bae19ac9ced8fa641fc794b330d5f32ecbe74df831bba572b7dfd6f561abfdbfbd230d29bea41b978b9c7890bc67fa2b9683b6ca8f8bdf2066eba03887bce3e549a568a64f4562e07c3b578ae8a52dc13d4385403380ef879af1581b7dbdfb08b2e9c8ee42b144f5ff525cda5546f82527c28b8b7ff4749a0f26513c2b05a721f70c2b8e8fd1fa7fca0cd1cf963f7a5f6b9a965f910a77dc89ed5c3729c53c0719343c330abf9ccb4c65b6c30c42e01e06e5874fb484ba929624f9861d00f9f0ff93708c6dbc0d25d92ad28179c43b1e68ead76ac770d1bc5482b123a12bed19e828014f69b7a01ccb68da371b922bb30bfb60b6f2fea4fbee6632bcb80dcd556713cb0863cd088363e27313147285af0ecda21a6dca17faf2943199e9971b70b853f2988317323c9adea789f13a1bf6b67d9f79b508e2a6f124845b31590566763e5ca87354f60fce5d623c43cdb1ede7f205622688ecc8d393ad3ea1a72e712c4dfebb27495fb106b2f75034a95fe45f2d069ac1f52e25da0c55c55228f82e4ee3456108f6745066b5d9ad287b4090f705f6ba82391d803432497106fd09298deac2f0ae441da9f71ee5492723a03582a2543c4eded48244ab7c2a1157f9fc1eaa72384d6c0dd6ac6a72aaa32eec2fecdf61dcd85602b6403406597890e197804013055a4b03d3b760e41fddad38a17562b0a294220d0348d6d696991b719c64d99aeb8eb3714cafa4f121e94aed180ae96190dbc911c62b46ae4cb7d2b8be75d0598f58f6af7653472aa19a4bcc8801afc8a45765aa1f31227946a913670e561469029d5ac1bb91973d1a516fcbfe878372178b91b8b79d665f318768ff141fbe5f29d49a74bafb65d823defd516060fea394ea3cd4cfae42ffab14dc595800dcdd002e2a8f8980d61c4fd5a1595609ed787172e440f6f4c664db58fb5eab85d9ac29ec88d620032d7009eef033c69aeccd50160133483751ff3eec11140be41e42782d94e6ce15d601a5369a843d7f7df8ccf48c13b5462667899e02d0555264279bf3ad26ca26feb67ee343899585960c98070d5e8e764e311158916a521d053a98f79c7feefc43cc80518c970813098e61d3af13adda7379844d8b96098f44b4d3898c6a23887c0f75daaa9c63ad649a656e008c1cf14f634fc4d9621835dfa89a900cd16f0f0ea5c4304a65c3dbbe55c6409fc754519c8719e9a8290eeb4261bf3baf4cc4c9a671e9c1ec03e5dc1b3fa456a648c988cec692d1d03d74502519201e61a0cecaa218edfd8da558d7b55781623b0e7661677f18c18e1d91c3ed31cca30cc61cd9ac1b2cfa5e8a54e653e34adac08e3494049538a4c79fac1fcb10dc553082639d15acf60ca1dc17e4bf2dbc7abf04c8c9d25beb79adac29e523f3ca1cc975d06689949a8546e502ec3c5d9027a120545a7c2616b433a009b29b81c35af2f59100f7eb8549101ff0ed308e80ef1d26e337fc447b9195d269ddbef913396fec810b284abdc5ee9e4adafc88d7e40cb98f93cb52045ea52c357b30650656243bffdd3be80fd39754070c854dac43225caebdf7c290d4fa4b918a56daacffd2770470e03dd9573863a88a37f88bbea998f3b4410e5eee1e32c44378fa4f6535187cf2764652d1c828f65cb53443f6e6c73fae52ee52d2fdb1a1d154b059599a157b6d46b49f71777a2f5788a0ef1d48e4dd64051018bbb0322f710932d28b5d078e830ba57fda7a25a70ccc3e8ff738706e353a3c675451d45b6fbe8f26ca8cd13ef667a05d19c217980898c1a86cc480fb6b1077d5d07265e5aeeb741ad4a06a81fad823ed21df4d30ef946491e9ddffa9c64ddf7c12c8c224dde82a4ec65a1e867ab1c49cc81fc832e42bd4ec644741b8a350c23234f5c430b7db6d51ca2ca28b4a23a6dc54c5b78e27b2ebeb3825b51cfbf080583bb3f4f95acbdf2fde86fa7fd7310ef04af333ec4a7b5e3d433e2d54fc4927d3fb29b11af683573856f76d3b9038b43395d0217a34bccf5eb32c1caf0fd060dce3275448c91d6abec6442adbbe7c69cbe383d799056dd9dec90debeb355d89b1378742ddc62edbb3ef0f8345f79beb803b6b71a36a49bd78090dc60d12ef0d0c28ae057a549cc2af2037c75bda42f4b824d2674d7fee2fa4229bcadddd11cf314c98f9974a96421daa1a41857dc81732d1404b8512f6759d800498432ae5f44a34b902f1ca2f1cf83175d5aed8161111198d2251b773c62b8c74ba34845a02cd54edd923fad724d2d151506f01ad074aeb6b8910c2b2641e1169f450743d322e088c0607e00a926777e5a5c50d1820ff84ba1e9d73c86a7718ef4d099dff197f2642bb34e01551ee9e9267843fc190063927c9d498569e283a924a4480a3b5f937df30aa481edfa285413642d7378c949f912249bb158b705d013ff3a15cad6a57cee370ac98b83060bc724c993edf0214e493d4acb68b0d81fc106475d0bdb74b64d079b3cf2a70295dd313275b0384b44e47244ea107a1287d2facf3a8ac24ac17df119f8e05b941190ef41055a426c21d05688ff7baf1e4f8814b119411ff624fe7de780b74c8eaee445066cc8369605614fce76dc5cb8968127bfe3647487edec2791aaea05a819084c5173435364212852d0b0b3ca097aeafc9c773bcac1ab9a5e1cbf29d07dcb19c6614741cce0483252f7e6194b948fe20e869a110fe05614855cd610f518e886c3f9d187acf5d6fd4dcc6f72865f2ccc644a12eb5c1f923096f1a09ca2f6acee03fd6efd91ed63b779799b6afe5759ff743c7f9ffe0bac5a6f38cb279e047578f04714d3d2b37bd3bbc200b897b28d7af5c73bc4b724ed918fa5698843e0c5a1fd966a4e0158be5ed686cdcf553dfd17fa31771d601518cfce573be935beeeb8fd8d9fc4250e5bbf25cad49e9b9210b26da6a909e3646eabbead6ff194eed68d4039eeaf6064b2012f837adb37c543fc5b0f478ef41d1f5f20a1839fd8b47515dd4b6e5ca2b5281f76456599aeb88d0e622cee6aba3fec409790242e2a4b32d17f032301e4c722be2462499a8ebfc65481e8425999a9e697d37bb9614a2e42d99086508af1559098cbcf712c856ad72c31a0c955fe8a0b3edaf70092108a92f30371effc62c4f0b6da079c7af4cbabeb2b404cc39e3d0643691ba014f4ed6d45fd2b1341d092761cdd6d3c0e82eb73616a87879400e623f1ede20400e08f53367ced43437a8753659ebe6f7fc6ee1eda7ab56a1b660b0ac9e895084321ad009d57d72c88f95816929a51621495773c5fb14a94cc75f27c762452bbd94b297b788545c8cd4098dd562161896012067a9ea17c8fda3078c71c58448eea7b93f197dca25a09284e19793cfa7a1990b5e8ced6c00da3449c0ffb85e68d5e8d589615976248a55a20ba9fd9d484af7c835aec36d99f3415bd2f3a8548ab4ecb8703de1207c546b8fb405e4496bbe6d010a4e1386ecdebb6d602a43d2e341139f19848edb7b4166d1691ce1c8b45b4a972441bacb9f780503d5f772a5b85a9f8d8fbef1f088363def16dba9bdc3a799181c82cd5ae17d8fa4bbd80ce9ca6154f97e93be9596dbce0e8c06fc08fc450e612e8650571780cfa08dce16dfd0c3a8f85eb8739837117851549ec8d7869493aea1e996bcb4f9f34c18ca5c18490a7cd00e2992b18c3fc2833a7359016843b0b39375105df70a2073750b8939501d3bef4cb1f5485dcc0a59d9b8ae1434e9c8c17756acbe4c4be5cceb959b083206f1422b918429bf3c9959f0ca96349b51080953a9b82259ca181a4467fbf3fea312c28eb5d1ee4d1ddb6504ac2a5620f6607f8080710811c6ff5e35257900f5dbf3fa4df8eb35230c8d05e9aa28bd18d5f609e34601ca8342c9bbc32ee01830a01e16f0d29a13d90d18dc927a8b44b9790c9e928f971f8699e784b7b0e3998fad2a9a2d896d3bc06059057a99a1f1b94a285e1c41314d17f38166ffe09a0fdbf099aa523fdacd70125da976154e64c2b583fa29241aad2b44f9acb3a3271dd70f3c2804c7dc0dda2291f75ba7f2c17da7e6c4f9f7e71f919829c2db0770dec2e89e92b916a0f1e28b672e6de1c477ea46c1d513543c6bd6391b2f1a210f8836c678909798d3573680dd05238e1eea22e568a0bd80d67caee7c61e54da20f4a05d86a00bbe240cb10943d1a58663b7c4962a61ad87dc5ad49223b8537df372921c24ff10ade150958b86776a20df25c348e4e097dd9928c391a3d3d25bb9cdc411f7ffae19dd7ba2e8eb6c26af6f6586e1ac71befb8169afd367482e0817a1888aa87a659a98cded30d495dc3c7362cfcd5a7b7e50d5c55ca49a453d4f27efbcc2b00cc94eed531cc97e2b8dee63054a3956aeba3cbd8f4b5698f178f21c14709ffc5fe30081e0dab3b30847e4e48aa6a3c7314daf88c4ce0f2256149c5618838c36fe292bc26bbf34dfa3b3aafddcb0d5b5a7427a669aa40f82371bdd52c0c7830900ffc39428d2f7d413ea411377035eb9038bfb5948aa3b24a02b8bcbffb9ed9131183c0805f0d61e5de1bcb65ca1cfc152c41fd2b903d7238e54932106394d6b0ad4cc3c2f2800650f171fac0010e42ee151ab4c30fcabd9fa1d54c589995a22a95a49fabed0bc1944c6081e1c1be441f177eae3c95c3f546dcc7751fb7a8a6d76b8d86c5d7a216419598e82db4ef9189517a80f06f5af78f675108fb067d63cc44114234106366f3174280db0da8120a992aaf79e10568d4308f6e792db33ae968aeb56c310d3724a7a30117a1df1e5fb4263b32b3f82a36ae6c7b63d88069b1710bcb9b4bce5e39fd20400a008deb38e31ea903658c8865a0b574274c1c8809e2fcb885aab9a752087890f48fc51451b4a5218dabf700a318eb0f194431ea5038b89753aaf6838a35f66f9ca5ae2055f525b2311c4b4fa700a659346c7bdd00beedfa7ffed8bbdc6c49e51f8c7065e30fcab0e82c347355b429791e6598f16b926e428f0fb36deb246f93aa3c3a2ef4e972e7cbfabaddd45854cd3cc0a679b8ca5f6a3403d22b504037c1d527417478defbd73a30e601bc4512d3635a9c925ca8ebaed5867bfe6c1f9bf08f1d7d748e93e16858146a84c4527955192c06950789cec12f7d01a5e216ec87b8e331885f4d286d3fa92f345f3628551e89ec3d58a0c49144b4f6f9ad82636290f07a51af543caa2292eaee950a7277c626c50fd0dd7cb7fd2f8fa5d645e4a9273d389a9963f4c3907c856e51589806d50de8736fcc85b37cd4a255eb1aad3303172b494407b5d02011ef31d05dd48e888d0c155dd6f6915d9cd135e9a987fefd1d1b573ed8a5e0ccc3dae52d52fcfbd3b1e15beafe57e3b2248de47b8fe4e79f2bbda72ee4283f8de27d2e35b8032bb0c85d6b21d96c2746aa4c1af68951eaf98135b854e19fdc394ee21bd5972ad3ecc1b1abade4611b0617c99d42095dc16214f5404fb4bb415f0760c31879b1bdfa79334a1578db945a7143f3e1622f7bf11316f35e2cbd3b5eefbe67a088880a5d28612f222bd35ad2a503a7091dc36159a491de3902454e2108b7efd5b3004fdf2b38507860d9fd3db23d12a653c72040cd10c089ac85209466a6732b7e7e94783f55a3e8421ac338a94bbaffd70587ad0eafe2e86c52bd39da7d07b79ffa79fbff310eac20309efab6f56c3a9c2bc30f83c48a750f199c04f9f8bb89cc9912634100bbf54c5c3351e3851186903688445cf299e2868a01e826f67524c8b5f0931b93450dbf1098d0b9089f9f91d6a9488565f272283e7f336d55c9d14ae5936773944b467da5d2f7ad560574d215e89f9971269306cfd1aa1bd5dd8cee8cf796df557a7e8f7456770bd55be45c29b803459a955f15a692bb6a025baec014e18f2a6b738c9c5574540053b5929ae9f261baa53a4545ab960b84eb05cadb4f6ee003b925a5e7160c6597aa270514d6ba1549d5ce6012c9d912277eb0a2fc305a947c43357a126815cee1657755c6107032416c67752d3c91cbad880e0f7bdcbf81f1ed3c00fb06d682e2e9eda61bd5ca912a9d56288454b8d1ad89c45c980e8726353732dabd90ddba628d1084732810e63506f4db80cdf421367917bc94bad70dbffda18adffe2328308e23a64c66c52ffddd94bf391b67a6a125a25fa628a40e94afc333719d833266fa6da109121e6a52e375fcbc927ed48f12916d93b7a1e43e78ad72d6acab9a8bb8c7ae434f061031ceb4bee6b565d0d5600f69b442d5e3e73143b740eca1fe114aeb6e84ce2ec7e76047a1983848a1e075c33736fae93c7bb54067aa1f59f0f7c037532720c061902c7978996af24e0046dd7ab9532164af0f84705acc9b43d181edb71ca1789bdc8179c31aa5ff0042b3cda0898b5afd8c28d7ac6a1c7bce73c7a641cc58ece1d4aa871d07c2c05c4d38d09cff356b67e2f73032c408e944e276701c3541f670f283c32d6d738ce482df3e0ca7e21d811abe9c62044781474bd015643ef3909cea09465968987a0f77922eb255097d8fceb45d23e54f20e94a3df9dd9bc726276b1744cebf542cd0cd8c36eae67b213e3bedc8d0aa8d2e70660fb21e65b5955f7e1358e697c6d5fefa07d4dbf469f1dda7568e440297c653beae5269c8b146c4244bd8eb71828a588593287b023690050b4c45497253f1d4f542527bd4398afeae9e6b01f8e2bf24d675b560e6c8714ec47911f1ca35e4a6d489409089d2cfecb1a1b5748c6485fe40c3f4f6722144fab1d48e053d91e947d109f760b53b6dfcc63118a69fc1e65809ef95bbbef830d8f16ec5c51d18f5c172886c97f5f2706ed6ef8abb99d8af98fc47d7904ea5872039e93f5d64ca3c2c4f4fba9a9dbcfdd974aa92e22a4088610a7a78e087e9eba1203808cb37da172059000bbccd80486676ba6f6fd5348c0f17fc95083a9a09ddaefe36cc757cc74d6875fc6afbb6025cd53e56fe292094985b54ecfdcbaf86420c6e80b7c05d51b3a67c3ae4106eb0caf78f2453505183b294bd14728cc3a48b7aaba4dfc9a6cd095e55cce93e23ed7b44ac31e1705140460b32391120f66d015bd218dfaf6abe2db486ef38ac315c2f6b62bdc6bc6f78d46b0dccfd37b436a070d3f17a96ed25c6f5fb820280d11a892916a4b4b8a9bbd819b6e8994fab9c24dbec2dcb431c3b46203cb75867bf71bf1f62ca19182c68f87ea1f96f765a3a969ab98a651a8cafbded6e83987e3f38e236bb3cd824890a03a84c22b8e1fff63543dccdc9b662c5418d867c468e4b217bfcb1c90bd26169d4cecaabbce9e7c2fefa80f18962fd472eb26eb8322329ef64b0539216967e301fe86211decbc30007bde73382453f87a60cae81723a8f4c96f87060c796352d73d0ef50bd38007936450fa152991dc7d71bf9e37093d7b7cedeb22bde7e3af28cc9a4701fba1d18205d856883527c4a6d6c52abd106721843128a5351c22729d1e640f6d43ff0e7a2ca4a53d446d440e977b27cd813bb07007d9c3d176dec4a6760644156ca4b8c96f172daa3f704508c4d625ae2b8aba858c9c726b10b7bb35a7deae6a21c16112ee62b1704a9120c376c04728698caf3182fed01b180e8d4a63dfa30b674f58c8d5ebf8dca8d0ce7b4c7b5984c9e019157a5c3a7bdd0fbfe40484bde3ede348665147cb4dc367e39a5059b7739b9cf1047767a003a291e71d15cd03ad08f7c90dc2c182ba49271334ea82946c4423b212bcaf3789858567e10f51d59142b05710fb73808c754a3cb4c0e1c352d37d453f16e7adb5253d1fc7dad25d7f858d2319f4f74b9802c422de75fea8af65f1ebd5693b96c92bbdb07efcc672fa4ea151ba350b51116ada8e5eb3b568d5827c6848d20a99433cfb64d9aded4314cb23bab837293ea9d02be96b7a1c70f827e57b9fcf0a2930e0092f923151edf68a38c4a91e3fb1a873b65d1cf67ec20bdcd7b73195151317d89e6b2a17edf96047371ad6760bf0750a86adf988a1c6cbb23d7b58f059e5772adc9b0ddae0f142b5e98bca0187d3e4f1c32ec71888af7b3e2ee8e5897673ec0458d43eec8fb2144465f39aca0bc13b5786190b4bd84989de95f97a7471c1d1a1f2e1b6dbfdde3f4c46b6a1151aa2f2bb5c60d2d1799a2de313f4a0293abc31dfcb353ee44353201bcded6af98cba9d34fd99c3cfbb92f3bca59612ab4f6336e3c0c4e7051cb4aaf91e290fc24b46f824b5c91fbbb29b8556c3ea0bd3425899f8cfa4f6f1c1478681aaaf9846f7406bf680a0371876090e56d7c9aa598e3eb1c72c39655bc601c23d435073c8e087eb65941b3c0c56cdfca67df3ba7f021d93fd23199a190e0151a32859cb7bae298b8fe4b3b62d7e2ce06ef50eec9d3150c5fecd7a1a408e26a3098387431f5468acf1486c53a01eb9b70006efcb505078e03fadbbd72fbd3cba1215c304795cb1ff7ca5b78b4b8a964d61178f682aa8d6e868f5e314dab710f9dd3f4d2f4b66430d792f1fc7bad29dd2287704d04a754ff681337509eb12f8fee1e433c5c6c61a553e51547bb1e7b31a27805fb20545289dd9d9ba4fdffd822e7c0fcedfa21e282acabd980903c468eeb5862a60708d9775d533774de9d722735ccfc1cfed2988b4d6e50154cef1bc6b760c60b2fbe36d9bcfe064ffff820db441540730c96aa56a302bb7afd3f7670d974c4de01c6580ca5946df589646c9300e824e9cd6b3db38868b9811df9c03523794d11fbe506a2ac920a502c182e2fd2c017f6f9b2cb4d6bc7db7e72a5c706af542ab5d50acc106812287048f629473d198641588d30d53c147a83483a6bfaa9e15f9a0a3e4ad2d885ba9a60aa70df51ddb4bed95abbc03d33b780b366444b2bcf294be63cd5cef5a0956521aa0e706158c3a79222aea6f69afc2cda1dd71160c6d0f2ae59c969a5dd148a2653f3c0f7fc586e9a0af42508954e5f9dd0958e07960f756ad4b56587c17fdc37632e6b1dc89030ab10b7460f5acd08515f3c105ad9c7d6326c7f3d0aeb36cbeb4bb80d79b22f1ef275c853ce559adb5bb1d2a3891fee0c35c51c4c36eb2f15a326f5ec05593758c10da8a7c60a054855b41014e69e55f6c5fdf52e5608985bf8b7f87a4e757c6da07910886577b2e27c9e072bce5422470f095280198ff450b779e026793bd2504139a7a17cf26ae860c405a5125f4b21b66ed4ef15adcd0fe3ffdd2300db56228960c620b14e89e26da0952f546dfa9853b92b8a7c56a9d4de65030e2894089b5931230dd21fa573027b3eebce8a74e54519ac36e26ff110707fc0a480f7572d04503cb70485ed0867ca5c8a809b167490a64b21150708e6d1463395ef198de17fcdae4dc92e5fc6ec79b6f7038156dff0746f1ea976cf3de934303933e190d50bccab1b3c333a6a6e2bc21126ef0627666ca67056b9cb820694c7d69187264cef865b46f53cfc304f4fc301234eaecbfdc65864e1cae921d14492de6623621ad92b17ccb7b4f6e008d074b333fa1f10b72e0f2ecf5d32bdd1a5893ef36083d26d2f2d5a84b51a3a00e3fe35d360adb5d4787ed1669621633e57c5505bb788cd31d5d5473eb7caa009abfb9f7c8071e91024a6e7c4265e769e8503437a2ef6fee3e7ef2256a17194f0f9a4d87e448c0add2868fd9670d0173a0cc0355ba704515ce3e728e569dd70d66b7bb74d28dfe9b68abb1f089fc6e92ce163adbb6419203a04340fdb3fb876964ddc5afb2676d4decb0fe130ff5f2949a73f3f1570a2218217937e9949893270765f4b72b89be08eb04ec58c40b689528e2ad553376acff6ea89422476d0613d27b703afd649c376e2a9a00c065d7e5c31b7414875fdee0932eec5873c5ae5f85a1e80df56eea409a958fca0bbfdc2a15e3bdf206b1efee317ff3471cf9b074b4759ad1ac88813a95eb9c336fd7905d98cf44f40ea413d96ad603863ba3265a3b61a3159efc6d7299c11fad5ae36c7363890294404dfd893f6f49751b686e4590358a733a04108aaae70fb1b2e6195507bfdaab447f8b359228c10428539df19e6926112b2f17de3f1968a246c80e13092aae7fee8406c68cc95756b0b20ea35ad4d8564516511b999f118c17e9256c3fdf21d0a100016fd01218ee30d43301d2eea50c36f7dc366f2830bef715d6081b9d2fc49970c25227e1af4d138ff0d2de227121c57f3f9a82b62e8720d70ef3f140b7b5a14fd9a5c610ddf91b561cb28620f7cdf2eb2053a27f853738b3e615fc1d571d25fa7f1ff86f8f5a75f07e57d03fcefbafffd598ab37e23e5f1a3d1f93e44069fba40a3402bde4330ab74208c128827dc8124aa6bc07e24e82635b121fc9df4609ab5a80bf0903ad7cde5fcc598086062fdcbcdd9c2e04f236e0cd1ee78ab413fa12820709d6e3418ae23d47b60daf835dce35d90043ba8da8f6f53239acbc7488a6815378a16ac853beef4069fe6373028b35b52b71edef44aa114a8a9d7b96a960a51d37973c00cd9e95b4862df916f41f2c43c8d5248a803a5601ccd7410a643048ea9968d7793a207dc78228a3458bd7e22a0ba2f4517562e1f29f8f724023fd875464d8fab78e76940c601adba311f4bc6535be451ad525801219598a830d4f99323fa76d9fe71ccb680af96a45935be8b2de4bf0bdec270d7bcbeee0eaacc7bf3536a1d7a7c0e6e306f514b47325ff32c06fe72ad8ea7a29b562837bce66b34dab5a1d53678bb44b8e5da2e4f35dc45b6adec41abbddaf9aeeef6882abedd80422623d876a1b9dc64b9a04697ec8664cb4445983e898822afa33263b8f86b0aaf1d9966db580048fef73d66d281ca1940f2a18fa37833ccdd96a4f0982d95f517905ef6bd62c35cea8bdad2c5adce595a9aad027cffcf1bfc6e7cbaf95979ce1ef69ea01306e19b1b6e0e9eadabb200472fcd106c8b98f4a58534f023d29bc27e2d292f535d9f77d6f6ff709f07ea13a42d2b0d701eafac71caf19f15b2294cf4181bcf286b574a392dbb4f0ec4538dbf5a25029163d7bb5c7cbad261ae436877db7b67b45efb75fa19fcaeca30cedd5b323996eadd79d260f6e833b997af57fd05bafd3ac11061309dfc37b006f43745a6f2aac20f07fdaf34f331b34a7c9140baba9fcdc72bc8a1f6b50c07945b5df040203eabb273b2b80e2292e54583415761fab4713782791e357bc08f0b935c8d848daf40397a4bd75852f73323bbaeed9d973d21e5c93639b3b94eed5f37e3809072d80fcf819f65b7921513ed6544d83b1b6e9e7ac4655ad7d10d0c3dd6a30f40c36c63aa8f79e3ca81d3e48badca41b5095d2f27c4f6bfbfccf1a95d1a119414b53a7094c81093685b09b9fb7ed138c5c8d64d623a66b85d43ec13e8d00edf098873582cfe09053c11e67136addec43e7b29ae3ccde7a02c7706366b500b4bfa0d1c760fb89b81689c7ab7970e4c031488b2372139b22b6a5f82c1a450650c079755c9717fc429d116638424319e7aa82f92eff2585e370e60cb1b690b22331b115f9ee184762026d8a60880138c23aa4d85c7c2fed1278704013e202abac8f84a7d1802d0a3b36cbc194382dadac7de74e0571e3a4d0d9e130c3efcd491fd2920bbcd874de468e532a1b181b53106afacf1d9b29452440d612af1f9a1e39ad005d309ea4ea902c740d89ce9c1f9fcbffcaa60876d4116c0f416b4f84702e477fd1fdeeeaf1fad7bfc780b77f6f455bee67a210b451af9cb68ebe7f086d12f5b51f20f578d3779b26c2713d2efce7b8f63fcc5deb66eca65306182956c62a0ae8d78ffc97bae37a1cfa9f8a0f0ff792cb2d168a1d378c3c7ed1e6af7b87f13345b55e6758fafcd732f2169534c88e8f9618905286823a78588debe6e8c4aee5dbbc6edfafc99c08971f463bca047ca133ee8c46b0f6d6c502b1d92806a88430d0527c98bcd3d488fc7ff64dcd5816959930af5483f98166b9735d7ccb6ff2d59cdf6ec852335f910c86f1626a54baf2fdf103de42103276bd7476a3f232c759543ba707cbc079b9973c6c95f987670e13ea113ab18c3fce817ab526e763c0dd090127d04a294b6599d89278e277ffb1faf578a30a2e89e21099773743d6f9b681088ea42b6df0bfc4040134ff4b18e00aaa2abc67a49abc13b886d577c52cc361685360fc106f05254e040463886e84e400e18834da8c84cf4b8919e98d2dcd2a90a1d44332eb74aa5b8e691ed9c51bb06fdf28c65786348f7c94a2d8a1fb1298a31a7b8e6bd549ed8691df055bcc9c9c60639d71885e5af4a6e10c038ae1c23414f865f592272411073eddc62ee41182a2145845badcc6af9cf3e3fdfec554eaf67f25cd0fe1bb8bffb36af4c995e96561613fe0d44890f130e0a3157ded878bf40cf855b3b3bbfd30cc2a0b229d4d9d5acd68967ea5cf392e18dbd016bf30e26e19290795375089d8e10993f49f13a4ad73731d0215dd8d9e2abecb2f57aebde06e30d32d441ff143774c791bf9dbd0bde45aa988242e01a19d3151f03e81761684c8acc292856e6ef65cf032c319e1c2aeaeae99efa2f2bbf3e3031ceca6527ff4bdbfd847d263fe4a24d7b237eaff0f0c706c60c4e7272cdd0bc1bea924799305739b7972d31746671a7dacdb3cbe3eee4666784f66b6013f49051c6e90653251a14f1362db83b31675c4a4ac9650844c8a8e7d8bfd30b0d4feb7a5f130a8b804fa86b6195708e9e7eb4178f2155da76b2b84fc64109682e96297092c68030cc2d4e5ee0480cf2379e1bc4e88d6216466ea87ed61819aaa40445678dd0e40ce88d0710bfced8ae4630fe0dd85dab953869741da3dbcc99b40773d72a9f92d969a6469b730b29bc54058ab71eebf57678ab922b35dc25a964fade5af37c8156af458d97d983c701603a4021a721a31177238b5a280e076f89f2fa6178b03ea54607214b049e046f6f890aa581bb126de4ff4d2bb08b0ed2ddaf3d80892742a14cbdeccb4a52964a2ac2bfcffb3e30e26ce47b5fa624f0c41f0398f436c4a4ffea1f127c21566aecee50ea22cdf5a439f3d047262c056efef169c9b17fd99e62c10db71d39bbaf897e815142c65d1ff45af36de593b0090d35f625c8e5d6ea5b395c1ac219c3bdd8afa9e9775e92484d96c4cc6802fa07ad1ea4d9aa809ecfd5d55a7f0b0136a58ffe236633492d217e3dafe478fbbf588b0946971ca83f0c8a18f607e9dd94f08eb69bb3b2ffefcb54d7255b712b6f19fe243bcbeec9a4ffedeabbf84e480c510da848a0bef5565110ee78a62a04140a0b7dc8e421dd474eec251ea231d9c82282bb281e83c5babf4aacf864c879b5679ee165512ebe9e39e202e5f4e947d7773884212760d0ee57789210ebed877f781e6fe49fe0b363926dadc67774e4fd9998554475fff5d8c2964412c942a372ddd3c7e8d6d94e5136874b71d33a235984ef2007c22bc66347c31eaf5f25af3ff26f86e17774fcc1d07e8f3229c8a0bbee8a927b4b7bb80a26a7dde295a60eabd001016ae1ef090419bd5f230b25e79441674a583f1376d1519bb044b44ff68c55286aa936d5da2fa235cd45323ed49bbee30df0011dec5b1f980466469d9ef254f2a335a56ea34e65feb300bd56818f0b8ace2c7d72e87f56d4d519b093d2e8834b05c6f32f1f53c4ea5d71790bc95e11b6e0f1fc7258f6ada30911d471ae842023124940a7119d15abc35355f0e2a2afecde362baf1fdf17c009bc21a1cbd48b586b31eb5e71a5258777f9f93a114ba5dfe32686b33096df1d88b0e805a2f5c7bb055338a5b5cb27c67b3ae93b4f60d08109cba2cab867c03a792d82e8ff9c258056b4506686a8462d2ab96da5188fba091256914ab157b4e2461c9f6e6f1d30ff751326cbd04fc8e3183daac4994112ee70fc5ed86342d1ab6178d9722b9395b91cafef76621910f2fa5d264483def1bebb94bb9633308c183f8ba81a42b04afcaacd38f981197c6002084f2cff21c257823a353883e47ceaf8c4b4e6fe58788b5d8189467256456b961d8609ea75d1a7ad1e71f205cf493993ba128c0f7ee14caae23c424a8bc1748e1782055c457a19d8d0770e22a7e8c803d1dfbda7f301b25e208226397a63bc6a0026d508492cc62cecbac7cd79f4c6b21c327939653d1e10ecce35db9591484bea1819b355a9e7dd19a90687530566f7c8b72bdcc1db4d6e851ff9e038423cd150a35fd4716f1cd9aae89b911f4f43e4c0c5a52d0fd2e532913a90d1408c74c05611f294bb0ae70a755011c44be1f5dd90bfc15c8232f62ea23461c5af1716dd74b4a2cbcba56a5d8799672770b437409d3db587b0ea471f6f9d8c9ee32554745c518bb6e7bd5da00ffab63ebeb170b1fcd3b17a716dad84ab5b6be2be457c8b17c1b8ca777c0bde088094a8b27f0e1005ba0a13e5bcb6502f84421d8e53ddcc94193553686b83ad3862b0d5d305b3d512f661c325a50bf4b7a1ff954db16070d62b8ff56cd376bd05131787d52aa4ac4ff53f3179221d9c639799830784ee02fc5de81ce3fb49cf76dcb9243c2d718c54f30cf80aaeedae704f7afd6b5d57e2ced6bfe55a9c110aba67ea204da5a7e1208cbed35ca596b13e1b1251d6732249a2df160035a4f1b91eca9da9dd7054d132daed78108a593e3e6604f31dfdbc68309d30dcec0c34ad47eac950f90daeb97383cf4ae546caf9880be24dd70ceb61fc3c64fa801450f2d8d17a6fecbec737d483b10d002c7235df5c121ca924068504aa4e51e8ab30ca7458898c1c65c4648f22b88baf33739f7eeec2fe924a6ab8ed4cc7245fb7d7f8cc91c270f9306a550453179cf70f510cac7fa75a448843e5adb61715de826d5830d970a4739f315743ffb611f903843e51a97c7ea5bad7092ae351fc8e804e47a6bbd5f3953fc7e82f08ab255d2ae1bf11bb7ced7842f75df1fbfecf3665bd16f6d5082e318a5e580acb2d43be30269f9b211602fc32de64e4906a817d02923b0c0ee61ab729d5a87ad894c20a2e5b7fb204aa2bd0f0130bdea8ef159c05bc90aa3e2b575649769fe3ccd2fc3a8b699a7f9206065532398d89f99bd2b42b880aff1f273636d717cb3400b0d639df5ab3062916a2825aee2d4e0d389813c3a750ac8b87f55caea45f61c34fe0c2fc7710a8be2d2815737ac4a3c227a48dacab077959549be376adf926d6aa9e9bf05f15599a9d26de4432c186e8ce62845f416eec7207525924b97761d2b0fd9a6117056e4ec6aade4d90b5744fd41ecbcef91e9cfd8ffb5f17a138f41a5b6bc4125b9239cb167dbdcc0e0cb8bed4b9023c8419fa72a7c84d91951045f4baf0108e16f57e676d02406e37b7555fdac20625e0cc9307a11f76a3900f846c23a91c440ae1e088725d02c5096894b52b6c76f1a3704ec3a063152e08f2099901e40227e8bda2d98aa2c12de9ab8254dcb88d1ca03de8580799a15069d253c8150574782996045c2371eb1cb2e7182016a874194952bffa728e330463ad24a44b7dac6c30d3c1ace7467aaf07c583a3e5b21a576d050e7646e4bc499f7a53a8f912d6fb1fe2ea568dea9a7b3863462d71112b649925ba1dcc152718dfbc372ac2d56176fbb7bfebfd10749f617e36918d859a20e89cfe262f68929c4ccf133dd4f0cbdbee3969925591c72a67f9daccfa04542396fcaafca703894ba14e82ffb2e3fd008850ff516d95fdfea3a3c560b668460529272a68c4cad9e4084bc68f12d9be81abff09c293805956d81c7aa90fcf133891bdf47f84ea2c3559a3e712ebcbc70e412324e106be9b6e67f9d00a8e0fdde6a86cb5d9917aa4789eb1f6f8f308103bbe11c9bcb8e8959210780379821f1d5a3b499e22d046d9b07e3f7253e2d6498258694f48f99501873fc2a9decf85415c13389ae0aae9511de20f73ba58f6a7731013850328d20ab077a902fe570a541f166cf709d2c4f71d21bd063f196c1b8f6d0ca91a42b41bb273048665245b5ddb7e5ec021f10667886246972fe326f515a1c45d6b7b4b5bed0270c189c0cb04977d9d36742e7274d92ed74d91cc5753d7b325b9f5240f276891f275dba602b34979ef120b8921771f7dcc274da00f25b245805588b8094e2e470c6a8d087e81c13865d718946d365fdec93f84b4ce34fb9bcc4ab7b77b8618ed8ea590648e4b2e12f06269056d73e07f061a558ad11d1f36c132989b09adae966fd730e8cc80eb3d9b6a46eb0d59428c0c8571c66f56cb6ac350e7262eb37d1e263b736f4b39324154f23a77368817ba0fb9a40246dc7a2af242df24a81463ef2e3062f8273ff90963830f9171309c37dcbde176d10c26864ca39a79e54b8b57e69d3f67ac0726a412f076881f13341a4cdcae71adbef541313ff86ef0f23b59e6a3ee64062f152867b89a0aaae1cf21b79cdf01c80af684dda41cd047f3f343bc5a1538a2ffdebe1360a15f76af224b2a41d2eaf65250e7e8d987ce21924d5bf46c64e635ede84c3457018f811b405bc9de768fb65ba3935b169579126b68636cff76d91ace8ebda231fa05c598f0f2deaff7cfe4b54336bad6c4c556df8fd9c1b78bac8170d9ffc66883f094e526c3c7395de4e55bd0337b3e3aa2033d4865255d74ab089f6c26c5b4c57ee5c168332663448a77998c92d32893e85827409c6f70967b91978d3b54c56b7c12541712dbee9205240cfd8fcf3af6922674666c969ed18d7be0c881b797215bc94272714d2f36e7c03f9c325d5782c7dc80e003378e22b748220224c4741d45bcd998b2997595d224f987e7c2a95f1f346144f2c1cd83f6f24a3f1699a4313f892bb94775397a79c8fbe3b75c23960e1d5707a302e6eddaa643e9b31c7ce82c10a0f1c381a63a108139dcbb8f7efac50070b67eabd016a46421099474ebc4627e7801b681386434550b6c5f5923f41b8876ed5a70fd048854ed9c1f9dc9936d4cc2cb76080e4b8b9916679ad1811a30179e7d13aae429505b2033ab9ed183ef4609b0928a10c1272247b22e7bcb6e5b04afabdb28470c9a9263db6ea0a8ac88c68de541617f96583518924da03c546423914bc9f0ff5a01ddb3390a972f8bbbd18a8d0ff088e722e529f97ae94ff67fa7e0f9bcd5928800fb144c27bbfabf33cfb482ebd41b12d17c9045f4352d913d5cce0cc6c1136147decfcb654beddaa46fb88407b1c91ad06e5a90015d6abb09c91b5d9be2a1da8f25313f8957a68ece27d4b9ef0555ccbc47272dff45acbe2597ed0e85daa1fe32f337452d7db0b3f36060fefafd2af2e419fbee7bde0f8fcd98cb93402976a43b576673b1b24d1c1ed428938fd0a4e76b5d8b5cdb18847eb6dd7d5adbf6c84cbd3767935eccc9ca3b09462bf28bf08d2d3a16c0bcb3b61728cf4262328801d4c10ed35b9286c1f92c9166ad986bed87af7ba559fb42a4fe1fae42f3967f2302066e5d5679cf3d9b97b9bff3077b921957edabf866d3f0a7bbce67c051839ecb2d4ffac87b784c4e5f9e02321f1a9d73b3ac9756b094e3093338161b29ce2fd4d20808f807e0b58844294d04c7467ad09b25d979f648ce9e7ecedc29d4a2a40f0c3345facbdfd5672770b4a286368b6deaf744c6d3b65b80219014be24fec75ccf905b2fd77dad078c82d8adf4399235aef4977ddc660a09229d16b19e48e2235f946dc774d4e0b38fe93024470944aea75d798bae301c9f005cbd757c31c47be458a9db1746447a26b77ac07dd597e76c44433f84010b5f756a594be0bed51bcf518084e1c3676822ddbd7cd7b0fe446cdb6bd52c69ebe5d5977cb41f896f1ca336f492918006874b3183aec2ba77a62d6f78cca50f487370fd79e4b82c767a5e2c55a268558b89cb28fc83536929b472fc58fa9d7bb765427d58aca82cd519349688bf61a13bcc25561205eee0df986d6c73d1c2fb7fcbf50528954d7c8e8769afbbb02161667739e55169215c79ac4a4499353f9e89285a5c982244414b8e39915a44e7b60f47f9b4df575e0bafe684ea166b96b8cc04dbef13f74784231c3e35b4a5a332c38278a4dd6d80845cb1edc6739dcc11c5a8288fcd707225b3b8a919e3e3bf728ed4446366e3f25c11663d8dbcdba08979878e9fcbcc509682e60bba70e511152df423f96b5ce34b2cbd695ae87f2be88e1095694f25f1febad1660993b7bb4128fbe898bcf82b6690a3291970accd11bb56d4623d1df03f92bcb807b9ed456c39b020d186deef8862bc8d15e1541e738558d2b13f76614d2d0cb93c78df161667770141cb9a3cea6d82de2b8488d092318e7f23ae77574843e8b664524a9827478241966273a7fafda26b25d1f7e24cfec1adfcf67ebe77cd6541a4f8a66ea2499c85329dfcc81bfe3dfe939c67e66299f1112e5d12b6f46340ee0f6b7aaea78458b51be6278293101a91ad816301e9455be3bec7168823fd41e6558850b793aa7a43d3987a3ca5cab52a45dae848ad33b9eada5b42c372a7ca739956d4076886a00df6c96df6486c0ab0a32cd968e0744ad5539aaf7d3398293edd398baac72a7105d0ccdcf8451b6cc808bde9e24a60ad1a70f52f77dd2a5e66b1e47acc2200172b75a4300ae3d44f8bc660d43b45f139ffb33f63648b5e6cd9e3b5267205a6eccc75a3faa0cb3befca88238ee8d367f3644e8acaeeca1cfc47e737f2101cf56a547f15c9120bcd243089c49b8979c4afb8784f7820880a3be279278cae89e6c7e4ea9f69dae89468c91ff578d889bb2ebd1b35e10d147df294a1170104da30e48772cc0b678d26a045049a5999a48893c5b1f64eb137d6ec5c7fd080d8824ca0fd10e27cab5b74bfe15dbd5abd8d5a104430d429b845a82681b0d28e11783fe6d917cda753fc0b6a697d0b391e056427f2c9d3f5442b5b5a71baa6475134487e35baf3533805ca78fcc3a6576359017e82bbe85d153fb7857327b0345de75d6c61f5afbed9a951653efc26676e5b4658a241f561acced3c7c85fba18f5340a4330b2e6ddc43fb9b3f1dbb3a195ff636ae2c74413e94baf56fcf5bd0d8a3498690b1b2960417b0b82c0f41b93dce6a9536f0d5f52fcd27ee4cd056e9b6f1a175c5a0b51b0dbdd2005db9e2c5336f6cc77d60e925d3da638e8de49c0ba1333bf77cdf195003bbb969be6d136433469e7c6a4bf36b3010f37e30cba61cfc833599db18b156ea1e0602ba65950924dd0ad68b2e38ff2ecfabc92587b6b590e013ad6b459e0478215a1f3cbe680b90d3596d3c5dcb418a4156f8df1d53d04fe7bcd7726846611204b5a1e4e2a8daa59d1089b53434f292c97185891aa0f9bac52f53686c737770e27876c6771b918f1c2dadabb2a44bcb2b7cc814b534928e06605fd0d7c4111619165291a14795d34b20cedb2776129b696958a64a1a5ed90a2cae82a5853a5b6356d5bc643145ea1c3beac0df88ef60e4267d6b57e5287818cb9c2b8f4edd43322773fc28c2ad514b9016e6608539cd9fe21aa377e93432548e104c3d4f267ecfb93a8dfbbb6204e772b426ff404c179f219fcb427145dcb4de2d784ee4b68a7a70fa308a879ef8cd2599dd6c571e97557397b16bd9aa815b59fdcba33136110cc8b5951fb8faa8dfd9720fd3b53605e92e3b6010a746fe172d7abdbd098268618d3c862e2d195e9b66f011d8d396a600752ac57a8a4222c93955d51c6c764e7ecddd8005c3fae064353974b043ce45ba31eea4b6f9bd0f2b2a6178641eb1f36874aedc2c960f519b8e79e6d097d3e609f72d89b0d2d54946109fe223d8546a4801c8a00d0c8bf1191764333ed036d5353ae1dbaccb34f425bc10cc787cf2072992258e78afd07a4776b2a9809886a461bf04c9b175c641d8211a37f1bc5e256bea53123f8fc617f63a449603978526b90e94409383ea25ba924abfbc49693d11a76940fdd065f6cddf6ef02faf8eef160faebf8a3f5593aeb84c24369c3f3f1ee57e0815918b97b4484afb2c65421179e3d3a0801d1d6890d8545901fefb1084d85d8679f76b323ef41904dbff282edbbd7995d40e12baec18dc2f59cf2a9b2e94a98559cc98917e693262c28eff04b9d287f313b47764d858ffb95b8946bb5241b55f1159824e76b8422d6e65f66107dc04136f4483a0def915e31987e6ca488482cc845350244f148674bf94df4644372b32b406a59e5eefcbe4c5655bc9d15e94be4d80fdd5ac466d1c69f5bfd7fbd7fed6e174723d36745184dfe492bd052a405c1dc9a1e7536d6be470590581e45f30221cf5d959d4e73af0e802403b5311ffd4b78726fa8edc377f68dc332419fa3a49c0c414b8a65271da0d8e8395af103aae48f23ff90de1b24d81619fa41ffd80a90ac0d4f6fc08cd677853c9687dec961756e6d12cb569ff78dc33d5daf9c3057f04464157c4070475c5471f3a2c540be15092bb716df9dae7b89981f24274e54411e18d6aaec86e636aea2a9d61571fcc57520746d2844f9c2903f4cbabc27154873c5d914847a0ae56526d5d25653a7bc5deec300c5aa19e3f2a48bd546535a4b502b76871d73acf2a3d5efec7bb460f75bb43f8ef63311a12ccbab29853064389756b248ff9b3f2f8aa1f144c5ba24b522d12185af7b0582d0df6c274a3aec2465d46176ff33c74df80d2919a3092c296fd83cd54678876b1211fcdb46b9e7dda6fa16afaff3f536aef959527d95d3b6735f25412665f294e748d7259323fab97cff32b011991a502646c90ad3a520dac7ec3abebc306aec48ef95619fe47fc89282626a643fb0c6013c70a0ce8ed547616bf59719853bcd3933945277eb704e70d298e355fa7dc8f128cd36a192b3fc1e93aa6aa70932a9be7748761bd29e1ba8ea93380519bb30267c99e50cf2e082c57ab4a3e51c003122360194708175881d5915cbd961494815730fa0eeabaa3c3035886b9360dff6599925147fe65094d7901391488809852270eb398ea9d91e4ca38d136a0a689d0319adafb02e817f1c13bebfbbafa8f5392b27afb2c5097d58b5d14a44d434a498c65b754cdb14035fc65c8eaf44daf9e2867684f143c2cd66f7be218a6c8bc2e7ca702f00702a10172500434599897b090645aa63b23445f9107dfba8ce1f04b839c8b59e1d29f3dc40f0aef99d2fb4173b44ecd3253dad512df067f5272c7b10bf9532660e56c5f2a7d3491cc32f5e0e55a04d9fd446ceeca529401b835cd79676f4308f9fbb5641eba83098659af5c2efd1f0c0fb745a2a7bbfeca44042dda417bfc1792c9efba0971413f26f8e21f746ea2f4b9cea792138b0ade945f6b08efaa903cbbb9a11c206dccc8763695088b582158015a210ce45382afbb508953341dbb298d1acbbab3325939dbb5d3593ddfb0e8d7487a6f9e42936526dae9939a955c06fce9e1ade76af6a164e7107a9f78e478ba9ab942c68c964dd7f90336cf66025c6ad43532d9773582f63d4404d6db75a47dbed04d2d45c3810bf6720493c19982dda02290c6049db3f5c6e39be006231d0b7a2679126f794d297c8c099fdaa53f346ace32d7fe97c61d561a35c0cdeb6c7b8174f803e29c5401d953faa9e8a5234d4a54b2ccd65e585d6f911e23c354b4bfaeff39c1454b7daf7d017e40b7a4cea652ad8b126d47815e258ff15a406e75bd43a92ed8831e87d81b4990d3e0181385beeba4dd49b68b968f420a511d52f04f59aef8ac9efcaddecb29a25b8fc90ed553f101552dacee96aa3fd4052ca952443ea7f65c6f0fc9dc8fbe50d1faa9b37fe8eeeebd97f66da56b932b878fd2d451b7708e464bcfd13f678420d1e53e3c30b9c7c23044d54fafb3bb57faffda120e295dccbd5ebbb9ca79263985ecdd661f5b78dee91e23def896c398595599f0eef6efd6b0a35d0bf27ae35b1c505b4bebb8e7cd18215774e0504953a6fe54ac4fbba11e5f424d72fe03f59269bcb0ebff822f8540aff13ac172b2ac48a8c2aa55b56b694d836298bf52dd7aa6e8ef8dc1b881ae8e11249e6711d00d8fff844c621a7da8d4dfd453ef1aef53cc346a9a834969722b6347be232aa0a22801ea5b4c68b29020fd7d00c92c4c4f7f406ae7340113f33ccb058400e611fa2fe5e1d50ea13df74024d1fce52ebd9f9b3495be205d5334ecf2a35b6b54c0119991b7f012b7e4a586ddbd7c2342edfc2b02d1f15a224fe9ccedb62775804040a886a0a6852804e9bf28288f954255b710b3fd0b6f3eaaf39140c9fa78f53955d2200036353f89baf296a773e243d39480850a8aa939ea7299d2304e3749d9c70557de27e1950952be81d276a0bccbaebb2486e21a0f5157a6f15a661c6842a165295d099d4dea5440b48e4d8cf713b4c2bc2f71b3ac882fdec8d50da70d70fc5ecf56189907cdcf4648643da88f44db8459a544a7b1efc33b215f739027b696b533be7fe9663ae44d976e534b11d1a06e0ba2e9d59cf73aa251368c537f3855f0b4a1a9caae718b3e0fd48b46972740e00f35ed8d8ac432f35abbfd91ba9ca2d32fe4fa0f1fd2cbd81a636cbcd6900b4de86368f19cf0f893205d6afa0309bbc6fbc1685c941e1bee61a64a09993e4b65e5cdc35d86fbbd64d2d43575226157948075b9a6eb533301cbee9e1cc35e236f89b831c347888fe2d81c69cb7a2dcd71e46a11887944eb780c08e2d91e6c15695d3da02b005c50daa81def52e024edde799fe427a7edba7c6e2717044d81bd69e2698011fc146ed4de6dade6f19eedaf7a6be35d71012545c27555839ffc467a4e7c304ccb0cafc0571aca6cdc67df566877d6c92724c525ed33884e315bfa4a7d44cf40e17b8801169c50b2f5a6087bc51d559e202450b0bb38e65106611a4ae4f3a7a41b9d119d0bc05e2209c282a9c86ac8b9173df64f57f118e7540faebf9031229c4fe8fa81870e889bf8dec3aff28998c111bfa0a2e4f2bd996c9e3f659716f20354e5e1c919f7544b00dc03dd055257a31389b06ceaae1769c37151cdf96c8222d35de07d02f317f3f4bd07ee28ebc9f353e968f87a410154927b2a4f79f001f6e4759e6f92e0d3428d7e10967946803a3cf304c31e81ca88df1a1433b2b4644ccf77e408ce3964d26da0cbd43d3983363840efd7a18296798691798c2f13e525d662eac29e3360d62917598a0346c799b378bc07750dc7b36e8a766791ce3c6738418cd30849463036f80296afe51c1b4f52e42fdd795bbd9cf1aa81c9c59d1f0568057cedc17c78759132d3873502c04631b17de6a00bdcd33bf753f7362f757f2d38338dac9ba7af4f48e8c13908bab3d611b13d09490be8a586e8b1823332ea84fc5235c0f84880b37d7549ec41812b5f6ebd0532c3a135ab34658805bd296af49ce71d96ed19ae97b58c8be3466ab16a0f4259ca7964ffbc8e9a4a2cf6ebce58b0f7b0eb89970aba37dcfb9df547f6c71be5ba19e13deb99c591a5d159fbb3b983b06495db2ba9551a74d65f67de47e3f2c6cd0ab01b0c6711c7ff2cfff9f65ead91b91b607fee1789f85d2984ada0e78e0aa9f54e14143a3d04b940ef982a492a3fe4d79aa4d3979bc0705259c40450335b4d34f4c00e2e434960ce3b0c302254649f4ae64facfef265b9afc45158b02c9e83d5db9a28495f91a4f10a5bf1926f21313133c6a40a2f2c7885fea4a68a84752424bb421ef43323461fe47c32973a3c4fabe75c7efe1b6e18a627015d42fc09d1f89089951b16831d39e679d94a075f19179ecb96bd19e44aeb5c9304978fd3606eee485bf27ef083da2a140c61c5d9db94a3e160677e4e8b3eacf0372c7a426cad3737084bca617027b5fec72e71342375a78af68179bdb9c0565022102927da916c44244c3b9fa862cc47ca8557077f5f804e7e4e962c6d8b6ff2d5afbba1abde1e21f3bbb22c498ad705ba6435f3ae6d491ed5709203f77acf6676ce07c4f0fe40c4b2e66ec3a1075efb722bf1a51b4a5e2a2e497c6f67cf9bbf60e74b274feaf3971ba4c348a04c9d03cb732e960882d180e86445e39693127a6cd6f94212b5d69f2a50ed323c6c09108cf13c2073e6699a7a88cdf6187ce8f5902c75721f9f0d4c5bd99091c2037b3b4796b3244e9e6f45799b7c191af70b4b78caea4075ea4904d639ec2615a2e11e64a4340bf17aa164f8216e04bd3dae573ddc3d5826079feb95746cd80fc3f2336714216e0c12afbe9a078fabc09ba7a69d0038aa1dcc54b4610db44d0f2d51ff648ac3a5735080860891f2ff1cc591486d1962faff3f11b24a3c6431e51101354359168aebd0094d25c774ef2f576fab4554bc216b5050c381636a469443df997b9f2c9ee1060277f94f6545c3e2ee4c8f1972500b1006ff5637888121af0098dd7298226a7dced79fe0c5a8f99ff3dae0956ed3f4ac66f07043c4500b077bb1f4056c11a3fb12fc7b5a7113142dbcb1b8363431aaf6904e73aa43638663502555a8493f72bce86eb2aa3d5c9776a0852ee31aa28bf3f263cd3955f74a65119414fa797f4f370c7175e7a6d31e27b6b7a825b098852e5b50302a577a2152fd03d49b7e6635632f922ff6404c21a5d95eb94061bf6604fa71bc68f3c48660237e31000f88654fc26ea1f9284906b41495130f9c275a98d17585779cffaee2a45f13ec5383bf98aa1b108061bdcc1f318d1d65a848599301bc23c8ce31efd51a300e1a1eab37a95828e687144326b9fb1d9e3df122c49aa02f3acf6f6c8819ce4f624bdaba6708b69be61d54234263ac13f14b07f474c84667a5bcf7dbb126c22a1687de1ee9c8a628fc9ea44261585263b4e3ecb60cf302eca38848e42412fcb886cf7779ca8fb24bb17ff719a15e5648093e91356776e9f1251394695d6b6de646e312e0e7ecc60a2ec2c135583106ed67615687a820d2921bf348c9eab51936316966d2d41321a832c927eac287f6aa773077325057bb85f67571c148bfae3363469ffed0367ccf887954fff8fd89705d62870d419c6b2689c6fa47e94fe18af01cf77ca69883c183d09cada7b6b62cea874abddf006012819b1f4bc7cafe3d4273953a9f8e531859310b1757a8cbcad947de04f48c755d1777a7583133bd04e7293bc95be3fc9e3bae2995277d393920dda2f59aa97fa7a054b29f69e37d273ea37f337bc50ff87b765cbf7ced537aef78aa74eed4912a1a2d66da2cf163eb4bc4153d1d7437c5c67c94020e5c04f8b25a4eb0fb7709dbc0043c338d7bba6ae03a77eced2e2488002a66b076d7e1d2875a00bc2ec8d1f14fb0d6404da9cffd376477e1a87ecfca00ca4e60858541d4260c4e90a5bff3a16e578dae68cce0c8992f3ff3f5072d561d1d19b273c5cd6364087ede78cc5dd97ac36787d65d431fd366b2c51dfd3b48780c44be540f39b8486f4174c02632c3f0516c262109a01b4222cbd34394a9ec3b5386f185060aaba6dce71304b9a45fd55e14347c4e5a73bf4a011683375b60a506143861a56a1787bdb8b270e05822c71c14b5d344df610da84137b6de6a2bd528c52727b72dfccb644eb6f3eb8704dd39af5ea5b25cd30a9491f4f7d7ec3240c4ff536d8401630bda8ed6a1e1b9495df5480c0dda5516434f1f0240f1e542da0fa612cf4460039fce8e65cb62e4535f0ae9a3d80702598474c4d188cda712a285d2271ad39158806fc3589efad7c5c781cb4e373f068e26beb2ce86e5e4aaccbe2e9ea4de340087e7ba69292db81fd4e12f40adb4d192fd67096c01bc442904e95dfc55d4a71a11b64ab7fe81a22d07bc97d54a626d654c5ed00c947dde1b109fa7f40ab7d320c304bb3a9e94263679f34780bffa1cd4c2e597a7d2de193ad83784786a0c4261016b52570f89c7e5a3c238f6b717e8791851fd69a758628055268a1e3163d16577982c235cce50db29abd47b24614e315a0a8ac872e943d4af9fcab2c8d07cff2d40a6c6ab2c92231cd2dd79e77ea0808aba1ce609527652e080e4249b3fecf9050f9dd187e9fc1ed2a4070a7d3946e5b2d702a7f5aa5f6e687a161905eb27338d472d49e73c4badbdbd9100de329a43b8f0f0dc33b7183c57d525e8373442ce33fb868f14171e8ad5bd5d59cffad2a53c08dd704f4b68d1df0bf4b462c67246c4862098cdf056c9d8c12240e04e5f2762711222c4504e337817814045317261d634dd3f3c3e6da826dee4ca8c2e11ad870114c2b1da55be204f42168f09a436e3b5093bdf201b891222e4bfd1dcf70a02c0f2a5b2070dd6ce5b7f688018a1bd364ebaa7c0447cd04ba04e104c21e26a4aef02a1210cd11dcba065f8467a40c6dd46fe4622a15cd497aafe0be2b9c62ba584a3f25914dfee30dfb63c32c640fefee9adaab8226be5ef35bc227d7e95a1afb9539f2f8821c9ac68d25cf2418813a0ac00ae9770cca94f9cb15a138e7b98f8d015d126f533dcd74afc908df7d650c4e2a40279e4519e96fe2c18e5f314ab11e6524b5bbe6564eaa025a27bac4f7e81ccf1b2806881386dda61065d593034dceeac792f8c89103d0b6d613adf08582d8e2198a183c6cfe926e74c67a40ce34315f1b26e5e753cf64a2144f6a5eb3ff37ac571f22923dc6877b2cb7447a5f7923eb109c34e2c40ccd5727394c403a03bc1d0e840bcfd1cec619f7f3d190fb0b1e1b6dfa21d92d974561c736022cb4c442844fd0c5f355b6fdbcbb3a68ca3be764482654f4843dfe31b1e09dee08b78f84c7b170e9ff625745c43ac3b670d8f2fd2a6a4e6b4428ff9fafb5b2c709941febd62a7ad9a31b28400db1bcde156e534d4e844b3ac40a97450dbc277ac82abb8f0af6a77d1cf3e656d62918de2231a22d9b842be00303a27fdfc89c34ddf314ca45d54fc940f814f69ef3938623e0b19cd8ad4da32d9d6475b3e0591c4327e5bbfe7b7d3dba952ec1b62127b6452922cbe5ebb0d3862326297ebfbd92b44b121f6e56dc938a2b21fc6efaf5815a0a35fca4491906d85c0a90c3b10a2e65b1ad007ff800ff55c319f77b2ce678bb3e24bd2441316fcc09f58ec7ae30069efe26e97b296fe443460fc05442db346c7fd100c1a2a8d5e2bb14bcde83a38d12695ce01c464f3cfeb4c01a369f15e4dce48b050d8bf963138c676672d9d584c50fa9ab47be2a5ac88c13dee914ec5d0f16dd7cad992f5230b6872404a3629512fd68e621450be9e4db548b4e90551e21331ff6839f875a68ba6f37230ac23162fa8e2f2cb48e16997395b9c5d68cb9d0124ec7e55f6b22f3ae5dbeb02d7cb3f866881cfe36385e771eb7bb7761e501c33069bdb4b9155b70c6c3032099e7f009101fffe8e5518dbf138dd3691d282f7c3980bcc3bc270a3e2fcb8f95b62fdfab4b036d62cdc8ea7ad1072f99901c645d2c85db9de8c496c32a80d097f94cedeb017276061e65dee4b43ab3231c26d4c0f37920c3957f2c78f4cf8fced63ea48c5502e5903b1f0471c8736c07ac277c16ced5814623d3d65618b3ea75e9becbb0fdc360a2a7b9d7a38464df02f9e4eeacb902b8a1c8ce8cc7d72f69b3d719e1cf6c681a96ee934b75844f9aabfc1a09e105bd6a521e29b48a0d82cdbee9c457552798f78506768bd95135e2ca7a239ebfb05a19ac65eb1888d9f546989d48edd8d6bd0491b76fa5d95c79b5d2ba4bf601f82cd6886af9182845944176dbef468b366a7f0dbaba85eab20383a60b254cd62218aa8208172d489a36f200896c55e0bf4166a0448ba2e35294f2d5a324acc4de6bad753052aa0074d950f909e152715e3cd2ac6d622b9715e1c7f96fdb6195ca108cc62559a7478ac116545512b574764ec228508038eb87be72a2733c959f69811f18c0deb5c1418ad92a8aeb4c3b9e50e09dafac8b9f098d77893cdc0e0057f885ba9a95606da7bded2f355a70427eb1a633549abd91db4a22e62add00470efd63cdbf61ecfb2508ade3f4a8c2963e470d4ca5f244f8e038a7dafd31756aea829ce297aa4f9ad7bc03ecb8e498a6bc1e06e8917a049f08ca521e324a91bd7c4a1518427383af576cd5adfe3083c583f639e114b6825107615797a49175d80081511d5d0f7b221c064ae448481826e890176258c9f4c9d6620af205fc9d5de734a830b325bce6f268271cdc4a9a525910edc2627ec646462a6e250fa56a7c8ac102094e7c853cd2f81caf351957e86379517782731ce0a062596107384c69c26dd49d756c4cf0ca6782f2ed6ed74f67f0ff986a79370f3f382ed7b1f9afba4f7b6d99bb9935117c3872984623466cbee7c497763e81f7122599f9f5592aa4570fcc8cb51b0026f1aef4be516aff371bc16029aeedf7dac47b3b62f9781b7c6b2618117e9781c8ee4320545e4c7dccdf26f5489554107aa6d66b4c50ee16623051d45b81d21d21e9c782087efb59e8d4288ad47695f2527e69cd3adb6838925bc53844d4ae60295409bfc0d14f35dbfb70901350c00ed84486213dc3458e2505547bb42a3456552628cb4c585481c9b0018cb9f51b2840d6af8853038384e68a7be420c632234a663604eb0d0080d26476581e8ba6fbe66f39d513c49b432e901e77e90029552fe708d7d36d1827b2d01635605e5301a2b7d84ac31cb3f188f063b88a1c30cfa159c3585ae1aaf613d1d57ca67d55a401b66c6db575d5c36f09ea5a7acada34d8d88effbd9ccfdda5ccbecf5defe514089979a95f4171f44f4f4c13aae92edd7c56a6fabbbba2b87aaaba4f41c18fe5c10fdb8a0cbbdab217261d5d349de02138f5a4b9d8c69ac66cd8c9bd5b0daf0027335b9e13316fa85a2e26728aaf01ab1b636dc07c1c4b3a8f8ecc55995139b32249cd847816037a464027597f3aa06ebf55107c34d1c24dda7621a1e1435ce1018cf296e34aa6a4f79e25664bf20064227ae6bffd3a69ce90e7caf8f83540e63add949150399670ad4a645bc26f24b4f1dee29bb6c667fb272c2659449d42cb6685408bffffad54c78a88ffba765a16c75bc226ff40ba4e395ac382b1de88fec30e6b7dcdb7000ca3d7f73038d4514e0bd36db247dbdd2c9cab1371d0bfd6811e2b28b2d68039689065d7a1fcbed379bcf648b4db62a174287afb9b9fcb67a34f53464ef3ad0fd89c2bbe4513fae1ab9c51f59b797bb45da5cf3fb1db86c9d47e308517daea949c49f55f9cb797934fa77492db9ac2c9e369b9773226fb48e30da6d5cb31144105ce22ff60d0c4ba16643a3d5d2db479df14f71d482bba36c6bfde5934cad3451d503585228c4fd848fbd04f40c1a72d1fc5ac0143ac7f7c0b4385b2e8ad184bc9bf892b74d065e17aef0f3973c068dc602a79b5766c1d064e52b37a4a120ccb5515b21c9883872563514dfcc74ae8972b097a8969a9d318940a97550d46dd4858aa183bf71900bdb79b384247af0c09ecc228ef3981f33d8643a1608c7bda6d4a09b461ca953411e5a936b3ef10a57903a9bce26b71a6a4c22250de68f9bd608c314a409bff1d3dea3cf88ccfa8dc37bc01158454e82d8b6ec58f8d94aab51f37afbf7c02ba504c03c2f6540e0dc95587fcb196143dd1a7802abb77c607c340ab429e1a1bd96515f1d1fdc1cdc29c974fb1d9b75984adcb2e3cf6b300785c41b56632acf7d4215a29ac021fef0aee8e1669c40ca6a693f752fb3a58b437711048286ef14728c7bcba642af36dbbe166121769f3cb92a2053f051ed6ec2129d8d29e753c629227b0598b2c372ed9e2552a091200c5be7049bb4463c86c9fed90795e2b492df86d86cccab67f611f5ba39e1dd3d52f04c1a48a8a93d32886f08b19b6673773b20aed0334747673e53d948aadfa18ddf06b800906e62ac4353a1f02a9fdda307a6bc74d42ea679943eac3bfb24bdf918ccb422afe1608ebfec322d1df726a87998b72fdeea158da41272262639bf0a0e19ea0ec08c90b99df9daea2a6a88d56f7484c370b2827d9923c8c55b22fa23d77c606c32f84c3a09f641b8f3fd312dd7a06b813b892df8ac369a94299b3a05ebd49f6ecad1bf899e470bb6e30ae0597c833027c18f1fac210af75b7d2ebb5896d45cf83b365df2d5a19e00c6003f930fa843ee2f7ce671b95e2dbedbd3d7a52ec8230d092b55f2c2f2eda8c030e61f2639cf9ac277778cedcee3ab51e77cf7b2be1bc2e8586eac720cedf84384989e4f02b92b2c1da3e9d129995cb102f06006763638a9c17d8eb88a323ce28e1133a348545e2b9024620c2ed847432d0252e8dcd894c20df9cf9608c930d20d4cf7436534a2b80ae86c3db495932fcca87670d62dec1d64d6316e69a05413760b47235afa06aed0a9a979324139c1fba29fce6652f408f8afe3c0825c35df3b099cb115f5e9c1f6d15c8296495e888529b21e6c71d5fd3d76a23066776b4c6290e7d059cf17914060950b63268ff03c4ce1ecd509e4f9565107df2b8af382f9b2de478f3041d1e1b199adb32361ac6ba0c2daa936a6fd3ee778290d73c8ae79544c821dce433e995bee6d07168ab4d67940a0144f278801b911bd8a051e3ce3a8e8a724fa6174bcf42edcbd5ed5f4bbcf6de3d0fb72a6146e3b30f7a945ae61e4458f7a5823806e34b521cb6dd8b69fc862e8d1dacdf8f3ce196f2369e82a721a963a96ca528b8c38dcda66ec2982ef34b3f7d58107b6326d86264a5ef3759281be65c85f6dc8b62b0b0bc07a30a372ded365b950e65652524529cf70c965d1ed9647da1ef288308f3eb37d47c6e97c0cfa3b990c8a3ef8005b5cf4d61f5c21714f1cb3b2e7d1f92887178f92c2ba46fda0793446e4a0c24d35735ea535ab7a288b4edee9df85a6d8ce61f1d48e190dcc025ceff13a678721c5ec83ec278e0bd5020e696188d0a17a4316df3e33b096307ffbb4e1610477e7aed830ec3b32b01f750f75ba68856109b03d9da011c6239008d63c49bcebeb750c145bd79042bb73684dab208dfa4b202d9276aeac681194e9b2630d25246065cec60c32263ba42e3d7cc497b0b95fcbd8c86356da48be04df21b0064eb12f1c81f816c7bf1ab8c7bfdb51159a9eed15b8a906624cb96e7a8f9c65750e259f37e59c16a751663804dc263a13c13a70019bb934ac00688a4c4bfc37a4af7661d23360b6014112b740b968acf79553cc5e4c1ad0a95c89f0952af6688a4026b609574145f3f910c41d5e07d9d05efd5592912108fa93e65c91824e6080f11adc34869ed0ed8126695149925cc7aaf86acc98ec724510244dc5e65ee2a91ff47359ec163bc35b609443eb08490e215933c1382bbe350c2663c2387cd30956992dece957acda6330f8516e26e8f26afd838505fc06c9245f935982ac914dc4615ccc3039e7ff3dbe2115864cff83348bf76fed54ddf1715ea20a333ebb3704721532b046e6159670491cc3c70b5294a144ce98bbbdb5b916a9698fb455a638612d0a4663ca87fdfb10db6549ed8f241abd9829732861f4ba095a294abd73ed03ccf023dffdb33c95b20ba931b5457a8e1f05cddd1617022d10d3c806e17756dae3a8480b77100d3b9446d5b9d90e77e78c4d60a2c8bdc28c38b31066ea371e9a08bd47365509f6cd4d0f38e815f48f7f3d37ee1fa45f43bc6231cd20d7fd7241a0c0472e7fcd19285aa56c3f0480e2bdf9b08a3245256713c63f85a0923e7506c691f7e8b7d6b1e2ced3ae177c859c9335b239d310792561f281ed216d0b6fd9c349d643ba604308f9a416e5a1db5e75e5796039f31dfeb359cf8326e0958377909e68f899311eaa25dfd1f07cc2f3c9e386845a1ed154ab143730a9a6fec32bf6a8dc3c7684590a1e3e7d58faca6afdad98b76789749ff36d795602a77c4f8c56ca23dc0f88006707fab99dda24257e72e0cdd92980014d33d851012361137bb130a3f0f89c411bd0006fa9d0f3247c824e66a6b2408211dc7381c790fb3ac7617f10c7f45ad25355077284396711c2f67526ea33db3afa9241ea6c217b13f0a094a9d09f151488b0628a5eeda7b1e855403baa5b41451d347d52c60fc4795f2fcad0bd64d9671ea31d37ad20d542e8c5d0a09435c95ec837f4d12e5a2e6f7c3ce99d569bbfdebad3ad0ba5787c69723d20be9b102af1206cf7929f9407ee7fbdf5495ad63ba1fab4e54eef1d11b742bd9501cbd1e797c2679d0a30ec573edbbb9189278a5f301774bad677fdb498f78abb0fe838fa173ac4a5b7c9d9378c5f95a4f1fafdbc861c6d21b4aaf76dade1e87ae862c931b54c7c2dd8a6e153637ad1d988ead5f7d46f3aaed18355dba5666e0e5c41034f5d4d7de9e26d0f717702cba50761a9cf2bc8961ae4b44208e2080dd12e450ca604a946ef4e2b139c64e10d8242d2662ac41cd2732e55a68d6edbaff83fcb88f3c6d1d839be6a57339527c9d32832c8d4979486a3dea2f2b2441268a2c01331bfdc0df14eb7899fa0c89aeea012f5cff98c8e752ee3adf57d53ed3ca40e5293f109a4d328fd0f4897b4cf39bda4a52780c8a178bab67e1997d345324de1d7ae47d477e2a6063577725fc37fcf42c13e2a42738002df28f05e8907c077cb298d84d738f482a50bae176e68a27a9a530c9494206a2862df5a4bcf290d3bd86abf6fe2faac7425d54773e9766e1ed2312e75bb103b89024bd4067200f44a232974b89a86989ea50f839af43c0418d11c73cb5cc170bab38a1e6421fd815a11537a4972502acd9c53e6b024789e894dc87f89ea83d7afcdb6d6a3291d688f75f87bac51181961d86d55fe04e383c728a42cd9049b528fe3f3f676ecaafde2428112feb9efbcaf6392d11fa983839587b2ebdce425e2e2437a60b01b0106f82e52fa6d7c8d7703ac0a8875005dafdeb751c8ed8f495230d0f2acb1f546b800fa566e4f5af5e9ceeaeb13ea529ef5c2e0305186bbb68a82fa32a680f40af6c0f7aea40756a72e691b6d0d18d096064a6131e3cd03d574a47ceca8af2af733bf66b79e7fca79b25708559029a3c1867ac7893a198eb17940bcaa13f0708542e577409ebc18f619b6783c7145f339e42a7a155368f1cd8d0951852348762814c966fc40a4cb0648eb84491e9e9df2376ac650e1a4ed5f24f6e679d78b95c18c08b86cb40af787f4bad23b9df26080c97cbfb18429191bc7e93f451c2418c29cf80027a314ac8fca47e8048c377223d729bb1fba477c2bd51317c9c91ba9a4ab02949af26d90a10bf963b9e44bb26861057af9c57722aa541c8f409a1721788d781c4affd6a1feef37716c0652c6a8456fa8fd7ac0d31b9a259e24cc2bf43c870ae95bd27de40533fb6484116f877b03da94c96dd6d6502b5e616e36e4ac15d2f50896dffad63e0daf41ace4e327dc423fa390f0e58bda714fd157828abf60439610215a6e7013e48fdbda09052054cc8bc439d9fe55ee1c3f30291bc4c5679b454fbb7dbb19c57b78d60f8d05d0f2850eb9382d337b66289aca51434359ed662ac44db13d8d4563768691d1af1558c824a863e40bb4c999184dc5f095bb9e9c35d2a1193c587052fb66ab7e4f497db63cd1244bd9fd9b56231a87e27478f7ae528b0dfff78dbf650d1be067feb2ff3d1806b8d1a345d3f3c8a709f90901f37bcf28390033b92fcc957569ae6e6f6dea5ea3584a800c3f9c8515b0a74c1422bcb542202e3fdb215e9d0e793cd4f81149828897237521c5e5add38877a0ab527fabe5c4e3fb8e3ad2be8235b4e7c5c7b0ffb8974543fc97de81ab258b22aa619989acbed401f60f64f236c797cb2b9b3a41e846f7ebfa38f82388b089309608e909143f2f48ccc7be4ae2c43be34fcfc95dd0c3a493497a507128a02f6248a0941d67accc2080c8518de0ad045aa8feb5750053eeea249442dfecf9e161c6d4d67da3143d86acc510e9bc8de3b634e217894f9e5af6e68a8c4cd42ffa2b52e9405437fdbf006ae0aecc579576b25ca823aa13b2e69bff2fe4d666759f2139c4ad32d6bd77630a114ce85a33cd1a54d84100b52c59aef2ce040a8e67e7a188cf287bb85e1004f27c822b27087c8358c626a4b40a688658d62d0f825f96ee043f5aa39df20247df8eb9a4354e982ede9b0efbfece81082a5dcff7cc592a224af6f81373b4c0d8e21e7bee92c791dc260ffc8717eb3f53aa0be0442a4570051c0b5853599fcc91687f46e91094b63b4208f268a50682179a6b82da929f86e44c7d67442a4a4a70bc4dcdef400255f55c2f799e281a1be2a5db9a8f4aa20890bfc2cca2302e35aaa6e90a8233bcb54aa5de72c9ddf2df299d49c5f257fa56d18ad41a72a3aef8300afc21de802b0a8edcf5d20a98442dcbdcef93298f6bf20d4c4f8cef8bad5b460a72471b739548e7a739cd2e74198137b6844c056d1e2f920a713ce0f5cccd8eee6b1a033be22edd09088d40a8b1122a97501717575f79e9bdd3ff7861b5c61e8948f907f8ce89ea3d4d814a6b827e1fa657ed450edf1c3a5065aa529d9d7efa35dfc7eec564c13f148c4c6e174c251d9eba9a9ea77dd17c228c0768c2333b55372732ab8e7b6b6ba85a3e4d72867614f8f2b4bf5831616432946eeb52d67986f05584f0054e54509ff4830c9561522aae42ec9fef023b50a200572dbe83aa605b253a37b35125c2d8f17ec0eb719460071ee026648a208ebc108f0b2ae45cdb085981445ecb3bafe209f03aa90e4927fe076e03b62f2ac98d5f84baf3111db71d20fd505053f05891ac2715515a1b405ce3be2a21a21cd404389b88a9e5a7bd9ac60824cb52c522c19771ef315e4337fcd2d8c20029bf5df081297e08d9e98c71dd199afc702c687859c4f780b713762e42e7d6911fb1a8aab2d43450393bad792abaf1b80e74229f8ee722975988492a96660e762f65569d94f0759407139444eeccde59868cb29ce955d6b684ee810195bd7e3e1574d570c4d0861174291b64b638c02709f1254dc8ffbced0e39bf52909365ae2bf9845426c166217b3975687e86c05b9d71ea77655507fb5811d4058869cb75dbb014dcd03360f15ae8d49560df4a8384fe80aa1f65ffacf7349d68525ee98e6a4037bc38068a210e4ac1ce734f4dd9af010aaf5947ab8a0bf3eaf742b58d5360b9ae69bb2134f8359c32c6bddb033874c1020dd27efc5e6087ef088ef33b459be5290cb9e2e8f11e8c753748c209cc2e3671989b666feb83117a2aae1974d3736e9cf0bc9f4e1510d2151eadcdff8898d3b1a8ef64372e1286e5956dec99b3595e0c3bcc80f147613e769616bdd7e3120c6e697e3a23736ab079830e3153d9a1c05037515ff241707439a5f0d18ed0d2585dfa0544f7f93a426a757d46def0d84e864d0826435bdb677d64dbf1840ac30b9a4fea2ad982004c06461e35e67795d5e291116ebc8fb6456412a0b5a1be6db71461a1eac7db8ea1e13f658e7c2d871f59a7fed0fa0886cebdaae8a25dc3636e15d9fa7af5ac2da5aa8b272751d0ec2adeaec652324123dd31cc9a9fa460dd48f8baea153e9472b3eef9e42b0c38b5be81cfd9c5d402303fdf7ee02c67915946acddff9505b98401317856443b8c8936920ffb95c8f593e18a279a65dc55be4fd57b3b54f0ed5fd73dd030398d3bb87cc88c941c9fec95f16c6ddea1a84fdba4ab6d679d2b4182febac9ad7151052363996d3bb57233df7954dbb08e1df91bb2c1a14ae9ff3f9c0bd79c7c55296709340663f804c136a0c8a8f7d496482e471752859972ff72197964b7257afeca4bae692ede8ab81b0a63877a161494d59f726cb07db539c27d1afb3c7c11610c5ed09185da46e08565b48338ba9b9dd1d315b996b64e819d3a9e0f26f080e49f1e5c50eba0430d3177587c11cd50365593d75fe89bcdbbfeb3d5f66119ae636ca175036cb8b0190f71d7c909e93dbd5d0307772d8e29d27b60750661eacb9fa084c699a29ecfd9b9867eb6474e6809d9ea03ecffcf63c43496c36a95ec99091f3abcc530d425322ac0644501f3a65cb1d3ebf7bdb0aec7d4176b26cb4ad04ffb56f42c0bd24324bff9b2ff68726453bac1a547ded54a9f0f78c24478a3a248e4b2d880cb50986846dc2f4064e450fa1bcc5ae1d36146ddb4ac6458aad24069ca57c27dd0c7779fd6167fb90b106c66baedd4e330d608f95c1441c62b6a66c8167da76d8a1057cfa2e43f23186f481fc096447bae1b41b58d0e95680fcc5e1582633f51a3d0c86a9f60d4beacdb7375528478ff2a9d6c59b80afbb7eb8b79c6c92461b55e09fd0d385f9c11670cc1814849762028ecf8d62e6b4263a988a13470acde593f4cac524dbe3b7b412ebc545b79c8a713003df0ba6a3784c31c1b05a40840e80c2521608e14e4cb282c191cda97186aa940b3304957e6496ae165f1a141cbf5d216974a227e1e2d2684d66f05b370f6798412e6e4a95fe6f7a0d4d4277cff1e04e754706e2d44d12a67e770b83700fdf170e722af151822957691d67fe25a45cbdf364909b6f07d2429d64d202bc9a7a424cd1ab0acd66eae8ad79cc516cc4ca44ca1dbbb8c8c9fe1670ca0ea9a9cd0e1015a4ec63b09a1a053bb733281aa70418d271783649474a791698015f1ed499f4667df5b9e36eb87239a47262756a4f1ed4545a95640011e003e5d68eaa14bee971889ffeeb0ef9325061f64f8f3bd6eef16138442b62d104c82a84c6cf1566cf670996f8db9c7cccd575b3ed789f6d7f8e420ed874785d1b85773e0a28ba3f5c00064d843fea2a9c7bd1b8ad4d39c5a7f69fc0bd1a30b5b95104409d5003260c5b0d7936d9c707a09bd645495e4a20a47e11293d4747d96fed5df4247177d8ae33210106cf9e7d2281f0ed656b5f7815464d1dddc58c489f2c6c0cc4baff1950965d60f86c23aba5cbaf9463d9ebb6aafc290d8467e14cbdde176454457db81541993d76843cbd598aa97a67e457564e8c60f0f1a2261c4afcf2493c799e98cd2095513cc1a10d097df8d748da5c27f7ff9f77d3bcebfebcc98cee04c81ab75cdb0f301493b39dcf86ae3a18d47a2bae05754149b85dad43940f67609238baa24a2ff9a3954e3e6b36f25c597b4ded881a586979f212f89d512b4022fe7d008a738b0782003e7ff7ff053c38f680727b59f2fbe02603cf6ee8c354472d0cd65c58ed3f499a040ab6fb2f940feb1ffe178e8204d1583db268ff23b9bd8e7860f511b5b6678d0c210ab988409731f2f31b889393954641a9077d3790da4b38315ae69e601397f8aa6943711a9451569d662cd7ff43e00c14bd1327d7d1688554e80575699f38786dbe0b5cdb7b94e9a48ee56c1c91503f4f1a318ee11aacefb985fff1db71dd12ff51f67ab1a1948ff25801f0226b35ee157f567f45c5750bc3233fd62c6e0f65bcb7274f498d9714d62f5fc6a13485b736ae12c94f213779aa64aab07c4e2ca51f05a9045e4c8dfdfad968241332a34485dbfc23feee970547f67909b1407148996d10e9f33cf58a833e24c1d4c6383063f8eb3567f4f48eb78d57fcd984f23c08f1011d16458412d450d1b88162b5ca45c5ecf6140376f2602813302db52d35a3220f1a7d6ef021561b6b3ce7e3e5a0c65a6592d3727499e07b4d6a5d2e19bc0634b876fe9f05ee0cfc59726910dfd2ad1eaf583b45ad5270a32d10d0a0bb36fd167e7153873469fc26cf89b955377b6fc7d8ae31c398c8ea1aae5eb35b8f375f604c125075d7f0595949986a8683eb3d511ec763a08f55522a41e02bbc7bb8ce00e15c3e17a2a2ce20888d3faa13e30058ccad83657590dd7e536bb3e89f25e3ea7e2d366fd869bfc3a72f93a7bcf8cadfb981296e762e03be241e37565de62ed660babbe7042a31f2c4a209e3c71f5e20e89ad83e1c18d674a61e5bcaf1d8d5a37fc4680af868bdaa0f3125fd0cc4612653429d2f2d6f280f704ca1b6f5d214916c4d3f8ffd07f3830b7c467f4b374972ea2d27577e4f9cc8374006164211f73b0595439ce4150beea530034d80381560d937ed9b0f15e159a8765a2e8143e561c013c8e2c8933f39f9e5e2943d0213c5f5faeca9fefcedb6a88e88f754233be6f0bf6a9b154db11cd2d7477f5bb89407203e5f929ca89a0e34c2e1a6b96373541b4cdc90f642f62a6d19cfb4928898722acae8f22fe3c91bf4bcc7f261fb5b330d82e5c05335c89d97d1dc881c67c4a34e86f213e1a701c9c9bbebce0718f9c33f2ce32476622df1428beeaa99f58ec26b7d74b5682a4f28b134a25ba78749f2a94fee5e8c61093fb45bc71bfb9e19a55a679792b45bb6b67a286c0cb768dcc4a3d789747bc4e701271780069f408093807cc01df202a242dae83ad10e10c9f43bce83be87f22ddf8707043b34ee28a1afc12084f499727bf95a663e82dc7b80453152ad1d04c126ae61e78b01e54ae85565604a846afb26885ac9e6fdcfc483efb8b98cdaed5e79aa60f5f3690dc900e7d23b506a5c35fff615ee2eb9eaf2c0e6b51f0fdd551c67f080927599655d4b4303abf66f17c10d7cddfba848e651ab6795c5bfb055c390e95d3e22901506172164898a50db04f5e91892130c24629c087f8dbc93849628b8412e0ff1bb5de94770aeb3fbaf008d9bf46ca8b9ca181a9c1923e5acdf3fb97f523395d7c9a3a0a521a597406c170992e7af9cda7632c05da1853b21c4e84c3f4dc9eee4a7bfefd911164907b0f6bfcf93c0cc1a6eacb016dd25fcc8a2fcc5f4a8894fc518808c62bdc6f1e160f8ef387d9cd79d8072f07d91d69d39012a766b1b974d2c32fa5e0bc593c09595739cb69b850e6fe62ce35490a648f1bd8355c657fcac7d8642e596196d53816de556f569e9ad2ce0998483744df57be11e05175c609e9a60b42bdd819b6d5da3da477530be1f60a59d026c9ee547c7a5c90a07ba5f9991ef3f30c87849a875b0e1dcd87303eeb8b976418da7e400303cf7dff6c813b884f03aa84f3885acc786f9634a180795a67218672baf1b35065a9a560a47be6d8948ecb4d44277d88be0bf09c178d6b278d2b159cd1c83d4dbdb500624b00091639a4a1d5c285976b3357d25c6ddcfd38076797b843440a3738e9c96137d05fe07d23b2558d582b63eac81ab75206401815491870b9351032b2f422d71359fd676909dadc5346e1dfcfab857ae568ef4dbdab075377830942cbbbf008ad62220096c3635d4fdcac576049eef3892f9deaf6a4a3b5d8c6ce7316d929f0fbdbb1dd2091b535c2050bce7cf4f87df8475a01ef5693d989448c60dfa1e60a63a7bbd2637f34a080cde02a9d1c1e15dd0ea18a18c8bff328fab9e0b27e8ec0e583ae07221cd6ab953f0a9f73001e96dab468053f75e90b2f2a9d34815bab9ee25c0bf9796893b4658ca47768611f144ffecfd47bfde1c3e901074687dca36cfcb46a326977920907109a6036179e8b6ad1463e2e4302909677fd7cf2546bf157b3ea449cedbb9d4a018fd80e5931329fdbc1fb3b94ebd27c6a0f8fc5afcd3bd541873628ed901ff38b5764a4dfa6f86e141df846dfda7bcdcfcaf68fe356ee3464252dbedb4841ff2a33e5079a75e0cbfb12484b734c20d886a00557ab063720e8fc1712e8c7937737767bacf1db56b5c14c7d60cd6751352f2453781afa1245f5805da6c86588b173a0888318965ad3f9afbdef236900bef281ea261ceb296f69a1f202f41ed16201c7f5cc46698217e404ca1321114ca4873a424679adf4d63378a6957bc89f80f249218ad0f50ee10f67f3a1f77a127e1e5191e202b352e98f8969f525745d7d7b81df1e97be400b8a1e90eb37ec6952999954ebe9eec1630fe02932b68e02e44786e5d1e951e9eca3503a76d64ed377bcee3e12b009e027e86b9c9c6b0e90f517adab886b069707d03ffb1c1b176823262b04a0364df3832a21dff60ff8e5b47eea568c88fc2d8d49a6b1af51facf2ed48e7cf675e3861be86d1b59400a86ceb2c8788256535a2dd31175b1f4cbfae855568d4e1764c5e93342f3ddcb314d8eede9a489ddd558b75a44d1bab4edaa371eef6f0473c91584ac778eb713cd921b8d638e0f0a98f78dae9e94574599663eac75219e94daeef2f59b8d9a2066060686f046d284112ceffdcb134bc5d9f3c083d7d230143dec5bd6780bcd05b9f244c32d7aadc9026afa137454b072e02d0dd34ad3cd7515c6814e686a9a52153d3c9254ab8912a17322845df184cbabe4cbf50bbaeffcad9cc83bc12768182f6b4d294bb3ba67499b97f629484fdc76ae8556b3a2ad808de4f4a295d98b41054332be2b49779ec877034c57bef888885e652d6f14b370241e9cd9666cb999e3cd2282095ca8ed209ae878bd2bd3b3ca33fba15908b0cffb0d3983a25173df65d1e8fc588502e489a0fb823ae11d53ae9629b1eb916134bdc1082fccf2dde40df4b5ed9d0b42433021f3e00c78343864d52b51c4e0f115b3a0fe50332695a9d34164c59dc4b04f7cc4a561f29e00c6a46cdd1a76015db5b2ffb3b523d87d3d0992d597fb30d96b4cdaf0ba964cb6bccecdf2749abf32343b2b28388bec8db908b4861c2a383d4bb14e83e9bc128787bbbfc34dedf748202ec85783e1a3d3ede2b9c4215d8bba3372c76a7731025bf88b9275a4974ed1e1ab938c7384f76959994e77912205dd288e9088c57f5f1664e2ab226efa68514e245cf505d155833a1a40f2179124a0aa29e741ed2cadaaf135d36ae9e6d9ef347cc3218b1ce11892defe277e1f741dd45f2220d78f754dd148507fa5c6fef54602fea155138383d1278fa54a06913b66518996ade6620c17ee7455831f2e8b137379c20fd100d3868ca644fb25fbb2603594d6cb002de8b0041eb413d03a7c17400e9cc71815c30b8f17f69c54dcaa34f1eb28be6ccfeb5c8ed4a6b04ea4673657c358a3685774e1891c3650856f2ace133685d9efcfb7512cb108dc290829db18a3e92f547495849bd3e47144523d88af6d4a8537cd6b977e1a2bdd25fddb939e28aca0b83d455adb28f62d308b296f6779ad20f52170704b273c77633a27acef689b1a6971b31dd547f1b182f06a2ad3ebecc9c0fc39f88ff6911d87cd792d4600db3cca7a44b40b9cfcda2c093b938e4c6c682b3af1c2441f46f93500c8306906394bad5784ba3e2d2be3a9ef3241741c3b073e928261ff348aec34cb7587c7e36a90308ddfbc0e17c0d70d88701b5def9b83480d121680cda2dedcb967a17d1307d3500a3ec1e22795fd4fc1cb136996218d3c585382f345e423edde4eab43c7c57c22e5de378f7fba4e0b992b9aa3fd35f7eed2b2463f25f2dd91a388f828ad02424d88f20179ff0716518eca7582f6978edc861e155f42ad12c3083e3f24ea451e6b64bfc4413a2f44629e1884af0e49560d09d54788ec53f07aa40db4a71d4552f6948770b10eaa157236fd1b5f0ebbbd030ff46377a08180289692f14e2b2b23f3a7aef3933a3ad50114a10c35a524b54db537c64cb388c12795c452b365a004edd51927a049137ea91dc62f006a39d44df0ef88035e06e59c629b35c9f86b75b47eb6fd8672eb52b0cde8979f3624c69904fe52536eeb23f529683df65a7bb37ad361a45eac353b929996bd021a97d1e5334465a248dd6c3c4261506f3e08b57c6098e1be5f57690457941fac71aa38281ecb0a9f9453e0d40bc966ab964dc95db21605864599ea8a00515711f1ce6bce4a5be0aa14a232aabf9480bbee1e6640334b4d014983b30e0b3a05f054eca3eabe56a2108a555cf11a3ccfb2b80d3a31c63f20127da26ae7a4e5f95adb2a7ef05d8ecd714ae5ea2b76b59c3139d2168bbb1be16a445d3bad80e4c142cc6ee49a88b9f4cd2163d2e2fd8f2d75ed4260fd39f47a6c1a117c69bd401bb86f6653b6c178722a8256acc2c854b41c6a3fdc1d1408fb94fe80b8a45b6306e644e8049a39cfb9ddf332281ba75eac796e15dfe9075504b1615a8d61e90b408e7fbbc1532a2fdff3b206b9981ba02ab554bdc05f7c27f1ab4d4f0216f8b2508a187a68210c8c0fad909250a961b3f9f50b655d319604df76b3b30b42d069952d29b76bc928ab9caf313175d71fff3e2e1bc4d10960136cbafad92984cd46bd971e8c437624e0d158e8df36f5880a8cbcf304d5f743fea701a321beef12a41ba8f063bdbed83d79dd53510b052f356452739084b722f2f7c33edc1cc0b52e564935eeb82839aac7c6105b377f057aa2e15b272204efe0e8172197ad3107882c1c2360681939ef5db884806daa742f68fef19ef1ed8791914bf9d01cbde46e38f0a449192977847caafbaaeef83bc30ede3a26eb109ee315c7362712ef5c878b67c86d329d36c644c5caaac44a718cf17cb08934dcb1c3edfbc2aec958163c81005dffb2561e335f022e5f665682480e9c5ee42df96738af52c8f6283e984959a88d2217dd0d18474e0d49155d03cd733cd5fbdf8c3989089ce6bca1800f8e85224df4dbe2975ef2020e3166782db7b9783058a97e5d16ea5c74d5a3766216fae63bd969cc6a2bc19466caff7154fd1c3362814ef5c044d9227e55f7252ec0ed4f386401ef41a995139d670b5972ebb17b356caaa2ea3e0f99e03637314f66b723ecfc2153812efd054a1c07e90772496add267c0fe56c1a1c8ba315b90516357e267c866d0bd887b84da33eabd00397505190fcf09b378935e256a010e5089f89f91b8087d143f433ca22f00666cbfac5cbadfd70ccf41b7e55f0808a20cef728afb58945963588693f610e71cbcbde4736cb44295e794806b1d91fdc9c5c285cb43d733487ea195574e6108741069e772dced6893ab428d95f0b9bbe98644e96d846dd9fcd4189945f8410283caecd200a08006c9b5792b1de122fa4a966bb4f1fb60d640699c1041e72f7988db0f2f34afddee441a84b3e625680cef44d2dbabc883df61556ff2354bbf0e02bdacb0c71386c6cbc7898c1fef2c7102f9edd0e58845b9f5346275b7d77ae60c2073553023050e287c6489d2bac71ed02f24a1068afd9b0ba4f0d6034cab2c76ff04e0d8d5dbea40e73f83dff8e1f3745d0cb4dbc07395b3913a4ef98217503a027eeb164f7bbacd85354d235573b49fe273e3d8bdacd161eccbf99bb917df6ae1bdf25895add2b0abaa728e65b5cfbe5d8a0f03be1ddec13aed22da7a98e1384360001868281dcd0c66dd99a6e25b786abc8430a9c46a75faff2cc8531f3f0637bd3532152f362dcf9e51a4c68e62887601e17a363b519d8e7f9f049c9a8ca87390e0330738e38217e64837a58994e73b7d9c49302ec53e7427ea5382e6f8b1d321a9a5811dfdd29711caec4b9996e3e64a90ea9a180c53be4dbe057309ef11a54f43fb987c70611aad5526a470c01a8252ad06c879d94ad24e4851ea4d94c44526db7a7d08849aef33c80fd419e6f038d653f8683624dc418eb646090c8f2610bb8d8952ca138d71c45615471795088f88d4835d1edeb1c9140c172892c7e2ddbc6be30ae0efdb9bffd8c0f711f294338c70ebf804ceda17234d2b2564e1590910c9c0132492ee07002dd90c158186d5901608d1068db7609e150ca18c34cfb683f3e1db7148aa8d7b7514cede1739c386ed697ff5009975a7be4d1ed13507f107413743a03424080fddb101bcff1b14f5ad785188af98a180eb9948a3f3007259d9526dc4de666efc8a413f20589f57ea36e018015129ed3c17d4febabf3078ff78f18e270445ae8ba719cee6dd17bd77788b07955fb3668902bd852c6e5958ec5c7db1e3e71dcf3bba53fcec2f55fd96004faa0029ef9736ad73ec8665d4dd17777bed0fa5db11ed3dc7df489cb3f2bdfc5c9353ff6103cafa9f21dac9b16d7665cd4a57367629de7c4a7b799775ec3b9478b4d6b8edcf1106f19f8f8832bdc06e886fd22777fd7573a77657ad5bb074e495d34dd2a84c378bddf1d2133fdfcefd96e208e54a6998e418d796822e82f8c2736c454869328cb8e3a272cdab8012ebde213cdb9e3c7840e2721a622f7fc91abb869d6bf071d2c732c76527f6de21437ea6c3aecd2f5276476105e61482776dde62586cae92055c9a04c1289e58d9bb32cd95bc4b87e163057dada89d05421901f78594f0a5cb9280ed4bbac30eec1e956e0e6c054da1b9936f4b3621162f6b7677862580e15cd24f3654fc2eceafa4f37a4e934a0bd3b6ad45bc346f0653551f20aa33f189507f75e74ec1753f766573b33ae35efc7bd235677b45eab8ac0f44a831d95029bdd31ec13e9e9b3cb26287e5bfe0e3d974e8905addc4d56ea0547c2181efe400bc61bcac55d5775f783daf29207e21b796aa65df3d66cdb55a071d059a47fef9b1cfab832faed4d8ba0df0bc5ca6c685f78edbf51d4e3f58b6181ee55712466983ff6f2a6183d7ef86bd7189c78e6b4bf889562ae4bb2f89c0348d834e3eb1b1c4fd080090995152b8476b15647247ac1dcc9748bf168d052c2901de3bd76d07925842ddfcfc5c5188b17e345105e7f807d42ab711b953111d13fafbf89f9e844cf4936a2c23831e60aa31413c333af854844fb1c3bb8011797cfeab5977ae61661ba52152bf7ce37b06e1b7777c81cb8e9113201bff7eb54b1334284605983c2eba3c05fecc8e21b6d03efc6d347fbfb684f999379fed8cb97dc67fcb46dc5cb1d93d89d56905a3efdf80dc6be8267e556f66d69d5e102529169887f66e8adbf795f20ad9bf1151c29b4a0d885de853b62c8252fa0d8641ec70ba8e90bc008f13c8666dc6d3d77de8d7bf7cbe3e4bc0f2045927773016a51f1fb41c49870a3d407e873db8c2dd7216ae71459ce156897b5c24f38a3008af333cb12e906e1af83bdba8075f5bae8af3da45b5e552cab0d77e80cd6b17bbd367ef31d59f8765c03fc31d7c5cf1a41c2b8b51659b812568f51304af5c79bed0a304e0dc4f64afe4873f1482c41beaf0897f43186fd63731e08dcbdc98256c906f0b54c085979eba300f7ba766bbcabe7e05218290680c0fa32f7c901e631b788f0b1934a492cba4b7ee1362bd7d1fa0744f0c869fc1ab41726a7fffff25baadcb7dc29a76576b19f5ef007b36f127dbc8ace12d415f4871b20e70cb04b87c24bd150e400a2b3683116063086d6096e3b91490cd99d6b5ee3b596a6d0812ea290761c2438094a9e75c6176a2565333e28b40f382664de88bb0d34f07dda39a91abf6aa3cb9b92046c511ff1db1013522bf95aa214866e2b7871ebba01afd9b169dbcc53d7fe6baf645f7f11aa86a384db001904044780a245aac8ed0d00594f3ba8674c4d1f4e49b01f828c3fae16ac9c2956b74a0dbaa9d4e4e4bb0f7eea7582a2da4c770a148931ab7f2b735fbe2c987b0b78595eca8802f04f761a3bc8785aeb92a38eaa197e2315436e5bf6457188c8aa73b371f5f0f30a1676244ecd3b903bf36529ee4fc2beb039a6dccd8066ff1b3665fcde58259fc4eb5f0d97feba98bf5142ef92469b46efc821311aad1ad62bae336fcaeb218f2cf720c465a15bc48570391776af01d9539e71c90b2b921c316f5e1335b4fcf34b4198e0fee30159308c4ca0e494bc8a5cda8f964fb5bbf7ef6dee7ff0394a4177422a2b5f952f77665287e40034101eeafd153c6d835fbe6a9374c46f573b92fdf4b1658de0a7ef2db5772444d1580d0de9afec8153840cb38234f24c6e27a2df8bd267e9d1d187e8157f7fae074cd2f6f4d14f21ec33f28ff67189db21e44731493e16b40bc27ad8b7ea75feead2a4ce9bc0b3bf325529c24939c999977ee2b2f4d248117339def9b53d1a7b20f086debf98c1b209b15d34fec86846acbd0c1bb3d308cb8d72893913dac79bbcb5d6620d3eee487ff87970b0dd9d6d7e210e4ff38df997166be78d7bd11404180a0df910900c102813f925aaf50260b95c68ba7379064aa67910bb301d4430411775f8aae5b73378430682c4c0b2005dc09ad78a4b800693c03e741482af0ba6aac63972ab3766776f554c3bb811aa9e33233b1c9e0f9166d7b96030b6c57a7a7540e431f7573af1f13ba3f2d52c63f2a8e56bd26f00bd4a24ce146fc0353601e418774dc3fc2868a4c2d5a85b8315d1490829b8702f6cad4f21c949568d710651a1fcfe361c5bc5ec776013b4c10aa552113385135a6fbac71f5d29ae23e87ffc21c3353750f3d386464819042fc98874d0eb5d45644fdb95973f26203343d703b85f7eb6c450596d7e87565263870d0d8fe2d22c7f60048e8def396b54ffa7201ee63891b7d5e38724a101e9a164cba4a939efa6ef77ae13be01f9701da4bd9ccde2d86f63e7507616b3ea3e4d48253d71bcabf31a5bd7fb880b0dc1a0ce16a9ee3d6f54fdf1306869eda2c51b2694a4750f6d1e1243ad058a65a6599db54a4eeea15d65883fbc6b934d1be7c14987fca71f7038c9fd20e2491b6106913171cf9d8d88f852b946ea95dd0529d183b7f46df626d6547cae198a0dda8125f29a5d9fd1d32d75de903c35f2f55fa981b757c164cb4c09bce3221b6002d2de70eaf364eabe233b2811e2f071cc5d907b949e6ed4666f9ea5a235433b85d3ce3b5cc8a0a3e880fd412183f2e2f119096288fc9e715e0143e278eeecbebf8104895cd6361c73e91e6737c8ac338954a5f76abcd90c6115d4a56f190fe4a8bd2fb49b233d068da036ef3018e547da0730e21810ef2c471af2db80b7d2237a92a53b9227437bf7b596b4926aa1e0e18cd0a3e1f0d8a4bad47baaad470a08c84fe853466b88ff25ff9f47ef596b0659bad31e29f43f3749e4fde3d162a39a6c318a4e646fcf3d14a1d9e2248fa618fad1b56a2117d09b06b8a00fa49cd19335c5c5903a18483c2b9f67456b11b1540777666ee1fd8a0834d91c4a90d6a5336066abe8bbc5bf1fb68928cc2ab2a1446e5a05fca24ed7ce04e35069609b299e6eb735ac7311684f7f2311f2889aedadbb5b88d8bad19609424bdf02465fb3c3fd678b9e1a02b8267e0ad9c234357111647788f9622b1a6a675a9c5507cca768b727041f29d7fc37703b536de76d0c08d55b05914e3e7e7d724c2e6970fc7e9fecff32f13335e8486c0aa135838eafe106726244476cf20c7d6d2b0b2390f77b08fe0a3e8b3faffbf652510a5298fa9836c31bc697d57bd1cfbe00781f467f760ef659fff7e1a214d3f4b55f3f2e243981faa259a65950af9afc0ea218d6a3bc1b8c418cd178f04496167ce00eb05545285e3e087b5b97b7c7bb22e280603c3545bf1cc1da2a4d215e5b671f8dddcc99aa3fe90f7342456ab3d2a5289dd03b82eeac96d9d8238f593b4c409f368782743f903d4b613a219b3acb5e77fdf5d9a1fb58b9b3058b92ad1a2c00e164f2072f88c38aec40610363aca3529d6f5f4fefabada9335bb606d2ecf0eb790fa14272a93bb1c447a14d001bf13562547649daa4844ebd0540187589ce3048198c65877d102265a3870cf2374ee9f26b9b8640ebddf509cce5ba7c4084c01e220cc0e7394b44836c7ff04a1384fe38672de11955cb4a9bec2afbbedc0137a0dbaf4c469fd4451751696041a09db7d63af96bfb32caf27a16f66b0c177d2519ec6c2d2bb1d3558f0c4150d17771a53b1a30231c480c221557966e771ee5018655fdd2ad10c578dabe82df3377135d3586412c437637b30f1290a380ab6e5aefda13ef7de35587fd1650407b1ff07e51401f1089b3250e51889197bb9c25e194178b9072aa11b32ca85d70a973436ae46abdd2dfc098c074ff45e94f7b4df6a19965f00a47c9edcc5245326bda374b6d64265b05a48eccd86b5bcd80903f3dfde9ce4316b290cd75713fac360bec410ee59828a52581971a8553ed91bbd02c2823411c3e0f7802765efb47dc0e51b00076a64f9ac23b6f8eeae0db65c44724cd28f2082d448a24ea96a83100f65849b6f64e1368ce82d717ee6288ee79a8a00e312a45082256cbe5471cfa8a6ed67a058624358b8d7ee6d8ee1b1c834d18e666984c28c31b8928489d0c3cacf6cda73c05a95c93a36cdaef78edad26b13b357b4609c3550ca371cfb4c6790541f5c96373ea44ddd5e8a0f31ad577757eb75de3bec66edd96bda39d8a73c5fcc2538b38f7ff75d9416d338fae24b3dd45304ecb369b1ee8ad797e22f55bf080856f1c1971d56a265f6138c9c1c8e7b03ab5659091cd0d5fb8669b05ac1cd544ccc2ed36deda1150ecc14590a88fbe1cd9b98d7b91e81316ac6a79f16caf4ef7bbc91c551a23ef0e87b2c8f941a7a1a9ee431c98bbdc86c1f89a3f59087bd162bcec6ef271e82946656a7418acb4705ac4c6bc367855f824364c90ef25930cf13038a5dc0267b3eaaaad160f2f00b4dad4e2bd7b527b8de0f45605eb45dca99519f329c9df72bc81a3d0ab0b34a126540af7265f8d07babfa4c100a26385e07741fef36ba3a31e2697bbfa8b4776c307429f54535fb52167d3d061f8a1ca7075abec52130e1137deb9ee53295a0c02831449fad43778a286d51118c243c5eb09494ac5979e9ed32c7854f85eb9bc1a367a4c1f1a575a3bd2d130a948b8fb082993f2f32362bb830ec29c0bf3eb3c0e146b12de9766b52df0909ee8131afd33969b3cd8bc1a783fff2b07f39c1a9219d742a185d3ca92d8b0d7b445f374427e4a099ad4878a96d57d1f4da481abb0f07962e9f80b77658a45d2717c412917e8da32e6979a63dbf5f32d8791d2f4efab0621d753edff9e0e51619a4d4efee9a3bffc421a67abdae72b3cad68b9f296181990c64c7c9cce0027ecfc2f7a9570f406dbbb00b5c7a7237ed5b7120efa88592b90ef238215c807c3e3a73d81c64db6b424c6f42bf805828f979a80e968290e9a3ee588b0cfd3926f8357289573ebb3781cc59e51bcd8e729aa9a3700b23ef0db3389d76513fff16b765aa2b3d46335304551876e8d0eddb1371a67ff29945a6600bed42f51b89a5a7b29c0dd14f8090988941a7324b85fae3014dd1c012da27b6b2910da933cb05b5fac642dec04764c28d7c132d68c4bba80f27f43782327fe0ec30773a9d28a1327d6d8629da5acc10f767a4d2a1aecbd946ec9e8302f20cccbdf16a5f1962f6b45491f30dde2c16ff4f4bc4af5f03f453581c7550e7a1ad234ce164565b8c6c2d7b9cd4e412031f215e039e3041788e1e2185320c75ff6425cc3d189a3d9179130f4cf0219c8e90aa77973607cbc0ceb5dad3a99c5b74ce9a5b85886ab8a5f7d9bc8c772b21d002a738133657def1f6b21f77b18295abe2363263bdaf3b4eacf212a0985e90ce4db20b4a6d7219da7f114897ce91ce805092747997afb260639ed287750e30a538e68b3f1a9fa24ed8de9532455ae3b284c35f6e62f24e1f918c93c22d5d4bc340b3d95675bd58500cd19659d58b375e4eb20b5f18e7cf06e62d4b78263012c95288ac9533f83348b785cda5fbf708f09743762e94828ff27d6b4029af505e57600865fba85750efe6f60caa27bf16e7ba4cf7459a2eeb02aedcb42aab21201f4e0ad2bb09629a94f26f0aa6fdd65ec7862f73d930b8f61b29cb6363793e65d15fce40bd13c8b245f52e5dedb5c4749464c52f6fc477aae154c9c2aea485980a880153179630373b936f6863eba0d7a1a06af8a3bb02786db9520fb734604409e4a17df3fc0857cdffe2b8e41d21abd1c1bd2f1c97b0699646114635ff0aae04e26ab34e9d8033071a5ce0a416ba647617c9357ec256f3f03e2b2c633b26c72660ae2332b8dbcca41e882925a0dd1e84119247b2206207dc95301588d2a9e7a8548a713395cb000bdedb5c911c4ecc1674a6b01969443db49facddbe2a0dc5e29cfe833e1e1d03996809215e5beaf39a23aeee90411f9d257e4a0928d0d9ca6ee5d926537f53311aaf6237306f7e751abb4f6e8a92639c57556d87e668dc180a38f915eb061c208555cdd7dc8f0880d6bb601168df3e099bd5f586a5023c99686791dab0300c88b54322bbcd7b89e51f94c3f3a3b5e0f6918dc1de6023ff95a55fffa87e28939172bc2ad0c75ae44afdb6181f9530f5398d95a8f1cd93af855b945d75feb1dcc3c048b87c5ec1e95727de0ca8baacafeda6070f501f845b8c9b15e66c9ade14edaf8c4c8d63732fc29f6c8e2310a3190cf7ff4977b8fb91023c267d784c02caca5af36d8ad9e67b9efea8356e140c8e27bcb9777403e7dfa5f79098e2f768af4c7020d8ab723e1204159acea3413a2d76dc54a84a1ec6655d38f947278c4dcfe717a96a6818022c03dbaa39bb000c7fb4c712e9a7a13632d8df6459d22fa87845112db6165278121945e7e772eadeffb9d3bccbb2e2d57085cfb80ef01578d0447e959bda859cb696474fe7afd12405a34bc9c7d7caa0af6eefb0d8557b17bd1068d3f401dbb6ae2f9217d14e17d39bfcf9514526270032b9acc35a742c56832d55245384d2d4317ce068ac1ad8578550d4b258190fc8b0c19b58a1c8b2fbd595ff706c47faf84f9729af7c66aea111e920603b0c90cd8840cbf9cb8ef819f7fc749ad742d24d697e5ccd569c563ba1d1b31d90f2caf26f54fe7882da3dfb7ef13ceda3462fc2887202d61b692ae5300a52291b64c3a518400000e1f8fd336a58d134350f8ad5a8f126d2aad507234719097286d1af63d124c62c899c27c22b631c770007ef6d3b8cfda00a5571299116795db95f0c3313d9dd1fae5e7d69f52773b54ac3f39d31b1da2be612109b347cd7295fdd5a4bc2588e8f23e3466ede8ca0f207ab432ce86aebd31a290384be809ef84cf9974e670f2697d857014c5b5b6891cf994a6f1afd50f2e5596e13847c6499c61f579b5d4cdae9300489ac13af992e049d3d69ddd61191711859418aef7ae1fdd117456d6be5553523ce7e7393dfa71676761cecc2f12cb808db72acd3fd2dce7006cd35c621422f2ea83234c74534e2fe4b81ab89e52d86671bb10d9cf7134c86c6b85c722151ed58554106f3b294f416d9beec9c2c2f06930bc082f1f9018694ea2867966a4391b86b243d887f981255477251ecda4d8f38a640e9059033185f6c664395ef3aef4025b481e0802579fd296f9a866f239befddb724b3b38ad53c37a5c709ebd45e590500ce8a742baa8ae63c86821be131c70c22e96b1ca2b00dc4880ffea5dcad09e0e5e6c069d0b9b921bcf064225a658050b821f49d958dcb8b3fee765db591db99787692e5b0150b240992fea4eb4dc640261a30b74af49715f126f59902c055eee62a077bb40c6e39b8bf8cf9ebbe85e5066ff9e1a2d68693091b03b85c513907e0946547179eb36f42e727d055ecfc285aa7ca6b4b55a9a86d4401ed5426396862e834442ba293a9d16d77c906a13e95f9800ae199e824b1636730ebce7502fc7f24cd9d02984d2ca05893355420bb40abae63355b76e9c814203614a4ceb2d5f5d65542b676fcb496e90d8f2ba760575471548a0b8ff579b42159fa72d4b75273e7578c02d28dbcf61fb650e74f7187b345f9d9c2fb080cb5e51f563fe1bf4cc9d8ac5f6d4bc255d53937db34249dac72031c5c909396796002d649b8cdc3aacc1e7b02356106114641a520bee600b650354fba0ccf0b9a078efd80e9ca5c18054906e3476b1b78c399c98cb91d3e6798e3dab73304162fac28ff9806032b69ab5d032e7e9f100cda72091644fcde55e85b980c78b70d22759756cca8823e84196b0d0cd64e9bddfdbdca95e850151910fec913443e2b48282b1051e56f7fb5081c0f24956dc650a7ae9d5bae13fbf2f284905e9d406d5a020b70857c9c67a32ea0fe5ab86418e3b9acec3c458b5921a3b511d4f922bcb8296df2e276c10326537573d45bc2e02edbdecb2c7baa2d5bc17a53d480bc6f014d05cfd7379c81e4603c0d642b3157754f582fef03b9da7bf52808c290c26b8514719fc84bffb6277b22435c459c4b0821a51fcb0794309bfe2926569d31df0516599e8ec293a11c0cf2e31bca07df05f37cb1431bcdb42aff521bd68e8743ac859689f0a5cc0e1349584a1f562c50995ec8f0be9700b38fece37ddc8900650f0ff04bea92d3532fdf44286f69008200ad602597ccb912686212a8c1bf1e634571d411a7c5f351eecc71913b2a8936463a1d776591415a328cf899d87f4cadd5ff38beac08f1fc3f8d692aad8a01dc7cd406ee97181d8fe7e6109f02121995cf0293338d92b18c7935d0441777f3e0a52da090bbb3060c72933a315292a853511b916d6835e8af627bc8f7f39598f1d319f53025ee3d3febf99f3ef0e42bc040f8b106f9cdae654f50cef02d5d2ea92a0096fd004c384504afcb18a4a2223a5d7e24b4ea2578dd6eb31e135ea5f115c2745400ec594ac19702b6813a793ab3e6e5aeb160826dcb98aefe18d3c38e2448930c80688ea7c53db56cc78b916996e975e215a45924662a7337d63cc4103312173ced244e766a6b58c3f630b144993190e81f4c832e9db3070857f3490443482020930213ddd19a7e6f13f0fb926d56d1fd22ec49690f53a76af7b49993a9e4957ee4e14be4abda25d9d91b1675b9061b8d43a7c1e62d30ce6d4341167679e2232511d1c57e402095770b118bd0cb1d74eeaa755994f385e9d5c9f417184ff20253a0f949197a19dc4de2618f2a4d1267fc54c5f9ed94119dd97f12ccc93177d5660386d7305f8afd371204aca5f0ad69b0c8e4307943b3db0761894368625de5c350886c5213cfe6422d20fa4b67b2216508f72c29d1c05a9b6db6e51c9fe40a9cc93668916c09d22616d2ce3b2200d7fabbf49b6787a1729eabd5a32179fcfd38c896ff2ced700ee6f89cf3650aba5320bfd1af65ea8f2407587184ba6b5cebed7c5f50a3d72659d616025c4c893676a240cd71ca1a74ad1a25a7ac917e0ba89a40f4417839d063c9cc4c5efcb4180239c85ededb1789dafe30027188e8a6abe58e57c4208e71883bd06691b99bf3374442f77e26303ae0c82dbfe55c386c580619eb765811b8c8f84d04b968bdd79ac5cc72da9e4c6a85927107be0528ca82d2e241a529ae812b7093a4d1ee16c83c157271c58e7ce167d06ddc468a3d28fcb954af06d8c93cbc4751d78c4b43b12f895e7cbdb985b9df36862fdbe8bf5d8907edf99d52044f3bcff496e3d851dc48e4b9e3f0c8d851efa26f0ff4cd66c0cb9c9e175f799de8beec531a9bdfb0144dfe2e5fb4f2dd36fe40d1f8a87b2e2c9e1534feddfa30da6395e79e2ae549dacfff4e653fa8dd257080b00d103ca218b8e83aa2af1395b4b1950cc66e0d10cbbcaf7c7b5f9db8cde054ceffb90d381ef28f094aee5aa65f776812342c2db5fca7ed55c73d387714f0390e33e12df8fa992ff4401bc1efa45a86b960b5dab6bd5b2fad82fff9085bfa6a28a5077fbd4bc9f836d86ba09b1f009a0c460a4798c6c3701430dc4f72d9b3b2010f15d267c1a32c81b51abcbc32d99e5c0e32d1fe3316d7b4ea4b4ec195a0ecb82f9c76f621e2b998db1e27119b8b4f1368753b677ec6e4f2434c3cc2bbca0d0992e69a9c10d1c3fbf3b49f4a4681b4619230b2069c7af4b55fffbc18570a0afa25ff53e9cda757dab1a9895fdadb741904f0711e646ab2bf6c2414fce5f9e8cf285b60ca9cbe868f41eb2920e62a8c8b50aa604f4e44e1492458330d4680aaabb019f27b6856e2034ac54e27e7f2e416fd6a99c4f909ed5166fcd81095c20a0fe23713f84bfb4cef8457f9eeb471b5acada46da772407bc2b5a1a4b2023a2f15d3614febfd886193bfbac0797bcf276b3ea5374076af452</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL| MYSQL优化思路+知识点梳理</title>
      <link href="/2022/02/14/mysql-notes/"/>
      <url>/2022/02/14/mysql-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>多数来自王校长MYSQL系列<br>笔记优点：从调优角度去挖知识</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>调优为主线，进行贯穿，再引申。<br>从mysql初期设计表开始考虑调优，<strong>控制单行数据的大小</strong>。<br>不能像初学者，直接来一个varchar(255)，过于浪费空间。<br>varchar不像char定长，它首先额外存储1或2字节的长度，再存储一个变长的数据。<br>存储就不得不讲B+树。</p><p><strong>B+树是mysql索引数据的存储数据结构</strong>。<br>先以<strong>聚簇索引</strong>为例，以主键进行索引树，非叶子存储索引，叶子存储整行的数据，比如bigint类型自增，除了存储本身8字节整型，还加上一个6字节的向下指针，对于bigint类型主键，非叶子节点的每一条数据需要至少占用14字节，（tips：B-是开区间）比如，ID 1，真正的节点存储格式80 00 00 01，ID 3 为80 00 00 03，这是8字节，指针来说，是6字节。根节点是16kb的内存页，16kb*1024/14约等于1170索引数据，第二层有1170节点，每个节点有1170个ID+指针，那么，第三层就是1170^2，大概1百万叶子节点，叶子节点存储的是所有数据。<br>那么，如果1条mysql数据，没有好好规划它的大小。如果1行有16kb，那么mysql只能存储1百万条数据，就是1个内存页只有1行数据，这是非常恐怖。如果是1行1kb ，那么，1个内存页存储16行，那么，1百多万乘16，可以存储1千6百万，差不多2千万条数据。</p><p>这里，3层B+树出现一个3次IO索引。每次IO索引时间复杂度O(logn)其实就是用了二分查找，这是B+树查询快的原因之一。刚刚讲到，有一个内存页1行数据的IO，这查效率是相对慢，这就涉及到加载内存页的问题，16kb内存页加载出来，这算1次IO。首先，一层16kb内存页加载完成后，再进行二分查找，定位ID范围，然后指向二层，此时，又要加载16kb内存页，在这里边，又要定位ID范围去加载第三层，三层又要加载16kb内存页，再二分查找最终定位数据。当然，1和2层一般回缓存预热，减少查询IO。但是，如果1行16kb，查询多行，IO次数依然较大。<br>控制1行数据大小，这就是B+树的<strong>高扇出性</strong>。</p><p>为什么不用二叉树？不用hash表？B树也不怎么用？<br>B树，<strong>每一个节点都要存储数据</strong>。从根节点开始存储数据，这时候，如果1kb数据，最多15条，再加上16指针，指向16个二层节点，二层节点又16个指针，三层就大概是16的平方，369个叶子。三层B树，撑死就这么多。如果2千万条数据，那么mysql一直IO内存页，再二分查找，非常要命。<br>二叉树呢，原因一样。B树起码是个多叉树，还不如B树。<br>那HashMap呢，在不冲突情况是O(1)，而树的索引，查询是O(logn)。为什么不用hash表？<br>第一点，<strong>不支持模糊查询</strong>，也没有最左匹配原则<br>第二点，<strong>不支持范围查询</strong>，一个个离散hash，太恐怖了。<br>第三点，hash冲突不可避免。</p><p>为什么不用跳表？<br>跳表是一种链表的优化，查询O(logn)。<br>主要是mysql的存储介质是磁盘，链式结构是存放内存。<br>mysql数据是块形式，是16kb内存页，在内存页定位数据。链表是一个个node节点，节点只有1条数据，磁盘IO更多，而且磁盘无法对链表预读。<br>B+树数据分布更均匀，每一条查询速度一样，更平衡稳定。<br>跳表数据分布不均匀，查询数据经过路径长度是不一样的。</p><p>B+树有一个最左前缀原则<br>能够支持模糊查询，比如查找同姓的，王1，王2，王3直接遍历叶子内存页；<br>能够支持范围查询，比如查找ID范围，从1到100直接遍历叶子内存页；</p><p><strong>聚簇索引</strong>，是每一张表都有的主键ID<br><strong>辅助索引</strong>，是自己设的索引，每个辅助索引都有一棵叶子是索引值+主键的树  </p><p><strong>联合索引</strong>，多个字段连起来的索引，如果没有主键ID，可以是辅助索引；</p><p>如何在表里边定义索引？<br>要看字段的随机度，随机度越高，定义为索引的索引效率越高。<br>举个反例，如果存储1000万人，性别只有男女，也就是只有01两种情况，这个字段定位性太差，一下子定位到差不多500万的范围，建议不加，因为加索引优化不大，而且还会增加插入数据时的一个索引负担。<br>如果是日期，随机性很高了，怎么看离散呢，命令show index，然后看cardinality（扣低内了体）的值，接近1，说明离散越高，就适合索引。当然，这最终还是对应我们的业务 来说。</p><p>cardinality的值，多说一下，它是通过采样算法，会实时变化的。</p><p><strong>覆盖索引</strong>，它其实不是索引，它是一种效果，没有树，指查询无需回表的索引。关键在于select的字段，是否都在辅助索引的叶子中。如果是select * ，那它回经历辅助索引三层，然后聚簇索引三层<br>，这个过程就是回表，发送了6次IO，差距就上来了。</p><p>索引前缀：把文本前缀作为索引，增加长文本查询效率。</p><h3 id="Q：什么情况索引失效？"><a href="#Q：什么情况索引失效？" class="headerlink" title="Q：什么情况索引失效？"></a>Q：什么情况索引失效？</h3><p>记忆：LOL+-*/ not null  function convert join<br>Like  不匹配最左前缀的模糊查询，比如，以%开头<br>Or    不匹配最左前缀的Or，or作为condition的连接符，当前后两个条件都是索引不失效，但凡有一个不为索引就会失效。</p><p>Lian联合查询，不匹配最左前缀的and联合查询，ab联合索引，如果不以a为首部作为查询，就会索引失效。</p><p>+-*/ 条件字段加减乘除计算，索引失效，比如，age年龄-1=10，失效。</p><p>not 非不等于，!=，&lt;&gt;，is not，取反集就会失效。</p><p>null 字段is null 和 is not null，不一定失效，索引允许null，但是B+树索引不会存有bull值，比如 age is not null，可以走索引，而且还有优化器可优化。为避免失效，字段尽可能设置not null，如果需表示null，尽量设默认值，使索引完全能够构建到B+树。对于联合索引，左边不为null右侧为null，也有索引节点。</p><p>function 对字段使用内置函数，比如dateadd(propName, -1) =2022.1.28，失效。</p><p>convert 字段转换，比如：员工ID是varchar类型，查询用了 id = 12345，这就发生varchar转int，因此，要加上单引号。</p><p>join 连表看情况，如果id类型不一样，那就会失效。</p><p>我是就是我，不一样的版本不一样的我。</p><p>select * from table where A&gt;3。A是辅助索引。<br>mysql5.5，一般是全表扫描，不会用A辅助索引，三次IO。这里考虑了离散读的问题，从辅助索引三次IO，拿到所有ID，再从聚簇索引发生超过三次IO拿数据，至少6次IO，有特别离散的5个ID，就有3 + 1+5+5=11次IO。<br>它有一个阈值衡量，比如小于20w数据或小于总量一半，辅助索引失效，聚集索引进行一次三次IO之后，从叶子全表扫描。大于20W数据，利用辅助索引进行离散读。</p><p>mysql5.6+，引入<strong>MRR优化</strong>，解决离散读。立马辅助索引3次IO找ID，存入缓存后排序，再进入聚集索引。如果ID间隔不大，就进行叶子顺序扫描，如果ID间隔大，就二分查找。<br>顺序磁盘IO，比随机IO，可能提高10倍。</p><p>在计算机中，随机io的速度比顺序的io的速度慢很多，因为在一个柱面中，随机io必然会造成磁头的随机旋转，从而产生一定量的磁盘io，而顺序io则可降低到最低。</p><figure class="image-box">                <img src="6E93E449-CEDB-431F-9F78-ADB219D3FC91_20220303211957.png?v=1&type=image&token=V1:geO33iNjY-_a2JB32jzPvAkcUhKneA_8zPt3utACWRg" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>索引下推：先在辅助索引过滤掉所有能够过滤的，再一次回表。</p><h2 id="Mysql锁"><a href="#Mysql锁" class="headerlink" title="Mysql锁"></a>Mysql锁</h2><h3 id="MVCC概念"><a href="#MVCC概念" class="headerlink" title="MVCC概念"></a>MVCC概念</h3><p>一致性非锁定读，也叫多版本并发控制。<br>一句话，基于自己的回滚机制，为并发场景读的优化，为了达到读操作不需要被锁定的效果，加快mysql读取。<br>底层基于undo log回滚日志和一致性视图。<br>接下来，讲一下mysql不同隔离级别的MVCC表现。<br>从低到高分别是 read uncommitted读未提交，read committed 读已提交，repeatable read可重复读，串行化读。<br>默认是可重复读。<br>已三条线程来举例子，A，B修改线程，C读线程。</p><p>A，C同时对1条数据读写，C开启事务，A去修改，A在修改前生成一版快照，就是undo log，A修改完成，并且提交。目前又两个版本，B又对数据改，又对生成一版快照提交，此时有三个版本。<br>C线程再读，C线程访问哪部分？<br>在可重复读情况：<br>C读的是最原始版本。</p><p>在读已提交情况：<br>C读的是最新B提交的版本。</p><p>在读未提交情况：<br>A线程改，生成版本undo log 后，未提交。<br>C读的是未提交的A中间状态的数据。<br>这是无所谓版本控制了，是一种即时读取。<br>读取没有持久化的脏数据，是脏读。</p><p>在串行化情况：<br>理解为无论读写操作，都会锁表，操作是严格串行，无所谓版本控制。</p><p>读已提交，事务隔离了吗？<br>没有隔离，AB的修改，影响了C的读取，违背了事务隔离性。</p><p>那么，可重复读，C的读不会收到其他事务影响，实现事务的隔离性。</p><p>对于读未提交，没有持久化的中间状态的脏数据也能读取，这就是脏读。<br>现在我们几乎不会碰到脏读，除非，隔离级别改为读未提交。</p><p>对于读已提交，如果C一个事务中在A修改前后读取两次，发现两次读取结果不一样，这就是不可重复读。<br>如果A改为删除，C一个事务中在A删除前后的读取两次，发现第二次读不了，这就幻读。</p><p>我认为，不可重复和幻读本质相邻。</p><p>对于重复读，通过行锁解决不可重读，再配合间隙锁解决幻读。</p><p>对于串行化，用表锁，不会出现以上问题。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>一种是锁本条记录，一种是锁范围。<br>共享锁：事务共享读。<br>排他锁：限制一个事务改<br>多个事务能同时获得某一行的共享税，这叫锁兼容。<br>若事务需要获得某一行的排他锁，就要等待所有共享锁及排他锁的释放，这是锁不兼容。</p><p>InnoDB有三种行锁的算法：<br>Record Lock：普通的单个行锁，总会锁住索引记录，如果没有索引，就会锁隐式主。</p><p>Gap Lock 间隙锁，锁一个范围，不包括记录本身。<br>next-key lock：左右两边的GAP Lock + Record Lock，锁一个包括本身的范围，对于行查询都采用这种方式。</p><p>InnoDB的[next-key lock]本身的设计方案就是左开右闭的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c2 = 10 for update;</span><br></pre></td></tr></table></figure><p>next-key lock则锁定的是 c2=10 这条记录本身，以及其[索引节点]上 c2=10 前面的那个gap。</p><p>但在RR隔离级别中，为了避免发生幻读，需要把所有可能插入 c2=10 这个值的位置都加上锁，所以对 c2 =10 后面的gap也会加锁。</p><p>当查询的索引含有唯一标识属时，Next key Lock 会降级为Record Lock，仅锁本身。</p><p>索引上的等值查询，未命中，所在的Net-Key Lock，退化为GAP Lock 。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p> 从插入场景开始讲，<br> mysql 插入会 记录持久化日志redolog，如果mysql非常高并发插入，会有什么性能瓶颈？<br> 首先，面临最大的性能瓶颈，就是ID自增长。ID不重复，就是数据安全，说明有锁，就涉及到block阻塞。<br> 5.1.22之前，所有插入有个auto increase locking，它是一个轻量级锁，innodb提供了是自增长计数器，它是保证计数器线程安全。插入sql提交前进行锁的释放，他不需要等事务提交后才锁释放，这算提高mysql性能：事务提交涉及到mysql持久化的问题，一旦持久化，就要消耗磁盘写入的时间，如果提交后才释放，就是要等待加上持久化时间。5.1.22之后，把id子增长，调整为三种模式。一种是原始的轻量级锁，二是默认策略，分两种情况：如果已知插入数据数量，比如10条，采用了更轻量的互斥量，如果自增长计数器是0，可知最终是10，只需要把1-10分配给10条数据，中间无需block阻塞。对于未知的插入数量，则采用原始的一插入一block的方式；三是无论如何都用互斥量，这会导致ID不连续，将威胁到mysql主从同步问题，不同节点ID不一样了。如果不考虑主从同步，可以用。</p><p>主从同步，有两个策略 ：一是rbr，row形式，记录每一行最后更变样子的语句，二是sbr，statement形式。如果用statement，会记录插入语句，那么在从服务器，执行未知插入数量的语句，互斥量形式插入，ID不连续，可能ID不一致。</p><p>在持久化redo log之前，会存入redobuff log 一个缓冲型日志，在commit时才会fsync磁盘刷新，flush同步到磁盘，然后最终到磁盘。</p><p>问题来了，1000万条每一commit一次造成刷盘，有性能问题，也会影响磁盘寿命。这个盘刷其实做了3种策略：一是每次提交刷盘，redo log立即刷盘，这是最好的，二是每一秒定期刷盘，是master thread的线程在做，相当于1000万条只有一次刷盘，有一定延迟，可能存在数据丢失；<br>三是从不刷新（交给os刷新），一时间内没有redo log，宕机就无法恢复。</p><p>redo log 记录的是内存页的实际数据，bin log 只是语句层面的数据，它不是用于恢复逻辑。</p><p>我们最好是在代码层面，将多条数据变成同一条语句进行插入，一次性提交。如果数据过大，可以分批batch每2000条插入。这样commit的量小，性能提升可达10倍以上，因为盘刷有性能瓶颈，磁盘1秒撑不住1千次刷。</p><p>binlog，用于主从数据同步，包括pit同步。</p><p>undo log，有两个功能，一个是回滚，有个undo段，理解为有几个阶段的回滚快照，以实现MVCC。</p><p>总结<br>MVCC结合undo来说，以及不同事物级别的表现，提到redo log，结合mysql插入性能，就要联系ID自增和提交刷盘。</p><hr><h2 id="其他的问题"><a href="#其他的问题" class="headerlink" title="其他的问题"></a>其他的问题</h2><h3 id="Q：执行计划？"><a href="#Q：执行计划？" class="headerlink" title="Q：执行计划？"></a>Q：执行计划？</h3><p>我们一一来介绍,并说明每个属性有哪些可选值,以及每个可选值的意思。</p><ul><li><p>id: 表示查询中select操作表的顺序,按顺序从大到依次执行</p></li><li><p>select_type :<br>该表示选择的类型,常见可选值有: SIMPLE(简单的), PRIMARY(最外层) ，SUBQUERY(子查询中的第一个select查询)</p></li><li><p>type :<br>该属性表示访问类型,有很多种访问类型。<br>最常见的其中包括以下几种: ALL(全表扫描), index(索引扫描),range(范围扫描),ref (非唯一索引扫描),eq_ref(唯一索引扫描,),(const)常数引用, 访问速度依次由慢到快。</p><p>其中 : range(范围)常见与 between and …, 大于 and 小于这种情况。<br>提示 : 慢SQL是否走索引,走了什么索引,也就可以通过该属性查看了。</p></li><li><p>table :<br>表示输出行数据所在表</p></li><li><p>possible_keys :<br>顾名思义,该属性给出了,该查询语句,可能走的索引,(如某些字段上索引的名字)这里提供的只是参考,而不是实际走的索引,也就导致会有possible_Keys不为null,key为空的现象。</p></li><li><p>key : 显示MySQL实际使用的索引,其中就包括主键索引(PRIMARY),或者自建索引的名字。</p></li><li><p>key_len : 表示索引所使用的字节数，</p></li><li><p>ref :<br>连接匹配条件,如果走主键索引的话,该值为: const, 全表扫描的话,为null值</p></li><li><p>rows :<br>扫描行数,也就是说，需要扫描多少行,采能获取目标行数,一般情况下会大于返回行数。通常情况下,rows越小,效率越高, 大部分SQL优化，都是在减少这个值的大小。</p><p>注意: 理想情况下扫描的行数与实际返回行数理论上是一致的,但这种情况及其少,如关联查询,扫描的行数就会比返回行数大大增加)</p></li><li><p>Extra 这个属性非常重要,该属性中包括执行SQL时的真实情况信息,如上面所属,使用到的是”using where”，表示使用where筛选得到的值,常用的有: “Using temporary”: 使用临时表 “using filesort”: 使用文件排序</p></li></ul><p>Q：为什么要做主从同步？</p><ol><li>读写分离，使数据库能支撑更大的并发。</li><li>在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。</li><li>数据备份，保证数据的安全。</li></ol><p>Q: 用过processlist吗？<br>show processlist 或 show full processlist 可以查看当前 MySQL 是否有压力，正在运行的 sql，有没有慢 SQL 正在执行。</p><p>Q: 讲一下MySQL架构？<br>MySQL主要分为 Server 层和存储引擎层：<br> <strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都 在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模 块。<br> <strong>存储引擎</strong>： 主要负责数据的存储和读取。 server 层通过api与存储引擎进行通信。<br> Server 层基本组件<br> <strong>连接器</strong>：<br>当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。<br> <strong>查询缓存</strong>:<br> 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。<br> <strong>分析器</strong>:<br> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先 看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。<br> <strong>优化器</strong>：<br>   优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成 执行计划。<br>  <strong>执行器</strong>：<br>   首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限， 就会根据执行计划去调用引擎的接口，返回结果。</p><h3 id="Q：大表怎么优化？"><a href="#Q：大表怎么优化？" class="headerlink" title="Q：大表怎么优化？"></a>Q：大表怎么优化？</h3><p> 某个表有近千万数据，查询比较慢，如何优化？<br> 当MySQL单表记录数过大时，数据库的性能会明显下降，一些常见的优化措施如下： <strong>限定数据的范围</strong>。比如：用户在查询历史信息的时候，可以控制在一个月的时间范围内； <strong>读写分离</strong>： 经典的数据库拆分方案，主库负责写，从库负责读； 通过分库分表的方式进行优化，主要有<strong>垂直拆分</strong>和<strong>水平拆分</strong>。</p><h3 id="Q-一条语句的执行过程？"><a href="#Q-一条语句的执行过程？" class="headerlink" title="Q:一条语句的执行过程？"></a><strong>Q:一条语句的执行过程？</strong></h3><p><strong>查询语句：</strong></p><ul><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p><p><code>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是</code> <code>18`</code>。`</p><p><code>b.先找出学生中年龄</code> <code>18</code> <code>岁的学生，然后再查询姓名为“张三”的学生。</code></p><p>那么优化器根据自己的优化[算法]进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li><li><p>更新语句执行过程</p></li><li><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、redo log(prepare 状态)、binlog、redo log(commit状态)</p><p>更新语句：</p><p>update user set name=’大彬’where id = 1;</p><ol><li>先查询到 id 为1的记录，有缓存会使用缓存</li><li>拿到查询结果，将 name 更新为 大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ol></li></ul><h3 id="Q-：重做日志刷新到磁盘的策略有几种，有什么优劣？"><a href="#Q-：重做日志刷新到磁盘的策略有几种，有什么优劣？" class="headerlink" title="Q ：重做日志刷新到磁盘的策略有几种，有什么优劣？"></a>Q ：重做日志刷新到磁盘的策略有几种，有什么优劣？</h3><p>innodb_flush_log_at_trx_commit用来控制重做日志刷新到磁盘的策略。 n 该参数的默认值为1，表示事务提交时必须调用一次fsync操作。还可以设置该参数的值为0和2。 n 0表示事务提交时不进行写入重做日志操作，这个操作仅在master thread中完成，而在master thread中每1秒会进行 一次重做日志文件的fsync操作。 n 2表示事务提交时将重做日志写入重做日志文件，但仅写入文件系统的缓存中，不进行fsync操作。在这个设置下， 当MySQL数据库发生宕机而操作系统不发生宕机时，并不会导致事务的丢失。而当操作系统宕机时，重启数据库后 会丢失未从文件系统缓存刷新到重做日志文件那部分事务</p><p>举例： 插入50万条数。正确方法：innodb_flush_log_at_trx_commit = 1，将50万条数据在一个事务或者多个事务中分派提交，减少fsync次 数</p><p>一般是双1策略，innodb_flush_log_at_trx_commit = 1；sync_binlog = 1。</p><p>write+fsync 直接刷盘，write不直接刷盘，只写到os cache当中。</p><h3 id="Q：purge-操作有什么作用-MySQL-篇-delete和update操作可能并不直接删除原有的数据。"><a href="#Q：purge-操作有什么作用-MySQL-篇-delete和update操作可能并不直接删除原有的数据。" class="headerlink" title="Q：purge 操作有什么作用 MySQL 篇 delete和update操作可能并不直接删除原有的数据。"></a>Q：purge 操作有什么作用 MySQL 篇 delete和update操作可能并不直接删除原有的数据。</h3><p>delete和update操作可能并不直接删除原有的数据。</p><p>例如， DELETE FROM t WHERE a=1; 表t上列a有聚集索引，列b上有辅助索引。对于上述的delete操作，仅是将主键列等于1的记录delete flag设 置为1，记录并没有被删除，即记录还是存在于B+树中。其次，对辅助索引上a等于1，b等于1的记录同样 没有做任何处理。而真正删除这行记录的操作其实被“延时”了，最终在purge操作中完成。 purge用于最终完成delete和update操作。这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事 务提交时立即进行处理。这时其他事物可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。 而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真 正的delete操作。可见，purge操作是清理之前的delete和update操作，将上述操作“最终”完成。而实际执行 的操作为delete操作，清理之前行记录的版本。</p><h3 id="Q：说说主从复制的工作原理"><a href="#Q：说说主从复制的工作原理" class="headerlink" title="Q：说说主从复制的工作原理"></a>Q：说说主从复制的工作原理</h3><p>1）主服务器（master）把数据更改记录到二进制日志（binlog）中。</p><p> 2）从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p><p> 3）从服务器重做中继日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性</p><p>复制的工作原理并不复杂，其 实就是一个完全备份加上二进 制日志备份的还原。不同的是 这个二进制日志的还原操作基 本上实时在进行中。这里特别 需要注意的是，复制不是完全 实时地进行同步，而是异步实 时。这中间存在主从服务器之 间的执行延时，如果主服务器 的压力很大，则可能导致主从 服务器延时较大。</p><p>从服务器有2个线程，一个是I/O线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是SQL 线程，复制执行中继日志。</p><h3 id="Q：主从复制bin-log-日志有几种记录方式"><a href="#Q：主从复制bin-log-日志有几种记录方式" class="headerlink" title="Q：主从复制bin log 日志有几种记录方式"></a>Q：主从复制bin log 日志有几种记录方式</h3><p>变更操作将根据选定的格式类型写入 binlog 文 件，目前支持三种 format：</p><p> statement-based Replication（SBR） ：master将SQL statements语句写入binlog，slave 也将 statements 复制到本地执行；简单 而言，就是在 master 上执行的 SQL 变更语句，也同样在 slaves 上执行。SBR 模式是 MySQL 最早支持的类型，也是 Replication 默 认类型。</p><p>row-based Replication（RBR）： master将每行数据的变更信息写入binlog，每条 binlog 信息表示一行（row）数据的变更内容， 对于 slaves 而言将会复制 binlog 信息，然后单条或者批量执行变更操作；</p><p> mix-format Replication：混合模式，在这种模式下，master将根据根据存储引擎、变更操作类型等，从SBR、RBR中来选择更合 适的日志格式，默认为 SBR；具体选择那种格式，这取决于变更操作发生的存储引擎、statement 的类型以及特征，优先选择 “数 据一致性” 最好的方式（RBR），然后才兼顾性能，比如 statement 中含有 “不确定性” 方法或者批量变更，那么将选择 RBR 方式， 其他的将选择 SBR 以减少 binlog 的大小。我们建议使用 mix 方式。</p><p>SBR 和 RBR 都有各自的优缺点，对于大部分用而言，mix 方式在兼顾数据完整性和性能方面是最佳的选择</p><h3 id="Q：-主从复制有几种方式？"><a href="#Q：-主从复制有几种方式？" class="headerlink" title="Q： 主从复制有几种方式？"></a>Q： 主从复制有几种方式？</h3><p>异步复制</p><p>MySQL 默认的复制策 略，Master 处理事务过 程中，将其写入 Binlog 就会通知 Dump thread 线程处理，然后完成事 务的提交，不会关心是 否成功发送到任意一个 slave 中。</p><p>半同步复制</p><p>Master处理事务过程中，提交完事务后，必须 等至少一个 Slave 将收到的 binlog 写入 relay log 返回 ack 才能继续执行处理用户的事务。</p><p>增强半同步复制</p><p>强半同步和半同步不同是，等待 ACK 时 间不同 rpl_semi_sync_master_wait_point = AFTER_SYNC（唯一区别） 半同步的问题是因为等待 ACK 的点是 Commit 之后，此时 Master 已经完成数据 变更，用户已经可以看到最新数据，当 Binlog 还未同步到 Slave 时，发生主从切 换，那么此时从库是没有这个最新数据的， 用户又看到老数据。 增强半同步将等待 ACK 的点放在提交 Commit 之前，此时数据还未被提交，外 界看不到数据变更，此时如果发送主从切 换，新库依然还是老数据，不存在数据不 一致的问题。</p><h3 id="Q：Innodb-和-mylsam-存储引擎的区别"><a href="#Q：Innodb-和-mylsam-存储引擎的区别" class="headerlink" title="Q：Innodb 和 mylsam 存储引擎的区别"></a>Q：Innodb 和 mylsam 存储引擎的区别</h3><ol><li><p>是否支持行级锁 : MyISAM 只有表级锁 (table-level locking)，而 InnoDB 支持行级锁 (rowlevel locking) 和表级锁 , 默认为行级锁。</p></li><li><p>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性 , 其执 行速度比 InnoDB 类型更快，但是不提供事务支持。但是 InnoDB 提供事务支持事务，外部 键等高级数据库功能。具有事务 (commit)、回滚 (rollback) 和崩溃修复能力 (crash recovery capabilities) 的事务安全 (transaction-safe (ACID compliant)) 型表。</p></li><li>是否支持外键： MyISAM 不支持，而 InnoDB 支持。</li><li>是否支持 MVCC：仅 InnoDB 支持。应对高并发事务 , MVCC 比单纯的加锁更高效 ;MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作 ;MVCC 可以使用乐观 (optimistic) 锁和悲观 (pessimistic) 锁来实现 ; 各数据库中 MVCC 实现并不统一</li></ol><p>来源：河北王校长</p><h3 id="手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前-哪些是update语句执行之后做的，哪些是commit语句执行之后做的"><a href="#手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前-哪些是update语句执行之后做的，哪些是commit语句执行之后做的" class="headerlink" title="手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前 哪些是update语句执行之后做的，哪些是commit语句执行之后做的?"></a><strong>手动用begin开启事务，然后执行update语句，再然后执行commit语句，那上面的update更新流程之前 哪些是update语句执行之后做的，哪些是commit语句执行之后做的?</strong></h3><blockquote><p>事实上，redo log在内存中有一个<code>redo log buffer</code>,binlog 也有一个<code>binlog cache</code>.所以在手动开启的事务中，你执行sql语句，其实是写到<code>redo log buffer</code>和<code>binlog cache</code>中去的(肯定不可能是直接写磁盘日志，一个是性能差一个是回滚的时候不可能去回滚磁盘日志吧)，然后当你执行commit的时候，首先要将redo log的提交状态由prepare改为commit状态，然后就要把<code>binlog cache</code>刷新到binlog日志(可能也只是flush到操作系统的page cache，这个就看你的mysql配置)，<code>redo log buffer</code>刷新到redo log 日志(刷新时机也是可以配置的一共有三种)。 如果你回滚的话，就只用把<code>binlog cache</code>和<code>redo log buffer</code>中的数据清除就行了。</p></blockquote><h3 id="在update过程中，mysql突然宕机，会发生什么情况"><a href="#在update过程中，mysql突然宕机，会发生什么情况" class="headerlink" title="在update过程中，mysql突然宕机，会发生什么情况?"></a>在update过程中，mysql突然宕机，会发生什么情况?</h3><ol><li>如果redolog写入了，处于prepare状态，binlog还没写入，那么宕机重启后，redolog中的这个事务就直接回滚了。</li><li>如果redolog写入了，binlog也写入了，但redolog还没有更新为commit状态，那么宕机重启以后，mysql会去检查对应事务在binlog中是否完整。如果是，就提交事务；如果不是，就回滚事务。 (redolog处于prepare状态，binlog完整启动时就提交事务，为啥要这么设计? 主要是因为binlog写入了，那么就会被从库或者用这个binlog恢复出来的库使用，为了数据一致性就采用了这个策略)，redo log和binlog是通过xid这个字段关联起来的。</li></ol><p>作者：暂停丶算不算放弃<br>链接：<a href="https://www.nowcoder.com/discuss/810539?source_id=profile_create_nctrack&amp;channel=-1" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/810539?source_id=profile_create_nctrack&amp;channel=-1</a><br>来源：牛客网</p><h3 id="大事务有什么问题？如何排查定位大事务？使用事务时，哪些需要注意来避免大事务？"><a href="#大事务有什么问题？如何排查定位大事务？使用事务时，哪些需要注意来避免大事务？" class="headerlink" title="大事务有什么问题？如何排查定位大事务？使用事务时，哪些需要注意来避免大事务？"></a>大事务有什么问题？如何排查定位大事务？使用事务时，哪些需要注意来避免大事务？</h3><p>并发下，DB连接池容易被撑爆；锁定太多的数据，造成大量的阻塞和锁超时<br>执行时间长，容易造成主从延迟；undo log膨胀，回滚所需要的时间比较长。这是大事务的影响。</p><p>排查是取binlog，用shell脚本去获取和筛选event的事务信息，即可找到大事务</p><p>事务使用时，避免一次处理太多数据，避免不必要的查询，还有， 在事务里做避免阻塞操作，比如第三方http，rpc调用，mq发送，尽量放到事务之外。</p><h3 id="Innodb体系结构"><a href="#Innodb体系结构" class="headerlink" title="Innodb体系结构"></a>Innodb体系结构</h3><figure class="image-box">                <img src="20220517225901.png" alt title class>                <p></p>            </figure><p>Buffer Pool<br>缓冲池，简称BP。BP以Page页为单位，默认大小16K，BP的底层采用链表数据结构管理Page。在InnoDB访问表记录和索引时会在Page页中缓存，以后使用可以减少磁盘IO操作，提升效率。</p><p>Page管理机制，Page根据状态可以分为三种类型：<br>  free page ： 空闲page，未被使用<br>  clean page：被使用page，数据没有被修改过<br>  dirty page：脏页，被使用page，数据被修改过，页中数据和磁盘的数据产生了不一致</p><p>针对上述三种page类型，InnoDB通过三种链表结构来维护和管理：<br>  free list ：表示空闲缓冲区，管理free page<br>  flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间排序。脏页即存在于flush链表，也在LRU链表中，但是两种互不影响，LRU链表负责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。<br>  lru list：表示正在使用的缓冲区，管理clean page和dirty page，缓冲区以midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后面的链表称为old列表区，存放使用较少数据，占37%。<br>  改进型LRU算法维护</p><p>普通LRU：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰。</p><p>改性LRU：链表分为new和old两个部分，加入元素时并不是从表头插入，而是从中间midpoint位置插入，如果数据很快被访问，那么page就会向new列表头部移动，如果数据没有被访问，会逐步向old尾部移动，等待淘汰。</p><p>每当有新的page数据读取到buffer pool时，InnoDb引擎会判断是否有空闲页，是否足够，如果有就将free page从free list列表删除，放入到lru list中。没有空闲页，就会根据LRU算法淘汰lru list默认的页，将内存空间释放分配给新的页。</p><p>Buffer Pool配置参数</p><p>建议：将innodb_buffer_pool_size设置为总内存大小的60%-80%，innodb_buffer_pool_instances可以设置为多个，这样可以避免缓存争夺。</p><p>Change Buffer<br>Change Buffer：写缓冲区，简称CB。在进行DML操作时，如果BP没有其相应的Page数据，并不会立刻将磁盘页加载到缓冲池，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并恢复到BP中。</p><p>ChangeBuffer占用BufferPool空间，默认占25%，最大允许占50%，可以根据读写业务量来进行调整。参数innodb_change_buffer_max_size; 【命令set global innodb_change_buffer_max_size=30;】</p><p>当更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。如果该记录在BufferPool不存在（没有命中），会直接在ChangeBuffer进行一次内存操作，不用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进性磁盘读取，然后再从ChangeBuffer中读取信息合并，最终载入BufferPool中。</p><p>写缓冲区，仅适用于非唯一普通索引页，为什么？</p><p>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。会直接将记录查询到BufferPool中，然后在缓冲池修改，不会在ChangeBuffer操作。</p><p>Adaptive Hash Index<br>Adaptive Hash Index：自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。</p><p>Log Buffer<br>Log Buffer：日志缓冲区，用来保存要写入磁盘上log文件（Redo/Undo）的数据，日志缓冲区的内容定期刷新到磁盘log文件中。日志缓冲区满时会自动将其刷新到磁盘，当遇到BLOB或多行更新的大事务操作时，增加日志缓冲区可以节省磁盘I/O。【innodb_log_buffer_size 默认大小为8M】</p><p>LogBuffer主要是用于记录InnoDB引擎日志，在DML操作时会产生Redo和Undo日志。LogBuffer空间满了，会自动写入磁盘。可以通过将innodb_log_buffer_size参数调大，减少磁盘IO频率。</p><p>innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1。</p><p>2、InnoDB磁盘结构</p><p>表空间（Tablespaces）<br>用于存储表结构和数据。表空间又分为系统表空间、独立表空间、通用表空间、临时表空间、Undo表空间等多种类型；</p><p>系统表空间（The System Tablespace）<br>包含InnoDB数据字典，Doublewrite Buffer，Change Buffer，Undo Logs的存储区域。系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的。</p><p>独立表空间（File-Per-Table Tablespaces）<br>默认开启，独立表空间是一个单表表空间，该表创建于自己的数据文件中，而非创建于系统表空间中。当innodb_file_per_table选项开启时，表将被创建于独立表空间中。否则，innodb将被创建于系统表空间中。每个表文件表空间由一个.ibd数据文件代表，该文件默认被创建于数据库目录中。表空间的表文件支持动态（dynamic）和压缩（commpressed）行格式。【默认是存储在独立表空间中的】</p><p>通用表空间（General Tablespaces）<br>通用表空间为通过create tablespace语法创建的共享表空间。通用表空间可以创建于mysql数据目录外的其他表空间，其可以容纳多张表，且其支持所有的行格式。</p><p>撤销表空间（Undo Tablespaces）<br>撤销表空间由一个或多个包含Undo日志文件组成。在MySQL 5.7版本之前Undo占用的是System Tablespace共享区，从5.7开始将Undo从System Tablespace分离了出来。</p><p>临时表空间（Temporary Tablespaces）<br>分为session temporary tablespaces 和global temporary tablespace两种。1存储的是用户创建的临时表和磁盘内部的临时表。2储存用户临时表的回滚段（rollback segments ）。mysql服务器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。</p><p>数据字典（InnoDB Data Dictionary）<br>InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数据。元数据物理上位于InnoDB系统表空间中。由于历史原因，数据字典元数据在一定程度上与InnoDB表元数据文件（.frm文件）中存储的信息重叠。</p><p>双写缓冲区（Doublewrite Buffer）<br>位于系统表空间，是一个存储区域。在BufferPage的page页刷新到磁盘真正的位置前，会先将数据存在Doublewrite 缓冲区。如果在page页写入过程中出现操作系统、存储子系统或mysqld进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite 缓冲区中找到页面的一个好备份。在大多数默认情况下启用双写缓冲区，要禁用Doublewrite 缓冲区，可以将innodb_doublewrite设置为0。使用Doublewrite 缓冲区时建议将innodb_flush_method设置为O_DIRECT。出现不能修改的配置文件时，直接在my.ini配置文件中进行修改。</p><p>重做日志（Redo Log）<br>重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。当出现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须redo，重新把数据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重做日志在磁盘上由两个名为ib_logfile0和ib_logfile1的文件物理表示。</p><p>撤销日志（Undo Logs）<br>撤消日志是在事务开始之前保存的被修改数据的备份，用于例外情况时回滚事务。撤消日志属于逻辑日志，根据每行记录进行记录。撤消日志存在于系统表空间、撤消表空间和临时表空间中。</p><h3 id="数据丢失。那么，有什么解决方法避免数据损坏？"><a href="#数据丢失。那么，有什么解决方法避免数据损坏？" class="headerlink" title="数据丢失。那么，有什么解决方法避免数据损坏？"></a>数据丢失。那么，有什么解决方法避免数据损坏？</h3><p>InnoDB 的页和操作系统的页大小不一致，InnoDB 页大小一般为 16K，操作系统页大小为 4K，InnoDB 的页写入到磁盘时，一个页需要分 4 次写。<br>如果正在写入页的数据到磁盘时发生了宕机，可能出现页只写了一部分的情况，比如只写了 4K，就宕机了，这种情况叫做部分写失效（partial page write），可能会导致数据丢失。那么，有什么解决方法避免数据损坏？</p><p>redo log 是物理+逻辑日志。物理日志部分，可以不依赖内存页进行恢复，逻辑日志部分，需要借助内存页进行恢复，比如插入数据，需要借助原来的内存页的page header行记录进行加一操作，如果原来的内存页损坏，则无法恢复。一句话，就是这个页失效，想只依靠redolog 恢复，是不可行的。</p><p>redo log日志在commit的时候已经完成了，数据脏页的持久化还需要定期执行。</p><p>数据页，也就是我们的b+树的叶子，会存储在buffer pool内存上。修改数据时，先查buffer pool内存，如果有对应数据，直接在更新在内存；如果没有在内存，则两种可能，一个是从磁盘IO拉取，再更新内存；另一个是进一步的优化，直接更新在change buffer内存，没有IO，等下一次用时才IO查出来完成合并。更新数据都在内存中，内存与磁盘不一致的页，就是脏页，会定期持久化到磁盘。</p><p>change buffer 以前叫insert buffer，对插入数据缓存，现在扩展为不仅是插入，增删改都有。但是，不是所有增删改适用，要求是非唯一索引的增删改，也就是说为数据量多的增删改操作服务。</p><p>答案：<br>数据恢复一般确实是靠redo log，对于数据页失效问题，是在持久化时已经避免，具体是，数据页先持久化到磁盘中的double write buffer 作为一个副本，再真正持久化到磁盘的独立表空间优化。这就是数据<strong>双写</strong>，保证数据在磁盘有一份完整的副本，以便恢复。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> mysql </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经 | 结合业务，步步深入，P8架构师二面摘录笔记</title>
      <link href="/2022/02/12/p8-interview-skills-2/"/>
      <url>/2022/02/12/p8-interview-skills-2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f4ce51d7fd5dbf75079380cf761638a4f3e1e0f5d38365cb6ffea3601fa4783d">4c4fd9e09482e311844f0584b2bdee0d55a93e30a00b4effa04e9e685df4b31426810d76a72c2de6b4babe10a143b2785b79067589b77f685c77ffbc5c0eb1ef0ebd6d8c84565551fb918f7aba3cc4437f9eea6d095fc1d6352d52f7af9a2fb3f6ae4bcc743b44762dbe8c9692c8e50931730dc38fa454a2f77549cb97a5726ba374dd9ac4d56a32df87b52d7cd5ebc06b15273128160875f6231d5922a1d85944a81ed8ff19ef719d1b5a4e096b98a85456b10520a194da2fb3dcc16b5f83ffe206a50d75713002ef293c9fae3fc306bba41a20972a4174508f37bb8f5a9617aa2da39c1a953c17b0a6bfcd5b03664d28709e5ad03d44b424f44a12bf945dbc97baf393a914ce9ff2d9f993a26b30c54da56b8b0fe8de673fd08b9f0d2772a6fa7c956eeda3ec5e1479c6e771985e5c85c54d4cdf70813ebdb12d71c802bc150b4048c1049b9df9cf30fff5ef583ff091f1ce5d6341952758c4c8e5661c4c23f866258ef8c51ea77088d6ddd173875ea15af627e81b2ebcdf09f44d1eab02a4ec20fd9bac5d3cd84bcb8ee55d1875b0069da7350a5884e9ef8dc6771ab421eb22d24caf0ad83ede945df38f9b2eea9ea0e3833ec90ef2f7d9b44e28c200203f2b5b5704416ccdc1f851911f4799f5e0af8ccf7fa4683c642634323cdb6a6b31fad4dd986ac4d67a5dded47ff7f049b319ea8cb4fbf41d8ac27c45dd56b436ecc01bc95137d63cdb021abeafc00df220fa60142c33e337f292a06d854be24173cf5f46a64f2cc0b1837076b4fc70a7b9f5a43cbeeb1aed41b2a897c5c6f4694a33c35ef8bea898f2c26d0564971a9858b57e88f08f1bb2798f48c120fd6fa44868c964b4343d6f0c8dfdb4500afd6823e3bb5df1734bcecd2dbdbaa03dcf168271666150a58efd58e3702617a94f5b1cfcbdea16b937a7586a0ee1835fc6a1e574ede9d14658a105761bc5f48b1fcbf91b6d0c348d090ef108620ad8aa0d80f86d3044aec1d8b59369c100725a5a06f35d8cf62de523c2003abc6b6dffd8691de80a5bba297cfa78e544c491b74ff0e5fc948a8f6106b6afa8a177a0978065c7fb72a9e9c66ec449989269197cd7cd4cb2f4e2b8e91612c50aa4ad24bb3e49e5a4d85273d3199ddc1ada7d7c27285296e7a61575c9fa7c2620eb9e4f52e617dddce6bc5da2f76ed9ae5cfd8aa80a39070e7874f8ad2607327a0566ccd221f72be10005e4df5554987e4c819afb5f9713ccc6fdfde6aca4dd0afde9f711fc29a98c9782c2cf18e76c5e19397c8cf80521c4cb3772d7903f20a7504a07bd766c0d9bc191fe81574f21fa603c8fe72d8e1ae117d4ccab92ae9bcefcb4123ea83174bfc72c5547bb069609c1f8b8b9abb2de934c954033642727e83e86b2c3c5c46e38e2996613d71eff8b639c0dd6f6aa3fc312e36b4737300078f8d50f374bc4cc695175443629a57b3c5c68bbf66ba8ec41635bcf1ba1a5839cd80338fad5a74ddd386ac3ad9cb14c11c765cfde6ee510147a476ee524fe1e1c45692be67e8839a37c8f50fc66112041d2503e8fc00c2b228c2181d821f624379dabafa890d2d14ae59b25efc215268ba11046d8a28b77c055b0a8d6ea3df7c10225894520be33518bb601e662688f78ea2ebe39aca6bd1055e09dc1ce60cfc3c01836f3e1890253ab2a6eb5d95e79eb364c9c202530de9a9065eedf0c593f90cd4228715d8f5bb72aba03d744fc8bbe4683f0ec00898be581f08bd2688512ccd8689d6f8712eba0063052669eaf84adf6164e707ac30c6b857e2d6e03fa09ed0d7ded866d7ef7addb379f730cd859e0356dc654e6ce7676769bccd977c5840d14ab8550b9e477f096e30c07d4f3edbafa530d9b1b551966ab4d826fd904c8f73252ffa49b11f889116af6354e786ec11e04c1b522a4dae4a8b97fe4bc323adf3e3e5f4d4f4bafd02278a29e38281682636c89f8dea6eab3ef126bfdc7d3972e284fad3b835929c4e889b7b4cdd6b8c2d04d6cc2d4211c8fd81741f0c15e3a9e183ce5a617d1f2048bcfae38645b80ac855f3d084b067a73499b4956abec147161e3628a98a6b5b222ede4f5ec203b8328b6e7e5d5d281f134daca41f3c26681305959aa476229d852f41ba8bc3a5f5fef2dbcab1b47739a01ab8fa1f7c3b4f581b6f7ea16ccc12b8dde8bae4b9b345dfea0e87e0fe55fb565cec5705138599c025481d88915831e45f073eecca1de0db2f7942d1eb384742e92a952e61a1b75d29da1b25479e9319d7da3d9d71ed691000d112c5b41a3db11cd2834651fa5c3fcaad22b1a3ca0e144ccd044baa76f850d028de1c9726d09826f1f988fba293d481ef735e5748ce890097a84acd4ba96f32a9a3c95bc541ea1edba6bd72825e859f9115344a55f1ff2f80b9e36d21221d6caf8ea518d8831f02ba480d8da7dc02634e7a67951aa88592e1f60536f4441dc100d8821eb9b8388f39414bff141d74b2ae62c621278dbb1a792c90c6dd35a75c2c0b8c1085ba83adfbd4e7986d4aa6fffb23ecd03fdba7c60fa60bf0361cc15ed03c7e6da880215602628914580d92b2f02792bc946aa107a71ad21ad50c782e492c2fecfcca27cb0b1b017aa9fb5335d523230508dd53fa19cb0f14a6d22228c6f9ef949eee5dcdd7cb5cc3d9b3b2bf60f7a105098d49c2a31baf3fac6ee31bcbecd0558686bbb7f8d69b795f4b9df9431163e8aa61a4b79e5ab496edf143bc0e867b6e9620b6fd9a28e73e1f2f3ee85b573e320190730ee092b31c6a4cd875e67798150394c1404eb38072bafd447a65e4243475dd1fe7255219bee871a2bef5dbe45d5ec9d248228fb7b9f2ca67f4563299f0b4b57d310fba9b53d3fa45f60aafc8976053af11f921737d73ae7e8ff2369ccfec90c918e713d959806d88f952cca6bb06e0592a0c2a6574dc06880c026d467ca6c3e9bb761a3f508c7e9580a40b8e59e40c57711e3421a200cc80d0211a641929abce731c1ab054658654a4eb61493a5f15ceba560a94098d9c0451a3ae6322c53480e0104b08a09b5bf1c16cd9f7ba8a6fdbb8c101dc6ff5e0c280eed34713cca2f2e12ccc1b600891254400e8647a5bbd00f91fbb69f25035a86f887c58d5bbace60ba7d7224e9143ea40b49f01c7fdf327978c9d7a51c46b2886ceb35a197ee78b28742ccb9bbba0888aa93b1be456976d3b87223eeaf5ead0c9d4d44c60ae3fe8897779de7d65f1afd59dc011380a7d627ec6470f814988afdf23308b440584be1cac8202b484e6bcf2ffcf4c2ae7f3b22e8da16dc035ee6afb4ef2b26e77025be0a61c14cd61d3931e78b72ba460c438e68d66312075d57aae871d9bd0c7481f849cdc75157175dd819d39b6feef76addfbdfe2a2cfc908f44c6b409f88caea38f0bb1099e617e32667aaddc10a38297b34b5e282bcb21675f4a88ba023a01ca2556374b343c829ac6ad2aaefa49c0e7a9a8a8def8abc2f23ff94b5ade6556aa11bb200937a6beb749b6d29bda227751c8da01c6dbc68c1e6b6ab3988e6cc2b75f00f3797fdfa0f05584d0fac21835bb3268cd195e2cff1a954924df543483bd3903c680b7cb08b541fd45125583b9fc876b20d722978b9d86614bfd53047d159456eb7c49ce359af1c47ee772f3a627a8c16433a45f8fc74affd10ec1f103a7f20d6df8c873105ef240e6beee6a79362fc1e1d30fe8268e3cd2862705b3a5304d74d0f2c711cba8e84a78dc80431727a5c47e4eb2d70d1099dbc928f02ba0551175025d74d4ca969459fb96e51ad970360bd28a1fe1224b22106b482bb0d8bb50934d36587110ab4eb1614d74ce245e7ac567ee519e201ea5934dae439a06b81eecd47ecdb54b89ccb26f0c59dcd39078dac46d645a499cc3ca46344c5ee70b8ccfd28382c15c46ab8b403dfb4675685ebe8b1ce397e35cfb706126a0d5999ea8151589646b7793390cda7422ff654744a590284170ff8a2bb27ed47d2c3804f78fc4e45d9602b0de712613ad730fb80d964597fc5a0ddbd1e9bcd3006b3dfc5463138710e8395ed65f7b0f76bf45e73e38d70811141f125236fcf943abd77a05a3567f13dd8305082155bef4de1dd5edb8b98576b382178ebe24b95e292b44b316b7755c563fa14f29583c201b119cc7b989bfd34f23cdf86c6ad4204948abb08b4ca86906d51a755c89ef47da3343a332e10d5fdba93629a954dc278b9b32509b001f446119004139f29206827b3dbd49deb4e6fd36648ddba309875b60e16d7f9300113068e4d999865010565d20edf735e4e755cafd623f542fda51a6ab2934c846a779446a81848c273611061b2ae92d62031c2e08166d8b1eb2c774462cee435926c7eb9003dc11401175f5f03688fa6c4b3daf1f658d42d73a5bc31c8338f7963fdf1ca6b2af31319894513f60d2d612eda1106ca76511cb8fba8eaebafd453721a19c060cd8d0cd322b2dba842f15b200cb911fd2435f2b50a93e2a0a95a66353c524eafc0f97ceedeb8a87e74b85d822026cd3dd2e8c7a479d66f0f6d74bfa1e1f4895c5a1b16c69fd8cce3d60399c6322ae7051913696500d1002c9173c28d9945298c6330b4120d312060b7090325ba047c9458881895e83b071912f16ed8766880161bd13de0ecbcca2f0b2c75e72b3aa02aefab3f17f8beaa027d058fdbf61fdefa1f7fb1d94db31f68bad4100a6be1d585b9f590688feac82d829bf7ebfd5e61e98469bbbc683d2ada70fbc4eb8465c1732b3fee51380b01640a0ed6dbeaa84609ac907028b0033b44a17338da5c3468e006c712754ee6281935a44ed9655ebdd21f1692fdcaab2e3c61339338a4b03cfd6719e343106593fbf54119b02cbb050a9e5199d0b83a05e170581def835dc3f10a98072b3732d576ea3a22dac5613f58e66ad74b8f5be386be107aed5dd38ec9ee296da8d404cf7737373f8795ceb295176fad59416d8bfc545eac29b97e2f2bbda7194f3096ea1fdd6c1969f47115b5b0f50882a6f8fe93b7c771e59f907f159be64b3873c3b867b2560b4dda69eda7c05b2290cb5094ad87cc5c9b01a8759374f805eaa6b7b8a3542339a19c145d509ec4199bf97ab931b5dedd1827b133aa92648351ab31fcee45b99fa762daa489b309b93a5e271d39e0e00861c28a41574cf86eb01f54214e308237440ac9801ca62bcebda87122d3037432a981715df8d8d3fc154a3eae85ef7dc7c3127b02707fcde2285555ae50c0c0813b73ad210a6c94c80d9ed54249fb2249e0a8a3f1fe018597a20d6b5ba0a1feb7fd45a1236e8d6c498a0a7f2b640ce27b52f7f431c5fde6210882297f79bd819218e5df1fff462716ec8cb5d02b3328b3aa25967cd5d76b2728c0fe45375f9bd3f9f89b523fdc25fb7ab03aca5bd763c369f64020c71ea20e94f73b7ea80071e7ac0893dea5edc45e232f0266781e3525cd2a0205102b70e537418672beca3d6ddaf29ba4dd395a04d17d7ee54464efa9fab75a3b7e27d299756ea35270dfd8fa267222500a342c2103453ab0fc7b1462b3cf84a0bc8e95adc42bd94c9629ce6b0aeda88151f3adf85f84c70156b7a8396c923854de1889d5ac6f93eba345a80758d7b9a99ff9d653e3f041576a0b880f5a63db12d4b9e723f77ece85a6023366f7b48567f018e1e0c4ad8e9d1b01b63f6674b661e39c60e0a0fdbd7a380a2418806a7671b4e8eb650aa88f69eb0028d635c6c9e36a9db9ab473ed829796ab9ebcf6233b8293a4130f4cc634cd59bcd65e8d72ecf0c025744379a00b8871cca4d908e903c648f2b633588980914f288f71332c5d97c6d276e6fe02aebf220023218c33169b58fc395be24f290379e463e429dc8fada9484ac9c6b963f1c5ccf70f5629b406d5c2a89234d020861edca623293127c5ecc5707a6433e069039b973987dde7a4776605fa87a4f2a3a4b2e00948246f7e1ea149ff5d6eb5b3de90800110c446d1b06c03d5ef65c9dc7e1ab55d694801b60c18104c1fb7f9d7cbed02447659ed40a70a4e3761186e988c977eaf5edce0fd69f07d5302a1d94e3a82b552faa731f6456f3eabec6dead7c35e1f12658c3b2af2070126317bfce534e20fa989cc0fb98f28b67ba426b4d8e4314c5977c33e943883499697e52504115ed33fedd91b2956f6e2aeab85cc9e2cfba8b8acf3b22cb4f8fd842c140b5b2a201f6c980d71c332cbd4e82fb5b84e841890a669626bff0dc0b43eccbc769f55f92e57d7902fb987f18629614cd5b92b414e3e74263fb27f281f760c5811fa915d623db18420c070fddbeb785edf0863906ea56676f867f431f466fb3fcc54c636f568f73c2b23f5bebe6294381cbdf54b81cec3667e1643e6512cf9dffa290e37f4b7549f32241d6d1e2a78d39e19108e07a4e2bae2ae60deff44e11dc1757f78aed2bfc9a68a56b71901ff7131dc345febe2b857deb8dcd3db5a375fa7572689cddeb8ed244c5ef089d7329a125d61021891a2fbaed8c08279a9774e418907e7a639c31550ee61c61dd044ddf43d4e6add8e14ac40b37e7eb6a81c43f934eb1172402ec2fa5f5792630f9c3553dbaed9ac04c0e2cbc6bee0eb286e97e15c71b6f81e9e3b7efbef18753979fac3416c6588ae49567a347469b4628072ac08b6b1227900cf110565ac2f47e578a0e2a41ed27ffb1919f04396ce0e13a72270263c7d75f38f88cc35a2066a950eecfa0cbe3efb9cebc64734aa083bec0edaa55a57806a7b47f6db412df81d84d1dfe8b69f169b0b02c7e06fe05366d9a7c30966c32afb20e441ba7742249194ecd4103496544add27902a76a1ba60d61c22ab84cb2c72b5a7d7674771ad05aa977edd99e0a11cf2b350fafe6a33ac27c8ecabb4df51f25de7929de4a863412be0750a41219d7f173cd15cac330afe00b7dfb4d059a18d5b1576862d115f1e97910cb357445667cc9e0e4d31f3d4135820b1f07c9908e56160dee58817fa366ad7daa677e6b067dd01231b8638f0510b80bf61c402f209f70650bc025821bb9b74948afe07a27491061a68e5328a727cf69ce57c6c57753ae59f8e6cee1003b2dcd3a458dffd65785a40c71708f5dc64680148bfe779b4ab971875a3cd1d3a33eff018bca7b3584641d6ec998f0fe2449d1bc50c3424767d41b1994ed9739ed34de9a654dbfab71266f28c6ea9cd8069bc5e198665885ae686b9bfa4502ce98f4e4dfba7350acbd3d05c22124f5f996ead4fce01abfc07f21ac1d14b4592712a0059025bac29f049d817b048ad1e0eb0f1e56125812eee4d7f0c22f573b33323ac53653fc1d06174a761d6b5ed4948828d215e0d7c4e505ea44c486b7caf17e377b72282f6ac7f8a67cc43077d634165d1df24f53adcdaf84e7342aa9dea32cf9bb8370c641fe08f3a883a1e8b134ccb29ff22913d11865fdb704c9b3735090cf1bb2611e4462e447de5f369365a197b6b460cf2e9d0f366f28005747f59c124012458b8d6913b8effc66a4634691f4d3415ee1f3f925d2b57992243302e23e0c37dbbea1e826c6ca8b6ff489f4833328e76d1892fd319b8fe7ae884b3981e35ccd156f25a8b66df4bacd337c7a9fdde3d71b8b43df0e25fe5246a406dbb07ef355634996f7c0ddd21967fffd40712b9116084365b1b344d3091c204ad58775effb3614a155f023ec1081602fb22b72eea6c45e10ca8f184b03261f8ce48a2060b529693634caa1dd3771e3bbff6e674f98cce59f09aaf635aa9d07978d491d1df144c49ab0290d6206a998672ec1082927a99932eb3dfd1af5eab2d0464484f988ea743a557014c6fcbe6a66206f236bd52ab5add70c761681da22e533437b5483648b10ca51a6059a9e1deb3373e4384080775e92bad6b49aff29781eb9bfb37c5c2395329dd32fe79f11f78ded7ce55698d8a45cf4e995a72971e942ddeda442d06d315d373881cdb3e6f842d3b8594dd88d26964b0f6ecdc0df4d69d946555be2de536f88dececccba179e21fe040d6c33c60b7ebea1befa38a3b01f8bb316c6b4b594411c39f8c9da14718cbe89dc724e301b148ac06ae569cb649ad8fa2d2f72b9d3084c2c8299211691b42c92bc969170f8fd1281a5b092c57bdac4f0c6f449f426c2efe300568a514387e530644bae667c77ad6202a7d494b2705b1b84ed9f1dc511d7387e71288897ea3dcb0a1dd6310c55f0c5ae76031d72266ba1cec3d7943bb8aa46ce2c213a1862ee77b9965f8b94f34566ef5a89d9010f322f4ed13b4e8ae6c65036585580bd0db41beec2c01482f0f3b9c53473c2e1774580d6d8f6f58e45615e12e49d558eb0b140305d298351a5af5aa70f6d533dcece1a14c945d4bdb5a34a0e9c7ec304f0016ce66986575ba6f26c0f2cd0e09d813bdd987ea7d7bef712d26f2aa10b72f19c0cb2db0485e1ac6c7256f65bc0b23a6ddeb5a6c156d6d0d4cc4a3a4f754525854446ee8c625f2aa2eb49ed0e424f894d6dfee83e6fdf6aa58ed2d1e03f86728c1915559bf41313035b4a28154aaffba11c0268f45ba33376021a74f6448cca72c2afcc2b2b2e824c4ccd5e51911352af343a44f48a7f92e938295eaedeef74e3029b3d5d3026a5f63b4aa5b75e72412fa2b007f749c8b12d8bc1e81bf23984c16a4d3a03286807d514526135021a125cc56b1312db1a629ad6a726ee49fb657e7bcf70b87f134f8af5bbc9fe858472fe7a18095fd77e11e13358fbc6f5b458a5041a83ca586aa0d2b453834f5b4c871356f80ea0772ab3aef07f515ec04ee75a3ca8ebf6fcaf4a3baa17ffd04ae329eb83d7f4268a8765026118841c893a1b185cdbcb222cb16ecbd528e47d775c086a949db9670754bb5e253dd98e355acf7cffd78c95ed130aba798ebcaebe548662e8717f0a3b1cb49c1170120e7bbda86f2c6a930d0baff9996834c07a0fc4f05acfced2988a00e7ba72aecbd9ad23913e7f1a9dca020609546c66c9e0b1b9404d0a06d27297b159300ab050ddf0798f6ecd6caba47a40b00346c9c722034e05f2bc8e052c44a242332fd81ff39501183962c6c9fda850edaac14ab5c3f42ee81d15f835968026614587e5bc39e91666fbfe4da79d772462e3fec6e9dc2d867cd432da45c8c57361556dbb3a87b34bfcbd68cb4416e8183dcc5622128fff9236202743ab6eea1fb57304093512876c8591641f1676a734eaf32a54d1829d85779e108cc2869438a72230a7a428dc1173eccf58566b720f3161ace2f61490191f1a9e4a5b2b9b33cbbeb6d68f05121575ffe0be0179c1a81206bda0557380e5a775bf7d03c7382d91ebcd5dedde33a2ea54ac89323f8ebacad756d01e3f7e5af5789583807efe94e5caeffe60143d6ea2b3e65511fed4522d8941f618a6be6adb6f207f8ebbddc641d1da9b48011fed525a4c6494fb6f07747d29eb9f1168425e9662576fd2c8e84f411ffc4ebbcc384947f6aba96fb10e847be5e0cdbb235cb0bc241f8707af64967e884b66214b9a3b6e53fba6a7a99335afb81b280f3e0fd7874507c4f4c072455c5cea39b7d5cf465e71d78f8636e96773662d9c8db3e750ec1b082a73a25d6623369e0f288c16fce98704e794f8100abe420da7c83f45cf0921da0bcf7e903ce2756dc09cc1f041af3ec79e5ce29722a8bca352f6a16c7b0e995af9260e50e4a4d261f0ee65ce918551df0cb1b93ec1387534a88c502ffd34242030a0c162c75a05efa01f8d4826bf058ff7d4e0d1ed2c2008c15409b9d16ab42760444ee7d52849639c447460b2367241e8b3fe76bf861e00f7001a22d90ac25fe0272c06ed6f564e623dad936d87f7fe7eea42f92d13978a43cb50b0633097ea76112bbc2750d0ee09709401f82f1123d6ee98ac8df323d01cd80a73758c9a67b2d9bde4dc03ae4e1dcafc68ad0523e134cdd141bf1b57b8ce800a979bcf540448719c56944a395f5eb8bddf0237b4a9b490df511f87d05171698a173c9a708e7ac1c475f1607b6ac47d08803448776c14bca9ecafafa951f966f62d93eb301cb279dae93a58613241ffec1ab79bfd565ed6b240da8f4d2a6c73b964b3d0e60757f354080442216548ecaaf12d44157528b254db84e9ee66544244d13c4f847b9350eadecba54c378769165ddceb49f0cb55f4cd06834efb896612a843d34bf0eb56c442659984e0e0a7adc9f3e0bf994bfb11229526116c00371656e484223ce049b2fe16b673d3248f249b48282878815a837b742aea1c607ec1a5d8f2fa09a2cd414cc1775029c05b3ef9d4d7d3e819dcc9f4f355f9a8c6ead8222a3305cd5239a26c401ce98989f4f0892b46922ea7ed13ab4502d2e1f9c678bdfc91a3c1289fe478077c6a82817497b64b4e919ceafae5326745125639797fd9c7e012bbcd8905f64717bc872525e48b35bed86848156cd3e11f0d2e74653f4b5beac5b679c89046a116d316ec94a8ccaf77ad237dddee8ae5f76f929ccd0ff012d7520fe8c2a638a4ccb0bc6649276df453d7d3cdc67a6064aed7d4db28129c9d51b5df7424eca6f3880ab33a9d323958a72db47325cd09fd7c8606df808b758d898136d13beabb49c18319d8357e22434f42440d2b489c3c50fa4bd981a0223e8f838e61f63f7fd34425886dc22cf7a980bffd9970f205a25c7c44b48591e90f015b26c2278455b21131ca5d405c3a88d54750f40df17b328c08bbee11bec02216ed02c8b7de0c91a1050b1468c57a00e7082afae80cde17e0b9729b3026ceea18b10c542f1c8260858c7c504d581a8b1d8a1233ab00a3b7f9328dc665aa150bf1070cbff0b90d9efe1b75e0ce4b308e35e4bf218fc78c3256ff26f70417a75af3977023f4e993a47b0fe7625c006907dcd325d6aad96c9f491a6e31d33fa97636b5558c2d9d42c63ee9ac23a34fbb2984f8b97eb074738ac0e1b89b3e44972ba62a752e1d90657453c3a725d5a8a9e60e20e6780aad43f64207d05c54a4ca23a018557c3d2cf5c8f057ceb0cd95f33994c077b8bb1cf01b6aa8b38980df8ba2cfd0f8d85e3cb11ee8467933bdda751fd7369d280e0a1f09b09ad2fc9faa3091b7060d1b0e397984aca148014b9162881ec3ae69b8b9a45482bc4f3a73f866bf8fb268936bb0f2d9a695650f7a9e77a75b20e3c80c38842395750049b7b84ea55c44038cc56541d56e7add48c6e54be0f5542d1a6799154a176af817bc880a615406d6f015f0859e79e50578d3a728e10257685cfba6d5758678f84f8ac560290bc0e054f72bfd10910c695a2e9e23ff3d75a667d85fa35cbc440ff2a2b327145a694eb4fcad209b986464cf0f624e56f825dcaf07a3b817c0b4cad31d0f1b9fed9ecc423ecffca0888307af8e54cf2ae3a33096b417bd03a51db8ee64cb1261dc4cb295a37f7ef1c90044d1794dd96a369944fed5872b7f6a22164a88ff5881e99eb46e638ff113c7332db8b5edc599c7106b3b92f5934d3605a7538a29849af2c9a99cf2cf2dfa1cad2d4e2c725e534f6f32845070a89bdcbd61fa3078dc3e5c61a40f891dec598d9e400ec31bf53a80d0b6324c8ac11aacd543667403fb6aa2a4e37942950a42acf85eb6ae4372344957570a105290029c94a53b07bd92d1693456a2e2c4bdbc30aa0bcb8e1fcd868c5bd7f2f4f0fb9efa462916f0e17ba8132b80ff183db08f2616c2a1a3652c55e7a0b38d274ed2559494f0603fae100e3eeea3dad2b4a2517a1d0b090b3daf3b47fb8fffe5cf5665b2eceb32399b192b4440eb9166855368f6cc74b6fc5e1c9db38464f46f5bedab6ea1ca33d6193ca0ddb1cab5753c7eb1c30eb672debd5682417ce31c70a3443eff841c172ee7d7146e8d8bd36bf82bb6f66ab86de30a723a1a42fff5684dfb64c1ae0534e8503d61e45fb98ef41662f7615d25657cbfdadbf76b40453af2156bb0d7ef424d2eeed70f0f8c55f033cd59ef26cd297ac782d9bdc3e60504d41eb96fcc007d55d9fb364bdc7d489bdf83946605623cfdb812df8738092752ff505a8e378667817a150aeee2cc6819d1662693ab794d3fc001e73cd487422796b0522a01cc99a17213112664f5c85e172f5d91829112254376b1d6193fffd42380edea27597621a8694d6d255a808ff405a44ba6d864c1d99cd45c749844aa29b9d96609776bea921934830bcc1e6e44b9e8f0b3ba240a50f6cbcc68b071789da7d9f2f6c6e03f4c93767fc54d5b0d0b04681ff79fd02f4490d6fbd44d1debc3045cbeaae4fb687f629af2f27622aea9227ded25ee677ac2cc12b1f3069cdb8cb1e064f464ea78de41ef2873615e168bbb3ff2e6c8a4c194905151e0c80dbf2cb2e831925f9e4a71ee9a4d24c75d70e1e502c76a7fe0bd9277803c9414b3c71489ffcc1ca1823a53680f574d4016dce2a759325492ca5cdc72c82cb6242ef654d102e8ba4a0a6947ad8d3fda91dc849127ae8541476a8a3e52162d5520400677ffc12729364b60961197933eececb94317fc19695a7b9f6b10f740c8d337ec6ecbee63e5a6619f071c57f701fa7178adc8aa2d93d788812a39d6e0362e372645d63f85389d756708f849290158bc9502c995958c7206894d27b75eeb374980071409feccc7ccd8abcd773146906d03754cf7cddfbc319e32eb7f341f4d453d8c98ed0ca4e502ea4716bd4d0d51db7e16101a98c155baeea8e43527097a8f279df997e0ab9f10eb124fe80e1e929ad6e0ad10e3dc4b4394ea7e41061f0a5a4197073572a31f65216c317410c579b80116227cefef3f7b691624b492a9c5199951f9688d713ead60111978808c947dea93d9ac2bba328f4ef73908a5cf089d2cafe79ca5717df60321e849914304d6e8bb577326e5f0ad14f10174268313c92ff6221989a444b10d526a1b2cdf6110b5ca1020a095cb3c1c7d0af434261a4434151e1bdfb7e6d334120a5625df1e75d644295bbbb8af1f292d9231b066bff800219146cd192b45c77af62be6bcdc093f08f190e6688b018d556a3a5cab29a496d3ea22ce46cdec50a43aa8f51e09b865c6e02e2ada1cf123a0c5608f46b2d2c2a0a7d2ba3b4201d666542eece96c324cb40fcacbeef0faf0473d5db83f0272b83eb15fd8e4b979cb272becb58ae5d118c86b483cb0da3df9c18209a0194408285abc5efbe7b91164d0e04bb76554879bb77efb208821c846f1ecf1fd480b0f682bca25083b36da67b8b6f5802f493985677c8ebf07041f317e217b6d405159fd2df71bc99e6401fc8ab26500a28c65491de86ba6f33e73e395c837caec119fe738bcdd227ac40265b48eea63f84cd05adb77450c9887d216d76072448dd8b405465f3c70552f73f0ad67e2555f83d5d721df8e18cf891ccb25ea1883c83441dd21b1d29b925507daade874854df439c3446998edfa5deebd9d4b1751c3dcb05d23acbbc242649476326af4de2793277cea40733122bb4f638471612c5ab3dc961fc635138e8159ebffbc79bf30e09c7d2a80ad0d81d3476a70df267fede018defc7631437d39ddc59c1c0d8c6bfa4e024773f82cf9baad669cf39fad9f5c47320b30805b51fd85cdaaff9c5fe1e40ef7dcd8337d8fcc76963ef7d68f13ccdcacf215a5df6bb18768867d252f17f374de35124404811c8bf68b19786a618dceaf07be252f1772a85aa1a8047dd4efa93cfdda8602b2473d9439159d077f5561976094f72980a0492b39d155c8880ae791824e7dcbc6d2cb5fdb77f97789080d6811d6ce6b443877f0b66d90e70a67467dd1b2e97531fed2112dab16c407adc179e1e557b241b4f3885f8e135c37fcc1242600766bc92cfc270d146925d3fce4c9735f85ddbbd0c43d1d6b15fcb2f4a329ce981844937e532ddcade40b305967cb08240275a557827eab435f9ed49eae18584caa7d557434615828b68f549fa44c0fbb863177de809a274cc9cd72ad2c8b00f1521bb5a740d9e7dc12488127128cc646d29e5f062df478ff1c1eeb4ac5ccafb349547b53169fe8da446e5a1f2289d7d653f4a93ca9046f010655549311326c4129943274b463d40d0b0535c01e00f24b1a59014ab97a1f5d00c8a893b98d749223d07f73fcfdb6b0b6115ac708a5cccd1d8d1d0c3621d94ec0d7baf2e30e25aff17a51a427bcfa770bb76ee594732e503fce83b79c184d6ff3377435c9b73d2479c8ee24460370427f535cdf63497b6f9be7c6d0d1974de4f562cd0ab93f79e05f495a005d71260e2f5cffa875de33c80352db4e898a7dbc8b28ab8ea3c01728575755a82d905571760edb5367787f484c0036ff67a95e654894b9cf5d7a4b3c7c5fa1d7133e0ff86882408630dcacfcbab6b084c7308b99a41a73c25f3d5b66840c958f8de4b4248af65c900c251e23868b9ccc7878a857f9368e714efd50dd07276b65275491126e5c3154b1c5b465c91c2db038716c6b5d4c06109c1274dc89e0807be5808e278d270ce2a7b5b959bdf7d905b81786aa7eace71b26d11dee6b76976373f8e8c443a4eb943c8b6ef472319046ec0ac08928da2b970d554ad6a06039c3f05a343764472a842c1058060ae292a2aee4a5cb6950d553e95f241dc342cf30855de6323bc6b0a58024d87c3b92bdeb69a0832cfcdb2b18a7791917805482f67c2ff8c9b2fffe8f25b4eaa3323559c4c037226afdbcc4807fe52a73e8fbb7e4bfc50e3e958a6997952f46b0b0deb154b1f03b18c6a7887cea3596015407f5d5aea6ff5a03d167b67e3d742f901febae94081072f281fca5ca3d95ec091c3142dd3b018b0bc29e6cc5cc61845e0a6e47f92dbf2209086add3d8994970ad5ed2882981a45c1f49401bbfcd27f341f74f55fd64a3bb9a79113a9bbb22e047cb4b6be9a8c295b49bc6c975360fd9b3486162f0891d477fbc9c150753c1da23044d9899dde9571681a5b501b37b8dd834be98188e4e0acd7670ce7ddbfd988e3e8f01eadc7ba623994768953685b2486382f296b8a7217fb181b0380f764a81f3d3eb3f91080019ca1edde9ff5b18a69b7a7991f46b14ff5722424a6fa2cde11d1c08f7ee61b88a414feb77f2bf3c2a16a2cb77296fb9921d5c10116ea2144163c0fdcd5d6c9294749939b109c02aa8212cec6197b4503c6420147e2738ce49c090b9bb0bc557f1a06b75964996ef2f93e29c3fdb872cfeeff6800479b5b4682b9d06e8619d2a74b85e1543766222fbb7bbdd00bfd5296b14e26cf8000bbe7bae879dbefcf83489179304c383a8142ec63e8873e8144a8cb7673854a672d1f4fe94847a928ca0d74a38cab968ae6dc86c596ebf16a17a94b52bffe183d7694513e55ccba1e40442e1ed6465905ae4b62465f7f273c4fa233eb50dc7a46ae3154a15f78bba080b1978d3801faebb4497993df3b4bf3df2ac07e8f17fb4219d33526ad96705e94fb728ace079acade6c96937b1c727ea51bca6f314492a978d5f16f19ca724bb7fe6002a55dbf57c3657d0ff3a2623b514a43473385f682b8bdbb3d8afb3dbdcf2cad03442efe7fcc8e5da6e0bfdebdaac2dd3029ae643c694b261edf3cf748a8e83054051243420917261cda53a2eb0aad06259271a6338187814185c33ebd2a75d027db50091572db47c06c121c5566127d3ff14c5d3196824c44f1d4711e50c05ed8652fc72e0b18045aea5d4e9e4bb36050913ba44742889faf49915359484ad930d5c95d9b0056bc9f671a9ba0c1f84382327a1b2f68427e217e1feac5b088d66449502bb47198b6d377858323638222f1f1a0b0db25ca86c6142b3bcc0cd24763f10bcee0acce60304a4ecdea58e180fba7053b23e7df751b6b1e1556a6b4de2d7eef0cc6860278e273594ac851e59ac3cadba559c2f802b39cba31793a2af86d20519cd69af27997bd0cde9367af4396e207db66da346bdf18b8b655ea075b182c03c2c1a686bad3288d1b9bb80ae9830f1fa1520233a93879f164f79071b6b973fb86a63a33a8f4b7f7bf380a43516dcfdb4976c0796fc387451e5a93b8453946cd4cc377c0e9abbcc057c8af26e9e110cc1fb706c136f979d5697ac57f4e57de697524ef932ba01f6f42f5376d743d86aa0175a1ee954e6474ad878e16f3b3c20ef202f7e49079b527729b9002807ae7d665973197dcc6b652ccccdc6a59d755ad9cd23e33443a78310cb9363335f1af35ac6fe3dc62e0b049776c29e960c45d25f2185cba81ef19687ed635492faebb049d50b8e2787771521f25c157e23d876d850ec64adcba236460b2f4b42adcca8713e8bcca46ee3b6a27203676c2c179caae2b95686a212e8a602d89cdc470616bd1a3b9adb0f3d61e230614c6739853846c9b350f2c49afcd3a4003f2708350536723a7a1b1585d7145066fbc85994affe35a43f3c53b151eb162160e7ac4e1bcdef23c65d7223197aa84544a4cb6c4be98621a98d636e9e4223f13efceb084c23f4f88bc9c114f4fefc6fd4a113712a731ccbdb5623fe3cb0db3f568dceffd7e87fed8b49bff4c24eeb4b5dc006ab6d5fbfb809dab7c690e62b93eb4f39504d8be55060878f0569c4b4316b0118d54fc38cbe3bf77aa2b67fa22a55b2d0c59791e07fb1c405d3516a857392bfe339640d2f2bb12aeaf6270f333e324af01ce762f19d8280af00b174fa19f48429d012a64c16cc7b568251f951adb9548b7700d151b51df2cc5543605e3e6c37f6cb24356b24d4ed9f4a237b1481ee545e9633b800623df79770fbb2d8776c3eaf13cdc6bace0cde3b349dcb48b346d71f4003c9b07caf78648d58e4dcce4e44da8d1af8baacabeb81786b8b893c3c8c7f819fc02e009debd50bd172b1b5ebaff412d5724065f2ce6b93960b1191f212d7955aed3c852c9adf11cc59ce3647e90745e32b9c66cf066948c5b0c4a2eccdc972265d6ff672bb4f12354ed40b17c08997e925b758ca7f386b395986ec79e6ca1010d1f1c9c351ba659336d003c6858918444c0e14b3793753f5b0fe12e719133bd96b792a9a3b90da8453eb77cfbd82f4a97a4f8f817650345159f2e540057d0a043e8776a492466e12ce331b209b3a1efb5ab784c731c9225aa77a6c20cd36b4691372b9006af5db6e663672ea08141f011a484c9117429842533d685f0364e5abdfdeb504903e2e191fe8ccea94e01507e71f650c0f8c202e2bfd251c6d8ae25b8d16d7aa719dfa363f4f3d7bbd61594dfe275912de9f1de18773c2f33e57e64aeda9b2e876e13fdf29ce255ecd49ed35534914c9055dfc832bbed0cce9349968c8b7263154a5d586befea5ab7db935c8752626d82a7dab403c95ef6e731cd2ad883d3dc11c6ef7e0c611834bf81b970f2e1267e8d875ba52e7649e6421285ebdffad4ec9260d8e9f71bab7b853334df02af3dcf10837377fbd20840f4d8ce9abcf3b5416b46300f8cacdbc20f4c960cb6cdd779ab8a7778c5dc7d98bc6bcbdf8dc5b9d1ca84e7be3c4b6813c9d93b12b6ab0b84992e09a2eb52047f99be88b99388c0b6255a61e3d8496c645c4eb63f36f9f1eb399c734e29acf4ed53affe31801c167acd9c1c3284a5f2ce12c36c15cbd328b7fcff027a63e6cd149b98f2896d025634e52a49342b6439f99f4da8452162ea5e84cfc5c5371d847e6304f707575f6de0febe841f6b9e1e3f3620657a6c6dd6bd977064fd8b4725e564e5b60e1218c26e61eae3fd045a29db552579abf5c214883a59f8c091dc0c372ccf8f26255742e9b5b28e5c2a9ee9c01be238fcf39259b91d9d5750c7deb0f6f848f2447aece6b3d99300692b59308b2d8368c54abd4ce449740b9e83c65879620de90e84b8c20f7ec8c7214f6c2486107a44152cba9af8b5b8c836eddcf3d162f4cc6e6b7f7de7f745366f957e000dc691b4ea55e6f3d8bf75e74ffd55b643fe1c223e6f4d2647080e3bee5c77664f908ae8fd91043daea4b3cf5d534448b8a37c4b0e41c73f017c0a334194dacf1140ae366f246a8abc9d6743726139d5a08099574ab311c015c55e69e6a642e6ecc46d1b0b59df076af91e8599f18153caab7f30c81655af4ac0a1fcafd8926c42516c8f655c9145c732fe3fa2691abc4f6445a2ba07f9f7b90d8cba42cd8f80a8d7ab1b918283c39349d92dd3926b03c3dc2cb96234e9c9de314a49864b0cb8317908249832eb6612ccb1f2f8604bf97e523c11bd60340b3a779d32a6c06668a3cef24e11c1e1965f5d2cb7157128ff1a1db64b1d997b850c39e5c3db373c1aaaeae8eac2267a9a2d44291785cfa754d24f67301b11939dff7ae6b0005d2d60adf9142f7272b4919aaa78061a6b21572d0f1e315f1f5f9b1e62eb79d608a59ee996642e77a0686dd3f3acad3034d437b8e2ea3241ce4d08a66e443608c952a714374be02cbbec82fc8ec6a93a0cf767f2bb47b0495e6dfb18964518cfd7080f6c4e5149a14b673832d9959705016a4ac293aa960906119bf064e606b69b56b977765452b7c0f7154f94e783e2f3e68a390add5c4cf109e6aa45261919a0de11467d5bee5e6ae8a8d7b51fa6f1609fb4eb7811b63b10291d05aab25c21bada3d36d28934ed50d83a494c1203ca24596881380bd5c252e1fc0d0a10ca4056333700e50642b1423435ae2cc2ff5a700150a29d60d01bc737afa626bb11f16c87d12222e491825b0b37acf98000609345ad3c450f088c7c1df61a972a68b02ec1fd4115c5f938c57de3e1a1944dc4fa4e721202c13e4b09fed1d88e3db19ce6d2f897f28e04e3be5f77c4fabeae6403ad589c28ec3376cd4c188fa5ad03b6030100f14ec32d59baca764edc171d7caca2bd50996d17dbb6bb12b9bfd98e6162cde0da1f5eeb479b7dec0b7443b307f034571341b644b5e9708ac9b50694cd07920b9d481d0f34a4b12268ba8d0aa23868652a742bdab97d769a001139a0099c93e43dfd34b0330f4c4a3c5959e6014d6a92f92e4a5f56dd032c7bf715e1d7c692a9c414e1e02291de5fb0f0fe2e2ebfc85fdea4a9e339821f5e4869478c94eb6dbedb45e052a92b9ee5ffaa39790886ed34fdfd486c7bd37cd790bd93f9cdb1da54512dcf4361d7c9dd06f213d00808bf93b7d8fa47a6a0e0ee8ee800cfa7276485a881f54cb77c45e0e8910e711f2d692ce1c1296144334de19a859f62e530ed6c29ac735a0201e4bd167964b2dcbc80cbf22ded03a0a741d0dbaa0bb9b77cac61a54ed526acec62e1f1ed1d3586acd211333251a1848dbe93400d4dd6eccb3c30b4a56f4bfe83ac54b083e81437db1338e41329dd797ba48eb4f9397428e0b689f805280c3ba6eb52be3d9f703c858889b6b97b3304a11e203e989133b06c823dd3358eb58fba53954cb2b921c110654294c2c8096167284f0f1e959c034ea15578d0da2cfa4ea28b09e9a09d721e3c3252853d9ea64c85be022967f63f33235c22b54787fb37d39374a31f616a685554945569b71b7be8d1ac61d43712edc965792ae77319747876058692d6ae072d6d1dda5903aa69dc23b5b5f1e462459b93e5637d31dd10c01ee41436dfdfeba07488c239508259811d9f8cd54d1b77ddd4bba98e026f7e6dc9fb5277f4aeed59ec053dc656806b842b6308b03c09586c58f572ea51b74c159679e585add83c28e40de395c892cfffd0e5a285a6f7312c8abb488df956cf9dbc8779d66ea7ac39d466267c6fc2e327c73fec5948ba91a49442360d91a1c46ddb2ab0cd40407a63d6e20d9068a6031d63313c55f040a4393dbbe0e0bc2f87aca0906b5bcb581a0319898fa49ed9c2e475872ad106b1adc02edd1fd1d0f477d62fdb77a98be14d03e525fec605ddb74f41ff5bd94f68bf7eb1bda9c2f09db3275f3ee0a146481ec2cc738eedd4685f73f90bf602d3143be30b9e58aacb55c2241e8275b72a50e28e02603a29980e285cbc0a514c3e1c1c129e3d4e6c38c1c8db79daf678aabd2a848339564d4d46fee8429bae9f91b1375c8a61d75c8bfba1fdb2c88bb351c7664e76d82f2e4818594f610e11e67c776d59a972aa4d8ecbaa3c28f4ad8735c25d84fccd84ffbc15c4a7ce2b307ad960dc85bd8894079569403cdbdb06c51f5432b6494a947767367818032c4b4f6638a8a734ece45dc74be15c0b1208480f5f78d8330fc3ca50e7493567543f675865eee0ee858543e89bd69097da8e9b5ad166dedc45d6b11f4cc6f287d2f2fa3f443ec0cc74cdf02a9ce9ddbc49081b9ea5182dab182468257ffb7476cf006a10f973309617eeb6d94ca37168c255b525dba88acc070fa36d1de705605783d5b3af06a6e9a997e38cc6c9d09a34a473e6d4c09393f514cbcd5eec96e38574af321c4de312a2508b26dba73ace337f455834c74a732f32527fdb9274edf441476c753a6fd668d4f89988a1ca6fed9b9d65c4b366ff4ea44931e5c4c4b57ebdf7a6157534b46919fed8e33db0cc93aa98ecba70c2e305d81a355559b169a767a2720bd7c0de58b3117a4b4baf0902fa57e37b029291aaa74a3e2d53e907466071cdc02dd8734f4e74ced402eadcafefc68e46d246abd37c77b825ff55911ae73c29009c79c6e5e0120aa5879e148c8f5b637561f4c3512cfab55e99037e1be9899cb180fc535139364c89bc492bb30e391c503bbc60a3984f76754462087bd178f4302b373c98dcbe9d36f3babcac0348a49d80f012ddecfd84063f2f7553b6f09d8fe542a0d45acfff1f87768d71b2c2529578df07945516fc85ce7772016fc24e3a1f2ca7171a7506fd8883180ad3e6893328802f74ce61dd0de6451cca8a930016f4270857ea7805dff04a99f998d4206e774450224497416c0bebc5e3160ebaae6ea9fd33bfda22be5f940113a2d1b4603e31d87a869941d93ed5b8528c4a45e29171cb4b22d273d7569452feb3f7c189385b950593cbc0dbde912b2ff80b67d9ed6458576d23a2d1d59700439f7660c04bf04eeb75994270eee4ce15c6ea6c3074e26c9eb7114058a313fcbf42cc591dddd298763c42c929714ef35c8c95182beb360b502fdf83f0d4ecc6c02fa1749b3821e8a5186b62ea5b9e65112fe9d0ecb8194ec2e69b335a3afa24c587a8dd759aaf2abb8047443bef32454960c5660d91ad9ba0e95feb05d07b1541124c2cbd2589f598f3d59fd3c6d45e6c5d7206ddc7d0b165f87910a3db1a020b45b3cc91311003f29fbd6de4b98569e8e319481f2816f4bc8bff2cd1e5aecc05e1075a762830a872c14213ed563597d15b7f2ef754c7aebd4bfb876bc412887831a25e72ba7cbc7f0008e5113f34371ac8c03495e07f9c7402377fa44281e47674c985325ebfa7f09be69a875cda0a78e8db76846e1b6a91bd7ee1bdef11a0aea8dac07e753d42de7a0d0697384b564feb62a030a293fdce35199c24e2a5f089c4b90690af3462f7bed6a0ee14ca295a0a7bc0b3b6aca95a81776895dd82df66da2c978c1466f829ed67e115dd0400b745948553e338b9e218113f331dce2eb07ac5cc4a8e52c6f520e37b2bed1a5a20fd2c2a8ae662fe4b0414391fd427dd4764887276672684c7e54e1b59099c8bbab91a07389f83949ecdb6fd873e45ee8f9fa4666a1c4d66de3e1e8c7cf3db86cd956f40fe438da45ddf95c6019cfe1c00186dbf22b2a3e149e3d5b4ffb67fd1af851d9c47abfdd9a45c8c7624c0dac1427b469b183d2fb5b59123e931d6e492d651ca773d3d4376448046dc456f10d97a5bf0ad30fe7ee6b976e9b024f932b9a2fd151ca1772734f953156c4cad7c17b5b1c34f086e2945798d1121555887a0fb165d0d43d993b2f974c43baff66a68afc1f50f986748c69600fe8b1448631ccd0d906573a954f41c1340f9d43d0a53158043de8303329f3a39bca443c2d90ec2a9aaf93b069ad26c97d78403baeda681e30c82b3d4dd089d1499e5e8f04827b53b11a00528cfafe8b36372dfe18bf0dce02f27be8360b62d63a2e6ca5b1871a6a82789c7d1e3cdbbc8a6c4b41b5c102d0082f97972e92d4343f16f81b87b15068a93e9269e95a3460e44276b24c4faa4b18d71904b9b665acff5be99b9c69496d6f570bf082e18f7fe8ce1328a797e648f6ae79ba0f9201b4c9855558a778714ab7063bee4693e6c17367793afa99fabf3847c01c0391c628cae1d7824c0df3109b65d1c7a00b8e9d1cd6014c5c8bd2e99e60c336a97f6e871792a39586febf63bd3af14fc0361d66b2e3c40d8d098e6a958682f1d50042f14f6cd5def837759814c8a97cdc82f9b8b4b313def4132ddaee834620201d2c23bdad3544c53683df7a975402ffb64109048f51a505e907fa020be122605e9fdb9af87c7d6fd3699bea6e6ddb5c78725a0adeaef6ad141651937ddc7059467f329899f22ba5c628e7d741be478a4dd527e7d8f6e4148604c79f984045fe9c62c000f672cfceca7f6a4a2037531dea259d32bc7cce2ada42c1124ba311786a4d77b0fe163be416bbafb56b6e1085aee67e86aa562a1c1d17d86557db228bb3e1dbbc1b493bb29691dd9b65088c18d51963cdb4c63378c95b2100d2ceacc891334378d814c70eb6b8b54607f3b71d0399e9e5681df167b5b50bf5f801c2359145cbf76e3585cc93f01231965948c827c78117412c721ecd6156c22e98bfab78be77adbd5a2587105fe0c846d8d4ef837a855514bcb4f387636258a14c2918fadd55e276837695e69f706bbe38ee316ae60818cd36db4033a5ddefaf0a1b6687656a108fa411545ef96a4babb3d81cc8594521ecbb44caf8dc90d47b360146166e4c386644094b9f3056e88b5c384372d7dd6180c58e2abf7492c7f92327ab1e4004aa9d988f9ba82669100d3c4ee726c2f8b25e8c7a6860cd2c9015aeb925d5758d924289e08f10c6ed97284bc9d25d7dd25ff708a4636ac375dce0c8e26fca815cdced8ce396498d76fa6632a24f3e6cb66c16c777f1e20c231bf34e7b187e0e100a6e8ee172a646ede9e8a968fe878f8de49b3bcc92161866bf93a409d32cd301af711811003ce147a9df8a799d47dac29f6a47149771280eaedf04eaae36c0a77d5b3e78071c2134ed85613904ab726914f3a73193e9316ee74f7aa940d2fd831a1b0d221435d303b0a213d7ab719e1603500acb2f87956969a6a873b180abe04a646edd1a5fccca79a6f52f1ed0c1fece4e4572a9fcc2f70a243abf35549ff46fdb8f20ffe167e73999334d3cc6ed2bbb82ee7618b4a1ee502b75efff60e16df584fcda2becac48c50721a162d8fbeed93a4c06f0a7df44a36c2d32becd9ec2f5261095c1776555497df7d57930a739e351ee040d35f70f1ecfb25d694e946cd2ee971b4b57c26ccd472c6b81b822ddf37fbb3c2cf833de290e9245ed3e6af7c5e0d95df2572120735a258c743024e46ff78f895156a90c15bb31f0a994f7b1e7d0dd0f8ccdaa28d499305686a71e5f5b925142b7d5b3b7566509035f4a6c2bb67c3fd4d4ed8a80fbd71130b16496609050160454fb009adfe5e316d3d833ca9c6245499365761019e8b00538ae7cb67445eb5f5fec54bd73b8e0ebdb748f7bd6e7515f510eeacbb57417307d196a8c9d369e99094f1fdf72441661cc45bc40cfd676f788d010a1bd8528ba59015d013b16c1e062cc733320b899b54fd75dcafee31aac29badd3bd2df3e2e88220b173fb8e6795d885aaa51f340bd68f10450433c11592887ce2626536c394174096178c87b6b4341991f6488cda15984aa220f802ce92f84d1f874daa1e20502c7d3e38616598f3382dc67630ed92c8e9c7dda8743b00ee69d00ce749d24a709265a506b0f9c96b23c79c3624a22824bb6b4414c5976964e1340b3233c563c1a20f7f25e088303dd9dd80133dd5bc999ce48e1eb3c03e17a38cd7e0a0649f3ff0b238ae9026524f15e133af3db63dd60d5eeb03723d8232208184f803c51ae123373e6a3fcea649a74079a1e9d58c1a656ff5d2e6d2333e6c7bfb2395e886cd769373dbc0acf84be17590c73c04e419f3762f2ee5bd9a3a65fc4be3c7cba08ee18019b91bab121062c29d4b51a0908713f67785da7a51bfe1b43bcc2cb8e31514b71eb45441d2cbe89cca03238516fd1e46e455dbb130861249345aefda527b12daa542a9cfa61a84640317eb8093b001cdd3bc4825266875f67b5d91e129076227b1215a07245c13a238765c881a94b82af6bf89fca6187504d8c15fdf30244940533b49232f81f94c5d98e5082a481e24198d09f33e0807b05f0e76f7ba149b33978ea35e8940a977b607fce88d499fe2dec32ddc08e421da1721b0701f1a5c9e39f95b1c30f38a56dd31a45ab0b90fc37a906458032f125ba3222555fd89ec614674b068f808d5e5ba759ee615a4e527462d6c267d097c1f328973032eaee9659502fa23bf03f5e49761b3eb87ba1506d3bc3ca0766f2bd0fa4a0a538faa1a336574b46a95c12707a6355c0e5d9ae693bc9c933ff415085205629e1a74b83196c84411b30bacd7b34716cb69f3f349842554e7955bd4adb2711087575fa446755a05d98301ab6108128d3411ba83a2cbe86b918bce04d91857b0cfe8b1e06614055fecc7b7acbf0226e8e6b0488b7613da8dc2ea72113056d795b4d157ad83b5a04e0b90b25f9fd3fadcbe424eb1b9cbbed70dd34baa692d53875c1fd81562674f8e4865fe1755b5dd7f33576dd3f14291aa6c88d655a0f9c4c94d4c257f46b902a025bde689245008f12e34f8a2e6a23f4b54f887437f9c1758fef48c11d22b2cb8792a91de04b3a2ca61aa6f0302849f0ccffa3b3e820da1da386cff16a99ccee06722bc6e55c7d82d27ec91bc609f31e90ac4edf1ec5729cfd985c73ec9196c54e2e4c4d98bbb849ec1b6d3b0082e1a8cfcc14241857f5bcb95ba4f771fb048feec303fdb5c58837eacadd04459d386d8a86f6dcd1a60721bb60720f8b44a645aa20a0aa9a0859aff2890ada51c89182aabd1ec71282f80ee780e54e9fcd3019d497e90cc00f8fb88984b35282eb92a8cf77c468cd46907644affbfffdd2969b6f26e52f3372d075f72e3379e020aa10dcc2a2b7812eb246787a33804230a9dd4bb93e1d0257e3156dfd9a89cb0ec11b01909dce934eff84729f89a24b0b343348eb693dd1233fd7b3d5891ecda7103fe279d1c1e07beff13a5e3c713fcc4a86fcd94d7e0c0056d6eb81e825d3ab26cf30d2fb7ac8b848fdd80db892f5d941b76b33f88d1940b5ca254c35c0a6921c0448233228da912900d5e796010bd0bfed9dd6291d7f8b3e1463c0c50af1dda6cb138dc900e868d179a5628e2dd59ef93debeb20ee7e808d0016b1cf787fc7d78935f15b61b50bf48d31dc58cd73e4811512a3d997969f5c46903c337c0a72af023786bb047a5be267a20f7296e428d80c2a645f71a590f75551a9203f920352463950b90a20538ebfadfde3ed86170ad7ecb13084041a38b9ff4ac277e0ef32b9faef9765c52238e1414b8a095b3e3ce7cf6b6a8f32fac7faf711cf03d4d4210776f157dc722fb4f3690ab153e9f0d946bbe06bd6e7c65ba2b4e85145998a90035cff1f8f70ba911c2a8a6a7d21b1b191a545b3514d38c518abda2b9b4efcedcb1585e3fa00f5cb6fc5037366e833b47351f5f488cfb604137c585d81d7a32b1079fe2b743d030062be3f3ca7658a1bef9d058d0569a68e829254ca2a68cb78c634f7cdfa35b7f4b7374a5d9f1ae4e2f34c4e52fd732e1d1ccc64be56fb1d93b0966ad3e182fa1fe47c02ac5b6f15941cc63c6d71e05ace9323f7a9fdc22344315b33e5dd50d5940452c005c303c610c27de11ff427096c12e58718e8beff8036a24cbe308c3aad3b300f135cb9e145ea90352429fa60f9b4ef2e04db0c4941e0e8cc51e299192e40e2176f5ac5732c6f69300ddc81a1738ab4de9a44327f69ac8a5cebb13f2635b8a4fedf4950edbcde5f0adc87004ba1ae372f9472b736a829481158d358eb1a0b7635e544e8ed1271c59bf70ac718d8599dfda6e5bc89c7fb73bbbd798d87f5a2c519f9b2c896716d7786689a755d732cba1770281f05bdf68622811cc4a7f906fb832f08107690901f4bd2b38e7f3eafd968653f06928f9633e7dcb28f0f10aea23bb3eb093a208355303ee23d2463299b23b4c138609f43c430b0b7cc110c73bc0659c371c14a5913624315bd60a8dedf553282e02b28542f1c7af3e0834e320b2ba7771dfd46deb4d96974aac7411fac4fc021609e388abf00cd4615743ca5974e5ef651113f003c125ed6ad8cb0f4e4539dc518702a12ff276917826188894cc73363066f4f2a5bb402feeef41a470ef4290e4cef5b31ca15dc1fcdd9f9a7cb2c792e7902b46afb185427c41e1d5dc77727ad3f629ff72d25f1334222e3769a96f2e43feffbaad5e76949c2940e8c56864c12180557475b33dd4373d7bb0415fee2f4632a5d09bc8c5fc3bfbb0681bb4da8fb7420e8bb6618627f2526bbe596af2ef61c3e747cfcf2e7864b31a4493ee8210af7916309b725c1ea814ac3eb9450b9c342ae70d284f046384146d0e7bf9e3416fdb548895f32ab39ae839ad3245c25d7a00a94476ce6644264dccdceda08cb9e57c20b44d2c6004c062b208e1798635ca21534e6f34d77efd8ad1604715ec7fb4dadb761781d14d19f3daa5467d56d1c46dcd5b841b806ba89e7d5e1e41480a64ee8515e4ac286793bda2506e071d943131533c00da706bae1f8f6ee75948d5d77f9e3ed3fb10083ac584baaf7c28eb2dd01e6206d19c44985aee9496c182ac842e9bdb560eca8d9e638a783dc6044715c763bb07ed86fbeefb413a5851dfccdc5fff48a570aaf05d8a007b87e171a36bd0b761891bc36a5e4acb0f6b3798ba567162997970922c3ea3a99265441525316f53a0f14ffaeb6f28a0d83d9376f36b87bc2ee155bd59fbec38cf54542ec13503e96eaaa5cbf841aa66c8655cb356ee57f6f85519621124e27954613c967b0ce172f226a254d1ce612e20d36b5f27b072cb934fe2d2a58abce2187aa6ae5889f056ee93ae7962b237b9cc1e23c1862832caf7230e0443eb808d036a9725e5e2c1cc79ab700dca473cd4497c749a309d7e1c95092e59f0315f02207671c7d444be456556edd19466e9b49d6731fe5fecd2f6108a3b591a1d60442b39d17ddd6a9efe9bf4cfe0b0599f487e27aca2691ae026fe8c6aca8ccd786f60badb5b1152f8a6ad0f16978655f91f7751459d02dc0fdb4e064272189195e3bf5d25c28fdc8ed04f9d15f8eec8329c128667fe2ea13a5ef4e7c70606c08dc97bfb98edb519d2441e1d1bdaf259b0087fd4be618f9460cc5d3d3ea6afc1f9370afea2f2cf9bb1ef0b32820bb58f32752e6f5645803f3620299e5ff6ecfe402fb1d321f5bc9f3382dc7e90bc1dd9cc3a813bd598d8f28b9c298a0a31bd2ae1f3f7ed6139edbb4e5fbb039ac20b99f9506d966a59a0b7b3d504a5c61c30994d70800d5d1935545bd51ecc0a05b9dc13cff222c9fa21281f044a5f0a9d28eb5516591785cdecd2ba6a38ae485f903d9a41f575e2175d4ac591650b47b46c306591fdf270a537e7d764b80cc33b5138f7494e95201521d0538aecf9e85b452dc35c22da987911ae150a986959b5724d4ead4137432c38f739e98eb45e84c968d5534b0d1fc4755da68347f9e61897d059bfeeeea03263b914a3872b0ee5405f15ebf8e3f2808ba3dd4d72aa7f8d9904b70aca800d197a62fad4ae3e973879fd6af58aca330d42b93d539cd0841ad76c2e98fc144e0c589be4194d4cc548081ec49a5bb7399630b7dd529e15c117063988054df169edf2b550e9ad857e0af81d39e820c4aeb36fc2fe2255780c6867489665b69754c00001d3c8249a3e5a931a161be001f06eab5a468d52b9f7f401786e6c6ef17f3e52b8ba4931cbe60bacb5e0aafdc4f31188e46a1e0e8d26c102809610c7053313da0712dbc1f235a43d16e545cac54b0250b8f83a99f9c87df8e4855b049b6a14aed322656cf5bed099176c7a1b971a7ca8686ede80a3937ca28e978a0c23c16429bad4574d2c0d13cb53a1b7d67b028d811fa732ce19993e4519279c77ef459ce1da23f3b1368b9423600a975bcedba962f943666a31692a981d2924183f57fff4f8c2aae05d07d3ae82d8666c1025bf7fd6838975f83551bc846b69169871f6de99b39d400db15efd44af3b28a52c7544d514dbca6d5b1f293987a11a5142a01d596b74f030be32623bec22c37038349444f136b4ca665c52043c0ed5c032e86ecf97c042aaf4b1acc390aacb6fc5aa7bb66705573b7707746f65b872ada81eabc4d423bc5310222f4b97fddaea2d1cddb4c451e9a11d98d1304873e2bdb6d723eb23ea1314480637e46d8d4dc43c9f29a28cd63892247e06b4574b54240da5aa16845cf9606036cfccc9477b57e8f4bf1831860c56eea7f75bca333b5fba623b5a5bdc0a9a077d462f9b3be2fd6151be1daa092c03c859475276d27cc9b07264d296a70b0c4907b82eb687dbd1f96be06a767f922d9f19a146461c64738fc58d9236d89b709a49970edfbdd3c8a721487661fc37210df7db521ff2f12f3bb813da3b4d6bc4b60677a0c3bb6d8724452f6fc0165bb449f0437a411ab19a15252734f2e46d7288d1d859a4d18a8839be692e39b4a71c2f838807d524b6f5e40301cd0846265178ea9f2f536f3494f817d4dd3702d63b9c7898e3971614a4c541f73d26bd948ec2d1f415b3ecf8e3cbfd7c229c5c0216a3b7c0136a9934f89e869c01fa11121cfd4fc1eb86bcc82d1cebbd0560a2369f0375ada11cc53c5ea20055800d20aca2c62eed00c852489acbd065e9ffb2ac5a0af7aae58cc0e4386678621cba29b86424b885af0cd1ffd94b21345a64460d6225f50e69e09a75478554a93437a0f16dc38b32f874e921eeadf6eea254741f43ddeb9161e0de721902bfc0c996a2106895bf69ffc8c891157af820a20a82323e995ed82d43dfc3dcc6532f7a0bbd12c5a497be09aa1e35e2c4f9362b2fc9a44931aef732f80a25cfea91b1e3ddeb3405004c77ccdac02388172abfa4d9688f5f095971c871dd2cf4be75b35ac54b70e85f18f74180682b5efa808ddb97966b4b2c5fc2e647e40629118d5356e5787a4e4438d558931203fcc8426306bc43d5c7b72e6e36071b8b74508b6ce2f6ef9756677b848d9f87bb77cf8f10e343fdfb0fbc88ec1494ddbf81ee4ae60be60ddac5404a3fba90dc011aaee0a9b635c4b91e9e2b71f27b439e29ac36c395870f2ae68c3d2228400c1436240fc7bd1f31849ab6843c890cdea491f809c36bf356e6dd874c7a46d6c55d3e4ff9df28a1947cf7c92fe7a8342c3a3cb81fc08d20a21180b345b17b75947c82667b7bda907966a3c3da4c928ea4592b00813082c942c272efae7653aaa6fe325d264e3f25f9688f31f562bce552855d3aba5bee915488d39df685295530cbe868ce36526f6e82b9baeb1471da15be42bd8355eab8ef3f1559c323c44e2874726ecf8dbaf71cf228e65fb3fc4a13faa1e57d3303b8d8b97308e271cb715a5edaa75568a0c44ca9fc90a281c15cd1792e2e36df0558e5d5f9414149673000b714c8d81e69ab6565d8ac8354a0800c4126c518e47c618911431ec689ab6abf0629974d5cb6278a239eef1b01d7cabc47b0af372e673a69fedf30a270c93e0c0fcbe0d59760919ed4e09438861aba1dfc66397c00f18f426051e688233f5a0d8285f0e1e1948fefbf6c63b64aaf5d63cfe0df9d4ca9846f785c1f7d335434d7b1943b4f6c8b9cbc039aa5d1bb0844efabd172546dad703727dc9fe3eb2e8dad99416cc4d4793bbccd77029db93a02d07f3a2a8d19d0bc490fc06122450b8643e9274550a19830a549b176b6aba2b6891bdc7b2d3d57ea428947ec5feafa32a6a4b78c81a90f36e35fdfced9c4bae92d27cd5c96a3a733d3e8a2d0e3b37e29ec0f9a975f65a03f8857b7c4475f35e8835bbab9599f0902c794f1dfc6968ca2599b08c7659c3ec800be24f81d828456aa58f2ab603bfc5661fd544f3b243db3c23223153b525e4a6004c3a0019a1971c25aa1e034f9d890b9cacba789a536fbcccc3553502cf13e8cdf35c934de9a7d3933284293023da0730569211596f12a65df94981e16c1a3afe8366a4b1b9f758ae9dd42e92a8f8d547cad466c1aaa1a174f7e5b64ab7c2eb16aa3aacaa1f8e148fac1d03abd6688d5e6348a38e56eeef06e4d56accad8610549a51d4bf8ab46a6be75671ea10c9eb800c717798d9215bb46ce46a3c09fe4afa96c76a9eb9c9592f16221f11327fa67edba1f4ada9f9a33b29523ded10de760893216d251d9673eded48fe33cd4bcf570ae61793e0001b9ae909509912e7cf646b95b87983d63d26b1bc64bee66ade708c5352cd1fa805c7aee4fc07784553fc639b56761944c5b26282a970db284b81b587861529de460571523acf75b490825a237cc8278ca00dd8672e95d1aa51fda0011ed6db60316969fdae3668ed8b13df2ab304459994690e29a4a579fca357400079d3127e01fc36d1c5175d81a76eed5a16eec6d54171b8bcc7b809e1951caa3e161daa75665e425334dc90b69dbfd057b46fcefa5fb47129767ae9397ac6e6715af4a9ab675a1376948980704486b5ff6cb2a8ca17849ff8d6d4dea1f27bf0ad269c7200139896f17002fe0862034b73abb77208197474af4abc2396c20bfbb7ed2ff0f31d868b11594941bce38e3bd460ccbc24efdac3559480d1932f879817299c086bfce8ea24f62a615cf99cddd7a3391351a7244daa41e7571244b9e944762d0b0b2fd3a880a1689b9b234b696f996c8878f8c75bc24cbceb7025e9934afbe672f45f1fe6108bba26d322dce33e023abc83e7e1173e332879c084fecc1b63e7e7e0af9065a561bba883acf1d433ffd437b77f7afdf02699471d71826add60225e13bc1dde7eeefd2e8973cd5ac6bd82786f5d940aa1b753f73478fd0c0ca7ac2c3569509f80d7609204b17b9fa3939f598d4163396097434220b86f786194bd7dfb0a0b89258a80e6e06a1274d48a483742fbaf5af0d547bce95f97a6108cd2c2489673d55168985fc82e075cd9f57087a629c368a9ec84c210dc5354e1ea25954caac9b48e9d3eb5cb0a7309c3c13c74297a2e3356842048d22a9d7bbf5c06378dbd7ef2d33b9a16b4848678d6721157cf5a2ed0956e4cfb25cd983d56993467839e0b393f7c7124dfab096d0ed65e3183d80f4e3fc40fd9c42d76a938390fb75adab5f30fa518792d9b0b2641b67ef1f1075bf3ea1016b392eeafd4a512920bac510a11f94d17a9742c7fbd7943ec5b9c8a7795d8ff22b2706966cb41a8c2d962b4aceec4ce3102750378d249e37a7b65a85f972f7557cfec6e826b2bc1c469a81803505d1b9e2da4257dc65e580af8116bd19c60392fa3427c17f7139a0955e82082f26034599cfd02b14bb7c77e8c3cf09d3ec9587a4cf3e770e540039f68c8587ea9328de39817268caf428988bfccbeb422836405ef6ec001236640214b8a01b9e272d7800e4390f050bbda6ca65d3761e1eaa62d6a1682670b86f7036d73936e3e38dc8e50aa6a6da6a092950b13d53202158f96f43af86de7faf914e8cc92a5f81d02d1b1811155db5f4f136e7a8ad5383bdfcff735c0d6f642579ba077698b0236d3abe9e5923be5232e49498e3cab6e5feaaeb4832c61c9004765643e8d91ffcdbf55c6fff0d4bab03197c969b6eccb136df9e3070b7111b7d0bbdec58420e0f3847af1ca7f362ea1e2146fe843dd08790a78a0de47683b566cc312a1979d6a0b0f07931766c1b4760edb9ab749258fa715d4090c5b91702a9e07dec73cb22b4e841e80aca030f1bb1c0ab212f7587e469b6ab259d073c4d10ae363a1b272bb6809ca20f4dc87a9f26624e454142cac056a609e712fd791ff4fa659f4fd98fce1fecadf8e854f78d4db23c36cf1706b45974057a747ac67da232f92a7aac5f7ca32379a4bb534e73d8a90c197cd143538d20e291c6d361787d09cf5eaf58c3b2ef7c4d50a94bb19cfff7d81700f86e298f64831b28d7dc171da69e6ef8f6ba69f23093395d6e68021dfc6165284c86add97fb9fc73c426270b373dfc62254d67af7050f892b2cb85ad8c6c23ec9b126c1c4068bae3c10f044654f0a3286253369557225f45bb08bc3e595cc984ed902af48f588f1b0248dd37506b3b61874338731f1c61e0e8639d3afae3e24f57a756ffd25747530d882039070de1c855c7e7ed172903a5cc6318ee176c532956165a9c8acbce2ed6143a56362958a038f2cc0c3f4af6ff5623322cc9407fedf0636a9e6ddacdb525ffb88dde48ca8386ec56d8873adc166c563d60040b38b7d730d2db2d09b1a9b8b13ba84135bb620f6cfae27a8b3110ae7a3f8c8299f58f17b4869f58b06bc8e7e58cf687a3491e4f4bc599e35f0c4846bfa6eac1006479f361d5fa9aa0e09c22292cb953590f3c735cdb5aeacec14d568944ad11e96a7c74ddda5950179252f9ce63c7c7ae97529411b4ecbc343b4674e7979f3957a7e6fe4a10e1326db5e184ecb0d4286554bca7abd49d128f265d441dde287b81b5fb743bf4ad927820562ce60072bdd19db1c8574fc8afd8468c1c4bfae311deb8e4e7b200c743d2a0b8449453b6f6d73f90de1d2252644e2aed5c14a3ac66ed303735aa159bd1317d015333c41283bfe9b84b60e8e6af567ca827a33cbcf0be528de7d72d34c77e91b41a4bdcc38f66e109813a7e48bd4a1e3a1e191c482d3b6888b6cd2f7d097da24ceee9f87dd6a65bf5b90e89d74ac31a0c436270af246292749188084972e42477845654ab6a38a998638d854151910eab77d6fcee97a242ea020291e10b8e240198e6c8cde5b0134e037791c76af0be9efdda49abe9d4d2b3c496f183eb9814f83f4ca9827eeacee756096ed984dd7fe552794ac0afe19ff64cb07a6e9e4a67694e2dccb5e676a6cc81bf5b1159186b202541609ea46d6ad000e435e59492eb07218814822f2645346c92b288d6e8249fd3868f20486e9ccdda0f58d5035c92116fcffc314ad862c9f64d08285939d6b757caee234c7ab84d13271ff0c0007aecaa8be510497763fae2724a6f3c58aefb871024892fd84b6d021be36603b3fb724d49d89958350fd8d0fbc658c784cc637e7b43024fa6426955360c17704aa4b079688a7b8b237313e00b5d31bdd43baf759974b22773c9bbdc10a9553f43dbaff2f6f893fb399b83177f60c55efbbe748a3e0e3d3721dc2bc772f6ec0aa8e49c1674543f83b1b56e766e110687fe9b32601eea995782d65bf3b563b08c5e9e30a826dde03aa97a99a8067f95d36104689251e780e8245def704b164d1bc8635e6469d116394c51450bb6d01a0b7d4b1f94c91a18ddcc6f91a0e3c149dd12aeaff94dd75d54405e51784cd4287465b542854d7dfbe701b093c5699187702bed3e43df451e1cb485e23bdb421ac94b9d2a8e7ffb3d9146f4bce49804844b1081248fceaa5b875306cf9a36b3e4a0f35371e117bab912fac6dc32dea8a328cd29b4e192f9ae4a72d88531559f7de715f5eb602fdab7560de91404f8dddd3dce668724d40342e6c30dbc767166c181094e15a0c56d4869ea2824c4f7cbc552ec13c5a6a45175dcf38043a7e0fa01b59bca144628be8e754b84101d045c9c22316a0fa8dec4b42df7b7897e14b0c34e6160e4edf048e0956b6cfc0a1ba58e051d607b0829c1a28cae824c2cfd595cc56a9bf24e9ba5ca9e592832b333fc12c7b264cef0b347e54a17e7afc6c26c7dde75f3a9e8f7b8b2dd2281497b48ceec1a5cc71d66c9958f1cc069a452961a8754e86fa9751c59119468c6d9125e1085d69fc6c63764fa3ca74430d35f2bef29eceb1c2301317cb14b7765eae931947496cabc81308406b5e9acc410b676ec9b04c2fd7e5dcc9a9a2056905f428177b183db90a44b5615eb916e75900935faeb3c5d49696992c2d84daf54121ca9953f0525ed3d52b5259139fc37c637d223f71a799fa9f318342a09266ff7f2297c245ec25b89c1f5986760a336e30aa9571bc3a35ff5065474fe9e6d59bfe2b4238af5a659bff88a469a460a18c2221cd7aac5a6961d818ee9fa13bf898e7b94c25d4dffcdb9098c59ec41992347038aec7791f1e1030f2c5cb476ea3c064768d3513e4fe923f9c27937ab4e07f0cbd14554fad479e141cae8ddfacff49fe94ae6f43e4177d119268e0e3630393b2e96eca0508f27cf56236d6a7fd96ccd1bd34cf1850b854a95a3bc77ac509661d75aa84d59ed065c401551a5c52198ee1e245c2dee238e4c22f639fc37e58e73dc5bcbf6c02d3c2d1f2507e07dd5095e152768724abb40c4b7a332625414f482d720097845524898231873e78af1f1c4ec51c5aaee1bb8c0a12379a38bb47bc53829a54b9cbae2dfc42b9ee2915af2e9ce1fc60d35af5a6088c30856690ee61e5aefabaf9a87a5f86f5cbd357f2ace935c12c8dadf757270dadc1c750565fcf733b69f4831139e91001fccad2a1a2c117bcaeb82444fde43b834e33b93f1ab9f59a9cc0290032d5a96e240184e5333f5078268ed809c46c2f4ef6478e69d92cbac76f0395226eebb061373fcce8dfc6274ed4f9e995923213e98babfd8640bf021e84a6e97c9a66e5ec4d1c7f243a38262a4b7a82f61d914c109f09a6ded36bd99d7fa78ccfad34d4f2986bfe3840c0c449f7545386ed6f93697e49ed260eb90f898371c54b3762cc262e6dff9e6d5d1d69dd133706298b59bd4c1ed3e1ed8ca582728bd74cb65fccef824ad871a6d79bdd4655d61ace947fd3fa4cdd492e542e85bce2419db955594bbb93f813ab74218e0870c95a11104262eca03e96ae37ec5248508cfaa12893cf32d060ba1338c29269fb993ee3fa9ae1e0be09bfbbbb9754c1a9a3b8f38357aa2a1c6978447e92ec06965cd15d7aebff94c69a610d70bdc03fd9a17df62c11ad135141cbed1b0ffd068f7190348a6c7beadf1fc22590cf4aac2ffbfc8dcdd15c6184d699bbaab656d488cc5f85e7c54f647752cb05f755d451daec9e34ff8922223ac47c46ec7808d486f605d228a1982a01921baaef331fb99d36da94179361c40e336a36ddad83ba6ca221aab5f22123c978837ceed6f02879c4c77c5c53835d94db3c1f681689c61e67399c3d6358eb46656ab7a6d2b9c0786764cff73c1f9969372962c1fe308762dc720a1ab6ffd2bcd9f0dff693be84b988f5317dd789d3b22195944e7c0d6da5d90c2c2411e2b821fa9316edaeba746620374f1af216af5bdce6946ee0b5190ad91a337e584696188aa41cd605e4a05f5bc8c6d0a9e7cfe6467141816a8ad0c7ab19c36c5b998403b0442341c7c707e97b470f7c65531af02025104300b4b7e50a02f6b1fdce72ffcb4d6a951c5a2e69ac89b0dcff85f3f9bb5775cb38126b35ff1319f721ced10e8b72dde5f3c6c656fd2713be2fa8c050c9e6a16c6b178187f83f9167d943f3978a450a5469ee126834cee2729f2260a6cb2fa2f40f0ddc9c24bc0dbc32421ab939be075cb53c70142afe0068c21856fc2271ced565d55e54cd8886fd29f9a03783dad92712d7481b21dfc207f2e1834416416c17505eff1797090c859f64c4ca775e55269b7b26c7ad4c7abf944d1ee1e7327f41bed160374cc82e62a61312a1e29e425722211acb94cabc66e39c28fb7fd955aaacbb21c712ce85a6f4ee11ac670a3bae487f0adfe86ead08534fb7fbd7e069e16dc446903a2bb013d234dcea9fea7f3b429ad7a5e15c6c4aa2dc4df8e56a7be9436eb2b664863ae167ab20110d3b57f11248fa66f90d91333856d4bd4ffd2a1b6d5bed8194c6705a823ea04f8895fb2ff2bc48c813000e0039e296c7659e1e0066d8d67359539566981e5b9f40a205a75d08cf4fb22da540b7d1dec060c4083ee62dedc94d4fa236c0919ea47051e65a4687f7e6e70ce687ef32c6c4766240f0fe30508af25815297370baa59b3d9c0e8401500e2b883b385b7e0e585885aec703b08c91961be10ab23899b5e65272ef909676c6f4310774a5e4c0de182e92e85a3a5ac6c3aded39c095e953198714616dce3a79ac84cef8885580bf394f4fd3a4541d99a114d8d6f1b56733302ca9f44412e61882dd4b843e5b41499d17ca5c35d8beccced698ce684d0b6e79f13aed41adbf189077e9008bcba8528e74ed09eaf181088b0642c133dc85c2197cfcd7b6b4c3d8f934fd3c54082e2d71bd4ba4c7577026371d99d3a95e2f3c76262eef40dd4e8d9a0192ca5b71c17c18af76038fd4704e8bc23b35816ba90f113eb2911896860677a325854541124eef87cc765550613ebc106d25109c89980c68a5ca986644b7648f9809468cec65f9d5792af4fd55007fd54f3a2d13421b7593c05d2e30306f3264d729d424e599e4059f77e49e261d38f2ea4eb0e2be0639ad9e08096997b87b932278ebb0dfc0db0ca00541a71d8192115c95193868dfa33ba6ce25aced975504f4cdb30fec466805de1782347a27e2d9fbfbc313b7d48775396f4a2bf5b7540e84d056b192dc7f54765b77ffb20882ce9ca1f92fa2a7bd3939ac4c7e25a17e6eded90ce6c50620850ba579425cdcdceeac6d3765b008c99d188a729e19fee12b242ca1907e04bbc49f1a2c4a376f7ef66b332b0ef0d829d44e1c792aaadd81675e22f403b68be572d4265ce8e4ec70347489fe9e88e0a3ce894593d0d6e8be52b077abdd253bc326d16f33b108b67e4d6946d833f4a5a3541dc88f623c0442f19415ed8d971243675e399014507d07ba415715864bce7a5ee626003d01fcb3a13f2ceaa6f3348e9d9eade3535a8c27e72bc5c8fbca459f9d100696329c1ba44e1fe8950e66e401b1417a31d573321cc2e07600a2c9de19037f37058b65f6c86605efa4d7e6c398cb2b23766ebd9c78f27995bfdc4adde645cfda188301d3fd88371edd4f0ce5d48db256adca1c5d07151a282d099245a0a68a6ce4720d5a78c688f3722ce1b65d8b9f880b1ce5a69597e8a10f43c69ed79ff200461c480c8ad9fda3c914b697cdde29139a4f98762a9dd7f5a11fadb97928f932ec5eaf2faa7a3c2c08faf7dfed7a9521f6658b28260230c33d6a2d2994ae486cf9b48404b831ab128b74caa5b1e76beda85a5b0da0027a9b3fec4a7791d50cc24f9d1100042314d9d89464d284967f00fb2adb5a9a7e1f79cc8857b625733436e4eea683367af660240998395397541387cd1fa13d5c8ef6bb2a3bc62d74c3a86807d4c2c7b9b129d9b1000a8e93cf988768d7c86bebf33c4a0c4480b976f041aaf07cfc049f4c68e6dba14077f7166fe3d0619a513ca2536e5b704bcf8bf3b766dc437d617b4791515e4c5b0cd603bbc2c4f1ee5d7fccd293e39f769659732fd43057262020e430141437be636014d69eb9f969911a2a849cf1616e328dcd77255641bd9f2064e19e04ae421558336c1b0e423dfea8940f67cfa770a7f069a61a2f4ef709f71b130ec578c7853e96a0c9643466fbf17a790d70cbdaf4c0b62000e794329d7859fabca41cbf42d6380fc40f0500862abb741cf77d13c0bce74c1bc6f473c8ac58b631eaa3f18bb3f7c2e426c38e0a8d1c1ec40f1974b05fa50bcdab484297540624225fc08230fb315c1003d23ba99ecc3dd97842171b11ad006cfaade7ab9cd3c524bc08b797c4f23c179ccb1ab1c5888cd0ebcf11fcd216c82531b8ae293b5e504b3c366dc08e6d11c6007891b785bafdfca22e198c67ae8f177992b9078065cb2d91a6be657196be0d9433568b34bee86f2dd9d7a1b7646e37bf096f52a3ad7a1b6c77cd32948327944c2eff950746225a2e315e764f90106ae12d62f1f4b611d9b1d0600fa0d2bdc0055eb44584775d7f7b2807ea4b48019344597cd6b0fc0f5a79dd941f6bdc65cfec8227245d126a2e00f1b278951194f93e64491402a7851dbea87a178a0c4c19afb4a3efd9894d16b4f1464edeb39196cbfdd617f3a01a1064391741033366fb534f57498a78c8a0d80494e8545e6a9fcda84460f99956be4e1764b8f5831e5da426cc8f7fd53490f614f194a7748f82bffaa9a42afea5510c820ce31d341fc72211a81508c19459731ba1693ca4fc68376193edc9051beb7a04a5a19a8a0a883f14227328b0111e242472599b8a9578d53e0e577df2c7a52f3774eace0fa2f0a3e86796c316e3c6634ad0f136cda4b3d4d991ef8a25e6080c88456eedddb5097e79cca3b601488a7bb82db2250479c3366416f847b4940690475292bcc45499f96903ae19bc76a563d1779b6475524b7dc5607b5e426651b5c76178fc9692b357e4cc353a7500ad486d8dc23ea32a5e8d2d1ac6259fa611cf55149f4d52859ec22a98e9daaa5e811fe5c1c1e1412964d253747568a9ac63509cd6ae22f44dadb587e6ce4a546e5ba140212b30caec1d154cb096039e9b1a3f5c32e30ec23685e208558240f96240e17ee9a604ea5f781308fef007a2a5cd3fab70f800a692cd0b91fbd442d526394695f944b7359ce3c940e7540a9f7e908d4659a2ec5fca5de523da9d8f60655088124a308a0652346201c8364a9b6d92b13789f05a29bd511daa5c1a9da1cf8ce3ce41d45375ea260cfe31f900145d9370fe771102b167827aa834d3e6b67c54536f6280517ea8365707b38562b69bd6fb093c521332941da9344453ac450e34803374da1462906ed813021b8cc40d7dc81fdcef42ef6f5e6fd4b237aa4304dbb566330e086661b83887607d4312d0c563dd9d03aa7e7247c6dd691c72f18220988f98438ab40393891d5288d2547ce3e58ece7c743791ba0bd557d2ec04d7f2d20cd1c8eb6b3e6adefd113fa599836273ac3f45ae92638bdec021b28329d3b65dd3673cca3d9f699808e437a0a65f359310ff47e2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 | 网络知识问答梳理</title>
      <link href="/2022/02/10/network/"/>
      <url>/2022/02/10/network/</url>
      
        <content type="html"><![CDATA[<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><strong>序列化就是将对象转换成二进制数据的过程，以方便传输或存储。而反序列就是将二进制转换为对象的过程。</strong><br>比如 网络传输 必须是二进制，但调用方请求的出入参数都是对象。就需要转换过程，如JSON对象和二进制互转，这个过程就是序列化和反序列化。<br>JDK 原生序列化。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>无状态，双向传输基于TCP/IP，灵活，明文传输不安全</p><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx 提示信息 2xx 成功 3xx 重定向 4xx客户端请求错误 5xx服务器错误<br>302 重定向<br>401 权限不足，需要授权<br>403  资源拒绝访问，需要登录<br>502 网关错误<br>503 超时</p><h4 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h4><p>Host  指定服务器域名<br>Content-Length 长度<br>Connection：keep-alive  长连接</p><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>早起1.0 每次请求都要一次TCP三次握手；<br>1.为了解决该问题，1.1 提出了长连接，<br>通过header 配置Connection：keep-alive ，建立CS持久连接，<br>减少建立和断开的额外开销；<br>2.长连接引入，使得管道pipeline网络传输成为可能，客户端可实现连续发请求，无需等待响应的阻塞其他的请求。但是，服务器依然按照顺序回应，必须一个一个处理回应，如果前面回应慢，引起 队头阻塞。</p><p>1.1性能一般般，需要HTTP的优化。</p><h4 id="HTTPS-解决HTTP什么问题？"><a href="#HTTPS-解决HTTP什么问题？" class="headerlink" title="HTTPS 解决HTTP什么问题？"></a>HTTPS 解决HTTP什么问题？</h4><p>解决明文传输的问题，HTTPS 在HTTP与TCP层之间加入 SSL/TLS 协议。一是把信息加密，解决窃听风险，二是校验机制，解决篡改信息风险，三是身份认证，解决冒充网站风险。</p><p>具体来说，HTTPS是 如何解决呢？<br>一个是混合加密，采用对称加密和非对称加密结合，保证信息密文<br>对称加密：只有一个密钥，运算快，密钥保密，无法安全密钥交换。<br>非对称加密：两个密钥，公钥任意分发，私钥保密，能交换密钥但速度慢。</p><p>建立通信前，非对称；通信过程，对称</p><p>二是摘要算法，用于签名，为数据生成唯一的指纹，校验数据完整性，防篡改。<br>摘要算法一般是不可逆的 ，散列函数与md5与sha系列。客户端在发送前，会通过摘要算法对明文计算，算出一个摘要指纹，把【摘要+明文】加密；在发送后，服务器解密得到【摘要+明文】，用同一个摘要算法对明文计算，算出摘要，并比对传过来的摘要是否想等。</p><p>三是数字证书<br>客户端先向服务器索取公钥，然后用公钥机密，传入服务器给私钥解密。<br>虽然摘要算法保证了数据不被篡改，但是，如何保证公钥不被篡改？<br>这个需要第三方权威机构CA，颁发数字证书，将服务器公钥放在数字证书。只要证书可信，公钥就是可信。<br>CA机构是分级的，树型，最顶是根CA，必须相信。<br>如何申请？<br>我们首先要知道，CA有自己的私钥，每个客户端都内置<br>已信任的CA的公钥。<br>1，服务器吧自己公钥注册给CA，<br>2，CA用自己私钥给公钥签名并颁发数字帐户上，<br>3，第一次客户端请求服务器，会拿到数字证书，会使用事先已内置浏览器或OS的CA公钥，校验数字证书真实性。<br>4，认证证书后，就获取服务器的公钥，加密报文数据，给服务私钥解密。</p><p>Q：HTTPS是如何建立连接的？期间交互了什么？<br>SSL/TLS 协议流程：<br>基本流程：C向S索取公钥，双方协商生成会话密钥，双方密钥通信。<br>前两步就是握手阶段。<br>详细流程：<br>握手四次通信：<br>1，ClientHello：客户端发送加密通信请求，这一步，客户端主要向服务端发送：TLS版本，客户端随机数（用于生产会话密钥），支持的加密算法列表</p><p>2， SeverHello，服务器回应：1，确认TLS版本，若浏览器不支持，关闭加密通信；2，服务端随机数（用于生产会话密钥），3，确认加密算法列表，4，数字证书。</p><p>3，客户端回应<br>首先通过客户端CA公钥校验证书，取出公钥，加密报文，向服务器发送：随机数（会被服务器公钥加密），加密通信算法改变通知（表示之后都是会话密钥通信），握手结束通知（表示客户端握手阶段结束，这里还会把数据做个摘要，发送给服务端校验）</p><ol start="4"><li>服务器的最后响应<br>这个过程产生3个随机数，通过加密算法的协商后，计算出本次通信的会话密钥。然后，向客户端发送最后端消息：<br>1，加密算法改变通知（之后都是会话密钥通信）；<br>2，服务端握手结束通知，表示服务端握手已结束（这里同时会把数据做个摘要，给客户端校验）。</li></ol><p>接下来就是，用会话密钥加密的HTTP请求。</p><h4 id="HTTP1-1-HTTP2-0-HTTP3-演变；"><a href="#HTTP1-1-HTTP2-0-HTTP3-演变；" class="headerlink" title="HTTP1.1 /HTTP2.0/HTTP3 演变；"></a>HTTP1.1 /HTTP2.0/HTTP3 演变；</h4><p>首先，将HTTP1.1 相比HTTP1.0 增加 TCP长连接，支持管道传输，节省了频繁建立和断开TCP的性能开销，减少多次请求等待的响应时间。<br>但是，有1.1的问题有三个：<br>一是数据太大，只压缩body，占用带宽；<br>二是队头阻塞，服务器顺序响应，一旦响应过慢，导致后续阻塞。<br>三是单向请求，不适应服务器推送场景。</p><p>那么，针对这些问题，HTTP2 进行改进：<br>一是头部压缩，如果头相同或相似，协议会自己消除重复，这是HPACK算法，实现原理是：客户端和服务端同时维护一张头表信息，所有字段都会存入这个表，生成一个索引号，只传输索引号即可，提高速度；<br>二是纯二进制格式，1.1 只是文本，头和主体用空格隔开，2.0头帧和数据帧都是二进制，也是提高传输速度。<br>三是数据流发送，不再像1.1顺序发送顺序响应，而是对数据包做标记，指出它属于哪个回应，同一连接发送连续数据包，每个请求或回应的所有数据包，统称为stream流。</p><p>三是数据流<br>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><p>四是多路复用<br>http2在一个连接里并发处理请求或回应，不再是按照顺序对应，不需排队，就没有队头阻塞问题。</p><p>五是服务器推送<br>增加新功能，不再是请求-答应模式，而是服务器主动推送消息。<br>比如，初始化HTML是，可以主动推送静态JS，CS到客户端，减少延迟等待。就是Server Push，可减少了多个RTT。</p><p>http2 缺陷：<br>多个HTTP请求复用1个TCP连接，下层的TCP协议不知道有多少个HTTP请求；<br>一旦丢包，触发TCP重传机制，此时，HTTP必须等待丢的包被重新传回来，这样阻塞了所有HTTP请求。</p><p>HTTP3 改成了UDP！<br>UDP不管顺序，不管丢包，不会出现队头阻塞，也不会出现丢包全部重传问题。</p><p>UDP不可靠，那么怎么实现类似TCP可靠呢？<br>QUIC协议保证。当某个流发生丢包，会阻塞这个流，其他流不受影响。然后是TLS1.3 把6次TCP+TLS握手合并为3次QUIC。<br>QUIC是一个UDP之上的伪TCP+TLS+HTTP2的多路复用协议。</p><h2 id="Q：一次请求发生了什么？"><a href="#Q：一次请求发生了什么？" class="headerlink" title="Q：一次请求发生了什么？"></a>Q：一次请求发生了什么？</h2><p>一是对URL解析，来确定是发送给WEB服务器请求。<br>包括协议头，服务器host，uri路径。<br>二是查询真真实IP，使用DNS服务器解析。在发送消息前，委托系统查询DNS服务器域名的真实IP。DNS服务器具有树状的层级，根域服务器保存所有域名，顶级域名服务器更少，只保存com或cn后缀的，权威域名保存更少，同时服务器数量也更多。<br>解析过程：客户端发出DNS请求，询问IP，在本地DNS服务器找，如果有自己返回IP，如果没有，委托根域名，根域名委托对应的顶级域名服务器，顶级域名服务器委托对应的权威域名服务器。权威域名服务器找到IP，告诉本地DNS缓存。</p><p>三是协议栈 封装<br><figure class="image-box">                <img src="3786F82F-6457-4550-A5A9-F1596205ABCA_20220228150247.png?v=1&type=image&token=V1:oAbMgcxeh4dd0mWA7fwzOxMQAo_vAQ8ncn8Cu-rEqrw" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><br>通过DNS获取IP后，就可以把HTTP的传输工作交给OS的协议栈。<br>协议栈的内部分为几部分，分别承担不同工作，上下关系有一定规则，上面会向下委托公，下面收到委托并执行。</p><p>应用程序通过调用socket 库，来委托协议栈工作，协议栈的上方分别是收发数据的TCP和UDP协议，下方是IP协议控制网络包的收发操作，在互联网上传数据时，数据会被切成一块块的网络包，而将网络包发送给对方的操作就是有IP负责。</p><p>IP包括ICMP协议 和ARP协议。<br>ICMP时告知网络包传输过程中产生的错误和各种控制信息。<br>ARP 是根据IP地址查询相应的以太网MAC地址。</p><p>IP下面是网卡驱动程序，负责控制网卡硬件。最下是网卡硬件，真正的网络信号的收发操作</p><p>四，细看，可靠传输TCP<br>先讲讲TCP，序号解决包乱序，校验和解决完整性，窗口大小声明窗口大小，解决两端流量处理能力的控制。此外，拥塞控制，控制发送的速度。</p><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><ul><li><p>一开始，客户端和服务端都处于  <code>CLOSED</code>  状态。先是服务端主动监听某个端口，处于  <code>LISTEN</code>  状态。</p></li><li><p>然后客户端主动发起连接  <code>SYN</code>，之后处于  <code>SYN-SENT</code>  状态。</p></li><li><p>服务端收到发起的连接，返回  <code>SYN</code>，并且  <code>ACK</code>  客户端的  <code>SYN</code>，之后处于  <code>SYN-RCVD</code>  状态。</p></li><li><p>客户端收到服务端发送的  <code>SYN</code>  和  <code>ACK</code>  之后，发送  <code>ACK</code>  的  <code>ACK</code>，之后处于  <code>ESTABLISHED</code>  状态，因为它一发一收成功了。</p></li><li><p>服务端收到  <code>ACK</code>  的  <code>ACK</code>  之后，处于  <code>ESTABLISHED</code>  状态，因为它也一发一收了。</p></li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><p>查看连接命令： netstat - napt 命令</p><h3 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h3><p>如果HTTP消息过长，超过了MSS的长度。<br>TCP 就要把HTTP的数据拆解一块块的数据发送，而不是一次性发送。</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为  <code>1500</code>  字节。</li></ul><ul><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被拆为MSS长度的单位，并加上TCP头，然后交给IP模块发送数据。</p><p>TCP会有两个端口，一个是浏览器监听 的短裤，随机，一个是服务器监听的80或443</p><figure class="image-box">                <img src="1ADA371D-52C5-44D6-9231-F5087EA7028A_20220228214150.png?v=1&type=image&token=V1:W1SnXQS3hWpVDWnHs53IsS8_HVJPDaPjIDjB3kjENfE" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>双方建立连接后，TCP报文的数据部分就是存放HTTP头+数据，组装好TCP报文之后，要交给下面的网络层处理</p><h3 id="远程定位-—-IP"><a href="#远程定位-—-IP" class="headerlink" title="远程定位 —- IP"></a>远程定位 —- IP</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p></blockquote><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p><h3 id="两点传输-—-MAC"><a href="#两点传输-—-MAC" class="headerlink" title="两点传输 — MAC"></a>两点传输 — MAC</h3><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><p><code>0800</code>  ：IP 协议</p></li><li><p><code>0806</code>  ：ARP 协议</p></li></ul><p>先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给  <code>Gateway</code>  列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要  <code>ARP</code>  协议帮我们找到路由器的 MAC 地址。</p><ul><li><p>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</p></li><li><p>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。如果对方和自己处于同一个子网中，那么就可以得到对方回应的 MAC 地址。</p><figure class="image-box">                <img src="A2E4BDD3-A5A6-44FA-8DFB-1E15722CE355_20220228221916.png?v=1&type=image&token=V1:RuUiMFuU-xJwTZUlj7ESjyJf8vlHyb066kLrMrfYN4s" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><h4 id="出口—-网卡"><a href="#出口—-网卡" class="headerlink" title="出口— 网卡"></a>出口— 网卡</h4><p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p></li></ul><p>网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS</strong>。</p><h4 id="送别者—-交换机"><a href="#送别者—-交换机" class="headerlink" title="送别者—-交换机"></a>送别者—-交换机</h4><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li><p>一个是设备的 MAC 地址，</p></li><li><p>另一个是该设备连接在交换机的哪个端口上。</p></li></ul><p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><h4 id="出境大门-—-路由器"><a href="#出境大门-—-路由器" class="headerlink" title="出境大门 — 路由器"></a>出境大门 — 路由器</h4><p>路由器是基于IP设计，俗称三层网路设备，各个端口都有MAC地址和IP地址；<br>而交换机是基于以太网设计，俗称二层网络设备，端口不具备MAC地址。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li><p>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</p></li><li><p>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</p></li></ul><p>知道对方的 IP 地址之后，接下来需要通过  <code>ARP</code>  协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>（城门）到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。（服务器内网）</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><h3 id="互相扒皮—-服务器-与-客户端"><a href="#互相扒皮—-服务器-与-客户端" class="headerlink" title="互相扒皮— 服务器 与 客户端"></a>互相扒皮— 服务器 与 客户端</h3><p>应用层 HTTP<br>传输层 TCP<br>网络层 IP<br>链路层 以太网MAC<br>从高到低封装，从低到高拆解。</p><p>当 扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>———————<br>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><h3 id="扩展-ping原理-ICMP协议"><a href="#扩展-ping原理-ICMP协议" class="headerlink" title="扩展 ping原理 ICMP协议"></a>扩展 ping原理 ICMP协议</h3><p>也就是<strong>互联网控制报文协议</strong>，<code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p><h2 id="细说-TCP"><a href="#细说-TCP" class="headerlink" title="细说 TCP"></a>细说 TCP</h2><p>首先，介绍TCP 头部格式。<br><figure class="image-box">                <img src="797DA83E-0574-4D7F-82CC-3440F36357D5_20220228224408.png?v=1&type=image&token=V1:XWMOSp193u83j6GshiGPmz4BIwQWv6PlX8pyz8iT894" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure></p><p>序列号：在建立连接时由计算机生成的随机数作为初始值，通过SYN包传输给接收端，每一次累加该数据字节的大小，解决乱序问题。</p><p>确认应答号：指下一次期望收到的数据的序列号，用来解决不丢包问题。</p><p>控制位：确认答应，异常断开，chu，结束</p><h3 id="Q：为什么需要-TCP-协议？TCP-工作在哪一层？"><a href="#Q：为什么需要-TCP-协议？TCP-工作在哪一层？" class="headerlink" title="Q：为什么需要 TCP 协议？TCP 工作在哪一层？"></a>Q：为什么需要 TCP 协议？TCP 工作在哪一层？</h3><figure class="image-box">                <img src="858E392E-2252-4CEA-A6B2-87A10AC1A95D_20220228225120.png?v=1&type=image&token=V1:OVmGFxz0wgPu7a6SeFkKHnHEzk7UBhhYa7LWsxI8GDs" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><h3 id="Q：什么是-TCP-？"><a href="#Q：什么是-TCP-？" class="headerlink" title="Q：什么是 TCP ？"></a>Q：什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><ul><li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p></li></ul><h3 id="Q：什么是TCP连接？"><a href="#Q：什么是TCP连接？" class="headerlink" title="Q：什么是TCP连接？"></a>Q：什么是TCP连接？</h3><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><h3 id="Q：如何唯一确定一个TCP连接？"><a href="#Q：如何唯一确定一个TCP连接？" class="headerlink" title="Q：如何唯一确定一个TCP连接？"></a>Q：如何唯一确定一个TCP连接？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li><p>源地址</p></li><li><p>源端口</p></li><li><p>目的地址</p></li><li><p>目的端口</p></li></ul><h3 id="Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:<br>最大TCP连接数 = 客户端IP数 x 客户端端口数<br>对于IPv4，2的32次方IP ，2的16次方端口，最大TCP连接数是2的48次方。</p><p>这是理论值，实际上：<br>Linux 文件描述符限制，socket是fd文件，打开句柄 1024，这个可调。<br>另一个是内存限制，每个TCP连接占用一定的内存。</p><h3 id="Q：UDP和TCP区别与场景？"><a href="#Q：UDP和TCP区别与场景？" class="headerlink" title="Q：UDP和TCP区别与场景？"></a>Q：UDP和TCP区别与场景？</h3><p>UDP 不提供控制机制，利用IP提高的无连接通信<br>UDP 协议简单，头部8字节，分别是 16位源端口，16位目标端口，16位包长度，16位校验和</p><p>区别：<br>1，连接<br>TCP面向连接，传输数据前先建立连接<br>UDP无连接<br>2，服务对象<br>TCP连接一对一<br>UDP一对一，一对多，多对多广播<br>3，可靠性<br>TCP可靠，校验和保证无差错，确认答应号保证不丢失，序号保证不重复，顺序性，<br>UDP不可靠，只是尽最大努力交付<br>4，拥塞控制，流量控制<br>TCP拥塞控制和流量控制，保证数据传输多安全性；<br>UPD即使网络非常堵塞，也不影响UDP发送速率<br>5，首部开销<br>TCP首部长度较长，不包括【选项】，20字节；<br>UDP首部只有8字节</p><p>6，应用场景<br>TCP：FTP文件传输 HTTP/HTTPS<br>UDP：DNS，视频，音频，广播通信</p><h3 id="Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h3><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><p>选项 常见：MSS最长报文大小</p><h3 id="Q：为什么是3次握手？不是两次，四次？"><a href="#Q：为什么是3次握手？不是两次，四次？" class="headerlink" title="Q：为什么是3次握手？不是两次，四次？"></a>Q：为什么是3次握手？不是两次，四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”但是，回答过于片面。<br>首先，了解TCP连接的连接概念。</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>那么，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接</strong></p><p>接下来，我从3个方面回答：</p><ul><li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）</p></li><li><p>三次握手才可以同步双方的初始序列号</p></li><li><p>三次握手才可以避免资源浪费</p></li></ul><p>原因一：避免历史连接<br>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong>。</p><p>如果旧SYN报文比当前SYN报文先抵达到服务端，服务端会返回SYN+ACK，客户端根据自身上下问题，判断是旧连接，那么客户端发送RST报文，表示中断这一次连接。舍弃之前的，重新开始新的SYN。</p><p>如果是两次握手，服务端就不能判断出历史连接而中断。</p><ul><li><p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是  <code>RST</code>  报文，以此中止历史连接；</p></li><li><p>如果不是历史连接，则第三次发送的报文是  <code>ACK</code>  报文，通信双方就会成功建立连接；</p></li></ul><p>原因二：同步双方初始序列号<br>TCP协议双方，都必须维护一个序列号，序列号是可靠传输的关键：可以去重，可以顺序接收，可以表示哪些数据包已经被对方接收。</p><p>第一次客户端发送初始序列号SYN，服务端需要ACK回应，同时发生自己的出生序列号SYN，客户端当然也要回应接收。<br>这样来回，次确保双方初始序列号被对方知晓。</p><p>原因三：避免资源浪费</p><p>如果只有两次握手，服务器ACK不知道客户端是否已经接收，这就导致服务端每次收到SYN就主动建立一个连接，这就有个问题，如果客户端SYN传输被网络阻塞，而引起了超时重发，之后阻塞的SYN也终于发送到服务端，意味着服务端接收了2次相同的SYN，服务器会重复处理请求，造成重复分配资源。</p><p>小结：三次握手是为了防止历史连接的 建立，帮助双方初始化序列号，减少重复资源的开销。<br>两次握手无法做到以上这些，四次握手显得多余。</p><h3 id="Q：为什么客户端和服务端的初始序列号ISN不相同？"><a href="#Q：为什么客户端和服务端的初始序列号ISN不相同？" class="headerlink" title="Q：为什么客户端和服务端的初始序列号ISN不相同？"></a>Q：为什么客户端和服务端的初始序列号ISN不相同？</h3><p>报文延迟，复制重发，丢失等造成不同连接之间互相影响，客户端和服务端初始化序列号不同，是为了兼容这些问题环境。</p><h3 id="Q：IP层会分片，TCP为什么要MSS？"><a href="#Q：IP层会分片，TCP为什么要MSS？" class="headerlink" title="Q：IP层会分片，TCP为什么要MSS？"></a>Q：IP层会分片，TCP为什么要MSS？</h3><p>首先介绍MTU 和 MSS。<br>MTU： 一个网络包的最大长度，以太网中一般位1500字节。<br>MSS：一个减去IP 和TCP 头部的网络包数据的最大长度</p><p>如果仅TCP报文交给IP分片，IP层超过一个MTU大小的数据发送，就要进行分片，把数据分片成若干片，保证每一个分片都小于MTU。分片后，由目标主机的IP层重新组装，再交给TCP传输层。</p><p>这里存在一个隐患，如果一个IP分片丢失，就需要整个IP报文的所有分片重传，因为IP层没有超时重传机制，那么，它由传输层TCP来负责超时和重传，接收方发现缺失，不会响应ACK，而是等对方超时后，重发整个TCO报文。</p><p>这样，非常无效率。</p><p>所以，TCP建立连接时，双方协商MSS值，当TCP层发现数据超过MSS时，就会先分片，他肯定不会大于MTU。IP自然不用分片。</p><p>经过TCP层分片后，如果TCP分片丢失，超时重发只是发送一个MSS单位的分片，大大增加重传的效率？</p><h3 id="Q：SYN攻击是什么？如何避免？"><a href="#Q：SYN攻击是什么？如何避免？" class="headerlink" title="Q：SYN攻击是什么？如何避免？"></a>Q：SYN攻击是什么？如何避免？</h3><p>就是在三次握手过程，攻击者伪造不同IP一直发送SYN报文，服务端接收后，就进入SYN_RCVD状态，且服务端发送ACK+SYN报文无回应，久而久之就会占满SYN接收队列（未连接队列），使得服务器不能正常给用户连接。</p><p>如何避免？<br>一是修改Linux内核参数，控制队列大小和饱和策略。<br>比如，限制SYN_RCVD状态连接的最大个数，超出处理能力时，采取丢弃策略。</p><p>二是启动sync cookies<br>首先，正常情况下：</p><ul><li><p>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</p></li><li><p>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</p></li><li><p>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</p></li><li><p>应用通过调用  <code>accept()</code>  socket 接口，从「 Accept 队列」取出的连接。</p></li><li><p>如果accept方法调用过慢时，就会导致「 Accept 队列」被占满。</p></li><li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li></ul><p>但开启sync cookies 后</p><ul><li><p>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</p></li><li><p>计算出一个  <code>cookie</code>  值，再以 SYN + ACK 中的「序列号」返回客户端，</p></li><li><p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</p></li><li><p>最后应用通过调用  <code>accpet()</code>  socket 接口，从「 Accept 队列」取出的连接。</p></li></ul><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>客户端发送首部FIN=1 的TCP报文，即FIN报文，之后进入FIN等待1状态。<br>服务端接收后响应ACK，进入等待关闭状态。<br>客户端接收ACK后，进入FIN等待2状态<br>等服务处理后面，再发送FIN报文，然后进入等待最后ACK状态。<br>客户端收到后，会一个ACK，进入时间等待状态TIME_WAIT。<br>服务器收到后，关闭连接。<br>服务端经过2MSL时间后，关闭连接。</p><p>每个方向都需要FIN 和 ACK，这里需要注意，TIME_WAIT是主动关闭连接才有</p><h4 id="Q：-为什么四次挥手？"><a href="#Q：-为什么四次挥手？" class="headerlink" title="Q： 为什么四次挥手？"></a>Q： 为什么四次挥手？</h4><p>因为双方都需要分开发送一个FIN 和分开响应一个ACK，来告知和确认。</p><h4 id="Q：为什么TIME-WAIT等待是2MSL？"><a href="#Q：为什么TIME-WAIT等待是2MSL？" class="headerlink" title="Q：为什么TIME_WAIT等待是2MSL？"></a>Q：为什么TIME_WAIT等待是2MSL？</h4><p>MSL是最大报文生存时间，它是任何报文在网络上生存的最长时间。<br>顺便一提，TTL是经过路由的跳数。MSL要大于等于TTL消耗位0的时间。</p><p>TIME_WAIT持续2倍MSL，在Linux中是60s，说白来，这其实是要等报文一来一回的时间。<br>比如，如果对方没有接收到最后ACK，超时重传FIN报文，然后我接收到FIN报文，ACK与重传FIN 正好一来一回，2MSL足够时间让我接收重传的FIN报文，之后，我重发ACK，2MSL重新计时。</p><h4 id="Q：为什么需要TIME-WAIT？"><a href="#Q：为什么需要TIME-WAIT？" class="headerlink" title="Q：为什么需要TIME_WAIT？"></a>Q：为什么需要TIME_WAIT？</h4><p>原因一 ： 防止旧连接的数据包<br>比如，双方关闭连接后，服务端的相同端口号的TCP连接被重用。<br>如果TIME_WAIT没有或过短，上一次由服务器发送，但被网络阻塞的报文，会现在发送过来给一个新的客户端，导致数据错乱。<br>等待2MSL时间，保证服务器所有数据包自然死亡。</p><p>原因二：保证连接正确关闭：<br>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>如果TIME_WAIT没有或过短，</p><ul><li><p>客户端四次挥手的最后一个  <code>ACK</code>  报文如果在网络中被丢失了，此时如果客户端  <code>TIME-WAIT</code>  过短或没有，则就直接进入了  <code>CLOSE</code>  状态了，那么服务端则会一直处在  <code>LASE-ACK</code>  状态。</p></li><li><p>当客户端发起建立连接的  <code>SYN</code>  请求报文后，服务端会发送  <code>RST</code>  报文给客户端，连接建立的过程就会被终止。</p></li></ul><h4 id="Q：TIME-WAIT-过多有什么危害？"><a href="#Q：TIME-WAIT-过多有什么危害？" class="headerlink" title="Q：TIME_WAIT 过多有什么危害？"></a>Q：TIME_WAIT 过多有什么危害？</h4><ul><li><p>第一是内存资源占用；</p></li><li><p>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</p></li></ul><h4 id="Q：-如何优化TIME-WAIT？"><a href="#Q：-如何优化TIME-WAIT？" class="headerlink" title="Q： 如何优化TIME_WAIT？"></a>Q： 如何优化TIME_WAIT？</h4><p>一是可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。<br>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p><p>由于引入了时间戳，我们在前面提到的  <code>2MSL</code>  问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><p>温馨提醒：<code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持  <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。小林在工作中就遇到过。。。排查了非常的久</p><p>二是当系统中处于 TIME_WAIT 的连接<strong>一旦超过一个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong>，问题更多</p><p>三是我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><h4 id="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><figure class="image-box">                <img src="88C54A0C-F18F-40A7-80F3-578C2C001BB3_20220301030128.png?v=1&type=image&token=V1:Yz1FxBY8R886pfetwNkycQ_fy2Zif_dTF5s4IPh4cbw" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><ul><li><p>服务端和客户端初始化  <code>socket</code>，得到文件描述符；</p></li><li><p>服务端调用  <code>bind</code>，将绑定在 IP 地址和端口;</p></li><li><p>服务端调用  <code>listen</code>，进行监听；</p></li><li><p>服务端调用  <code>accept</code>，等待客户端连接；</p></li><li><p>客户端调用  <code>connect</code>，向服务器端的地址和端口发起连接请求；</p></li><li><p>服务端  <code>accept</code>  返回用于传输的  <code>socket</code>  的文件描述符；</p></li><li><p>客户端调用  <code>write</code>  写入数据；服务端调用  <code>read</code>  读取数据；</p></li><li><p>客户端断开连接时，会调用  <code>close</code>，那么服务端  <code>read</code>  读取数据的时候，就会读取到了  <code>EOF</code>，待处理完数据后，服务端调用  <code>close</code>，表示连接关闭。</p></li></ul><p>这里需要注意的是，服务端调用  <code>accept</code>  时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><h3 id="Q：-listen-时候参数-backlog-的意义？"><a href="#Q：-listen-时候参数-backlog-的意义？" class="headerlink" title="Q： listen 时候参数 backlog 的意义？"></a>Q： listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p><ul><li><p>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</p></li><li><p>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</p></li></ul><figure class="image-box">                <img src="E5A16EFC-F8E5-413F-A373-A9AE832AB3EA_20220301030414.png?v=1&type=image&token=V1:IrGEHjzfy7HoFoFVvIODOCSedyypxsuKtA6k7XErHQs" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><h4 id="Q：什么是-TCP-半连接队列和全连接队列？"><a href="#Q：什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="Q：什么是 TCP 半连接队列和全连接队列？"></a>Q：<strong>什么是 TCP 半连接队列和全连接队列？</strong></h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p><p>半连接队列，也称 SYN 队列；全连接队列，也称 accepet 队列；服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来</strong>。</p><p><img src="3b87e950352ac65c20611873e5e4751793138a62.jpeg" alt="img"></p><h3 id="Q：accept-发送在三次握手的哪一步？"><a href="#Q：accept-发送在三次握手的哪一步？" class="headerlink" title="Q：accept 发送在三次握手的哪一步？"></a>Q：accept 发送在三次握手的哪一步？</h3><figure class="image-box">                <img src="2F2DCEA4-F84A-44B5-B5FD-F3F1F9292894_20220301030519.png?v=1&type=image&token=V1:E9Nf8kAwwyq1S2JJ4Qqf53TxBVbnze5R7dw2mCAKtEA" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><h3 id="Q：客户端调用-close-了，连接是断开的流程是什么？"><a href="#Q：客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="Q：客户端调用 close 了，连接是断开的流程是什么？"></a>Q：客户端调用 close 了，连接是断开的流程是什么？</h3><figure class="image-box">                <img src="FF99FD84-160C-451C-9D75-9BA45177F732_20220301030633.png?v=1&type=image&token=V1:Gby9jS5wb0Zu6mRJVZlZ6LovpSaNhvuwrtvx92VrAoM" alt="输入图片描述" title class>                <p>输入图片描述</p>            </figure><p>————————————————</p><h4 id="Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？"><a href="#Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？" class="headerlink" title="Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？"></a>Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？</h4><p>如果有保活机制</p><ul><li><p>如果<strong>对端程序是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p></li><li><p>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p></li></ul><p>没有的话：</p><p>如果客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程</p><p>kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。<br>如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p><ul><li><p>第一种，客户端主机宕机，又迅速重启，会发生什么？</p></li><li><p>第二种，客户端主机宕机，一直没有重启，会发生什么？</p></li></ul><p>客户端主机宕机，又迅速重启</p><p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p><p>客户端主机宕机，一直没有重启</p><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了</p><h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p><figure class="image-box">                <img src="image-20210921112213523.png" alt="img" title class>                <p>img</p>            </figure><p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p><h2 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><figure class="image-box">                <img src="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p><p> 当 cwnd &lt; ssthresh 时，使用慢开始<a href>算法</a>。</p><p> 当 cwnd &gt; ssthresh 时，停止使用慢开始<a href>算法</a>而改用拥塞避免<a href>算法</a>。</p><p> 当 cwnd = ssthresh 时，既可使用慢开始<a href>算法</a>，也可使用拥塞控制避免<a href>算法</a>。</p><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始<a href>算法</a>。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p><p>快重传<a href>算法</a>可以避免这个问题。快重传<a href>算法</a>首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p><p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免<a href>算法</a>，使拥塞窗口缓慢地线性增大。</p><p>在采用快恢复<a href>算法</a>时，慢开始<a href>算法</a>只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><p>常见重传机制：</p><p>超时重传</p><p>快速重传</p><p>SACK</p><p>D-SACK</p><h1 id="TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解"></a>TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解</h1><p><a href="https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA</a></p><h1 id="精炼版"><a href="#精炼版" class="headerlink" title="精炼版"></a>精炼版</h1><p><a href="https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis | 底层数据结构 | 主从复制</title>
      <link href="/2022/02/10/redis-principle-cluster/"/>
      <url>/2022/02/10/redis-principle-cluster/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="讲讲Redis的5种数据结构的理解"><a href="#讲讲Redis的5种数据结构的理解" class="headerlink" title="讲讲Redis的5种数据结构的理解"></a>讲讲Redis的5种数据结构的理解</h4><p>5种，字符串，列表，哈希表对象，集合set，有序集合zset。<br>Redis对象有统一的数据结构，RedisObj，里面包含对象类型，对象底层实现数据结构标识encoding，指向底层结构的指针。</p><p>先说<strong>字符串</strong>：<br>底层是名为SDS的结构，有buf字节数组，对应长度，未使用空间长度。好处是：<br>1.O(1)定位长度，<br>2.对\0兼容的二进制安全，<br>3.追加字符串，可利用未使用空间，减少内存重新分配空间次数；<br>4.空间不够时，通过自动分配新空间而不会像strcat函数引起缓冲区溢出：小于1MB，按2倍扩容，扩容阈值为1MB。<br>5.用5种不同大小的SDS，灵活保存，节省内存看空间。</p><ol start="6"><li>空间节省还体现在编译优化上，我们先了解，编译器会有一个字节数对齐的工作，以更好地让CPU对内存的规整读写。SDS取消字节对齐，压缩空间。比如，结构体有char，int，对齐下是4+4字节，压缩后1+4字节。</li></ol><p>不过，空间只增不减，需要手动调API惰性释放</p><p><strong>列表</strong><br>双向链表或压缩列表，3.2后用quicklist，50后用了listpack<br>双向链表<br>表头：头节点指针，尾节点指针，长度<br>节点：前驱指针，后驱指针，值指针</p><p>插入多时会比数组好，但不连续内存存储，产生空间碎片，无法利用CPU缓存；多出存储头尾节点的空间开销；</p><p><strong>压缩列表</strong><br>内存紧凑列表，没有所谓对齐空闲，很好利用CPU缓存；<br>表头3个，整体字节数，尾部偏移量，节点数，表尾1个，8位1结束标记；<br>节点内部：上个节点长度，当前节点类型及长度，节点数据</p><p>这种设计，大大节省内存空间。<br>举例：<br>列表中存储字符串，如果用双链表，<strong>每个节点有三个指针，加上SDS的2个长度的存储，再加上字符串本身</strong>。32位操作系统，一个指针6-7字节左右，三指针占<strong>18字节</strong>；<br>如果字符串是个位数，基本每个整数占用1个字节，加起来20个字节左右，不包含字符串本身。<br>当<strong>开启压缩列表</strong>，存储结构变化，它会按照序列化的形式存储，每个节点除了存储字符串本身，<strong>只需存2个整数，一个是前一个节点的字符串长度，另一个是当前节点字符串类型长度。</strong>若它是个位数长度，只需每个整数只占1个字节，总之，字符串本身加上两个字节的额外开销，跟之前字符串加上20字节的额外开销，差了N陪。这样，开启压缩列表，每项存储节省18字节。在此情况，做内存节省，适当将redis里的列表长度的阈值调整，<strong>默认512调整到2048或1024</strong>，不建议特别大。这样满足更长列表的列表压缩，节省更多空间。</p><p>但是，压缩列表会产生一定的性能消耗<br>一是读写过程需要编码解码；<br>二是连锁更新问题。新增或修改元素时，一旦空间不够了，压缩列表就会重新分配。特别是插入元素较大，会导致后续的上个节点长度的整型记录发生连锁空间变大，即后续所有空间都要重新分配，造成访问压缩列表的性能下降。<br>比如，前节点原本长度小于254字节，prevlen上节点长度只需1字节空间保存，如果前节点增大超过253，prevlen上节点长度要用5字节保存，而这，又导致当前节点的增大，同样，下一个节点为了记录当前节点长度，也要增大，这是一个多米诺牌的效应。</p><p>结论是，压缩列表保存小数据和几乎不变的数据，控制在连锁更新能够接受的尺度。</p><p><strong>哈希桶 Hash</strong><br>底层是压缩列表 + 字典，新版本有变化，压缩列表改为listpack<br>压缩列表已经讲过，这里主要是用来存储键key。<br>字典的结构是：2个ht哈希表，ht指向dictEntry哈希节点数组，数组元素指向dictEntry哈希节点链表；<br>1.先说哈希节点，内有key，v，next三个指针，v是联合体结构，里面val有两种含义，一种是8字节指针，一种是8字节长度整型或浮点数，无指向，空间节省优化。</p><p>2.采用数组+链表，是解决哈希冲突的链式哈希法。一个ht哈希表内部有数组，数组大小，掩码，节点数量；set的时候，通过key.hash对掩码与运输，定位数组桶位，头插法插入链表。</p><p>3.扩容缩容时的渐进式rehash。与hasmap不同，rehash执行过程分散到crud过程，减少单次set操作的性能开销。利用两个ht哈希表实现，一个ht用于存储旧数据；另一个空ht用于扩缩容数组。当达到负载因子阈值，空ht会扩容2倍，新数据进入到在新数组，同时，旧数据在每次crud时分批分次迁移。这是一种归并思想。</p><p><strong>集合（sadd）</strong><br>底层是整数集合或字典<br>字典已经介绍过。<br>下面介绍<br>整数集合intset<br>内部有：元素编码，数量，数组<br>优点：</p><ol><li>连续内存空间，规整的元素大小划分，减少空间碎片</li><li>升级操作，针对不同规格的类型，选择编码合适的集合。当新元素超过当前编码，比如int16集合中新增int32，会对整个集合进行一个大小的升级。好处是节省内存资源。</li></ol><p>不过，只增不减。</p><p><strong>有序集合（Zset）</strong><br>底层是压缩列表或跳表。新版压缩列表改为listpack。</p><p>跳表<br>一个带有层级关系的有序双向链表。<br>主要介绍三个参数，层级，分值，跨度。<br>每个节点有随机层级，不同层级有不同跨度的指向关系，越高层级跨度越大。利用浮点数分值的有序性，实现一种下楼梯式地层层检索，似二分查询，沿途跳过过多少节点，就是节点跨度。<br>还有前进指针和后退指针，后推指针用于从尾到头的检索。<br>好处是，查询效率下降一定小于log（N），且保持顺序性。</p><p>能够实现排行榜。</p><p>3.2版本的<br>quicklist<br>跟链表类似，区别是节点val采用了压缩列表指针，并额外存储字节大小，元素个数，能控制压缩列表的大小或者元素个数，规避潜在的连锁更新风险，并没有完全解决</p><p>5.0版本的<br>listpack<br>为了解决连锁更新问题，listpack代替压缩列表，舍弃前一个节点长度。<br>结构是：表头： 字节数，元素数量，表尾：结束标识<br>节点：编码，数据，编码+数据总长度。</p><h2 id="Redis-3种高级结构"><a href="#Redis-3种高级结构" class="headerlink" title="Redis 3种高级结构"></a>Redis 3种高级结构</h2><p>bitmaps<br>01数组，实际上String类型上的一组面向bit操作的集合。<br>用于活跃用户统计，布隆过滤器</p><p>HyperLogLogs<br>是用来做基数统计的算法，HyperLogLogs 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>底层是散列出1w多个6bit的桶。类似bitmaps</p><p>实现滑动时间的UV数据统计</p><p>GEO<br>地理坐标<br>使用了GeoHash编码后，经纬度[120,40]就被编码成了1110011101，这个值就可以作为key对应的score值，把二维变成一维。</p><p>pipeline<br>网络管道技术，降低RT次数。<br> pipeline打包命令发送，节省网络时间。pipeline不是原子操作。<br> pipeline都会将数据顺序的传送顺序地返回（redis 单线程）</p><p>脚本<br> 大量 pipeline 应用场景可通过  <strong>Redis 脚本</strong>（Redis 版本 &gt;= 2.6）得到更高效的处理，后者在服务器端执行大量工作。脚本的一大优势是可通过最小的延迟读写数据，让读、计算、<strong>写等操作变得非常快（pipeline 在这种情况下不能使用，因为客户端在写命令前需要读命令返回的结果</strong>）。</p><h2 id="数据库空间"><a href="#数据库空间" class="headerlink" title="数据库空间"></a>数据库空间</h2><p>数据库空间是16隔DB，包括键-值空间和键-过期时间的字典。</p><h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p>每一个键定时删除，CPU开销大；<br>每一次查询检查的惰性删除，容易内存泄露；<br>设置时间定期一次性检查删除，需要合理的频率和执行时长；<br>默认惰性+定期</p><p>RDB AOF对过期键的处理：<br>不同点：二者在主从服务器保持数据一致性载入文件对过期键的方式不同。<br>RDB文件，1.主服务器运行时载入会判断过期键不载入；2.从服务器运行时载入不会判断全载入，因为在主从服务器保持数据一致性时会先删除从服务器数据。<br>AOF文件，1.主服务器运行时载入判断过期键会在AOF文件中追加一条del命令；2.从服务器对过期键暂不处理，因为在主从服务器保持数据一致性时，主服务器统一发送del命令，从服务器才会处理过期键;AOF文件处理过期键是由主服务期统一管理。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>用引用计数器，因为没有循环引用。</p><h2 id="AOF持久化日志"><a href="#AOF持久化日志" class="headerlink" title="AOF持久化日志"></a>AOF持久化日志</h2><p>只记录写命令操作，追加方式；<br>先执行成功再记录<br>好处：<br>一是避开额外的检查开销<br>二是不会阻塞当前写操作命令执行；<br>风险：<br>一是非原子操作，未及时刷盘导致丢失<br>二是redis单线程写日志，受限于IO压力，可能给下一个命令造成阻塞</p><p>这都给写硬盘的时机有关</p><h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>写入过程：命令追加至AOF缓存区，然后write调用拷贝至内核缓冲区，等待内核刷盘，什么时候刷盘，由内核决定<br>Redis刷盘的3种策略：<br>Always：总是，每次同步<br>Everysec：每隔一秒<br>No：转交给系统控制</p><p>要么减少数据丢失，要么阻塞主进程，高可靠，高性能只能选其一；</p><p>系统刷盘函数：fsync（）</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>为了解决AOF日志过大问题，AOF会读取当前数据库所有数据，生成新的AOF文件，再进行旧AOF日志一次性覆盖。</p><p>AOF重写由<strong>子进程</strong>完成，避免阻塞主线程。<br>不使用线程是因为，多线程内存共享，修改 共享数据，需要加锁保证数据安全，降低性能。父子进程的采用数据副本，通过fork，系统把父进程的页表复制给子进程，页表是记录虚拟内存映射关系，不会物理复制。也就是说，虚拟空间不同，物理空间相同。<br>这样，实现内存共享，不过只标记为可读。当父子任意一方进行写一个页表项，CPU就会触发违反权限导致的缺页中断机制，会进行一部分页表项的物理复制，并重新调整映射，该过程就是写时复制：写操作时，才会对在写的物理内存复制。防止整体内存复制过长而引发父进程写阻塞当问题。<br>当然，复制进程页表，父进程会阻塞，但页表其实很小，开销不大。对在写的物理内存复制也会阻塞，这要数据量大小。如果是个bigkey，就有阻塞风险。</p><p>如果AOF重写过程中，主进程写入导致两块物理内存不一致，怎么办呢？<br>增加AOF重写缓冲区：重写AOF期间，写命令写入到”AOF缓冲区“与”AOF重写缓冲区“。<br>正常写入”AOF缓冲区“，是为了保证旧AOF文件日志也是ok的；<br>AOF文件重写工作完成后，此时还没覆盖旧AOF日志，会向主进程发送信号，这是进程之间的异步通信方式。</p><p>主进程接收到信号，把AOF重写缓冲区追加到新的AOF中，再把旧AOF日志覆盖。这个过程是阻塞的</p><p>整个过程，进程页表复制，写时复制，信号接收处理，都是阻塞的。其他情况不阻塞。</p><h2 id="RDB-快照-默认"><a href="#RDB-快照-默认" class="headerlink" title="RDB 快照  默认"></a>RDB 快照  默认</h2><p>所谓快照，就是记录一瞬间的东西，好比拍一张照片。</p><p>RDB记录某一个瞬间的二进制内存数据，是全量快照，而AOF是命令日志</p><p>好处是Redis要恢复数据时，RDB效率更高。</p><p>提供了两个命令：<br>save 和 bgsave： 区别是是否在主进程执行。<br>开启以后，会定期执行保存，这是比较重的操作，这个频率要控制。</p><p>缺点：<br>发送宕机时，RDB记录旧的数据，比秒级AOF丢失更多。</p><p>执行快照时，数据能被修改吗？<br>可以，使用bgsave，也是子进程写时复制技术。<br>能同步刚修改的数据吗？<br>不同步，只能交由下一次bgsave操作。</p><h2 id="RDB和AOF-混合文件持久化"><a href="#RDB和AOF-混合文件持久化" class="headerlink" title="RDB和AOF 混合文件持久化"></a>RDB和AOF 混合文件持久化</h2><p>为了高可用和高性能，控制持久化好频率。</p><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，RDB写入完成后通知主进程，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，然后，将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>，不再有AOF全量数据。</p><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p><h2 id="缓存三个异常问题"><a href="#缓存三个异常问题" class="headerlink" title="缓存三个异常问题"></a>缓存三个异常问题</h2><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>大量缓存失效，同一时间过期或者Redis 宕机。<br>导致Mysql压力剧增，引发系统崩溃。</p><p>解决：<br>如果是缓存过期：<br>在设置缓存时，提前过期时间散列化，增加随机数；</p><p>如果访问缓存不存在，使用互斥锁，保证一个时间内只有一个请求来构建缓存。其他请求等待完成。当然，要设置超时时间，防止长时间阻塞。但锁开销大。</p><p>主备双key，一个主key，有过期时间；一个备key，永久缓存。<br>但，更新缓存需要同时更新主备双key。</p><p>定期程序更新，缓存不设置过期时间。<br>但，导致缓存紧张，引发淘汰策略。<br>解决上面可以用：<br>一是线程不仅要定期更新缓存，还要频繁检查缓存是否有效，就是把BD和缓存对比检查，有被淘汰的，就马上读取DB更新缓存。几乎实时，不然只查到空值。不推荐</p><p>二是消息队列，发现数据淘汰后，通过消息队列发送一条消息到后台线程，后台线程接收消息，先检查缓存是否存在，再读取DB更新到缓存。</p><p>在业务上线，要把缓存先加载，这就是所谓缓存预热。</p><p>如果是Redis 宕机<br>首先，最好集群化保证高可用，进行一个主从节点的复制。<br>再一个是，构建限流，熔断机制。<br>为了减少业务的影响，触发请求限流，只允许少部分请求进入，等待重启Redis并缓存预热后，再解除限流。<br>还有就是，启动熔断机制，暂停业务应用对缓存服务的访问，直接返回服务不可用错误。等Redis恢复，再允许访问。这主要保证除了Redis缓存外，其他的整体的服务依然可用。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>频繁访问的热点数据过期，大量高并发请求直接访问数据库，造成数据库被冲垮。这问题算是缓存雪崩的一个子集：<br>解决：<br>互斥锁：未查到缓存时，保证一个时间内只有一个业务对一个缓存构建，其他请求该缓存，要么等待要么返回默认值/null</p><p>不设置过期时间，后台异步更新缓存，或者热点数据准备过期前，通知后台线程更新以及重新设置过期时间。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>访问的数据不在缓存，也不在数据库。<br>一是校验请求合法性，二是返回空值或默认值，三是布隆过滤器。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h5 id="Q：redis-到底是单线程-还是-多线程？"><a href="#Q：redis-到底是单线程-还是-多线程？" class="headerlink" title="Q：redis 到底是单线程 还是 多线程？"></a>Q：redis 到底是单线程 还是 多线程？</h5><p>Redis 是单线程模型，这是指【从网络IO处理到实际的读写命令处理】都是单个线程完成的。有些命令是可用用后台子进程执行，比如快照生产，AOF重写。</p><p>严格意义上说，Redis4.0后并不是单线程，除了主线程之外，后台线程在处理一些比较长的操作，比如垃圾回收，无用连接的释放，大Key大删除。</p><p>在Redis6.0后，采用了多线程等待Socket读些，最终执行读写命令的过程依然在主线程。</p><h5 id="Q：为什么处理操作命令的过程在单线程呢？"><a href="#Q：为什么处理操作命令的过程在单线程呢？" class="headerlink" title="Q：为什么处理操作命令的过程在单线程呢？"></a>Q：为什么处理操作命令的过程在单线程呢？</h5><p>这样，Redis  不存在CPU瓶颈，主要受限于内存和网络。<br>如果采用多线程读写命令，虽然提高并发性能，但却引入了程序执行顺序的不确定性，带来并发读写的一系列问题， 增加系统复杂度，还有个线程的切换，甚至加锁解锁，死锁造成的性能消耗。</p><h5 id="Q：AOF重写缓冲区会被占满吗？"><a href="#Q：AOF重写缓冲区会被占满吗？" class="headerlink" title="Q：AOF重写缓冲区会被占满吗？"></a>Q：AOF重写缓冲区会被占满吗？</h5><p>理论不会，缓冲区维护着一些内存块的双向链表，每个节点指向对应aofblock空间。</p><h5 id="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"><a href="#Q：为什么AOF重写和RDB生成要开启子进程而不是线程？" class="headerlink" title="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"></a>Q：为什么AOF重写和RDB生成要开启子进程而不是线程？</h5><p>因为如果使用线程，多线程之前就会共享内存。那么修改共享数据，需要加锁，锁会阻塞主线程。</p><p>子进程的方式，可以利用写时复制的技术，不用加锁。</p><h5 id="Q：什么情况才会save？"><a href="#Q：什么情况才会save？" class="headerlink" title="Q：什么情况才会save？"></a>Q：什么情况才会save？</h5><p>当 Redis 内存数据高达几十 G，甚至上百 G 的时候，<strong>如果用 bgsave 进行 RDB 快照的话，在创建子进程的时候，会因为复制太大的页表而导致 Redis 阻塞在  <code>fork()</code>  函数，主线程无法继续执行，相当于停顿了</strong>。</p><p>所以针对这种情况建议用 save。</p><p>虽然 save 会一直阻塞 Redis 直到快照生成完毕，但是它这个阻塞并不是意味着停顿了，而是在执行生成快照的程序，只是期间主线程无法处理接下来的读写命令。</p><h5 id="Q：混合持久化如何区分开？"><a href="#Q：混合持久化如何区分开？" class="headerlink" title="Q：混合持久化如何区分开？"></a>Q：混合持久化如何区分开？</h5><p>头部有有个REDIS 表明锁RDB内容，中间遇到RDB结束标记，然后再解析AOF格式。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>避免单点故障，最好做集群化，做主从备份。<br>多台服务器要保存同一份数据，就要保持数据一致性。<br>Redis 提供了主从复制模式，且主从之间，采用读写分离。</p><p>客户端写操作：<br>对所有的数据写入只在主服务上进行，然后，讲最新的数据同步到从服务器，这样，主从服务器的数据保持一致；<br>客户端读操作：<br>通过负载均衡策略，可以在任意一台服务器读取。</p><h4 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h4><p>一是从服务器输入命令： replicaof  主IP+端口<br>建立连接，协商同步；<br>二是主服务器同步数据到从服务器，全量复制：主服务期生成并发送RDB文件，从接收后先清除，再载入。为了保证数据一执行，新写入的命令写到replication buffer 缓冲区中。<br>三是主服务器发送新写操作命令给从服务器；<br>将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，然后从服务器重新执行这些操作。</p><p>主从服务器再完成第一次同步后，会维护一个TCP连接。</p><p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p><p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p><p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p><h4 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h4><p>刚刚讲到，第一次会有生成RDB文件和传输RDB文件两个耗时操作。<br>特别是从服务器非常多，数据量非常大，有两个问题：<br>一是fork阻塞主线程，redis无法正常速度处理读写请求；<br>二是RDB占用主服务网络带宽，也会影响命令请求的速度；</p><p>这个时候，需要设置助手，主从架构分成树状架构。从不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器形式将数据同步给从服务器。</p><p>这种方式，把同步压力分摊到多个服务器。</p><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>主从服务器再完成第一次同步后，会基于长连接进行命令传播。<br>这有个问题，就是网络的不稳定性。<br>一旦网络断开，就无法保持数据一致性。<br>2.8之前，断开恢复会进行一次全量复制，这种开销是很恐怖的。<br>从2.8开始，从服务器会采用增量复制，继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p><p>主要有3步：<br>1从服务器在恢复网络后，会发送psync命令到主服务器，与第一次有区别，offset参数不是-1<br>2主服务器收到命令后，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；<br>3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p><h5 id="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"><a href="#Q：主服务器如何知道要传输哪些增量数据发送给从服务器？" class="headerlink" title="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"></a>Q：主服务器如何知道要传输哪些增量数据发送给从服务器？</h5><p>依靠两个东西：<br>repl_backlog_buff环形缓冲区，用于主从服务器断连后，从中找到差异的数据；<br>replication offset，标记上面的那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用master_repl_offset来记录自己写到的位置，从服务器使用slave_repl_offset 来记录自己 读到的位置</p><h5 id="Q：repl-backlog-buff缓冲区是什么时候写入的呢？"><a href="#Q：repl-backlog-buff缓冲区是什么时候写入的呢？" class="headerlink" title="Q：repl_backlog_buff缓冲区是什么时候写入的呢？"></a>Q：repl_backlog_buff缓冲区是什么时候写入的呢？</h5><p>在主服务器进行命令传播时，不仅会将写命令发送从服务器，还会将写命令写入到repl_backlog_buff 缓冲区里，因此，这个缓冲区里会保存着最近传播到写命令</p><p>当网络断开后，当从服务器重新连上主服务器时，从服务器会通过psync命令将自己的复制偏移量，slave_repl_ofset发送给主服务器，主服务根据自己的master_repl_offset和slave_repl_offset 之间的差距，然后决定对从服务器执行哪种同步操作：<br>如果从服务器要读取的数据数据在缓冲区，采用增量同步；<br>否则，采用全量同步。</p><p><strong>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</strong></p><p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。</p><p>因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p><p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p><h5 id="Q：如何解决覆盖问题？"><a href="#Q：如何解决覆盖问题？" class="headerlink" title="Q：如何解决覆盖问题？"></a>Q：如何解决覆盖问题？</h5><p>因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p><p>那 repl_backlog_buffer 缓冲区具体要调整到多大呢？</p><p>repl_backlog_buffer 最小的大小可以根据这面这个公式估算。</p><p>second* write_size_per_second</p><p>我来解释下这个公式的意思：</p><ul><li><p>second 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。</p></li><li><p>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</p></li></ul><p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p><p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p><p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p><p>关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p><p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p><p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p><p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p><p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p><h2 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h2><p><strong>先更新数据库，再更新缓存</strong><br>一是 db：1 2  缓存：2 1</p><p>二是 非原子操作，缓存可能会失败</p><p><strong>先更新缓存，再更新数据库</strong><br> 缓存：1 2 db：2 1</p><p>加分布式锁，保证一个时间只允许一个请求更新？  性能差，过期很快</p><p>旁路缓存策略。</p><ul><li><p>先删除缓存，再更新数据库；<br>缓存：  A删 B读旧改</p></li><li><p>先更新数据库，再删除缓存。<br>一是会写问题 A读db  B更db B写缓存 A写旧缓存<br>二是删除失败  写db后，删除失败，等过期才回写生效</p></li></ul><p>缓存过期 + 延迟双删<br>第二次删除前加睡眠，确保A请求在双删内部时间中，B能够读取db，回写缓存，然后A睡醒再删除缓存。</p><p>这方案尽可能保证一致性，极端情况，也会出现不一致。<br>比如，第二次的删除全部崩溃，这样，与先删缓存，再更新数据无差别。</p><p><strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？</strong><br>一 是重试机制<br>二 是 订阅binlog，再操作缓存。</p><p>基于消息队列的重试</p><ol><li>更新数据库数据；</li><li>缓存因为种种问题删除失败</li><li>将需要删除的key发送至消息队列</li><li>自己消费消息，获得需要删除的key</li><li>继续重试删除操作，直到成功</li></ol><p>基于binlog的阿里中间件canal<br><strong>canal 工作原理</strong>  canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump（转储） 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )，canal 解析 binary log 对象(原始为 byte 流)</p><p>摘抄自：小林coding</p><hr><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><h4 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制?"></a>为什么要主从复制?</h4><p>1数据冗余 “数据的热备份”  2单机故障 “服务冗余”  3读写分离 “增加读请求能力”  4负载均衡 “分散单服务的压力”  5 高可用的基石  “哨兵和集群化”</p><h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><p>将一台Redis服务器的数据，复制到其他Redis节点上，前者是主节点，后者是从节点，写操作交给主节点，读操作主要给从节点。</p><h4 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h4><p>slave节点初次连接master节点，会发送psync命令，并且触发全量复制，此时master节点fork一个后台进程，开始生成一份RDB快照，同时将那些从外面接收  到写命令缓存到缓冲区中，RDB文件生成完毕后，将此文件发送给slave节点，slave节点写入磁盘，再从磁盘价值到内存，接着master会将增加缓冲区的写命令发送给slave，slave执行写命令并同步数据，如果slave节点和master节点因网络故障而中断，会自动重连，连接之后master节点会复制缺少的数据给slave节点。</p><h6 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h6><p>建立长连接，  全量数据同步，  增量同步：命令传播，数据反复同步。</p><h5 id="主从同步类型"><a href="#主从同步类型" class="headerlink" title="主从同步类型"></a>主从同步类型</h5><p>1全量复制 全量同步一般发生在slave初始化过程，这时slave需要将master上的所有数据复制一份；  2增量复制  增量同步一般是slave初始化后开始正常工作时，主服务器发生写操作同步到从服务器的过程；</p><p>主从刚连接，全量同步，再增量同步；  redis优先考虑增量，如果不成功，就是会全量。</p><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p>runId 主节点ID  offset 复制便宜量  replication buffer 内部队列缓冲区  建立连接时创建，全量和增量都会用  repl_backlog_buffer 环形缓冲区  开启命令传播之前，会建立buffer。  buffer记录当前的master接收到新的写操作，offset和命令本身，是所有slave公用的buffer，salve发送psync之后，会和master的offset比较，，来决定是否增量复制。</p><h5 id="全量复制流程-（初始化）"><a href="#全量复制流程-（初始化）" class="headerlink" title="全量复制流程 （初始化）"></a>全量复制流程 （初始化）</h5><ul><li><p>master连接slave：【slave上输入save of命令】，发送psync ？ -1 命令，用于同步数据  “？” 表示是master的runID，“-1”表示offset第一次复制；</p></li><li><p>master回复ACK告知slave，它的runId和offset，slave将其保存</p></li><li><p>master fork子进程（如果单线程做耗时动作，性能非常差），生成RDB+AOF组合快照，然后向所有slave发送快照文件，并通过写时复制技术，继续执行接下来用户的一些写命令，并存放到replication buff 缓冲区当中；</p></li><li><p>slave 接收后，把本地数据清空，然后把快照加载到本地磁盘，接着加载到内存来执行。</p></li><li><p>master 发送replication buffer缓冲区给salve同步</p></li></ul><h5 id="增量复制流程-（重连接）"><a href="#增量复制流程-（重连接）" class="headerlink" title="增量复制流程 （重连接）"></a>增量复制流程 （重连接）</h5><p>1从服务器在恢复网络后，会发送psync runId offset命令到主服务器，与第一次有区别，offset参数不是-1 ；（runId比较，如果不一样，就全量复制）  2主服务器收到命令后，两offset求距离差，小于replication buff缓冲区大小，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；  3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p><h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><h5 id="Q：长连接还是短连接？"><a href="#Q：长连接还是短连接？" class="headerlink" title="Q：长连接还是短连接？"></a>Q：长连接还是短连接？</h5><p>长，减少连接开销；</p><h5 id="Q：判断某个节点是否正常？"><a href="#Q：判断某个节点是否正常？" class="headerlink" title="Q：判断某个节点是否正常？"></a>Q：判断某个节点是否正常？</h5><p>主从ping-pong心跳检查机制，一半以上的节点区ping一个节点，如果没有pong回应，集群认为该节点宕机；  master 10s发送一次，检查对方在线  slave 1s发一次，给从节点发送自己的复制偏移量，获取最新变更+检查对方在线</p><h5 id="Q：过期key如何处理？"><a href="#Q：过期key如何处理？" class="headerlink" title="Q：过期key如何处理？"></a>Q：过期key如何处理？</h5><p>处理key或者淘汰key，master模拟del命令发送给slave；</p><h4 id="Q-redis主从切换如何减少数据丢失？"><a href="#Q-redis主从切换如何减少数据丢失？" class="headerlink" title="Q: redis主从切换如何减少数据丢失？"></a><strong>Q: redis主从切换如何减少数据丢失？</strong></h4><p>1 一般是异步复制丢失。  解决：  一master本地缓存或持久化磁盘，在一段时间后写入新master；  二先写入rocketMQ，再发送一个延时消息去写入master。  2 脑裂丢失  脑裂就是一部分slave误以为master已死，选举新的master后，旧的master依旧存活，导致出现了两个master，从而读写数据混乱。  避免脑裂：  一种是投票超过半数作为leader，才被其他节点认可，这也是zookeeper方案。  重点是第二种，哨兵模式。  哨兵群会监控节点存活情况，当超过半数哨兵认为master主观下线，即master转为客户下线，就要推举新master。  哨兵内部讨论，每人1票，投超过半数，成为选举人。  选1举人，根据先优先级，再是节点的同步率，最后是创建时间，选择新的master。  slave会全量同步新的master。  旧的master恢复后，降级为slave，也会全量同步。  这个过程中，旧master全量同步过程就是产生<strong>脑裂丢失</strong>  解决：  两个参数  min-slaves-to-write 2 至少2个slave  min-slaves-max-lag 5 至少5秒  至少2个slave进行同步复制延迟不超过5秒，一旦违反，master停止接收任何请求，让原master下线，选举新的master。尽可能</p><h4 id="Q：redis如何做到故障自动切换？"><a href="#Q：redis如何做到故障自动切换？" class="headerlink" title="Q：redis如何做到故障自动切换？"></a>Q：redis如何做到故障自动切换？</h4><p>哨兵模式内部选举出一个选举人，选举人选举新的master。</p><h4 id="Q：数据备份方式"><a href="#Q：数据备份方式" class="headerlink" title="Q：数据备份方式"></a>Q：数据备份方式</h4><p>1热备  主库承担业务流量，通过实时备份数据到从库。</p><p>2冷备  主库承担业务流量，通过定期或者手动执行脚本备份数据到从库。  （redis）</p><p>3多活  由两个数据中心承担业务流量，互为主备，一般主数据中心会承担大部分流量，备数据会承担小部分流量。（多地域）</p><p>摘抄自：tojson</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计跳表 | 栈记录插入前驱可能，丢硬币控制插入层级（java）</title>
      <link href="/2022/02/10/design-skiplist/"/>
      <url>/2022/02/10/design-skiplist/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">the leetcode link</a></p><h3 id="1206-设计跳表"><a href="#1206-设计跳表" class="headerlink" title="1206 设计跳表"></a>1206 设计跳表</h3><p>不使用任何库函数，设计一个 跳表 。</p><p>跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：<br><a href="1506_skiplist.gif">skiplist</a></p><p>Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。</p><p>了解更多 : <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Skip_list</a></p><p>在本题中，你的设计应该要包含这些函数：</p><p>bool search(int target) : 返回target是否存在于跳表中。<br>void add(int num): 插入一个元素到跳表。<br>bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回false. 如果存在多个 num ，删除其中任意一个即可。<br>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p>示例 1:</p><p>输入<br>[“Skiplist”, “add”, “add”, “add”, “search”, “add”, “search”, “erase”, “erase”, “search”]<br>[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]<br>输出<br>[null, null, null, null, false, null, true, false, true, false]</p><p>解释<br>Skiplist skiplist = new Skiplist();<br>skiplist.add(1);<br>skiplist.add(2);<br>skiplist.add(3);<br>skiplist.search(0);   // 返回 false<br>skiplist.add(4);<br>skiplist.search(1);   // 返回 true<br>skiplist.erase(0);    // 返回 false，0 不在跳表中<br>skiplist.erase(1);    // 返回 true<br>skiplist.search(1);   // 返回 false，1 已被擦除</p><p>提示:</p><p>0 &lt;= num, target &lt;= 2 <em> 104<br>调用search, add,  erase操作次数不大于 5 </em> 104</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>设计Node，定义max_level，head ，level</li><li>通用步骤：枚举寻找目标所有层的前驱，过程是：先同层跳链表至前驱或尾节点，再进入下一层反复；</li><li>查询逻辑：在步骤2枚举过程中，一旦发现是前驱，则返回true；</li><li>删除逻辑：在步骤2枚举过程中，一旦发现是前驱，则同层的前驱指向其后驱，完成一次删除后进入下一层继续删除。优化：之后把可能产生的孤立头结点也删除；</li><li>插入逻辑：</li></ol><ul><li>第1步，在步骤2枚举过程中，一旦发现是前驱的可能，则压栈；这将得到一个能从底层至高层弹出所有前驱可能的栈。</li><li>第2步，先底层插入，才开始反复丢01硬币，概率性地从二层至高层插入新节点，以起始丢连续1的个数来控制插入多高层级，过程是：先不丢硬币，底层前驱出栈，新节点必插入在其后方，然后才开始丢硬币，决定是否插入次高一层，不插入则结束；如果要插入，就从栈取出当前层前驱，新节点插入在其后方形成连接，如果丢硬币运气太好，栈用完仍需插入，此时说明高度已超出原有层，则新建一层：新建头节点作为前驱，后方插入新节点。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LEVEL = <span class="number">32</span>;  <span class="comment">// 层级最大阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node right; <span class="comment">//指向同层的后驱</span></span><br><span class="line">        Node down; <span class="comment">//指向同节点的下一层，底层为空</span></span><br><span class="line">        Node(<span class="keyword">int</span> val, Node right, Node down)&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.down = down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node head; <span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 当前最大层级</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Skiplist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        level = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;target) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 寻找新节点的所有符合条件的可能前驱节点，用栈记录下</span></span><br><span class="line">        Deque&lt;Node&gt; prevStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;num) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line"></span><br><span class="line">            prevStack.push(node); <span class="comment">// 高level到低level压栈 保存所有前驱节点</span></span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 反复丢01硬币，决定插入新节点的level，底level必须插入，硬币初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> coins = <span class="number">1</span>;  <span class="comment">// 硬币初始化为1</span></span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        Node prev = <span class="keyword">null</span>, newNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(coins == <span class="number">1</span> &amp;&amp; level &lt; MAX_LEVEL)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!prevStack.isEmpty())&#123;</span><br><span class="line">                <span class="comment">// 当有前驱，高level到低level弹栈</span></span><br><span class="line">                prev = prevStack.pop();</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 当无前驱，则新建head作为前驱节点，level++</span></span><br><span class="line">                head = <span class="keyword">new</span> Node(-<span class="number">1</span>, <span class="keyword">null</span>, head);</span><br><span class="line">                prev = head;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入到当前层的链表上</span></span><br><span class="line">            newNode = <span class="keyword">new</span> Node(num, prev.right , newNode);</span><br><span class="line">            prev.right = newNode;</span><br><span class="line"></span><br><span class="line">            coins = rand.nextInt(<span class="number">2</span>);  <span class="comment">//丢硬币 [0,1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">while</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val&lt;num) node = node.right;  <span class="comment">// 同层跳链表,寻找当前层的前驱</span></span><br><span class="line">            <span class="comment">// 删除当前层的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; node.right.val == num)&#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                node.right = node.right.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.down;  <span class="comment">// 进下一层</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除孤立头节点</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.down;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 跳表 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Rand7() 实现 Rand10() | 分页 | 翻看日历的时候，把题做出来</title>
      <link href="/2022/02/04/implement-rand10-using-rand7/"/>
      <url>/2022/02/04/implement-rand10-using-rand7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="470"><li>用 Rand7() 实现 Rand10()<br>给定方法 rand7 可生成 [1,7] 范围内的均匀随机整数，试写一个方法 rand10 生成 [1,10] 范围内的均匀随机整数。</li></ol></blockquote><blockquote><p>你只能调用 rand7() 且不能调用其他方法。请不要使用系统的 Math.random() 方法。</p></blockquote><blockquote><p>每个测试用例将有一个内部参数 n，即你实现的函数 rand10() 在测试时将被调用的次数。请注意，这不是传递给 rand10() 的参数。</p></blockquote><blockquote><p>示例 1:<br>输入: 1<br>输出: [2]</p></blockquote><blockquote><p>示例 2:<br>输入: 2<br>输出: [2,8]</p></blockquote><blockquote><p>示例 3:<br>输入: 3<br>输出: [3,8,10]</p></blockquote><blockquote><p>提示:<br>1 &lt;= n &lt;= 105</p></blockquote><h3 id="随机择日"><a href="#随机择日" class="headerlink" title="随机择日"></a>随机择日</h3><p>一个名为卢迪的宅男，他相信着，八月是循环的高发期，且时常有”/remake”自己的想法。</p><p>于是，<strong>他计划在2022年8月的随机一天，去坐公交车</strong>，为了遇见车途中可能发生的时空循环。</p><figure class="image-box">                <img src="https://pic.leetcode-cn.com/1644778673-nOHaQj-image.png" alt="image.png" title class>                <p>image.png</p>            </figure><p>看日历，很巧妙，2022年的8月的1号刚好是从周一开始。</p><p>一周有7天，而本题又很巧有Random7()的功能。</p><p>虽然卢迪不会做题，但他想了一个方法，<strong>利用Random7()，实现了等概率随机选择哪一天上公交</strong>！</p><p>这小伙子怎么做呢？</p><p>只见他眼疾手快，啪一下，直接写一行代码 <code>return rand7()</code>，</p><p>竟然把Ramdom7()作为输出结果。。。。。。真无语了</p><blockquote><p>第一次提交，输出结果是几，他就选择周几，记为a<br>第二次提交，输出结果是几，他就选择日历上的第几行，记为b</p></blockquote><p><code>补充说明，8月1号所在行是第1行，9月5号所在行是第6行。</code></p><p>当然，这样抽选的范围是从8月1号到9月18号，为49天。</p><p>抽到每一天的概率都是(1/7)*(1/7)，也相当实现Random49()。</p><p>但这不是他想要的结果，他<strong>只会在8月份中选择一天</strong>。</p><p>如果抽到9月份，他<strong>拒绝采样</strong>，重复第一次和二次的提交过程，重新择日。</p><p>有了拒绝采样步骤，就能实现Random31()，这才是他想要的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">他的随机过程：</span><br><span class="line">a=5，b=5，很不巧，8月没有这一天。拒绝采样，重新再来；</span><br><span class="line">a=2，b=7，很不巧，8月没有这一天。拒绝采样，重新再来；</span><br><span class="line">a=2，b=4，成功随机定位到23号出伏日；</span><br></pre></td></tr></table></figure><p><strong>Q：已知a和b，如何用公式计算出几号日期？</strong></p><blockquote><p>利用简单的分页公式：<strong>index = (pageNum - 1) * size + currentPageIndex</strong><br>页号是从1开始，把一周看作一页，得到： 几号日期 = (b-1) <em> 7 + a<br>例如：23号 = (4-1) </em> 7 + 2</p></blockquote><p>用<strong>分页思想</strong>，也可以得到一条<strong>随机数公式</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randAB = (randB-1) * A + randA</span><br></pre></td></tr></table></figure></p><p>比如上述例子，通过两个Random7()推出Random49()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rand49  = (rand7-1) * 7 + rand7</span><br></pre></td></tr></table></figure></p><h3 id="关于拒绝采样范围过大的问题"><a href="#关于拒绝采样范围过大的问题" class="headerlink" title="关于拒绝采样范围过大的问题"></a>关于拒绝采样范围过大的问题</h3><p>卢迪突然接到父母指示，8月10号后不能出家门。</p><p>他只能计划在8月1号到8月10号中随机选择一天，意味着要实现Random10()。</p><p>他按照之前的方法操作，由于拒绝采样的范围过大，他总是抽取到8月10号以后的日子。</p><p>时间已过去很久，依然没抽中前10天，运气过背，他快抽麻了……</p><p>于是，他想办法优化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">抽中第 1，11，21，31的位置就是1号出发</span><br><span class="line">抽中第 2，12，22，32的位置就是2号出发</span><br><span class="line">抽中第 3，13，23，33的位置就是3号出发</span><br><span class="line">......</span><br><span class="line">抽中第10，20，30，40的位置就是10号出发</span><br></pre></td></tr></table></figure></p><p>这样，采样范围由10就变成40，他马上抽中结果了。</p><p>这就是取余数的思路<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">几号日期 = index %10 + 1</span><br></pre></td></tr></table></figure></p><p>先决定取样范围：应为N的倍数，再用模N+1方式得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(index&gt;40)&#123;</span><br><span class="line">    index = rand7()+(rand7()-1)*7;</span><br><span class="line">&#125;</span><br><span class="line">return index%10+1;</span><br></pre></td></tr></table></figure></p><h3 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">SolBase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">41</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">40</span>)&#123;</span><br><span class="line">            index = (rand7()-<span class="number">1</span>)*<span class="number">7</span> + rand7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index%<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算 | 2bit标识3状态 | 有限状态自动机</title>
      <link href="/2022/02/02/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"/>
      <url>/2022/02/02/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 56 - II. 数组中数字出现的次数 II<br>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [3,4,3,3]<br>输出：4</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [9,1,7,9,7,9,7]<br>输出：1</p></blockquote><blockquote><p>限制：<br>1 &lt;= nums.length &lt;= 10000<br>1 &lt;= nums[i] &lt; 2^31</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题解主要是根据k神题解的<strong>有限状态自动机</strong>思路，补充了一些数据结构的可视化，方便大家理解。</p><h3 id="一个结论"><a href="#一个结论" class="headerlink" title="一个结论"></a>一个结论</h3><p><strong>如果所有数字都出现3次，把所有数字的每一个二进制位分别求和，各位置的结果均为 3 的倍数。</strong><br>对于本题，我们分别统计所有数字的每二进制位中 1 的出现次数，并把各位置的结果<strong>分别对 3 求余，结果得到只出现一次的数字</strong>。<br>比如： [3,4,3,3]<br>|  0 |  0 |  0 |  1 |  1 |<br>|—-|—-|—-|—-|—-|<br>|  0 |  0 |  1 |  0 |  0 |<br>|  0 |  0 |  0 |  1 |  1 |<br>|  0 |  0 |  0 |  1 |  1 |<br>出现次数：<br>|  0 |  0 |  1 |  3 |  3 |<br>|—-|—-|—-|—-|—-|<br>模3：<br>|  0 |  0 |  1 |  0 |  0 |<br>|—-|—-|—-|—-|—-|<br>得到结果：4</p><h2 id="方法：有限状态自动机"><a href="#方法：有限状态自动机" class="headerlink" title="方法：有限状态自动机"></a>方法：有限状态自动机</h2><p>对于所有数字中的某二进制位 1 的个数mod 3，会得到3个结果，即存在3种状态：0,1,2。</p><p>1bit只有0和1，无法表示3种状态。</p><p>于是，我们把<strong>每二进制位的位置，用2bit表示：00，01，10</strong><br>比如：<br>各位的出现次数及其对应的mod3状态：<br>|  0 |  0 |  1 |  2 |  3 |<br>|—-|—-|—-|—-|—-|<br>| 00 | 00 | 01 | 10 | 00 |</p><ul><li>对于每一个二进制位置，累加过程mod3的状态转移是循环的：<br><code>出现0次：00</code> -》 <code>出现1次：01</code> -》 <code>出现2次：10</code> -》<code>出现3次：00</code> -》<code>出现4次：01</code> …</li><li>对于不同两个二进制位置，状态同步转移，比如一个位出现1次，另一个位出现4次，此时次数mod3状态是一致的，当新累加一个数，两者状态都要一次转移，可能入0转移到自己，可能入1就到下个状态。</li></ul><h3 id="Q：这样2bit的结构具体如何在代码中表达？"><a href="#Q：这样2bit的结构具体如何在代码中表达？" class="headerlink" title="Q：这样2bit的结构具体如何在代码中表达？"></a>Q：这样2bit的结构具体如何在代码中表达？</h3><p>定义两个变量表示当前mod3状态：ones，twos<br>ones表示所有2bit二进制位的所有第一位；<br>twos表示所有2bit二进制位的所有第二位；<br>比如：<br>出现次数mod3状态：<br>| 0<strong>0</strong> | 0<strong>0</strong> | 1<strong>0</strong> | 0<strong>1</strong> | 0<strong>1</strong> |<br>|—-|—-|—-|—-|—-|<br>ones是：<br>|  <strong>0</strong> |  <strong>0</strong> |  <strong>0</strong> |  <strong>1</strong> |  <strong>1</strong> |<br>|—-|—-|—-|—-|—-|<br>twos是：<br>|  0 |  0 |  1 |  0 |  0 |<br>|—-|—-|—-|—-|—-|</p><h3 id="状态转移方程推导"><a href="#状态转移方程推导" class="headerlink" title="状态转移方程推导"></a>状态转移方程推导</h3><p>对于某一个二进制位：<br>定义第一位one，第二位two，新累加二进制位数：n<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> two == <span class="number">0</span> &amp;&amp; one == <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one  <span class="comment"># one = 1</span></span><br><span class="line">    two = two   <span class="comment"># two = 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> two == <span class="number">0</span> &amp;&amp; one == <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = ~one  <span class="comment"># one = 0</span></span><br><span class="line">    two = ~two  <span class="comment"># two = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> two == <span class="number">1</span> &amp;&amp; one == <span class="number">0</span>:</span><br><span class="line">   <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    one = one   <span class="comment"># one = 0</span></span><br><span class="line">    two = ~two  <span class="comment"># two = 0</span></span><br></pre></td></tr></table></figure></p><p>已知位运算特性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特性1：异或运算：x ^ 0 = x​ ， x ^ 1 = ~x</span><br><span class="line">特性2：与运算：x &amp; 0 = 0 ， x &amp; 1 = x</span><br></pre></td></tr></table></figure></p><p>观察可知：<br>a.当 two是1时，one不变<br>b.当 two是0时，入1则one取反，入0则one不变 <code>（符合特性1: one = one^n）</code><br><code>（a,b符合特性2: one = (one^n) &amp; ~two）</code><br>c.当 one变为0时，入1则two取反，入0则two不变<code>（符合特性1：two = two^n）</code><br>d.当 one变为1时，two不变<br><code>（c,d符合特性2: two = (two^n) &amp; ~one）</code></p><p>推导简化公式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one = one ^ n &amp; ~two</span><br><span class="line">two = two ^ n &amp; ~one</span><br></pre></td></tr></table></figure></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int ones = 0, twos = 0;</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        return ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双端递减队列 | 滑动窗口最大值</title>
      <link href="/2022/02/02/sliding-window-maximum/"/>
      <url>/2022/02/02/sliding-window-maximum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p></blockquote><blockquote><p>返回 滑动窗口中的最大值 。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [1], k = 1<br>输出：[1]</p></blockquote><blockquote><p>提示：<br>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104<br>1 &lt;= k &lt;= nums.length</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>定义递减的双端链表</li><li>链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</li><li>先校验是否足够组成窗口</li><li>若3步骤通过，窗口最大值取队头的元素</li><li>若3步骤通过，判断链头元素是否在下一个窗口内，不在则舍弃</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        1. 定义递减的双端链表</span></span><br><span class="line"><span class="comment">        2. 链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</span></span><br><span class="line"><span class="comment">        3. 先校验是否足够组成窗口</span></span><br><span class="line"><span class="comment">        4. 窗口最大值取队头的元素</span></span><br><span class="line"><span class="comment">        5. 判断链头元素是否在下一个窗口内，不在则舍弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 1. 定义递减的双端链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; d = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;nums.length;r++)&#123;</span><br><span class="line">            <span class="comment">// 2. 链尾循环，舍弃比当前值小的元素，并插入当前值，注意空校验</span></span><br><span class="line">            <span class="keyword">while</span>(!d.isEmpty() &amp;&amp; d.peekLast()&lt;nums[r])&#123;</span><br><span class="line">                d.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            d.addLast(nums[r]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 先校验是否足够组成窗口</span></span><br><span class="line">            <span class="keyword">if</span>(r-k+<span class="number">1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 4. 窗口最大值取队头的元素</span></span><br><span class="line">               res[index++] = d.peekFirst();</span><br><span class="line">                <span class="comment">// 5. 判断链头元素是否在下一个窗口内，不在则舍弃</span></span><br><span class="line">               <span class="keyword">if</span>(d.peekFirst()== nums[r-k+<span class="number">1</span>])&#123;</span><br><span class="line">                    d.removeFirst();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 双端队列 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm | 虚拟机全面扫盲+深入理解的原创笔记</title>
      <link href="/2022/02/01/jvm-notes/"/>
      <url>/2022/02/01/jvm-notes/</url>
      
        <content type="html"><![CDATA[<p><strong>引言：</strong><br>来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。<br>优点：笔记知识点关联性好，挖得深，延伸多。<br>缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般</p><h1 id="1-class文件"><a href="#1-class文件" class="headerlink" title="1. class文件"></a>1. class文件</h1><figure class="image-box">                <img src="image-20220208022707509.png" alt="class文件" title class>                <p>class文件</p>            </figure><p><a href="https://blog.csdn.net/lioncatch/article/details/105919391" target="_blank" rel="noopener">https://blog.csdn.net/lioncatch/article/details/105919391</a></p><p><a href="https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc</a></p><p>8字节 2进制  Java文件编译之后</p><ul><li><h3 id="4字节魔数：标志文件类型；视频，照片也有魔数"><a href="#4字节魔数：标志文件类型；视频，照片也有魔数" class="headerlink" title="4字节魔数：标志文件类型；视频，照片也有魔数"></a>4字节魔数：标志文件类型；视频，照片也有魔数</h3></li><li><h3 id="次版本号和主版本号：标志JDK版本；兼容低版本问题"><a href="#次版本号和主版本号：标志JDK版本；兼容低版本问题" class="headerlink" title="次版本号和主版本号：标志JDK版本；兼容低版本问题"></a>次版本号和主版本号：标志JDK版本；兼容低版本问题</h3></li><li><h3 id="常量池计数器：记录后面常量池的常量（数据项）个数；※"><a href="#常量池计数器：记录后面常量池的常量（数据项）个数；※" class="headerlink" title="常量池计数器：记录后面常量池的常量（数据项）个数；※"></a>常量池计数器：记录后面常量池的常量（数据项）个数；※</h3></li><li><h3 id="常量池：字面量-符号引用"><a href="#常量池：字面量-符号引用" class="headerlink" title="常量池：字面量+符号引用"></a>常量池：字面量+符号引用</h3><p> 1.字面量：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值。<br> 2.符号引用<br>   package名字，权限命名，字段名称，方法名称，字段描述符，方法描述符，方法句柄，方法类型，动态调用点和动态常量（不了解）<br>   <strong>一句话：这部分就是常量池，装载了全部类的字段，方法，类名称的信息；</strong></p><figure class="image-box">                <img src="image_20220118183346.png?v=1&type=image&token=V1:3n03VpBe2yMBZgKD5g9o0h5d90CeNevbyQO6LX2UnvQ" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image-20220208023504211.png" alt="符号引用" title class>                <p>符号引用</p>            </figure><p><strong>每个常量项的第一个字节 对应上图中的tag标志 找到对应的结构</strong></p><figure class="image-box">                <img src="image_20220118170506.png?v=1&type=image&token=V1:6K2y024TT-YRQvmLRY5b09neyTtm2iaN319VPeQprHY" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184004.png?v=1&type=image&token=V1:rLsRMkCAd22AUMMS2KXLkI8chGO6nlPHBPOsm1vbbXM" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="image_20220118184033.png?v=1&type=image&token=V1:3CCva6EeaLck4wLZttiedHSfKB0KY8VF3QdPIXjTUjE" alt title class>                <p></p>            </figure></li></ul><ol start="2"><li>面试题</li></ol><ul><li><p>Q  哪些字面量会进入常量池中？</p><ol><li>【final修饰】的8种基本类型的值会进入常量池。</li><li>【非final类型】（包括static的）的8种基本类型的值，只有【double、float、long】的值会进入常量池。</li><li><p>常量池中包含的字符串类型字面量（【双引号引起来的字符串值】）。</p></li><li><p>final类型的8种基本类型的值会进常量池。</p></li><li><p>final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进常量池。</p></li><li><p>常量池中包含的字符串类型字量（双引号引起来的字符串值）。</p></li></ol></li><li><p>java 字段名和方法名，有无长度限制？<br>A: 有，CONSTANT_Utf8_info 存储字符串字面量， 最大长度是65535，大小限制在小于64kb</p><figure class="image-box">                <img src="image_20220119024159.png?v=1&type=image&token=V1:W7pDbZc-acY3wco7miFQ9qcUzZDjMeym7ot3fpzX19A" alt title class>                <p></p>            </figure></li><li><p>Q 字符串有长度限制吗？是多少？<br>  答：</p><ol><li>运行期限制<br>首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,<br>由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</li><li>编译时期限制<br>通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错。<br>原来是为了弥补早期设计时的一个bug，“长度刚好65535个字节，且以1个字节长度的指令结束，这条指令不能被异常处理器处理”，因此就将数组的最大长度限制到了65534了。跟程序计数器有关</li></ol></li></ul><p>运行时拼接或者赋值的话范围是在整形的最大范围。<br><a href="https://blog.csdn.net/rd_w_csdn/article/details/110387250" target="_blank" rel="noopener">https://blog.csdn.net/rd_w_csdn/article/details/110387250</a></p><p><del>错误回答：</del><br><del>CONSTANT_Utf8_info 中有 u2 length; 表明了该类型存储数据的长度。 u2 是无符号的 16 位整数，因此理论上允许的的最大长度是 2^16=65536。而 java class 文件是使用一种变体 UTF-8 格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534 个字节。</del></p><p><code>Modified UTF-8</code>  UTF-8 缩略编码是改进版的<code>UTF-8</code>编码，它和标准的UTF-8编码有下面三点区别：</p><ol><li><code>null</code>空字符的编码从一个字节的<code>&#39;\u0000&#39;</code>改变为2个字节的形式，即11000000 10000000，因此在字符串的编码中不会出现嵌入的null字符；</li><li>只使用1~3个字节的格式；（即范围由\u0000-\uffff）</li><li>辅助字符以代理对的形式表示。 <strong>补充字符通常指大于u+ffff而小于等于u+10ffff范围内的字符</strong></li></ol><ul><li>Q常量池计数器从0还是1开始？<br>A: 从1开始，0索引留给无法指向的东西，即没有父类，没有类名的，比如匿名内部类，Object类</li></ul><figure class="image-box">                <img src="image_20220116204409.png" alt title class>                <p></p>            </figure><ul><li><h3 id="2字节的访问标志："><a href="#2字节的访问标志：" class="headerlink" title="2字节的访问标志："></a>2字节的访问标志：</h3><p>  表明这个class有什么修饰符 只有两个字节</p><figure class="image-box">                <img src="image-20220208024117844.png" alt title class>                <p></p>            </figure></li></ul><p>举例: 原来是00 20(看下表中ACC_SUPER描述，最低限度必须有此标志)<br>如果：类是public类型-的，则第一个ACC_PUBLIC为true 则加上00 01 ，结果为00 21<br>如果：类还是 final类型-的，则第二个为true，再加上00 10 ，结果为00 31</p><p>00 21 = 00 20 + 00 01 ( 加了public)<br>表示为public 的类<br>设置的数值刚好不会出现相加和其他状态相等的情况，很巧妙<br><strong>一句话 访问标识就是只用两个字节表示了这个类的修饰符有哪些</strong></p><ul><li><h3 id="类、父类-This-class-Super-class"><a href="#类、父类-This-class-Super-class" class="headerlink" title="类、父类(This class,Super class)"></a>类、父类(This class,Super class)</h3><p>如 00 02 和 00 003两个标识符也都是一个两字节的引用，我们class文件中，分别引向常量池中00 02的第二个常量项和00 03 第三个常量项<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到类名</p><figure class="image-box">                <img src="20200506112335237.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></li><li><h3 id="接口索引计数器"><a href="#接口索引计数器" class="headerlink" title="接口索引计数器"></a>接口索引计数器</h3><p>类文件实现了接口的数量，没有就是00 00 ，有一个就是 00 01</p></li><li><h3 id="接口索引项"><a href="#接口索引项" class="headerlink" title="接口索引项"></a>接口索引项</h3><p>指向常量池索引<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到接口名</p></li></ul><ul><li><h3 id="字段表：字段个数，字段1，字段2。。。。"><a href="#字段表：字段个数，字段1，字段2。。。。" class="headerlink" title="字段表：字段个数，字段1，字段2。。。。"></a>字段表：字段个数，字段1，字段2。。。。</h3><p>和上面差不多<br>字段表，方法表，class类都有自己的属性表！<br>`<br>※  注意：ConstantValue属性：</p><p>  final static String = “hello”<br>必须是String 类型，其值直接存储在字段表里面附带自己的属性表的ConstantValue属性指向的常量池里面，这样就可以类未加载直接用，效率提升<br>`</p></li></ul><blockquote><p>ConstantValue属性<br>属性表中的一个属性<br>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；static类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p><p>在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p><p>为什么ConstantValue的属性值只限于基本类型和string？</p><p>因为从常量池中只能引用到基本类型和String类型的字面量</p><p>final、static、static final修饰的字段赋值的区别</p><p>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</p><p>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</p><p>static<br>final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。</p><p>可以理解为在编译期即把结果放入了常量池中。</p></blockquote><figure class="image-box">                <img src="image_20220118180056.png?v=1&type=image&token=V1:CPihlXhsDyMBxTiSaP4vHqG9vSKcCYlTGlI4SJLB2Os" alt title class>                <p></p>            </figure><p><strong>分析第一个 access_flags</strong><br>—-其实跟之前我们讲访问标识的时候一样，不一样的是这次的访问标志修饰符是修饰字段的<br>所以在标志名称上有些不同<br><img src="image-20220208024515966.png" alt="在这里插入图片描述"></p><p>这里加一张图用另一种方式表示我们的修饰符<br><figure class="image-box">                <img src="image-20220208024418503.png" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></p><p><strong>分析第四个 attributes_count</strong><br>表示这个字段所拥有的attribute类型的个数，如果是00 01 就表示一个<br><strong>分析第五个 attributes[attributes_count]</strong><br>就是一个长度为 attributes_count，类型是：属性类型的数组<br>这个类型我们暂时不分析，到后面讲到 属性 时一起讲</p><p><strong>一句话总结<br>就是一个装有我们定义的所有属性的数组，长度为字段个数，里面的每一个表信息都表示一个字段</strong></p><ul><li><h3 id="方法表：-方法个数，方法1，方法2。。。。"><a href="#方法表：-方法个数，方法1，方法2。。。。" class="headerlink" title="方法表： 方法个数，方法1，方法2。。。。"></a>方法表： 方法个数，方法1，方法2。。。。</h3></li><li>字段表，方法表，class类都有自己的属性表！<figure class="image-box">                <img src="image_20220118182212.png?v=1&type=image&token=V1:I_meGZXidnP-pQ7GadHjyGZ5OJv_1gQzErPxNEyHeg0" alt title class>                <p></p>            </figure>access_flags的修饰类型<figure class="image-box">                <img src="image-20220208024616971-16442595798677.png" alt title class>                <p></p>            </figure></li></ul><p>※※  方法的代码存储在： 方法表里面附带自己的属性表的CODE属性里面。<br><a href="https://blog.csdn.net/weixin_29732737/article/details/113051809" target="_blank" rel="noopener">https://blog.csdn.net/weixin_29732737/article/details/113051809</a><br> <strong>max_stack</strong><br>操作数栈的最大深度，说明方法在编译把方法的栈深度已经定好了。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。<br><strong>max_locals</strong><br>局部变量表所需要的空间，长度不能变<br>单位是Slot，int、byte和returnAddress不超过32位的数据类型采用1个Slot来存储；<br>double和long等64位的数据类型采用两个Slot存储<br><strong>其他（包括异常信息）</strong><br>code_length存储了方法体中的字节码指令的长度<br>code就存储了具体的字节码指令<br>exception_table_length<br>显示异常(受检查的异常)中的个数(try-cacatch中的异常)<br>exception_info<br>这是受检查异常的具体信息</p><ul><li><h3 id="属性表：-属性个数，属性1，属性2。。。。"><a href="#属性表：-属性个数，属性1，属性2。。。。" class="headerlink" title="属性表： 属性个数，属性1，属性2。。。。"></a>属性表： 属性个数，属性1，属性2。。。。</h3>上面所说的<strong>字段</strong>和<strong>方法</strong>的最后都有一项：<strong>属性项数组</strong>，里面装的就是这个类型了,比如ConstantValue和Code<br>其实class文件还有一个属性表，就是上面那张图没有覆盖掉的最后一部分<br>在Class文件、字段表、方法表都可以携带自己的属性表集合！！！<br>属性表中不要求各个属性表具有严格的顺序，只要不与已有属性重名即可</li></ul><h1 id="2-JVM-类加载的整体流程"><a href="#2-JVM-类加载的整体流程" class="headerlink" title="2. JVM 类加载的整体流程"></a>2. JVM 类加载的整体流程</h1><p> 普通回答（过于绝对）：<br> 加载，连接，初始化<br> 连接又分为验证，准备，解析</p><p>※ 从细节回答：<br>真正是分为7到8步</p><ol><li>加载<br> 静态加载，java编译为class文件二进制字节流，获得的是class文件二进制字节流</li><li>验证<br> 进入连接阶段的验证：<br>第一步，文件格式验证： 魔数和主次版本号</li><li>加载<br> 验证成功后，把class文件二进制字节流 加载到 方法区<br>  作用： 结构调整，把静态存储文件转换为运行时数据结构<br> （思考： class常量池和方法区的运行时常量池的区别和联系）</li><li>加载<br> 堆内存生成当前类class对象 作为方法区中这个类的各种访问入口，比如：Object类，java.lang.Object 一定先加载，放入堆，提供给其他类访问</li><li>验证<br> 跳到连接阶段的验证：<br>第二步，元数据验证，字节码描述的信息进行语义分析</li><li>验证<br> 跳到连接阶段的验证：<br>第三步，字节码验证，通过数据流和控制流分析<br> <a href="https://blog.csdn.net/weixin_38608626/article/details/88173916" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38608626/article/details/88173916</a></li><li>准备<br> 0值的初始转化，含了给这个类的静态变量static和其他数据分配内存空间（<strong>仅仅是分配内存空间，具体初始化在最后一步</strong>）。<br> static int a=123;  这一阶段a会变成0</li><li>初始化<br> （解析： 第四步，符号验证，常量池内符号引用转直接引用，确定解析一定初始化之前，不确定在何时）【直接引用与虚拟机有关，不同的虚拟机翻译出来一般不会相同】<br> JVM用赋值或者缺省值将静态变量进行初始化，并执行静态初始化程序（static块中的代码），初始化发生在执行main方法之前，但在指定的类初始化之前他的父类必须先初始化，若其父类仍然存在父类，那也需递归的初始化。</li></ol><p>真正执行java代码，会调用<code>&lt;clinit&gt;()</code>方法 ：<br><code>在编译生成class文件时,会自动产生两个方法,一个是类的初始化方法&lt;clinit&gt;, 另一个是实例的初始化方法&lt;init&gt;。</code><br>只有被static修饰并且赋值的静态属性才会产生<code>&lt;clinit&gt;()</code>方法，不管是直接赋值还是在静态块中赋值，最后都会被合并成一个<code>&lt;clinit&gt;()</code>方法，并按照代码中的顺序依次赋值。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口。</li><li>在初始化一个接口时，并不会先初始化它的父接口。</li></ul><h3 id="（面试题）-什么情况下立即对类初始化？"><a href="#（面试题）-什么情况下立即对类初始化？" class="headerlink" title="（面试题） 什么情况下立即对类初始化？"></a>（面试题） 什么情况下立即对类初始化？</h3><p>1 遇到四条字节码指令会立即初始化：</p><ul><li>创建普通对象的指令：new</li><li>访问类字段（static 字段，或者称为类变量）的指令：getstatic, putstatic</li><li>invokestatic 指令：用于调用类方法(static方法)。<br>（new引用类会立即初始化， new数组不会初始化： 原因：创建数组得到指令：newarray , anewarray , multianewarray，不是new指令）</li></ul><p>2 反射直接初始化<br>3 父类未初始化先初始化<br>4 有main函数<br>5 java.lang.invoke.MethodHandle 实例最后解析结构结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，必须触发其初始化。<br>6 jdk1.8 接口default 方法</p><p>引申知识：</p><ul><li><p>加载：<br>  双亲委派模型：<br>  1启动类加载器（lib目录，根加载器），<br>  2拓展类加载器（lib-&gt;ext目录），<br>  3系统类加载器<br>(又叫应用程序加载器，加载用户类路径（classpath）上的指定类库，可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器)<br> 4当然，可以通过继承Classloader实现自定义加载器<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p><ul><li><p>（面试） 双亲委派好处？<br>1.顺序加载。父类优先加载，<strong>避免重复加载</strong><br>2.安全性和唯一性。<strong>避免核心类篡改</strong></p><p>  利用 沙箱安全机制。 比如：加载器发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来（或自己写）的java.lang.Integer<br>  <code>tips： instance of 是根据类名称+类加载器 定位</code></p></li><li>JVM加载数组？<br>数组这个类加载，不是类加载器加载，其内存区域是运行中内存动态构造的。<br>类型的类在new时，才由加载器加载。<br>如何标记出唯一数组？</li></ul><ol><li>当引用类被加载器加载时，数组标志在加载器的<code>命名空间</code>上。</li><li>基础类型数组类型直接标记在<code>启动类加载器</code>的<code>命名空间</code>上。</li></ol></li></ul><p><strong>命名空间</strong><br>    <a href="https://blog.csdn.net/chuifuhuo6864/article/details/100887587" target="_blank" rel="noopener">https://blog.csdn.net/chuifuhuo6864/article/details/100887587</a></p><blockquote><p>由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间。命名空间由一系列唯一的名称组成，每一个被装载的类有一个名字。JAVA虚拟机为每一个类装载器维护一个名字空间。例如，一旦JAVA虚拟机将一个名为Volcano的类装入一个特定的命名空间，它就不能再装载名为Valcano的其他类到相同的命名空间了。可以把多个Valcano类装入一个JAVA虚拟机中，因为可以通过创建多个类装载器从而在一个JAVA应用程序中创建多个命名空间。<br><strong>初始类装载器/</strong> <strong>定义类装载器</strong></p><p>命名空间有助于安全的实现，因为你可以有效地在装入了不同命名空间的类之间设置一个防护罩。在JAVA虚拟机中，在同一个命名空间内的类可以直接进行交互，而不同的命名空间中的类甚至不能觉察彼此的存在，除非显示地提供了允许它们进行交互的机制，如获取Class对象的引用后使用反射来访问。</p><p>如果要求某个类装载器去装载一个类型，但是却返回了其他类装载器装载的类型，这种装载器被称为是那个类型的<strong>初始类装载器</strong><br>；而实际装载那个类型的类装载器被称为该类型的<strong>定义类装载器</strong><br>。任何被要求装载类型，并且能够返回Class实例的引用代表这个类型的类装载器，都是这个类型的初始类装载器。</p></blockquote><h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h1><p>1.常量池常量池,也叫Class常量池(常量池==Class常量池)。Java文件被编译成Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区各种字面量(Literal)和符号引用。在Class文件结构中，最头的4个字节用于存储魔数(MagicNumber)，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念。如下</p><p>2.运行时常量池</p><p>2.1运行时常量池的简介运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中2.2方法区的Class文件信息，Class常量池和运行时常量池的三者关系字符串常量池</p><p>3.1字符串常量池的简介字符串常量池又称为：字符串池，全局字符串池,英文也叫StringPo。在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p><h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3. 运行时数据区"></a>3. 运行时数据区</h1><ol><li>线程共享<br> 方法区，堆</li><li>线程私有<br> 虚拟机栈，本地方法栈，程序计数器</li></ol><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol><li>小内存，几乎无OOM，控制代码执行位置，比如循环，线程block恢复，wait恢复</li></ol><h2 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h2><ol><li>存储类信息 （第四步加载过程）</li><li>常量，静态变量</li><li>即时编译后的代码缓存数据 【Class方法表中Code属性，保存执行指令字节，将其缓存在方法区】</li></ol><p>元空间：能不限制使用系统内存资源</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ol><li>存放编译期生成的字面量+符号引用</li><li>具备动态性<br>不要求常量一定只有编译期才能产生<br><strong>String.intern()</strong> 是一个Native方法。调用intern()方法后，JVM 就会在当前类的运行时常量池中查找是否存在与str等值的String，若存在则直接返回运行时常量池中相应Strnig的引用；若不存在，则会在运行时常量池中创建一个等值的String，然后返回这个String在运行时常量池中的引用。</li></ol><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol><li>对象头（Header）: （Mark Word+ class指针+ 数组长度）<br>hashcode，GC分代年龄，锁标志状态，当前锁，偏向锁ID，偏向时间戳</li><li>实例数据（ Instance）</li><li>对齐填充（Padding）： 不满8字节的倍数就对齐填充<br><strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。 如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></li></ol><p><strong>（面试题） 64位JVM 中 new Object()  在Java中占多少内存？</strong><br>16字节。<br>Mark Word （8字节）+ class指针（指针压缩4字节，否则8字节）+实例数据（0字节）+对齐填充（4字节或0字节）</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>java栈是针对每一个线程的，每一个线程都会有自己的栈，维护在其内部的引用就是本地变量表。</p><p>通过线程想起栈，提问，对象是如何被线程访问定位的呀？问的非常底层。<br><a href="https://blog.csdn.net/y471519146/article/details/104638340" target="_blank" rel="noopener">https://blog.csdn.net/y471519146/article/details/104638340</a></p><ol><li>使用句柄。句柄是一个对象的唯一标示。中间有一个句柄池，存在于java堆的内存区域，线程指向句柄池，句柄池reference链接到对象地址</li><li>使用直接指针。线程对象指向另一对象。<br>优劣：直接指针访问快，但gc清理将对象位置移动，每个线程的指针就要改变，消耗大。<br>句柄优势：稳定，句柄池位置不变，当gc清理将对象位置移动，只需改变句柄池1个链接。</li></ol><h3 id="栈帧※"><a href="#栈帧※" class="headerlink" title="栈帧※"></a>栈帧※</h3><ol><li>1个方法创建1个栈帧：存储方法的局部变量表，操作数栈，动态链接，返回地址等。【class方法表中附带属性表中code属性有局部变量所需要的空间】</li><li>开始调用到完成过程就是一个栈帧的入栈出栈<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5>存储方法里的局部变量（包括方法参数），编译完成存储【class方法表中附带属性表中code属性】<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5>方法调用的最大深度【code属性的max_stack】，比如递归，调用数超出，则StackOverflowError。<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5>方法调用过程中，链接其他方法或其他类<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5>谁调用返回给谁。分两点</li><li>正常退出。</li><li>异常退出。抛错给调用方。</li></ol><p>####</p><h2 id="堆-展开知识-（第二期）"><a href="#堆-展开知识-（第二期）" class="headerlink" title="堆 展开知识 （第二期）"></a>堆 展开知识 （第二期）</h2><p>Q:新生代  eden s0 s1 是根据什么思想 8:1:1分区 ？ 回收器都是这样吗？<br>基于标记复制算法思想； 而基于标记清理算法就不是。</p><p>第一次minorgc： eden 空，s0 年龄1<br>第二次minorgc：eden空，s0空，s1 年龄有1和2<br>此时 s0 和 s1 角色互换<br>第三次minorgc：eden 1岁，s0空，s1 年龄有2和3<br>                             eden 空，s0空年龄有1,、2和3 ，s1空<br>此时 s0 和 s1 角色互换…</p><p>为什么需要s0和s1？<br> 需要空闲的缓冲内存，存储清理后的存活对象，避免s0区空间碎片化。</p><p>老年代</p><ol><li>年龄15岁以上</li><li>超大对象，超过阈值设置 max tenuring thread hold</li><li><p>相同年龄所有对象大小总和大于一个幸存者空间的一半，取年龄大于等于的对象，<br>所以年轻代空间利用，只有 90%</p><p>（一旦老年代要满就引发fullgc）</p></li></ol><p>※ 空间分配担保策略<br> minorGC发生之前，第一步先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立确保安全，如果条件不成立，比如空间剩余500M；<br> 就会第二步检查虚拟机HandlePromotionFailure参数是否true，是否允许担保失败；<br> 如果允许担保失败，jvm再次第三步检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小；</p><ul><li>如果大于，比如平均之前300M，冒险尝试一次minorGC，  存在风险：minorGC后存活对象还是大于500M，超出最大可用连续空间，说明老年代要满了就引发fullGC。<ul><li>如果小于 或 HandlePromotionFailure参数false，就直接fullGC。</li></ul></li></ul><p>（面试）如何判断对象是否存活？ gc过程是什么？<br>可达性分析算法，通过一系列称为“GC Roots”根节点，开始引用链的搜索，如果对象搜索不到，证明对象不可达，标记白色，最终被垃圾回收。<br>引申：引用计数器算法，每个对象有引用计数器，Redis使用<br>5个问题：</p><h3 id="1-gcroots-是什么？"><a href="#1-gcroots-是什么？" class="headerlink" title="1.gcroots 是什么？"></a>1.gcroots 是什么？</h3><p>是可达性分析的起点，是两个栈的栈帧的本地变量表中引用的对象，方法区中静态属性引用的对象，方法区中常量引用对象（两个栈两个方法区），其实还有，jvm内部也有引用，锁的获取和释放。</p><h3 id="2-引用链是什么？"><a href="#2-引用链是什么？" class="headerlink" title="2.引用链是什么？"></a>2.引用链是什么？</h3><p>强：常见，永远不被垃圾回收<br>软：非必须，内存溢出OOM之前，列入回收范围进行第二次回收，还溢出就抛错<br>弱：生存到下一次垃圾收集之前<br>虚：幽（或幻）灵引用，主要用于监测对象是否已经从内存中删除，堆外内存回收。</p><p>软引用尝试保留其引用对象，弱引用不会试图保留其引用对象，虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除。</p><blockquote><ul><li><p>虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中</p></li><li><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</p></li></ul></blockquote><h3 id="3-对象不可达意味着什么？一定被回收吗？"><a href="#3-对象不可达意味着什么？一定被回收吗？" class="headerlink" title="3.对象不可达意味着什么？一定被回收吗？"></a>3.对象不可达意味着什么？一定被回收吗？</h3><p>意味对象即将被垃圾回收，当然，不会立即回收。<br>※ 对象会放入f-q 的队列，会启动一条低优先级别的线程，读取对象，一个个调用对象的finalize方法，如果方法被覆盖并且被调用过，jvm会对该对象置为非必要垃圾回收，它逃过垃圾回收</p><h3 id="4-三色标记法是什么？"><a href="#4-三色标记法是什么？" class="headerlink" title="4.三色标记法是什么？"></a>4.三色标记法是什么？</h3><p>白： 对象不可达<br>黑： 已被访问，所有关联对象也扫描过<br>灰：未被扫描 （重新标记有关）</p><ul><li><figure class="image-box">                <img src="7779607-eecbd09f81b721f8.gif" alt="img" title class>                <p>img</p>            </figure></li></ul><p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p><ol><li><p>初始时，所有对象都在【白色集合】中；</p></li><li><p>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</p></li><li><p>从灰色集合中获取对象：<br>3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中；<br>3.2. 将本对象挪到【黑色集合】里面。</p></li><li><p>重复步骤3，直至【灰色集合】为空时结束。</p></li><li><p>结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收。</p><blockquote><p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p></blockquote></li></ol><p>当 Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。</p><p>而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p><p><strong>多标-浮动垃圾</strong></p><p>假设已经遍历到 E（变为灰色了），此时应用执行了 objD.fieldE = null (D &gt; E 的引用断开)：<br><figure class="image-box">                <img src="1153954-20201220213532679-409632912.png" alt="img" title class>                <p>img</p>            </figure></p><p>此刻之后，对象 E/F/G 是“应该”被回收的。然而因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮 GC 不会回收这部分内存。</p><p>这部分本应该回收 但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p><p>另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p><p><strong>漏标-读写屏障</strong></p><p>假设 GC 线程已经遍历到 E（变为灰色了），此时应用线程先执行了：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG;</span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 灰色E 断开引用 白色G</span></span><br><span class="line">objD.fieldG = G;  <span class="comment">// 黑色D 引用 白色G</span></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="1153954-20201220214557708-22631031.png" alt="img" title class>                <p>img</p>            </figure><p>此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。</p><p>最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。</p><p>不难分析，漏标只有同时满足以下两个条件时才会发生：</p><ol><li>灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。</li><li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li></ol><p>从代码的角度看：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG; <span class="comment">// 1.读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 3.写</span></span><br></pre></td></tr></table></figure><ol><li>读取对象 E 的成员变量 fieldG 的引用值，即对象 G；</li><li>对象 E 往其成员变量 fieldG，写入 null值。</li><li>对象 D 往其成员变量 fieldG，写入对象 G ；</li></ol><p>我们只要在上面这三步中的任意一步中做一些“手脚”，将对象 G 记录起来，然后作为灰色对象再进行遍历即可。比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。</p><blockquote><p>重新标记是需要 STW 的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记 STW 的时间，这个是优化问题了。</p></blockquote><p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。<br>它们的拦截的目的很简单：就是在读写前后，将对象 G 给记录下来。</p><p><strong>写屏障(仅拓展)</strong></p><ul><li><p>CMS：写屏障 + 增量更新</p><blockquote><p>当有新引用插入进来时，记录下新的引用对象。</p><p>思路：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。</p></blockquote></li></ul><ul><li><p>G1：写屏障 + SATB</p><blockquote><p>当原来成员变量的引用发生变化之前，记录下原来的引用对象。</p><p>思路：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的 GC Roots 确定后，当时的对象图就已经确定了</p><p>比如 当时 D 是引用着 G 的，那后续的标记也应该是按照这个时刻的对象图走（D 引用着 G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p></blockquote></li><li><p>ZGC：读屏障</p><blockquote><p>当读取成员变量时，一律记录下来</p></blockquote></li></ul><h3 id="5-有没有跨代引用的问题？※"><a href="#5-有没有跨代引用的问题？※" class="headerlink" title="5.有没有跨代引用的问题？※"></a>5.有没有跨代引用的问题？※</h3><p>minorGC时候，如果当前年轻对象被老年代的对象引用，那么就需要遍历老年代对象里面的引用，如果有引用就不删除年轻代对象。 遍历过多，这消耗过大。</p><p>空间换时间，引入<strong>记忆集</strong>（<strong>RememberSet数据结构</strong>），<br><strong>（卡表CardTable是具体实现类似数组的一种实现）</strong></p><p>用于记录从非收集区域指向收集区域的一个指针集合的抽象数据结构。</p><p>它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题。<br><a href="https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc</a></p><blockquote><p>记忆集根据记录的精度分三类：<br>字长精度：记录的是老年代指向新生代地址。<br>对象精度：记录的是老年代引用的新生代对象。<br>卡精度：记录的是新生代一段地址是否存在被老年代引用的记录。</p></blockquote><p>把地址的值右移9位相当于除于512就是卡表索引，每字节512为一组对应卡表同一个元素，一组就是一个卡页，<br>如果这个卡页中只要有一个对象被其他区域对象所引用，对应卡表元素的值就变成1，也就是所谓的元素变脏。</p><p>在垃圾回收时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页对应的内存包含跨代指针，把他们加入GC Roots中一并扫描。</p><h3 id="垃圾回收的3种算法"><a href="#垃圾回收的3种算法" class="headerlink" title="垃圾回收的3种算法"></a>垃圾回收的3种算法</h3><ul><li><p>标记-清除算法<br>标记后统一回收<br>空间问题: 他只有一块内存空间，会产生空间碎片，导致没有太多的可用的比较大的连续空间，导致对象创建找不到容纳空间，直接进入老年代。<br>优点：快，找到并马上删除</p></li><li><p>标记-复制算法<br>起初思想是将内存分半，内存1:1，一部分存储新对象，一部分负责我们的存活对象。实现的时候，eden，s0，s1，幸存者区1个缓冲<br>缺点：至少10%空间浪费，相对慢<br>优点：针对创建对象，有很大的可用连续空间，GC后，eden区域清空，都是连续空空间，没有空间碎片</p></li></ul><ul><li>标记-整理算法<br>优化了标记复制算法和标志清除算法的改进，</li></ul><ol><li>标记并清除</li><li>存活对象整理到1边<br>删除快，没有空间碎片</li></ol><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="image-box">                <img src="image_20220129152044.png?v=1&type=image&token=V1:muO6XhBva0We3ErRpB0T7PPyoRqWWSq-G6D2IwZ9ymA" alt title class>                <p></p>            </figure><ol><li>新生代：serial 单线程<br>单核服务器最快最理想，有stw暂停和安全点线程挂起的问题。<br>Q：会不会有CPU时间切片轮询？为什么单核快呢？<br>其他线程必须挂起Stop the world，cpu时间片都要落到垃圾收集的线程里面，其他线程不会有cpu时间片轮询，即便有，cpu时间片也是0。其他线程处于内核态，只有垃圾收集器处于用户态。</li></ol><p>为什么Stop the world呢？</p><ol start="2"><li><p>新生代：并发的parNew 。 serial 的多线程版本<br>标记复制算法</p></li><li><p>新生代：parallel Scavenge。<br>能多线程，又能关注和控制吞吐量。<br>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)<br>不与CMS合作</p></li></ol><p>两个控制参数：<br>    最大垃圾收集停顿时间<br>    直接设置吞吐量大小<br>如何控制吞吐量？<br>    首先，运行用户代码不会变。<br>    那么，通过多运行几回垃圾收集，来提高一次虚拟机运行的吞吐量。<br>    比如： 注意吞吐量参数是（0,100）</p><ol start="4"><li><p>老年代：Serial Old 收集器<br>单线程，标记整理算法</p></li><li><p>老年代：Pallel Old 收集器<br>标记整理算法，jdk1.6才开始，吞吐量优先。</p></li><li><p>老年代：CMS 收集器<br>Concurent Mark Sweep 多线程标记清除，以最短回收停顿时间为目标的收集器。<br>记忆：<br>三个mark一清除，初重stw</p></li></ol><p>CMS步骤过程：<br>初始标记 stw，标记gcroots 直接关联对象<br>并发标记  不停顿，扫描old区对象。</p><blockquote><p>刚才产生的集合中标记出存活对象；<br>应用程序也在运行；<br>并不能保证可以标记出所有的存活对象；</p></blockquote><p>重新标记 stw，修正<br>并发清除</p><p>stop the world 其他线程被挂起，处于内核态。</p><p>※※<br>CMS 缺点：<br>首先承认，G1 出来之前，jdk9之前, CMS是靠谱的。</p><ol><li>对资源处理非常敏感。<br>在并发标记时，占用CPU线程数，影响项目中运行所用线程数。因为占用资源，可能导致资源不足。默认启动(核数n+3)/4线程，这样，核数多防止占用。</li><li><p>无法处理浮动垃圾。<br>并发清除，程序运行依然运行，有新垃圾出现，本次收集无法处理，留到下一次GC才清理，这就是“浮动垃圾”。如果对象被疯狂访问，大量对象堆积，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p></li><li><p>“标记清除算法”虽然快，会产生大量空间碎片。</p></li></ol><h3 id="stop-the-word-※※"><a href="#stop-the-word-※※" class="headerlink" title="stop the word ※※"></a>stop the word ※※</h3><p>引入概念：根节点枚举。<br>在开始标记收集的时候，不管单线程还是并发，不管是对象还是线程，一定在一致性的快照里，才能进行。<br>如果不知道当前的状态的话，没办法进行后续的标记。<br>一致性快照的分析工作就是根节点枚举期间：所有线程停顿。</p><p>OopMap 特定的位置记录下栈和寄存器中的哪些位置是引用</p><blockquote><p> OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。<br> 一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。<br> 我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。<br> <strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong><br> 通过上面的解释，我们可以很清楚的看到使用 OopMap 可以避免全栈扫描，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC 。</p></blockquote><h3 id="安全点Safepoint"><a href="#安全点Safepoint" class="headerlink" title="安全点Safepoint"></a>安全点Safepoint</h3><p>垃圾收集过程，用户线程到达特定位置，这位置不会产生新对象，也不会影响项目的执行，只能让垃圾收集非常安全的进行下去。<br>位置：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置</p><p>OopMap线程找对象<br>回顾句柄池，直接指针。</p><p>如何线程如何找Class文件？<br>找常量池里的Constant_class_info指向Constant_utf8_info,找到权限命名，再去方法区。（类加载过程中，对象加载到方法区，再在堆生成class对象，作为访问类的入口）在堆中定位到Class。</p><p>想继续找方法？<br>方法表-&gt;属性表-&gt;code-&gt;max stack，max local，方法入口-&gt; 代码</p><h3 id="G1垃圾收集器※※"><a href="#G1垃圾收集器※※" class="headerlink" title="G1垃圾收集器※※"></a>G1垃圾收集器※※</h3><figure class="image-box">                <img src="image-20220208015310593.png" alt title class>                <p></p>            </figure><ol><li>分代理论垃圾收集，只不过是增加一个拓展。</li><li>把内存区域分成多个大小相等的内存区域块Region。</li><li>jdk9发布，把吞吐量组合取代了，成为服务端默认。如果换成CMS，那么JDK参数配置开启CMS，不过提示Warnings：CMS以后会被废弃。</li><li>内存分块会按照“意愿”进行局部收集。</li><li><p>Region堆内存布局的原理：<br>不再坚持固定大小的分代理论，把内存区域分成多个大小相等的内存区域块Region，每个Region会根据需要扮演新生代eden，survival），老年代的角色。<br>如果有大对象？<br>G1会分出一部分区域作为特殊区域专门存储大对象，如果通过G1检测，只要大小超过<strong>超过1.5个region</strong>，就可以判断大对象，就放到H。Region可以通过JVM参数设置，1-32GB之间。如果超过16GB，肯定放在大对象区域。<br>大对象区域称为：humongous，全称：attempt_allocation_humongous。<br>对于超大对象，比如32GB，会分配两个连续的Region空间。</p></li><li><p><strong>标榜：可预测停顿时间的模型。</strong><br> 关注每个模块里回收价值的大小，通过设置一个很低的最大允许GC时间ms，，-XX：MaxGCPauseMillis =200，根据200ms去找它能够进行收集的Region，比如：收10个Region需要花300ms，由于超过200ms，按比例降低先收集6-7Region达到而200ms要求。</p><ul><li>由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制</li></ul></li></ol><ul><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,<strong>每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</li></ul><p>Q：如何解决跨代Region引用问题？<br>A：使用记忆集，结构相对复杂，是个双向卡表。</p><p>步骤：<br>1.初始标记：stw<br>    GCRoots根节点枚举，在安全点进行<br>2.并发标记<br>3.最终标记：stw<br>4.筛选回收<br>    <strong>根据MaxGCPauseMillis最大允许GC时间，优先回收价值最大的Region， 保证可预测停顿时间。</strong></p><h3 id="JVM调优经验-※※"><a href="#JVM调优经验-※※" class="headerlink" title="JVM调优经验 ※※"></a>JVM调优经验 ※※</h3><p>根据用户访问量，在不同时刻导致JVM回收<br>在上线前，做压测，监督内存空间的使用，以及发生GC回收的频率和停顿时间。</p><ol><li><p>大访问的压力，一边回收一边对象持续创建，minorGC会比较频繁，那么，一：<strong>调大年轻代的大小</strong>。二：如果发生时间不长，很快回收，且回收率高，不会导致老年代短时间内有对象填充，那么就，<strong>进行持续压测</strong>，观察老年代的上限。</p></li><li><p>大对象创建的频繁且常访问，导致FullGC比较频繁，（对于G1会分配到humongous区）。一：压测观察大对象的大小，过大可以把对象拆分，维持在JVM参数下；二：适当调大判断为大对象的参数，防止它直接进入老年代；三：发生OOM异常，如何排查呢？压测过程，一定先dump出来堆内存的heap文件，导入visual VM工具，主要查看堆栈信息。找内存占用高的对象，Reference指向堆栈信息，最终定位代码。springboot的Context上下文是单例，很难发生大对象频繁创建。四:  线程无法到达安全点，请求第三方等待中，比如60s超时时间，其他线程的已经在安全点STW，这里细说：用户态和内核态。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验 | 性能优化的整体脉络的梳理</title>
      <link href="/2022/02/01/overall-performance-optimization/"/>
      <url>/2022/02/01/overall-performance-optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化要求我们关注整体效果，兼顾可靠性，扩展性，以及极端情况的异常场景。<br>笔记特点：大部分是已掌握的内容，一些知识只会概括提及。</p><h2 id="衡量指标※"><a href="#衡量指标※" class="headerlink" title="衡量指标※"></a>衡量指标※</h2><p>性能：有限资源，有限时间完成工作。</p><p>体现在横坐标为时间，纵坐标多种指标。</p><p>加载性能低，会导致搜索排名下降。</p><p>性能指标：</p><p>吞吐率 和 响应速度</p><p>响应速度是串行的优化，通过优化步骤解决问题；<br>吞吐率是并行的优化，充分利用计算机资源；</p><p>侧重于优化响应速度，就能提高吞吐率</p><p>这两点，构成了高并发。</p><p>类比，十字路口，开车排队到经过红绿灯时间，就是一个请求的响应时间；如果灯信号时间短一点，一些车可能通过快一点，如果灯信号切换过于频繁（限流力度过大），单位时间内通过的车过少，导致后面的车排队时间更长，这个就是吞吐量减少</p><p>吞吐率:</p><p>QPS，TPS，<br>HPS： HTTP请求数</p><p>细化指标：</p><ul><li>平均响应时间：所有耗时的平均，但不能体现出方差，抖动大小，</li><li>响应时间百分位数，TP值：理解为一种阈值，像合格率（水位），反应出应用接口的整体响应情况。指数目标是 干掉严重影响系统的长尾请求。</li></ul><blockquote><p>例若有100个请求， 每一个请求的响应时间分别是 1-100 平均分布 平均响应时间： 1-100 的平均值，即 50.5 95% percentile ： 按从小到大排序，累计第95百分位，也就是 95 （即样本里95% 的数据都不高于这个值）</p></blockquote><ul><li>并发量：同时进入的请求数量，指在同一个时间点，同时请求服务的客户数量。</li></ul><p>注意：吞吐率和并发数是两个完全独立的概念。拿银行柜台来举个例子，并发数指同时有多少人往银行柜台涌来。吞吐率则指银行柜台在一段时间内可以服务多少个人。</p><ul><li><p>秒开率：APP启动速度，页面加载速度。</p><p>使用CDN加载；用mokey脚本检查白屏，用动画或加载骨架，减少白屏情况；HTTP2的缓存推送机制提前推送JS，CSS；</p></li><li><p>正确性：接口请求无BUG。</p><p>比如，一个事故，测出的并发量特别高，这是由于项目使用了熔断，压测过程触发熔断，又因为没有对接口正确性判断，造成低级错误的报告。</p></li></ul><p>性能优化：</p><p>基准测试，木桶理论，Amdahl定律</p><p>基准测试：测试最佳性能。</p><p>比如，要排除掉项目启动，进行缓存预热，消除JIT编译器影响。</p><p>木桶理论：性能瓶颈取决于最慢的组件。</p><p>比如，DB的I/O落盘。这是首先要解决的问题。</p><p>性能优化注意点：</p><p>一是依据数字不是猜</p><p>二是个体数据不足信</p><p>三不要过早优化和过度优化</p><p>四保持良好编码习惯</p><h2 id="7类技术优化手段※"><a href="#7类技术优化手段※" class="headerlink" title="7类技术优化手段※"></a><strong>7类技术优化手段</strong>※</h2><p>复用优化</p><p>计算优化</p><p>结果集优化</p><p>资源冲突优化</p><p>算法优化</p><p>高效实现</p><p>JVM优化</p><hr><p>其他：</p><p>数据库优化</p><p>操作系统优化</p><p>架构优化</p><p>协议优化</p><p>等等</p><p>展开：</p><p><strong>复用优化</strong></p><p>1、代码复用：抽成公共方法，抽成公共模块；</p><p>2、数据复用：首先想到缓冲和缓存。</p><blockquote><p> <strong>缓冲(Buffer)</strong>：对数据暂存，然后批量传输或写入；<br> 多使用顺序方式，缓解不同设备频繁，缓慢地随机写。<br> <strong>缓存(Cache):</strong>对已读数据的复用；<br> 缓存在相对高速区域，针对读操作。</p></blockquote><p>3、池化复用：对象创建和销毁成本高。</p><blockquote><p>线程池，连接池，把对象预热存储，方便所有后续使用。</p></blockquote><p>4、对象复用：clone思想的原型模式，共享技术的享元模式</p><p><strong>计算优化</strong></p><p>1、并行优化：想加快任务执行，最快最优就是让它并行执行。</p><blockquote><p>硬件上是：CPU等设备多核，多机。</p><p>模式上是：</p><p>多机：采用负载均衡，将流量或大计算拆分多个部分，同时处理，比如Hadoop，用MapReduce将任务打散，多机并行计算；</p><p>多进程：nginx的NIO进程模型，master进程统一管理worker进程，由worker进程真正代理，利用了CPU多核。</p><p>redis的主进程读写，子进程RDB快照写时复制技术；</p><p>多线程：Netty的Reactor的NIO模型。boss线程接收请求，worker线程真正计算。</p><p>多协程：更轻量，比如GO语言</p></blockquote><p>2、同步变异步：涉及编程模型的改变</p><p>同步简单，但对突发的，时间段倾斜的流量，问题大，容易失败。</p><p>3、异步方式：请求横向扩容，缓解瞬时压力，使流量平滑。</p><p>4、惰性加载：单例模式，代理模式，分页加载</p><p>加载图片文件，可以先加载占位符，再通过后台线程慢慢加载所需要资源。</p><p><strong>结果集优化</strong></p><p>让体积更小，传输效率和解析效率更高</p><p>1、protobuf二进制优先于JSON，优先于XML</p><p>2、Nginx，开启HTTP的GZIP压缩，保持数据紧凑</p><p>3、批量处理的方式：对于时效性要求不高，对业务能力要求高的业务，要减少网络连接的交互，先存缓冲区，再批量交付。</p><p>4、数据结构优化：对于要二次使用的结果集，会存入缓存，可以根据使用场景，存储索引，bitmap位图，二进制数，B+树，跳表，压缩列表来加快读速度。大对象优化为只保留有用属性粒度</p><p><strong>资源冲突优化</strong></p><p>涉及共享资源，如：单机HashMap，mysql的数据行，单资源Redis的某key的setnx，多个资源协调的事务和分布式事务。</p><p>就要选择合适的锁。</p><p>锁应用各种地方，mysql的行锁表锁，java各种锁，底层cpu锁，jvm锁，操作系统内部锁</p><p>按照锁级别，分为乐观锁和悲观锁，乐观锁效率更高</p><p>按照锁类型，分为公平锁和非公平锁，任务调度上有差别</p><p>锁越重，性能消耗越大，</p><p>实现无锁的机制，对性能提升巨大的。</p><p><strong>算法优化</strong></p><p>提高复杂业务的性能，一般采用空间换时间，加快处理速度。</p><p>算法是代码调优，考验开发者的编程技巧和API掌握程度。</p><p>常用的递归，二分，快排，动态规划，贪心等。</p><p><strong>高效实现</strong></p><p>1、技术选型，尽量选择设计良好，性能优越的组件；</p><p>Netty作为非阻塞web容器，</p><p>语法分析器javacc，效率比正则表达式更好</p><p>2、维护性，采用适配器模式，以便在测压找到瓶颈点，用更高性能的组件进行替换。</p><p><strong>JVM优化</strong></p><p>配置参数，一定程度提高JAVA程序的性能。</p><p>如果不当，可能OOM。</p><p>1、G1垃圾回收器，内存高效回收，CMS已经被java14移除</p><p>2、堆大小调整，minorGC和fullGC</p><p>3、大对象阈值设置</p><p>4、代码层面优化</p><p>5、监控线上堆栈信息</p><p>6、开启补齐，避免伪共享</p><hr><h2 id="分析哪些资源，容易成为瓶颈"><a href="#分析哪些资源，容易成为瓶颈" class="headerlink" title="分析哪些资源，容易成为瓶颈"></a>分析哪些资源，容易成为瓶颈</h2><p>1、系统组件之间的速度不均衡；</p><p><strong>CPU，内存，IO组件，容易成为瓶颈。</strong></p><p>CPU：</p><p>top命令，CPU性能</p><p>uptime命令，看负载，评估任务排队情况</p><p>vmstat，CPU繁忙程度，上下文切换程度。</p><p><strong>缓存行伪共享问题</strong></p><p>内存：</p><p>top命令，看进程实际占用内存</p><p>free命令，看剩余内存</p><p>大内存时代，采用<strong>HugePage</strong>将4kb快表页增大2MB，但竞争加剧会增加性能。</p><p><strong>JVM预分配好内存</strong>，加快运行速度</p><p>IO设备：</p><p>IO设备是包括所有外围设备</p><p>缓冲区解决差异的唯一工具，但断电容易丢失。</p><p>iostat命令工具，查看IO性能。</p><p>网络：</p><p>iotop命令，看网络流量最高的进程</p><p>netstat命令，看机器网络连接汇总</p><p><strong>零拷贝技术</strong>，kafka，Nginx</p><p>优化IO+网络</p><p>kafka操作磁盘 吞吐量高的原因?</p><p>磁盘慢是慢在寻道操作，磁盘顺序写和随机写的速度差达到6千倍，kafka采用顺序写。</p><h2 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h2><p>nmon获取系统性能数据工具</p><p>jvisualvm 获取JVM性能数据</p><p>CPU分析：代码执行时长和热度</p><p>内存快照分析：内存泄漏</p><p>线程分析：死锁情况</p><p>HotSpot VM 的JMC，获取java性能详细数据</p><p>web容器，线程，内存，锁，socket IO，方法，垃圾回收</p><p>JIT，TLAB</p><p>arthas 获取单个请求的调用链耗时</p><p>trace命令获取调用链</p><p>wrk HTTP压测工具，获取web接口性能工具</p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>为了测量某一段代码的具体执行情况。</p><ul><li>最简单，编写统计执行代码时间。</li></ul><p>​    这不一定正确，代码块频繁时，JVM会有JIT编译和内联优化，要想得到稳定结果，需要执行上万次循环预热；</p><p>​    有大量埋点，统计指标单一</p><ul><li><p>JMH基准测试工具。JDK12内置，低版本需要引入。通过注解形式单独配置，OptionSBuilder全局配置</p><p>通过开启多个进程多个线程的子任务完成预热，然后真正的迭代，最终结果合并</p><p>精度高，纳秒级，多指标，可图形化结果</p></li></ul><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>保持各自节奏，顺序不打乱</p><p>结合批量处理，减少网络IO操作</p><p>优化用户体验，音视频的提前缓冲</p><ul><li>文件IO流  是装饰器模式</li></ul><p>缓冲区读取一块一块的部分数据</p><ul><li>日志缓冲</li></ul><p>Logback异步采样，写入缓冲区达到阈值，才持久化。</p><ul><li><p>kafka发送缓冲</p><p>生产者发送前有个缓冲区，如果生产者断电，消息丢失；</p><p>解决：</p><p>缓冲区设置非常小，退化到单条，影响网络性能</p><p>发送前持久化消息日志，发送后处理完回调再记录一条日志，扫描对比。</p></li><li><p>Mysql的innodb_buffer调整大小，减少换页；</p></li><li><p>StringBuilder 和StringBuffer，字符缓冲区，提供拼接字符串的性能</p></li><li><p>磁盘，网络IO，缓冲区提高信息流转效率，可以flush强制刷新数据。半连接队列，全连接队列</p></li><li><p>ID生成器，缓冲一部分ID段，避免频繁耗时的交互。</p></li></ul><p>缓冲区饱和策略：丢弃，异常，等待</p><p>缓冲区数据丢失解决：</p><p>优雅关闭，没完全解决；</p><p>预写日志，故障后重启，根据日志恢复数据。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>让页面秒开</li><li>减少数据库压力</li><li>处理冷热数据</li></ul><p>堆内缓存</p><p>大多数对内缓存，会将对象的引用设置为弱引用或软引用，当缓存非常频繁，而且数据量大，如果发生GC回收，缓存空间被释放，又瞬速沾满，从而再次垃圾回收。</p><p>设置缓存小一些，减轻JVM负担。</p><p>进一步加速</p><p>linux文件缓存：</p><p>预读算法，从磁盘智能加载到缓存</p><p>缓存算法影响命中率和性能，</p><p>目前最好的是Caffeine（咖啡呢）使用的W-TinyLFU算法，性能非常高</p><p>例子</p><p>HTTP 304 Not Modified，请求头if-Modified-Since判断客户端缓存是否最新</p><p>CDN，用户最近最快节点，读取静态文件内容，贵</p><p>双写缓存不一致问题：延迟双删，binlog-MQ</p><h2 id="数据冷热分离"><a href="#数据冷热分离" class="headerlink" title="数据冷热分离"></a>数据冷热分离</h2><p>数据双写</p><p>冷热库CRUD在统一事务</p><p>由于热库和冷库类型不同，事务大概率是分布式，缺陷：难以改造。</p><p>写入MQ分发</p><p>通过MQ发布订阅，分发到冷热库，逻辑非常清晰</p><p>binlog订阅</p><p>canal组件获取数据，结合MQ，同步到其他数据源</p><h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><p>减少创建对象的成本，资源反复利用。</p><p>公共对象池化包 Commons Pool 2，Jedis连接池使用到。</p><p>maxTotal：对象上限</p><p>maxIdle ：最大空闲数</p><p>maxIdle： 最小空闲数（核心对象数）</p><p>maxWaitMillis：资源用尽时，最大等待直到对象空闲时间，-1表示永远不超时。超时快速失败</p><p>minEvictableIdleTimeMillis 资源池中资源最小空闲时间(单位为毫秒)，达到此值后空闲资源将被移除，默认30min</p><p><strong>HikariCP连接池为什么快？ （Hi卡乐CP）</strong></p><p>1，有效减少数据库连接创建，消耗的资源消耗；</p><p>2，FastList代替ArrayList，通过初始化的默认值，减少越界检查。通常情况下，同一个Connection创建了多个Statement时，后打开的Statement会先关闭，FastList从数组的尾部开始遍历删除，更为高效</p><p>3，优化并精简字节码，使用javassist，减少动态代理的性能消耗，比如invokestatic指令代替invokevirtual，指令更便于JVM去做更底层的优化。这个优化甚至把<strong>栈帧中的栈深度从5降到了4，减少了push和pop指令</strong>。</p><p>4，无锁的ConcurrentBag，减少并发场景下的锁竞争，减少伪共享</p><p>​    ConcurrentBag，有三个重要的成员变量：</p><ul><li><p>ThreadLocal 缓存，加快本地连接获取速度</p></li><li><p>CopyOnWriteArrayList，sharedList共享写时拷贝List</p></li><li><p>SynchronousQueue，无存储的等待队列</p><p> ConcurrentBag 的优化思路就是CAS尝试从ThreadLocal中找空闲连接来避免锁竞争，如果没有可用元素则再次从共享的CopyOnWriteArrayList中获取，还找不到就放入SynchronousQueue等着。</p><p>通过将连接本地存储化来减少竞争，又根据连接池读多写少的特性用 CopyOnWriteArrayList 来实现 sharedList 。</p><p>这里还有个<strong>中途窃取的概念</strong>，其实没什么花头，就是充分利用连接。</p><p>根传统锁模型不同，它用了标记模型，抢占资源只是CAS操作进行”标记状态“ <code>STATE_IN_USE</code>。</p><p><strong>中途窃取</strong>无非就是本来属于某个线程的本地连接，当它归还连接的时，恰巧有另一个线程从 sharedList 遍历找到这个连接，这时候连接的状态是 <code>STATE_NOT_IN_USE</code>，那么这个连接就会被另一个线程也保存到 ThreadLocal 中了。 否则是没有窃取，就唤醒等待队列的线程。</p></li></ul><p>冷门技巧优化：根据业务的类型设置多个连接池，减少连接资源争抢。</p><ul><li>快速响应时间，把数据快速返回给用户</li><li>可以慢慢执行，耗时比较长，对时效性要求不高</li></ul><p>池一般存储的是执行对象，缓存一般存储的是数据对象</p><p>结果缓存池：保存某个执行步骤的结果，使得下次无需从头执行；</p><p>比如：热点文章页面静态化，无需再从头渲染。</p><h2 id="大对象复用与聚焦"><a href="#大对象复用与聚焦" class="headerlink" title="大对象复用与聚焦"></a>大对象复用与聚焦</h2><p>substring方法，JDK 8 是new复制出部分字符串，在JDK 6直接获取源字符串，</p><p>借鉴意义：在大对象中获取部分信息，根据业务情况，决定是否有原对象的引用关系。</p><p>扩容，StringBuilder，StringBuffer，HashMap，ArrayList等：扩容操作需要重新组织数据，注意线程安全问题；</p><p>优化：</p><p>查询用户的字段，Redis存储的用户的JSON字符串数据打散， 改为Hash对象结构，方便hget</p><p>bitmap  </p><p>java Bitset</p><p>potobuf</p><p>数据结构优化：对于要二次使用的结果集，会存入缓存，可以根据使用场景，存储索引，bitmap位图，二进制数，B+树，跳表，压缩列表来加快读速度。大对象优化为只保留有用属性粒度</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>大多数设计模式并不能增加性能，下面列举性能相关的设计模式：</p><p>代理模式，单例模式，享元模式，原型模式</p><p>代理模式</p><p>通过一个代理类，控制一个对象的访问</p><p>jdk面向接口，CGLib字节码增强，新版本性能差不多。</p><p>Spring AOP如果引入CGLIB，就是用CGLIB对java字节码增强，完成一个切面编程。比如权限，日志等切面。</p><p>虽然方便代码，但动态代理模式的处理更慢。</p><p>可以通过arthas分析慢逻辑来优化。</p><p>单例模式</p><p>scope注解指定bean的作用域，标识多例还是单例</p><p>默认是单例，线程安全。</p><p>单例有懒汉和饿汉加载方式：</p><p>饿汉会造成空间资源的浪费。</p><p>懒汉需要DCL或者静态内部类创建实例。</p><p>享元模式</p><p>通过共享技术，最大限度复用对象一般使用唯一的标识码进行判断，然后返回对应的对象。</p><p>比如，池化对象。</p><p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p><p>很多设计都使用享元模式，只是语境下差别。</p><p>原型模式</p><p>首先缓存一个实例，然后通过这个实例克隆出新对象，</p><p>一般可配合工厂模式。</p><p>必须实现 Cloneable 接口，</p><p>由于 Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生异常。</p><p>clone如果只拷贝当前对象，实现的就是浅拷贝。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>IO密集型，计算密集型</p><p>线程池</p><p>写时复制</p><p>StringBuilder 对 StringBuffer</p><p>HashMap对CurrentHashMap</p><p>ArrayList对CopyOnWriteList</p><p>FastThreadLocal</p><p>首先ThreadLocalMap没有链表红黑树，使用了开放地址法。</p><p>FastThreadLocal 底层是数组，定位数据直接根据数组下标 index 获取；</p><p>而且，写了9个多余long类型，对伪共享问题优化</p><p>Foin/Join</p><p>CompletableFuture</p><p>不正确使用问题：</p><p>线程池不正确，造成资源分配不可控</p><p>IO密集，线程池太小，造成请求频繁失败</p><p>线程池用等待线程释放饱和策略，造成业务阻塞</p><p>SimpleDateFormat的时间错乱： 多个线程之间共享变量calendar，并修改calendar。因此在多线程环境下，当多个线程同时使用相同的SimpleDateFormat对象（如static修饰）的话，如调用format方法时，多个线程会同时调用calender.setTime方法，导致time被别的线程修改，因此线程是不安全的。</p><p>解决方案：</p><p>　　1、将SimpleDateFormat定义成局部变量</p><p>　　2、 加一把线程同步锁：synchronized(lock)</p><p>　　3、使用ThreadLocal，每个线程都拥有自己的SimpleDateFormat对象副本。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁分层升级</p><p>乐观锁</p><p>悲观锁</p><p>Redis分布式锁，lua脚本，看门狗续期锁</p><p>无锁</p><h2 id="NIO模型"><a href="#NIO模型" class="headerlink" title="NIO模型"></a>NIO模型</h2><p>BIO到NIO，再到AIO</p><p>Netty Rector模型</p><p>select/epoll</p><p>响应式编程：WebFlux底层使用Netty，一种面向数据流和变化传播，表达为生产者消费者之间进行流量控制（背压问题），通过全面操作异步化，来减少无效的等待和资源消耗。</p><p>Spring Gateway 的RouteLocator</p><p>背压是反应流中的一个重要概念，可以理解为，生产者可以感受到消费者反馈的消费压力，并根据压力进行动态调整生产速率。</p><h2 id="Springboot-性能优化"><a href="#Springboot-性能优化" class="headerlink" title="Springboot 性能优化"></a>Springboot 性能优化</h2><p>1，首先要暴露数据，比如缓存命中率，连接池参数，业务数据，然后开启监控。</p><p>可以用普罗米修斯暴露数据，配合Grafana数据展示。</p><p>可以看火焰图找到性能瓶颈；</p><p>2，优化请求链路</p><p>HTTP优化：使用HTTP2</p><ul><li><p>CDN，Cache-control浏览器缓存</p></li><li><p>减少单页面请求的域名数，4个之内。因为每次请求域名，查DNS找IP，再调用服务器。若没有本地DNS缓存，产生一定的调用链路开销。</p></li><li>开启GZIP，减少传输效率，Nginx或者Okhttp</li><li>对JS，CSS等资源压缩，应用在前后端分离模式。</li><li>使用keep alive 长连接，减少连接创建和关闭消耗</li></ul><p>JVM优化</p><pre><code>- G1- 堆大小- 堆比例- 进入老年代阈值调整- -XX:+AlwaysPreTouch 在服务启动的时候真实的分配物理内存给JVM</code></pre><p>访问数据库慢优化</p><p>​    - 本地缓存</p><p>分布式</p><p>​    - skywalking 全链路追踪</p><p>Controller</p><ul><li>保持结果集精简 JSON</li></ul><p>Service</p><pre><code>- 单例- 设计模式组织代码- 分布式事务，保证最终一致性：</code></pre><p>Dao</p><pre><code>-  使用合理缓存，避免缓存穿透-  注意sql在分库分表环境执行的性能</code></pre><p>使用HikariCP连接池</p><h2 id="常用代码优化法则"><a href="#常用代码优化法则" class="headerlink" title="常用代码优化法则"></a>常用代码优化法则</h2><ul><li>多使用局部变量：栈分配，可避免堆上分配，堆是垃圾回收主要区域，也避免过多对象造成GC压力。</li><li>减少变量的作用范围：在if分支内，减少创建。</li><li>访问静态变量用类名，不要用this，否则导致多了一步找类的寻址指令。</li><li>StringBuilder或StringBuffer拼接字符串，减少字符串创建</li><li>重写HashCode，要重写equals</li><li>HashMap等集合初始化，指定初始值</li><li>不要在多线程下使用同一个Random，否则seed会在并发访问发生竞争，建议ThreadLocalRandom，配置jvm参数使用速度快的urandom随机生成器</li><li>自增推荐LongAddr，这是synchronized和volatile组合；AtomicLong是CAS替换，导致自旋。</li><li>不要捕捉RuntimeException，要提前判断</li><li>能复用的SQL合理PreparedStatement预编译，能对SQL执行提速，对能复用的SQL语句<strong>放入缓存执行计划中</strong>，下次执行跳过解析动作，所谓预编译语句就是将这类语句的值用占位符替代,可以视为将sql语句模板或者说参数化，防止SQL注入</li><li>日志打印优化，使用占位符，避免多余的字符串拼接操作；减少日志打印，减少占用IO资源</li><li>减少事务作用范围</li><li>位移操作代替乘除法</li><li>不要打印大集合</li><li>少用反射，它通过解析字节码实现，性能不理想，若使用，可加缓存优化</li><li>正则表达式预先编译，初始化一次即可，加快速度；正则解析很慢，可改为状态机</li><li>invokestatic指令调用静态绑定方法 ，代替invokevirtual调用实例动态绑定方法</li></ul><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>inline –方法内联：对于短小方法体，采用直接追加代码的方式。</p><p>分层编译层次：</p><p>1字节码解释执行</p><p>2执行不带profiling的C1代码</p><p>3执行仅带方法调用以及循环次数profiling的C1代码</p><p>4执行带所有profiling的C1代码</p><p>5执行C2代码</p><p>profiling是指运行时程序执行状态的数据：循环调用次数，方法调用次数，分支跳转次数，类型转换次数。</p><h2 id="逃逸分析："><a href="#逃逸分析：" class="headerlink" title="逃逸分析："></a>逃逸分析：</h2><p><strong>对象，除了基本类型，一定是在堆上分配吗？错。</strong></p><p>经过逃逸分析，可分析出对象的作用范围，来决定是否讲对象分配到堆上。</p><p>成员变量可以分配到栈上，方法返回对象可以分配到堆上。</p><ol><li>对象是否被存入堆中（静态字段或堆中对象的实例字段）</li><li>对象是否被传入未知代码中（方法的调用者和参数）</li></ol><p>总体分3点：</p><p><strong>对象可能分配在栈上</strong></p><p>JVM通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。</p><p><strong>分离对象或标量替换</strong></p><p>当JVM通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，我们将这个打散的过程叫做标量替换。将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。</p><p><strong>同步锁消除</strong></p><p>如果JVM通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。</p><p><strong>这里，需要注意的是：这种情况针对的是synchronized锁，而对于Lock锁，则JVM并不能消除。</strong></p><h2 id="什么是JVM预热"><a href="#什么是JVM预热" class="headerlink" title="什么是JVM预热"></a>什么是JVM预热</h2><p><strong>JVM预热</strong> ： JVM Warm Up</p><p>一旦类加载完成，所有重要的类（在进程启动时使用）都会被推送到JVM缓存（本机代码）中，这使得它们在运行时可以更快地访问。其他类是根据每个请求加载的。<br>对Java Web应用程序的第一个请求通常比进程的生命周期中的平均响应时间慢得多。这个预热期通常可以归因于延迟类加载和及时编译。<br>记住，对于低延迟应用程序，我们需要预先缓存所有类，以便在运行时访问时立即可用。<br>这种调优JVM的过程称为预热。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pob3VmYW55YW5nX2NoaW5h,size_16,color_FFFFFF,t_70.png" alt title class>                <p></p>            </figure><p><strong>基于采样的热点探测</strong>：<br> 周期采样，检测各线程栈顶方法，经常出现的方法即为热点方法。好处是简单高效，缺点是不精确，容易受线程运行状态的影响。</p><p><strong>基于计数的热点探测</strong>：<br> （包括方法调用计数器和回边计数器）每个方法建立计数器，用来统计调用次数。如果该方法执行次数超过阈值，则该方法被认定为热点方法。好处是足够精确。缺点是空间损耗大，且实现较难。</p><p>另外，可以通过如XX:CompileThreshold等参数来修改阈值，不过，没有绝对把握，还是不要动为好。</p><p>TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。</p><p>是对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内。</p><p>JIT指导代码优化</p><p>为什么我们在刚写代码的时候，总是被建议不要写很大的方法体？方法内联的JIT优化策略就是其中一个重要的原因。（还有GC友好等原因）</p><p>JVM内的每一次方法调用，都是栈帧在内存中出栈入栈的过程，方法多了性能损耗自然大，所以要进行方法内联，即把方法执行逻辑直接复制到调用方内部，避免方法调用。</p><p>但是，方法内联是有方法大小限制的，超过了一定大小的方法，没法做内联优化。所以，平常应该注意，尽量避免写很大很冗长的方法。</p><p>方法内联虽然只是一种简单优化，但是，是后续其他优化的基石。</p><p>而JVM的分层优化涉及的点非常多[1]：</p><p>局部优化：关注局部数据流分析，数组越界检查消除；寄存器优化，优化跳转、循环、异常处理等；代码简化，如公共表达式提取等等等。</p><p>控制流优化：专注于代码重排序、循环缩减、循环展开、异常定位优化等等等。</p><p>全局优化：主要关注冗余消除，如方法调用、锁；逃逸分析；GC和内存分配优化等等等。</p><h2 id="综合思考性能优化"><a href="#综合思考性能优化" class="headerlink" title="综合思考性能优化"></a>综合思考性能优化</h2><ul><li>业务需求层面</li></ul><p>报表业务，查询缓慢，有时候造成内存溢出</p><p>经过分析，查询时间跨度范围太大造成，缩小到1个月，速度快多了。</p><ul><li>硬件层面</li></ul><p>有一个定时任务，每次将CPU用满，由于系统架构硬伤，无法横向扩容，经过技术评估，如果改成按照数据分片执行的模式，则需要消耗长达1个月工时。</p><p>那么，这个时候，增加硬件。</p><p>尽可能在效果，手段，工时权衡。</p><p>如何找到优化目标？</p><p>利用率：一般是瞬时值，属于采样范围，用来判断有没有峰值</p><p>饱和度：一般指资源是否被合理利用，能否分担更多工作</p><p>错误信息：严重的特别关注</p><p>联想信息：靠经验去猜，然后用工具验证。</p><h2 id="基本解决方式"><a href="#基本解决方式" class="headerlink" title="基本解决方式"></a>基本解决方式</h2><p><strong>CPU问题</strong></p><p>top-Hp命令获取CPU占用最高线程，针对性优化</p><p>棘手问题经验：线程阻塞在ForkJoin线程池上</p><p>代码在等待I/O时，采用并行流（parallelStream）处理，但Java默认所有的方式是所有并行流的地方，共用同一套线程池。这个线程池的并行度只有CPU的两倍。并发量增加，造成任务排队，产生积压。</p><p><strong>内存问题</strong></p><p>通常是OOM。如果内存资源紧张，CPU利用率低，考虑时间换空间。</p><p>一般在高并发应用，会把Swap关掉，因为它很容易引起卡顿。</p><p><strong>IO问题</strong></p><p>一般情况，磁盘IO小，网络IO大</p><p>通过调整日志级别，清理无用日志代码，缓解磁盘IO的压力</p><p>通过RPC调用一个远程服务，期望使用NIO减少无效的等待，或者并行方式加快信息读取</p><p>类似ES数据库，写入造成繁重的磁盘IO，可以增加硬件的配置，换成SSD固态磁盘，或增加新的磁盘；调整segment块大小，translog的刷新速度等。</p><p>对于网络IO，</p><p>springboot和OkHttp开启gzip压缩，</p><p>结果集合并</p><p>使用批量的方式</p><p>netstat命令，获取进程网络状态</p><p><strong>中间层</strong></p><p>加入中间层，缓冲/缓冲，池化，牺牲信息的时效性，加快信息处理的处理速度。</p><p><strong>资源同步</strong></p><p>切分冲突资源的粒度</p><p>减少资源锁定的时间</p><p>将读写分开</p><p><strong>组织优化</strong></p><p>重构–设计模式</p><p>异步化</p><p><strong>资源利用不足</strong></p><p>资源不能合理利用，就是浪费。</p><p>轮转：一定压力下系统的最优状态</p><p>IO密集：并行</p><p>合理利用空闲空间：高位要加大容量</p><h2 id="PDCA-循环方法论"><a href="#PDCA-循环方法论" class="headerlink" title="PDCA 循环方法论"></a>PDCA 循环方法论</h2><p>管理性能优化的过程</p><p>P计划阶段：收集指标，找性能问题，设定改进目标，制定改进措施</p><p>D执行阶段：执行计划</p><p>C检查阶段：检查优化效果，及时发现改进过程的经验和问题</p><p>A处理阶段：将成熟经验推广，有点及面覆盖，为负面形成解决方法，将错误方法形成经验。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 系统 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务 | volatile | 单例模式 | OS | 杂笔摘抄</title>
      <link href="/2022/01/26/distributed-volatile-series/"/>
      <url>/2022/01/26/distributed-volatile-series/</url>
      
        <content type="html"><![CDATA[<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a>select/poll/epoll</h2><p>在客户端请求服务端时，就是在服务端写入对应的客户端文件描述符FD，如果多个客户端同时请求一个服务端，每一次请求开一个线程，会耗费CPU资源，因此，用一个线程监听多个服务器资源，就是IO多路复用，通信模型有三种，select/poll/epoll。<br>第一种select，在需要判断是否有节点就绪时，会把文件描述符FD从用户态拷贝到内核态中，因为在内核态中判断，效率会比较高。<br>当遍历完文件描述符FD，会把事件返回，select再由用户态向内核态会耗费系统资源，效率比较低，除此，文件描述符以数组保存，在32位，有最大数量1024，64位为2048。拷贝过程中，是用bitmap位图来标记文件描述符的状态，并且使用完后需要置位。</p><p>第二种poll 为了解决数组上限和位图置位问题，引用新结构体pollfd，包含fd，event，revent，首先看fd，是由链表保存，解决连接上限问题，event是读写和异常事件，revent是返回事件，可重用，解决select中位图置位问题，需要循环遍历判断就绪，时间O(n)。</p><p>第三种epoll，可以把就绪判断控制在O(1)，通过三个方法实现，epoll_create()会创建poll实例；epoll_ctl()，会FD注册到内核，避免了用户态的拷贝，内核中保存FD是用了红黑树；epoll_wait()，在<br>红黑树中有就绪时间时，会把它在双向链表中，让用户调用epoll_wait()时，会直接从链表中返回，这里涉及两种触发模式，LT和ET模式；LT水平触发，wait检查fd就绪时，不立即转化双链表，当下次调用wait方法时，再通知进程，这是默认的触发方式；ET边缘触发，通知后进程立即处理事件，下次调用wait方法不会通知，减少epoll时间被重复触发的次数，效率比LT高。</p><h2 id="Spring-Cloud-微服务"><a href="#Spring-Cloud-微服务" class="headerlink" title="Spring Cloud 微服务"></a>Spring Cloud 微服务</h2><p>起初，一个项目的所有功能模块都在一个工程中编码，编译，打包，比如部署在一个tomcat容器中，一般只需要一个数据库，随着业务和用户增长，tomcat需要集群化，负载均衡则需要一个nginx，甚至用到文件或缓存服务器，这样存在单个项目过大 ，而且耦合严重的问题。流行的微服务就可以把项目拆分粒度更小，耦合度降低，并且可以独立部署和扩展，可维护性更强，一个微服务可以部署多个节点来支撑。当服务过多，需要有效识别和管理服务，就需要引入服务治理，通过服务的发现和注册，比如阿里nacos，充当注册中心，把所有启动的服务注册进来，当然，它也可以作为配置中心。</p><blockquote><p>注册中心：Eureka册中心将返回所有可用的服务实例给消费者，但是一般不推荐这种情况。另一种方法就是本地Map存储服务实例列表，服务的消费者向注册中心订阅某个服务，并提交一个监听器，当注册中心中服务发生变更时，监听器会收到通知，这时消费者更新本地的服务实例列表，以保证所有的服务均是可用的。<br>配置中心：客户端是通过一个定时任务来检查自己监听的配置项的数据的，一旦服务端的数据发生变化时，客户端将会获取到最新的数据，并将最新的数据保存在一个 CacheData 对象，对比apollo，配置都没有心跳机制，nacos2.0 采用则统一gRBC通信，流式推送更可靠，吞吐量更少，QPS更高，缺点是没有权限配置，只提供给轻量化的配置）</p></blockquote><p>之前服务注册中心，通过30秒心跳包确定服务是否存活，30秒续约一次。但是，服务扩容时，由于心跳处理不及时，如果大量服务瞬时进行注册，有一定的概率推送超时，但是会在重试后推送成功，保持数据一致性，这种重试会使系统处于达不到稳态。nacos2.0长连接心跳，响应及时，推送失败率少，快速达到稳态。</p><blockquote><p>nacos 1.x</p><ul><li>每个服务实例都通过心跳续约，在Dubbo场景每个接口对应一个服务，当Dubbo的应用接口数较多时需要心跳续约TPS会很高。<br>心跳续约感知时延长，需要达到续约超时时间才能删除实例，一般需要15S，时效性较差</li><li>通过UDP推送变更数据不可靠，需要客户端定时进行数据全量对账保证数据的正确性，大量无效查询，整体服务的QPS很高<br>通信方式基于HTTP短链接的方式，Nacos侧释放连接会进入</li><li>TIME_WAIT状态，当QPS较高时会有连接耗尽导致报错的风险，当然这里通过SDK引入HTTP连接池能缓解，但不能根治</li><li>配置的长轮询方式会导致相关数据进入JVM Old区申请和释放内存，引起频繁的CMS GC</li></ul><p>nacos 2.x</p><ul><li>应用POD按照长连接维度进行心跳续约，不需要按照实例级，大大降低重复请求</li><li>长连接断开时可以快速感知到，不用等待续约超时时长就可以移除实例</li><li>NIO流式推送机制相对于UDP更可靠，并且可以降低应用对账数据频率</li><li>没有连接反复创建的开销，大幅降低TIME_WAIT连接多问题<br>长连接也解决了配置模块长轮询CMS GC问题</li></ul></blockquote><p>消费者服务向提供者服务请求，可以采用dubbo组件，进行RPC远程调用，通信基于HTTP2长连接，交换数据格式基于Protocolbuf。</p><blockquote><p>Triple 协议是 Dubbo3 推出的主力协议。它采用分层设计，其数据交换格式基于Protobuf (Protocol Buffers) 协议开发，具备优秀的序列化/反序列化效率，当然还支持多种序列化方式，也支持众多开发语言。在传输层协议，Triple 选择了 HTTP/2，相较于 HTTP/1.1，其传输效率有了很大提升。此外HTTP/2作为一个成熟的开放标准，具备丰富的安全、流控等能力，同时拥有良好的互操作性。Triple 不仅可以用于Server端服务调用，也可以支持浏览器、移动App和IoT设备与后端服务的交互，同时 Triple协议无缝支持 Dubbo3 的全部服务治理能力。</p></blockquote><p>当并发比较高，需要做负载均衡，Ribbon组件提供多种负载均衡策略，轮询，随机，最少活跃，最短响应，一致性hash。<br>当依赖服务无法请求，导致调用链的大量服务雪崩，可以使用 Sentinel组件，可以使用熔断降级和限流阻止情况的发生。如果所有方法都用同一个线程池第线程，A把打满线程池，导致B不可用线程池，Hystrix采用可以创建多个线程池隔离，也能进信号量隔离，舱壁模式；Sentinel用tomcat现有的线程池，不创建新池，只能信号量隔离（并发线程数限流）。防止恶意流量，需要限流，其策略采用漏斗或者令牌桶算法。</p><p>要了解多服务的调用链路和顺序，监控性能指标，需要搭建APM系统，采用Skywalking全链路服务追踪，无入侵埋点，使用java Agent探针，通过字节码注入实现拦截和数据收集。比zipkin效率高。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>少数情况，需要使用分布式事务。单机时代，可以把多个逻辑放在同一事务中，保证原子性，当两个逻辑在A，B两个节点时，需要保证要么全部成功，要么全部失败，需要引入第三方事务协调者TC，分别向A，B下达开始began命令，A和B分别预处理本地事务，处于uncommitted状态，会被排他锁锁定，本地处理好事务，会ack通知事务协调者；所有ack成功，此时进入第二阶段提交，TC下达提交commit或回滚rollback命令，A，B返回提交成功或回滚的ack响应。但是会存在一个问题，下达二阶段提交命令，由于网络或其他原因，造成无法及时送达，A，B处于阻塞状态。</p><p>解决这个问题，需要再引入一次提交precommit命令，ack协商，保证各节点状态相同，还引入超时机制解决阻塞，这就是3阶段提交3pc。在第一次预提交事务之后，插入一次询问是否提交就绪，并设置超时时间来解决阻塞问题。 三阶段提交解决了二阶段提交的单点故障问题并减少了阻塞。引入了超时机制，仍然有一致性问题，而且整体的交互过程更长了。PreCommit后，发出abort请求，只有一个Cohort收到abort，其他继续Commit，不一致性。</p><p>2pc问题<br>1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p>2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p><p>3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p><p>4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>2PC与3PC的区别：<br>    相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>*2PC：主持人<strong>跟第一位组员通话后</strong>，主持人<strong>失忆</strong>，<strong>组员</strong>得知结果并<strong>执行后痴呆</strong>，重选主持人，<strong>没人去提案</strong>，任务阻塞。</p><p><strong>3PC：</strong>即使主持人通知一部分组员执行后<strong>失忆</strong>，<strong>全体决策组员过一段时间决定全体自发提案或全体默认否决</strong>，此时没有阻塞，也没有不一致</p><p>如果主持人通知全体组员，大家再次确定，进入第三阶段</p><p>这时主持人通知第一位组员，请通过提案后两人<strong>失忆</strong>，<strong>重选</strong>出主持人，<strong>所有人仍自发去提案</strong>，没有问题；如果主持人通知是否决任务，通知第一位组员否决后两人<strong>失忆</strong>，<strong>重选</strong>出主持人，<strong>所有人仍自发去提案</strong>，出现不一致。</p><p>其实在我看来，解决单点故障减少阻塞的并不是将第一阶段掰成两半的操作，而是在最后提交的时候，超时自动提交。</p><p>两阶段完全也可以做成超时自动提交，只不过这样就和三阶段一样，无法保证数据的一致性。<br><figure class="image-box">                <img src="image_20220220170723.jpeg?v=1&type=image&token=V1:wIKY4Q2qtCsc_zurcS0boXyzKsv6apc4fDSJ40yytuA" alt title class>                <p></p>            </figure></p><p>为了得到最终一致性，我们要用补偿机制。</p><p><strong>2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务</strong>，从思想上看和 2PC 差不多，用于补偿。</p><p>TCC是成熟的分布式事务解决方案，核心思想是事务补偿机制，包括try，confirm，cancel三个接口。try尝试锁定所有需要使用的资源，当所有回答yes，进入confirm 提交事务阶段，如果出现失败，调用cancel会滚补偿，不过有一个缺点，就编码量大。</p><blockquote><p>优点：<br>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。<br>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。<br>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。<br>缺点：TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p></blockquote><p>SAGA 是一种长活事务，把一个大的事务分解成一个个小事务T，每一个小事务T，都有一个对应的补偿任务C，当小事务失败，有两种补偿，1是正向重试T，2是反向恢复C。</p><p>也可以借助本地事务状态表来实现分布式事务：初始状态为1，每次成功调用一次服务，则更新一次状态，在所有状态为3时，就说明所有服务调用成功。</p><p>基于消息中间件的分布式事务解决方案：利用额外的MQ实现事务一致性，在业务A中把B的任务记录为msg B，逻辑合并在同一个事务中，并且把消息存储在本地DB表中，状态为待发送，并且开一个异步定时任务在本地轮询扫描这个表作为后续重试机制，通过MQ把消息发送到B，过程中可能存在消息投递失败的可能，此时就依靠<code>重试机制</code>来保证，当B收到消息时，在做对应操作前，会检查之前是否做过，因为集群或重试重复消息，需要做去重的幂等处理，保证消息不被重复消费。而后面如果B消费失败的话，则依赖MQ本身的重试来完成。B做完返回ACK到MQ，弹出MQ对应消息，同时将A接收ACK将对应消息状态更新或者消息清除；当然，后面A处理任务也是幂等。<br>多次重试后消息状态改为“超时”，要么回滚整个业务，要么再加一个单独地定时任务，它会间隔更长时间的定期轮训长时间处于<code>超时</code>状态的消息，通过一个<strong>check补偿机制</strong>来查询确认该消息对应的业务是否成功，如果对应的业务处理成功，则将消息然后将其投递给MQ，走一遍幂等业务；如果业务处理多次失败，则将对应的消息更新为失败，多次尝试失败记录警告，并通知等待人工干预，比如后台补单操作。因此在使用该方案时，消息生产者必须同时实现一个check查询服务，来供消息服务做消息的确认。</p><p>联想“支付场景”逻辑</p><p><a href="https://www.cnblogs.com/myseries/p/10819804.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/10819804.html</a></p><p>独立消息服务<br><figure class="image-box">                <img src="image_20220220181659.png?v=1&type=image&token=V1:wI5_dncmAo9J1SqGOy916FBsmqKqYsfb54Unekn4JFY" alt title class>                <p></p>            </figure></p><blockquote><p>优点：<br>消息数据独立存储，降低业务系统与消息系统之间的耦合。<br>实现部分事务可重试<br>缺点：<br>强依赖MQ可靠<br>一次消息发送需要两次网络请求(half消息 + commit/rollback)。</p></blockquote><p>业界有一些为“最终一致性”而生的消息队列，如Notify（阿里）、QMQ（去哪儿）等，其设计初衷，就是为了交易系统中的高可靠通知。</p><p>seata支持多种模式：<br>XA协议：2PC，3PC，实现强一致性<br>TCC，SAGA，独创的AT模式，实现最终一致性；</p><p>AT模式，有几个重要的角色，TM用于开启全局事务，可提交或会滚，A，B对应两个子任务，TC是事务协调者。<br>第一步，TM，A，B分别把自己注册给TC<br>第二步，TM开启全局事务，A处理事务，首先向TC注册分支事务，然后预处理A的操作，并向sql写入会滚日志，最终提交本地事务；同样，B也注册分支事务，预处理自己的逻辑，写会滚日志，提交处理成功告诉TC。<br>第三步，所有逻辑处理完，TM提交全局事务，TC分别向A，B提交分支事务，并且删除所有回滚日志。或者，进行全局的回滚。</p><h2 id="单例模式的原因"><a href="#单例模式的原因" class="headerlink" title="单例模式的原因"></a>单例模式的原因</h2><p>双重校验锁DCL ——double check lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeDoubleCheckedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SafeDoubleCheckedLocking<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();<span class="comment">//instance为volatile，现在没问题了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.懒汉实现惰性加载资源。</p><ol start="2"><li><p>volatile修饰，设置内存屏障，强制指令执行顺序，先分配内存空间，再创建对象，最后引用指向该对象。</p></li><li><p>static修饰，定义属于类变量，保证单例</p></li><li>第一个判断null，过滤synchronized锁的性能消耗</li><li>同步块，设置临界区，同时间只允许一个线程完成对象的创建。</li><li>第二个判断null，防止多线程进入第一个判断null，而导致多对象的创建。</li></ol><blockquote><p>Q: 过去DCL不安全的原因？<br>JVM1.4前，允许指令混乱情况。final：一个线程构造函数为final修饰变量赋值，另一个线程可能获取final的初始化0值；volatile：只保证读可见性，不保证写的顺序</p></blockquote><blockquote><p>Q: 不用volatile，先临时变量，再赋值到单例变量，是否能解决指令重排？<br> 不能，JVM只是潜在的reorder推手之一，CPU和缓存也会导致重排</p></blockquote><blockquote><p>Q: 新版本volatile如何保证DCL安全？<br>设置内存屏障，防止指令重拍，其中store-load屏障是保证读写顺序，实现volatile上的happens-before语义，即一个线程对volatile变量的写，先于其他线程对该变量的同时读。屏障的结果就是原来只保证volatile字段本身的可见性，现在保证本身以及所有相关字段的可见性，代价就是造成访问volatile字段的更大性能开销。</p></blockquote><blockquote><p>Q：是否可以用final实现DCL？<br>能。<br>a.对final字段的写必然先于其它线程装载该final字段的共享引用。（final字段必须被正确地赋值后其它线程才能读取到它）<br>b. 构造函数执行完毕后，对 final 字段的所有写以及通过这些 final 字段间接可及的变量变为“冻结”，所有在冻结之后获得对这个对象的引用的线程都会保证看到所有冻结字段的冻结值。（所有线程对final及其间接字段有一致的可见性）<br>c. 初始化 final 字段的写将不会与构造函数关联的冻结后面的操作一起重排序。（构造函数内部，对某个final字段而言，它的冻结点之前的操作必然先于冻结点之后的操作）</p></blockquote><blockquote><p> 再来说一下final域的重排规则：</p><ol><li>写final的重排规则：<br>JMM禁止编译器把final域的写重排序到构造函数之外。<br>在final域的写之后，插入一个StoreStore屏障。<br>也就是说确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了。</li><li>读final的重排规则：<br>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。<br>在读final域操作的前面插入一个LoadLoad屏障。<br>也就是说确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。</li><li>如果final域是引用类型，那么增加如下约束：<br>在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。<br>就是确保在构造函数外把这个被构造对象的引用赋值给一个引用变量之前，final域已经完全初始化并且赋值给了当前构造对象的成员域，至于初始化和赋值这两个操作则不确保先后顺序。）</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> FinalWrapper&lt;Helper&gt; helperWrapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Helper <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      FinalWrapper&lt;Helper&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;Helper&gt;(<span class="keyword">new</span> Helper());</span><br><span class="line">              &#125;</span><br><span class="line">              wrapper = helperWrapper;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper.value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Q: DCL是否是实现单例的最佳方案？是否有代替？<br>不是。DCL的目的是懒加载和提高性能，但现代JMM加强volatile保证可靠，但副作用是性能开销变大，且加上了同步块的开销。</p></blockquote><p>完美方案：<br>推荐通过内部类实现惰性加载：<br>有一个大前提，JVM保证类的加载过程是线程互斥。<br>第一个调用getInstance，instance只被创建1次，且赋值给instance的内存已初始化完毕，避免reorder，此外，该方法第一次使用互斥机制，解决同步块带来的性能问题；<br>当然，只有第一次调用getInstance时才让instance加载，所以是惰性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;      </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">             …          </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonContainer</span></span>&#123;</span><br><span class="line">             <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();          </span><br><span class="line">&#125;          </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">return</span> SingletonContainer.instance;          </span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://blog.csdn.net/doraeimo/article/details/5714239" target="_blank" rel="noopener">https://blog.csdn.net/doraeimo/article/details/5714239</a></p><h2 id="volatile-保证可见性？"><a href="#volatile-保证可见性？" class="headerlink" title="volatile 保证可见性？"></a>volatile 保证可见性？</h2><p>层层深入讲。</p><ol><li>可见性是指解决多线程在操作同一变量时，多个工作内存中的值不一样的问题。</li><li>JMM中定义了8种原子操作保证可见性：<br> 除了lock和unlock，<br> 还定义了<br> read load use 作为一种读原子操作<br> assign store write 作为一种写原子操作<br> 主存值read到执行引擎，执行引擎值load到一个栈存副本变量，栈存值use 到执行引擎，以便计算处理；<br> 执行引擎值 assign到栈存副本变量，栈存副本值store到主存，主存值write 到主存的变量，以便共享；<br> 避免在 读过程 或 写过程 中间操作被打断。<br> 虽然use 和assign存在 被打断的可能，但工作内存和主内存依旧想等。<br> 因此在多线程内，适合flag赋值，不适合a++等非原子操作，运算结果a会对中间加数a产生依赖。</li><li>原子操作的底层实现需要两种方式：<br> 一个是通过总线的，总线上有一个<strong>缓存一致性协议</strong>。总线有一个数据修改，所有的数据修改都是从总线推到主存，这个时候，其他cpu会<strong>嗅探</strong>总线上的修改，然后推送给其他cpu置旧的缓存不可用，下次再使用，就会从主存里读取（这部分可展开CPU底层）。还有一个是通过<strong>内存屏障</strong>，<strong>禁止指令重排序</strong>。<br> <strong>内存屏障有4种，load和store指令之前执行，比如：volidate 有读和写操作，在写前加store屏障，保证写写操作，不能重排序；在写后加storeLoad屏障，保证先写再读。在第一个读后加入loadLoad，保证读读的顺序；读后加入loadStore，保证读写顺序，StoreLoad虽然是全能屏障，同时具有其他3个屏障的效果，但开销大，因为处理器通常要把当前的写缓冲区的内容全部刷新到内存。基本上这就是volidate的禁止重排序的配合。</strong></li></ol><h3 id="Q：问点简单的，细说8种原子操作？"><a href="#Q：问点简单的，细说8种原子操作？" class="headerlink" title="Q：问点简单的，细说8种原子操作？"></a>Q：问点简单的，细说8种原子操作？</h3><p>（这要背了。。。）</p><ol><li><strong>read</strong>  读取：作用于主内存，将共享变量从主内存传动到线程的工作内存中，供后面的 load 动作使用。</li><li><strong>load</strong>  载入：作用于工作内存，把 read 读取的值放到工作内存中的副本变量中。</li><li><strong>store</strong>  存储：作用于工作内存，把工作内存中的变量传送到主内存中，为随后的 write 操作使用。</li><li><strong>write</strong>  写入：作用于主内存，把 store 传送值写到主内存的变量中。</li><li><strong>use</strong>  使用：作用于工作内存，把工作内存的值传递给执行引擎，当虚拟机遇到一个需要使用这个变量的指令，就会执行这个动作。</li><li><strong>assign</strong>  赋值：作用于工作内存，把执行引擎获取到的值赋值给工作内存中的变量，当虚拟机栈遇到给变量赋值的指令，执行该操作。比如  <code>int i = 1;</code></li><li><strong>lock（锁定）</strong>  作用于主内存，把变量标记为线程独占状态。</li><li><strong>unlock（解锁）</strong>  作用于主内存，它将释放独占状态。</li></ol><figure class="image-box">                <img src="JMM操作指令.png" alt="深入浅出Java虚拟机" title class>                <p>深入浅出Java虚拟机</p>            </figure><h3 id="Q：解释缓存一致性协议和嗅探机制？"><a href="#Q：解释缓存一致性协议和嗅探机制？" class="headerlink" title="Q：解释缓存一致性协议和嗅探机制？"></a>Q：解释缓存一致性协议和嗅探机制？</h3><p>a.  cpu三级缓存讲起，为解决主内存IO速度远远低于CPU运行速度，防止读CPU被阻塞，浪费CPU性能，CPU引入L1/L2/L3缓存行。<br>由于高速缓存行的引入，导致了多核CPU的并行访问缓存数据不一致的问题。比如更新一个CPU核的缓存，另外CPU依然存旧的值。<br>b. 为了解决脏数据和丢失更新的问题，要实现写原子操作，那么，需要两个锁：<br>一个总线锁，锁cpu和主内存通信，还阻塞其他CPU，保证锁期间只有一个CPU改写，但其他CPU也不能操作其他内存数据，似乎无影响操作也锁上了，开销过大。<br>一个缓存锁，只锁定被修改的缓存行。锁期间会进行一个CPU缓存的更新，以及其他缓存失效。这利用了缓存一致性协议mesi。缓存行有4状态：M修改，E独占，S共享，I失效。<br>共享表示主存和所有cpu的值一致，独占表示只有一个cpu有缓存，失效表示当前cpu存储旧值，修改表示当前cpu存储新值。<br>当一个cpu由共享态被主存改为修改态，cpu会更新一个排他标志，并且，通过总线，广播通知其他CPU，其他CPU异步“嗅探”事件后，把数据改为失效态。等下一次访问，再更新。</p><p>拓展性表格：<br>|  |M |S |E |I |<br>|–|–|–|–|–|<br>|M |X |X |X |O |<br>|E |X |X |X |O |<br>|S |X |X |O |O |<br>|I |O |O |O |O |</p><h3 id="Q：有缓存锁？为什么还要总线锁？"><a href="#Q：有缓存锁？为什么还要总线锁？" class="headerlink" title="Q：有缓存锁？为什么还要总线锁？"></a>Q：有缓存锁？为什么还要总线锁？</h3><p>（小细节不放过）</p><p>有两种情况不能用缓存锁：<br>一是数据大或数据跨多缓存行，二是部分CPU不支持缓存锁。<br>现代CPU总线锁和缓存锁并存实现数据一致性。</p><h3 id="Q：从硬件架构来说，CPU为什么会重排序？"><a href="#Q：从硬件架构来说，CPU为什么会重排序？" class="headerlink" title="Q：从硬件架构来说，CPU为什么会重排序？"></a>Q：从硬件架构来说，CPU为什么会重排序？</h3><p>​    前面指令如果依赖的数据发生缓存缺失，那么需要去内存磁盘读取数据，这个过程很耗时，如果不乱序执行的话，后面所有的指令都会被block住，这样CPU的吞吐量上不去，所有会有乱序执行机制，让后面没有数据依赖关系的指令可以不用等前面指令执行完了再执行（IPC，指令级并发）</p><p>作者：sakura1027<br>链接：<a href="https://www.nowcoder.com/discuss/459561?channel=-1&amp;source_id=profile_follow_post_nctrack" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/459561?channel=-1&amp;source_id=profile_follow_post_nctrack</a><br>来源：牛客网</p><p>​    首先，我们要知道，CPU是并行流水线作业。本质上是利用了电路天然的并行性。这些电路，实际上都是一个个晶体管组合而成的。想要计算得快，一方面，我们要在 CPU 里，同样的面积里面，多放一些晶体管，<strong>也就是增加密度</strong>；另一方面，我们要让晶体管“打开”和“关闭”得更快一点，<strong>也就是提升主频</strong>。而这两者，都会增加功耗，带来耗电和散热的问题。</p><p>​    在 CPU 内部，和我们平时戴的电子石英表类似，有一个<strong>叫晶体振荡器（Oscillator Crystal）的东西</strong>，简称为晶振。我们把晶振当成 CPU 内部的电子表来使用。<strong>晶振带来的每一次“滴答”，就是时钟周期时间</strong>。Clock Cycle Time 一次晶振时间，时钟周期。简称<strong>CPI</strong></p><p>比如2.8GHz 就是电脑的主频，<strong>CPU 在 1 秒时间内，可以执行的简单指令的数量是 2.8G 条</strong>。<strong>2.0GHz意味着每秒钟它会产生20亿个时钟脉冲信号，每个时钟信号周期为0.5纳秒</strong></p><p>对于 CPU 时钟周期数，我们可以再做一个分解，把它变成“指令数×每条指令的平均时钟周期数”，<strong>加法和乘法都对应着一条 CPU 指令</strong>，<strong>但是乘法需要的 Cycles 就比加法要多</strong></p><p>现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机性能优化的重要一环。</p><p>指令执行过程拆分成“取指令、译码、执行”这样三大步骤。这为一个指令周期。</p><p>CPU一个时钟周期有很多条并行的流水线。</p><p>比如，五级的流水线，就表示我们在同一个时钟周期里面，同时运行五条指令的不同阶段。这个时候，<strong>虽然执行一条指令的时钟周期变成了 5，但是我们可以把 CPU 的主频提得更高了</strong>。</p><p>并行如何保证顺序流水线之间顺序？</p><p>数据冒险，其实就是同时在执行的多个指令之间，有数据依赖的情况。这些数据依赖，我们可以分成三大类，分别是先写后读（Read After Write，RAW）、先读后写（Write After Read，WAR）和写后再写（Write After Write，WAW）。</p><p>解决这些数据冒险的办法，就是流水线停顿（Pipeline Stall），或者叫流水线冒泡（Pipeline Bubbling），起到延迟再等等的作用。好像是内存屏障。</p><h3 id="Q：什么是三级缓存？"><a href="#Q：什么是三级缓存？" class="headerlink" title="Q：什么是三级缓存？"></a>Q：什么是三级缓存？</h3><p>刚刚提到，为解决主内存IO速度远远低于CPU运行速度，防止读CPU被阻塞而引入L1/L2/L3。<br>L1各CPU独立，保存L2的数据，最小最快，如256k；L2各CPU独立，保存L3的数据，更大偏慢，如1M；L3各CPU共享，注意，不是所有CPU核共享，有多个L3，每几个CPU核共享一个L3，保存主存取的数据，最大最慢，如6MB。具体是二级还是三级根据CPU硬件而定。</p><p>CPU需要数据的时候，会先在一级缓存中寻找数据，一般一级缓存的数据命中率可以达到80%。如果一级缓存中找不到数据，CPU就会到二级缓存中寻找数据，如果依旧找不到的话，就会到三级缓存中找。有的CPU有四级缓存，三级缓存中没有，那就到四级缓存中找。</p><p>缓存怎么存呢？用缓存行，一个缓存行为64字节。<br>偏爱存储连续相邻的空间位置数据，体现为经常是访问数据+相邻数据，存指令也是，这就是空间局部性，比如mysql的B+树。如果一个信息被访问一次，近期可能会再次被访问，比如循环，递归，方法的反复调用，这就是时间局部性。共同构成局部性原理。</p><h3 id="Q：既然提到缓存行，知道伪共享问题吗？如何解决？"><a href="#Q：既然提到缓存行，知道伪共享问题吗？如何解决？" class="headerlink" title="Q：既然提到缓存行，知道伪共享问题吗？如何解决？"></a>Q：既然提到缓存行，知道伪共享问题吗？如何解决？</h3><p>（深…不见底）<br>伪共享，不是缓存是否真假共享问题哈，而是一个性能问题。<br>a. 首先，我们知道，对共享数据的写操作，会加锁+EMSI操作，耗费性能。<br>b. 伪共享，就是几个在逻辑上相互独立但在同一个内存单元内的数据，由于被cpu加载在同一个缓存行当中，当在多线程环境下，被不同的cpu执行，导致缓存行失效而引起的大量的缓存命中率降低。<br>例如：当两个线程分别对一个数组中的两份数据进行写操作，每个线程操作不同index上的数据，看上去，两份数据之间是不存在同步问题的，但是，由于他们可能在同一个cpu缓存行当中，这就会使这一份缓存行出现大量的缓存失效，如前所说，一个线程更新CPU缓存，会让其他CPU缓存失效掉。<br>c. 解决伪共享，采用缓存行填充，Cache Line Padding。具体就是定义无用变量代码。<br>解决伪共享问题的一个办法是让每一份数据占据一个缓存行：因为缓存行的大小是64个字节，那我们只要让数组中每份数据的大小大于64个字节，就可以保证他们在不同的缓存行当中，就能避免这样的伪共享问题。<br>比如一个类当中原本只有一个long类型的属性。这样这个类型的对象只占了16个字节（java对象头有8字节），如果这个类被定义成一个长度为4的volatile数组，这个数组的所有数据都可能在一个缓存行当中，就可能出现伪共享问题，那么这个时候，就可以采用补齐(padding)的办法，在这个类中加上public long a,b,c,d,e,f,g;这6个无用的属性定义，8字节对象头+8字节long*7个，使得这个类的一个实例占用内存达到64字节，这样这个类型的伪共享问题就得到了解决，在多线程当中对这个类型的数组进行写操作就能避免伪共享问题。（妙）</p><p><del>Q: 8字节对象头包括什么？算了，先不问这个</del></p><h3 id="Q：volatile的使用会导致什么问题？能避免吗？"><a href="#Q：volatile的使用会导致什么问题？能避免吗？" class="headerlink" title="Q：volatile的使用会导致什么问题？能避免吗？"></a>Q：volatile的使用会导致什么问题？能避免吗？</h3><p>（真的能问）</p><ol><li>volatile和cas使用过多会产生工作内存和主内存频繁交互、嗅探等操作，其很多事无效的操作，而系统共用一条总线，总线（bus）带宽资源有限，其中还有其他数据流、显存等交互，总线流量激增，这样就导致总线风暴。</li><li>不保证原子性。使用<code>volatile</code>在相关领域周围竖立记忆障碍物.好处是这不会导致线程进入”阻塞”状态。原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。但上面提到，use和assign是被打断的，以至于a++不是原子操作。只能一定程度上保证有序性。</li><li>可能导致内核态与用户态的上下文切换。 它不会像锁一样直接引起线程<code>上下文的切换和调度</code>。当<code>volatile</code>访问该字段时，程序必须刷新对中央存储器的更改并更新需要周期的高速缓存存储器。在CPU的“嗅探”到消息后，CPU中断去处理失效，此时CPU程序计数器栈会发生上下文切换。</li><li>当然，还有刚说的伪共享。几个逻辑上独立数据，加载在同一个缓存行，更新引发批量缓存失效问题。</li></ol><p>解决原子性，可以采用Atomic原子变量，有两种写set和lazySet<br>set方法使用CAS + volatile，在写操作的前后都加了内存屏障。lazySet方法并不是直接的操作value字段，而是通过Unsafe类的方法先通过初始化时候计算出的value字段的偏移变量找到字段地址，然后调用本地方法进行操作的，在本地方法中只在写操作前面加了一个屏障，而后面没有加。相当于只用普通变量。<br>因为引入CAS轻量级锁，有自旋操作，更消耗CPU。</p><p>总之，使用volatile或Atomic，根据具体业务场景而定。</p><h3 id="Q-CAS底层？"><a href="#Q-CAS底层？" class="headerlink" title="Q:CAS底层？"></a>Q:CAS底层？</h3><ol><li>处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性</li><li><p>cmpxchg指令加上lock前缀（lock cmpxchg）</p><p>3.锁住总线，使得其他处理器暂时无法通过总线访问内存。</p><p>4.StoreLoad内存屏障，<strong>禁止该指令与之前和之后的读和写指令重排序</strong>，使得线程把不是单单被修改的数据会被回写到主内存，而是写缓存中所有的数据都回写到主内存。</p><p>5.而将写缓冲区的数据回写到内存时，就会通过缓存一致性协议（如，MESI协议）和窥探技术来保证写入的数据被其他处理器的缓存可见。这就相当于实现了volatile的内存语义。</p></li></ol><h3 id="Q：上面有提到CPU上下文切换，来说说用户态和内核态？"><a href="#Q：上面有提到CPU上下文切换，来说说用户态和内核态？" class="headerlink" title="Q：上面有提到CPU上下文切换，来说说用户态和内核态？"></a>Q：上面有提到CPU上下文切换，来说说用户态和内核态？</h3><p>（来了，来了。扯操作系统，干爆！）</p><p>从4个点讲：</p><p> a. 从CPU指令集开始讲，多个汇编指令的集合就是CPU指令集。</p><p>CPU指令集分为4个权限：ring 0，ring 1，ring 2 和 ring 3；</p><p>ring 0 权限最高，ring 3 权限最低。</p><ul><li>ring 0被叫做内核态，完全在操作系统内核中运行，可以使用所有 <code>C P U 指令集</code>；</li><li>ring 3被叫做用户态，在应用程序中运行，，不能使用操作硬件资源的 <code>C P U 指令集</code>，比如 <code>I O</code> 读写、网卡访问、申请内存都不行。</li><li>ring1与ring2主要是访问驱动程序，win10 和 linux 只有 ring 0 和ring 3。</li></ul><p>b. 为什么划分权限？内核模式下任何异常都是灾难性的，会导致停机。用户模式下，可以限制对硬件的直接控制权限，只能通过系统提供的调用接口来控制。在这种保护模式下，即时用户程序发生崩溃也是可以恢复的，在电脑上大部分程序都是在用户模式下运行的。</p><p>c. 再说，每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用。用户程序会使用用户栈，为了可以操作ring 0 级别的 CPU 指令集， CPU切换权限级别为 ring 0，进入内核态，CPU再执行相应的ring 0 级别的 CPU 指令集（内核代码），执行的内核代码会使用当前进程的内核栈。</p><p>d. 再一个是，用户态与内核态的虚拟内存寻址空间。操作系统会把一个进程的虚拟控制内存地址划分为两部分，以32位Linux操作系统为例，假如有<code>4G</code>寻址空间范围 ，高位部分为内核栈， <code>1G</code>由内核使用；低位部分为用户栈， <code>3G</code>由各个进程使用。</p><p><code>Q: 我插一句。。。</code></p><p>c. 先别插话，讲最后一点，用户态和内核态切换的开销大。</p><ul><li>保留用户态现场（上下文、寄存器、用户栈等）</li><li>复制用户态参数，用户栈切到内核栈，进入内核态</li><li>额外的检查（因为内核代码对用户不信任）</li><li>执行内核态代码</li><li>复制内核态代码执行结果，回到用户态</li><li>恢复用户态现场（上下文、寄存器、用户栈等）</li></ul><p><code>Q: 那我问一句。。。</code></p><p>d.  还有！还有！关于什么情况会导致用户态到内核态切换？</p><p>1-系统调用，如fork()创建新进程；</p><p>2-异常，如缺页异常 ；</p><p>3-CPU中断，如硬盘读写操作完成，中断处理后边程序。</p><h4 id="Q-插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？"><a href="#Q-插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？" class="headerlink" title="Q: 插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？"></a>Q: 插一句，低位空间只能由用户态使用吗？内核态空间是独立的吗？</h4><p>（问这么细）</p><p>都不是1. 用户态只能操作自己的3G空间，内核态是能操作4G的所有范围；2. 内核态自己的1G是所有进程共享的，指所有进程的内核态逻辑地址是共享同一块内存地址，记住，这是虚拟映射空间！！！这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。所以，这个地址空间，包括整个进程的虚拟地址空间，对于每个进程来说都是逻辑独立的，而且，每个进程看到的逻辑地址空间都是一样的，实际上，物理内存有共享部分和独立部分。</p><h4 id="Q：再插一句，问题来了，不同进程-有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※"><a href="#Q：再插一句，问题来了，不同进程-有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※" class="headerlink" title="Q：再插一句，问题来了，不同进程 有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※"></a>Q：再插一句，问题来了，不同进程 有相同的逻辑地址，但是却又不同的内容，这怎么实现呢？※</h4><p>（啊啊啊，这势头，内存继续深挖…）</p><p>这就要靠 每个进程的的<strong>页表</strong>了，每个进程都有一个自己的页表，使得某逻辑地址对应于某个物理内存。</p><p>首先，我们要对进程的虚拟内存空间有清晰的认识：</p><ul><li><p>操作系统为每个进程分配的内存空间是一样的；如32位Linux操作系统的内存空间是0-4G。</p></li><li><p>操作系统为每个进程分配的内存空间所提交的物理内存空间在用户的角度一般是不同的，在内核是相同的。</p></li><li><p>用户可以通过操作系统将同一块物理内存映射到不同的进程空间。</p></li></ul><p>正因为 每个进程都有一个自己的页表，使得相同的逻辑地址映射到 不同 或 存在相同 的物理内存。对于线程 ，它也有自己的页表，只是页表的 逻辑地址 映射到的物理内存相同。</p><h4 id="Q-大概讲下，虚拟内存映射过程？"><a href="#Q-大概讲下，虚拟内存映射过程？" class="headerlink" title="Q: 大概讲下，虚拟内存映射过程？"></a>Q: 大概讲下，虚拟内存映射过程？</h4><p>（挖了个大坑。。。预感还问页面置换算法。。。）</p><ol><li><p>进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，需要用页表来记录</p><blockquote><p>页表的每一个表项分两部分，第一部分记录此页<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">是否在物理内存</a>上，第二部分记录<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">物理内存页的地址</a>（如果在的话）</p></blockquote><p>2.当进程访问某个虚拟地址，去看页表，如果发现对应的数据不在物理内存中，则<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">缺页异常</a></p></li></ol><blockquote><p>缺页异常的处理过程，就是把进程需要的数据从磁盘上拷贝到物理内存中，如果内存已经满了，没有空地方了，那就找一个页覆盖，当然如果被覆盖的页曾经被修改过，需要将此页写回磁盘。这里用到一些<strong>页面置换算法</strong></p></blockquote><ol start="3"><li><p>辅助映射的硬件：内存管理单元MMU，通常是 CPU 的一部分，<strong>本身有少量的存储空间</strong>用来存放从虚拟地址到物理地址的查找表；</p></li><li><p>三种内存管理方式：分别是<strong>分段、分页、段页</strong></p><p><strong>分段</strong></p><p>分段管理下的虚拟地址由两部分组成，段号和段内偏移量</p><p><img src="640.png" alt="图片"></p><blockquote><ol><li>通过段号映射段表的项</li><li>从项中获取到段基地址</li><li>段基地址+段内偏移量=使用的物理内存</li></ol></blockquote><p>有两个不足：</p><p>一是容易产生内存碎片：没有足够一个段的空间映射就是内存碎片，解决方法是<strong>内存碎片整理</strong>，而内存碎片整理是通过<strong>内存交换</strong>的方式来实现，即内存部分数据加载硬盘，再读时，会紧挨另一个段形成连续物理内存。</p><p>二是内存交换效率低：因为容易造成内存碎片，导致内存交换的频率较高，又因为因为硬盘的访问速度比内存慢太多了，把一大段连续的内存写入到硬盘，再又从硬盘读取出来，如果交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿，过程也很慢的，所以说分段方式内存交换效率低。</p><p>为了解决内存分段管理造成的内存碎片与内存交换效率低的问题，就出现了内存分页。</p></li></ol><hr><p>   分页方式是这样解决的，如果内存空间不够时，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页释放掉，也就是加载到硬盘，称为换出，一旦需要的时候再加载进来，称为换入。所以一次性写入硬盘的也只有一个页或几个页，内存的交换效率自然就提升了。</p><p>   分页方式使加载程序的时候，不再需要一次性都把程序加载到物理内存中。完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去（用大白话说，当你需要用到的时候才会去使用对应的物理内存）。</p><hr><p>   简单分页：是每个进程都会分配一个页表，虚拟地址会分为两部分，页号和页内偏移量，页号作为页表的索引,页表包含物理页每页所在物理内存的基地址，页内偏移量+物理内存基地址就组成了物理内存地址，如下图所示</p><p>   <img src="640.png" alt="图片"></p><p>   就是下面这几步</p><blockquote><ol><li>页号找到页表中的页项</li><li>获取页项的物理页号基地址</li><li>偏移量+物理页号基地址计算出物理内存地址</li></ol></blockquote><p>   不足之处：</p><p>   每个进程分配一个页表会有空间上的缺陷，因为操作系统上可以运行非常多的进程，那不就意味着页表数量非常多。</p><blockquote><p>以32 位的环境为例，虚拟地址空间范围共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间范围的映射就要/有 4MB 的内存来存储页表。</p></blockquote><blockquote><p>4MB看起来不大，但是数量上来了就很恐怖了，假设 100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p></blockquote>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">贴心提示：</span><br><span class="line"> 1B(Byte 字节)=8bit，</span><br><span class="line"> 1KB (Kilobyte 千字节)=1024B，</span><br><span class="line"> 1MB (Megabyte 兆字节 简称“兆”)=1024KB，</span><br><span class="line"> 1GB (Gigabyte 吉字节 又称“千兆”)=1024MB</span><br></pre></td></tr></table></figure><p>   为了解决空间上的问题，在对分页方式的基础上，进行优化，出现了多级页表方式</p><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>   在页表的基础上做一次二级分页，把刚刚提到的100万「页表项」分为<strong>一级页表</strong>「1024个页表项」,「一级页表项」下又关联<strong>二级页表</strong>「1024个页表项」，这样一级页表的1024个页表项就覆盖到了4GB的空间范围映射，并且<strong>二级页表按需加载</strong>，这样页表占用的空间就大大降低。</p><p>   做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 就是一个巨大的节约。</p><p>   <img src="image-20220222221928062.png" alt="image-20220222221928062"></p><p>   在二级的基础上是不是又可以继续分级呢，能分二级，必然也能分三级、四级，在64位操作系统是做了四级分页。</p><h4 id="TBL快表-：一种CPU的高速缓存"><a href="#TBL快表-：一种CPU的高速缓存" class="headerlink" title="TBL快表 ：一种CPU的高速缓存"></a>TBL快表 ：一种CPU的高速缓存</h4><p>   多级页表虽然解决了空间上的问题，但是我们发现这种方式需要走多道转换才能找到映射的物理内存地址，经过的多道转换造成了时间上的开销。</p><p>   程序是局部性的，即在一段时间内，整个程序的执行仅限于程序的某一部分。相应的，执行所访问的存储空间也局限于某个内存区域。</p><p>   操作系统就利用这一特性，把最多使用的几个页表项放到TBL快表缓存, CPU 在寻址时，会先查 TLB快表，如果没找到，才会继续查常规的页表，TLB 的命中率其实很高的，因为程序最常访问的页就那么几个。</p><h4 id="内存段页"><a href="#内存段页" class="headerlink" title="内存段页"></a><strong>内存段页</strong></h4><p>   段式与页式并不是相对的，他们也可以组合在一起使用，在段的基础上进行分页分级。</p><ol><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制</li><li><p>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页</p><p>虚拟地址结构由段号、段内页号和页内位移三部分组成</p><p><img src="640.png" alt="图片"></p><p>就是下面这几步</p><blockquote><ol><li>通过段号获取段表的段项</li><li>通过段项获取到页表地址</li><li>通过页表地址找到段页表</li><li>通过段内页号找到段页表的段页项</li><li>通过段页项获取物理页基地址</li><li>通过物理页基地址+偏移量计算出物理内存地址</li></ol></blockquote></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>   多级分页通过树+懒加载+缓存解决了空间占用与时间消耗的问题，虚拟地址很好的做到了让进程与物理内存地址解耦，正因如此，多进程使用物理内存时才不会有冲突，很好的做到了相互独立与隔离。正因如此，多进程使用物理内存时才不会有冲突，很好的做到了相互独立与隔离。</p><h4 id="Q：虚拟内存的好处？"><a href="#Q：虚拟内存的好处？" class="headerlink" title="Q：虚拟内存的好处？"></a>Q：虚拟内存的好处？</h4><ul><li>既然每个进程的内存空间都是一致而且固定的，所以<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">链接器在链接可执行文件时，可以设定内存地址</a>，而不用去管这些数据最终实际的内存地址，这是有独立内存空间的好处；</li><li>当不同的进程使用同样的代码时，比如库文件中的代码，<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">物理内存中可以只存储一份</a>这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存；</li><li>在<a href="https://github.com/Durant35/durant35.github.io/issues/24" target="_blank" rel="noopener">程序需要分配连续的内存空间</a>的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片。</li></ul><h4 id="Q：页面置换算法？"><a href="#Q：页面置换算法？" class="headerlink" title="Q：页面置换算法？"></a>Q：页面置换算法？</h4><p>（ 。。。果然）</p><p>当所需页不在内存，要将其调入，但如果内存没有空闲空间，为了保证进程所需的页能够调用，必须选择另外一些页调出。此时选择页面置换算法，算法的好坏直接影响系统性能，不适当的算法可能会产生系统“抖动”。</p><p>内存进程过多，缺页越拼单，有效访问存储器的时间急速减少，换句话，就是大部分时间用于页面的换进/换出，而几乎不能完成任何有效的工作，这就是系统的“抖动状态”。</p><blockquote><ol><li><p>最佳置换算法</p><p>理论算法，选择不再使用或最长时间内不再使用的页淘汰</p></li><li><p>先进先出置换算法</p><p>选择先进的页淘汰，与进程实际运行规律不符，缺页率高，抖动高</p></li><li><p>最近最久未使用置换算法LRU</p><p>作用如名字所说，比较符合业务。</p></li><li><p>时钟置换算法</p><p>所有页面用指针链接成一个循环队列。当某页被访问时，其访问位置为1，当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描。</p></li></ol></blockquote><h4 id="Q：问简单的，进程和线程的区别？"><a href="#Q：问简单的，进程和线程的区别？" class="headerlink" title="Q：问简单的，进程和线程的区别？"></a>Q：问简单的，进程和线程的区别？</h4><p>进程是最小的资源分配单位，线程是最小CPU调度单位</p><p>进程：</p><p>P C B是 进程 存在的唯一标识，这意味一个 进程 一定会有对应的PCB，进程消失，P C B也会随之消失。</p><p>P C B通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列；</p><ul><li>将所有处于就绪状态的 进程 链在一起，称为就绪队列</li><li>把所有因等待某事件而处于等待状态的 进程 链在一起就组成各种阻塞队列</li></ul><p>CPU把一个进程切换到另一个进程运行的过程，称为进程上下文切换；一个进程的上下文切换，同时可能影响其他CPU核心上的进程的执行效率。</p><h3 id="Q：插一句，-什么是CPU上下文切换？"><a href="#Q：插一句，-什么是CPU上下文切换？" class="headerlink" title="Q：插一句， 什么是CPU上下文切换？"></a>Q：插一句， 什么是CPU上下文切换？</h3><p>C P U上下文 是指 C P U 寄存器 和 程序计数器</p><ul><li>C P U 寄存器 是 C P U 内置的容量小，速度极快的缓存</li><li>程序计数器是用来存储 是 CPU 正在执行的指令位置或即将执行的下一条指令位置</li></ul><p>上下文切换就是把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些指令寄存器(IR)和程序寄存器(PC)等寄存器中。这些被保存下来的上下文会存储在操作系统的内核中，等待任务重新调度执行时再次加载进来，这样就能保证任务的原来状态不受影响，让任务看起来是连续运行的。</p><p>根据场景不同，CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p><p>进程是由内核管理与调度的，所以 进程上下文切换 发生在内核态，进程上下文切换的内容包含用户空间资源（虚拟内存、栈、全局变量等）与内核空间资源（内核堆栈、寄存器等）</p><p>什么时候会发生进程调度？</p><ul><li>进程的CPU时间片耗尽，被系统挂起，切换到其他等待CPU的进程运行。</li><li>进程所需要的系统资源不足。要等待资源满足后才可以运行。这个时候会被系统挂起。</li><li>进程通过sleep函数主动将自己挂起。</li><li>当有优先级更高的进程运行时，当前进程会被挂起，由高优先级的进程运行。</li><li>硬中断发生时，CPU上的进程会被挂起，转而执行内核的中断服务程序。</li></ul><h3 id><a href="#" class="headerlink" title="***"></a>***</h3><p>特别需要注意的是<strong>操作系统会将当前任务的虚拟内存一并保存</strong>。而Linux中通过TLB快表来管理虚拟内存到物理内存的映射关系。TLB用于虚拟地址与实地址之间的交互，提供一个寻找实地址的缓存区，能够有效减少寻找物理地址所消耗时间。<strong>当虚拟内存被刷新后，TLB也会被更新。</strong>如果没有TLB，则每次取数据都需要<strong>两次访问内存</strong>，即查页表获得物理地址和取数据。在多核的技术下，这会极大的降低程序的执行效率。因为缓存L3 Cache 是被几个核共享的。当TLB被更新后，<strong>缓存中的TLB数据会失效</strong>，每个CPU都需要从主存中<strong>重新载入</strong>，一个进程的上下文切换，同时为保证缓存一致性，<strong>可能影响其他CPU核心上的进程</strong>的执行效率。</p><p>线程：</p><p>一个进程下面能有一个或多个线程，每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p>线程带来的好处有以下几点</p><ul><li>一个进程中可以同时存在多个线程</li><li>让进程具备多任务并行处理能力</li><li>同进程下的各个线程之间可以共享进程资源 （同进程内的多线程通信十分简单高效）</li><li>更轻量与高效</li></ul><p>线程带来的坏处有以下几点</p><ul><li>因为进程资源共享，所以会产生资源竞争，需要通过锁机制来协同</li><li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃（一般游戏的用户设计不会采用多线程方式）</li></ul><h2 id="线程与进程的对比"><a href="#线程与进程的对比" class="headerlink" title="线程与进程的对比"></a><strong>线程与进程的对比</strong></h2><ul><li>进程是最小的资源（包括内存、打开的文件等）分配单位，线程是最小的运行单位</li><li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li><li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系（和进程大同小异）</li><li>线程的创建、终止时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，所以线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们（线程管理的资源较少）</li><li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的，一个是快表失效，二是重新载入几个核，三是为保证缓存一致性，影响其他CPU核心上的进程</li><li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了</li></ul><p>线程比进程不管是时间效率，还是空间效率都要高。</p><h4 id="Q：刚聊到进程共享，进程之间的通信有哪些？"><a href="#Q：刚聊到进程共享，进程之间的通信有哪些？" class="headerlink" title="Q：刚聊到进程共享，进程之间的通信有哪些？"></a>Q：刚聊到进程共享，进程之间的通信有哪些？</h4><p>一般来说，每个进程都是独立的，操作系统为每个进程之间提供了「隔离」。所以进程之间不能直接互相访问，但可以借助它们共享的「内核空间」来实现通信。</p><p><strong>1.管道</strong></p><p>管道是用环形队列实现的，数据从写端流入，从读端流出，这样就实现了进程间通信。一个管道只能单向传输数据，进程之间的双向传输则需要创建两个管道。比如管道符 。</p><p> <strong>2.消息队列</strong></p><p>消息队列是存储在内核中的消息<strong>链表</strong>，遵循队列的<strong>先进先出</strong>原则。</p><p>消息块遵循进程双方自定义的数据类型，有固定大小。</p><p>消息队列不适合传输较大的数据，因为每个消息块的大小有限制。</p><p>消息队列存在于内核中，所以进程的读写消息需要在用户态与内核态频繁切换，系统开销较大。</p><p><strong>3.共享内存+信号量</strong></p><p>mmap是一种内存映射文件的方法。利用mmap把普通文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问。</p><p>信号量有效解决了进程间竞争共享资源而导致的数据不同步，用于实现进程的访问共享资源的互斥与同步。</p><p><strong>4. 信号</strong></p><p>信号可以理解为给进程发送一个<strong>命令</strong>。</p><p><strong>5.Socket</strong></p><p>实现跨越网络的进程通信</p><h4 id="Q：线程通信有哪些？"><a href="#Q：线程通信有哪些？" class="headerlink" title="Q：线程通信有哪些？"></a>Q：线程通信有哪些？</h4><p>1 锁与同步   包括互斥锁、条件变量、读写锁</p><p>2 等待/通知机制    基于<code>Object</code>类的<code>wait()</code>方法和<code>notify()</code>, <code>notifyAll()</code>方法来实现的。</p><p>3 信号量 Semaphore</p><p>4 管道流 PipedOutputStream<code>、</code>PipedInputStream</p><h2 id="你的代码如何保证原子性？"><a href="#你的代码如何保证原子性？" class="headerlink" title="你的代码如何保证原子性？"></a>你的代码如何保证原子性？</h2><p>一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><ul><li>synchronized同步代码块</li><li>cas原子类工具</li><li>lock锁机制</li></ul><h1 id="sychronized-和-lock区别"><a href="#sychronized-和-lock区别" class="headerlink" title="sychronized 和 lock区别"></a>sychronized 和 lock区别</h1><p>sychronized有两种方法，一种是作用在方法，另一种作用在代码块；<br>如进入临界区前，先判断ACC_SYCHRONIZED标记，有才可以进入moniter对象之后，执行moniterenter指令，把当前的计数器+1，然后开始执行方法，当结束时，先释放moniter对象，再执行moniterexit让计数器-1，然后结束方法。<br>出现异常，也能够自动释放，但有个问题，它无法中断。<br>而Lock，可以调用方法中断，当锁竞争激烈，性能较好。</p><h1 id="讲讲代理模式"><a href="#讲讲代理模式" class="headerlink" title="讲讲代理模式"></a>讲讲代理模式</h1><p>当client 使用RealObj时，先创建proxy代理类，在使用时抽取出RealObj接口，叫做抽象主题类，原来RealObj叫做主题实现类。那么，代理类场景，比如1. I/O处理图片文件，设置虚拟代理，当真正需要使用才会创建出来； 2.设置访问权限，设置保护代理，实现防火墙网关；3.网络访问，grpc/dubbo远程调用，使用远程代理对方式；4. 日志记录代理，AOP实现； 5. 缓存数据，需要缓存代理，AOP实现；6. 事务创建到提交代理过程代理；<br>一种是静态代理，自己new对象作为代理对象，另一种是动态代理，JDK反射，实现Handler，调用newProxyInstance；Cglib操作asm框架在字节码层实现 spring AOP有实现接口就用JDK，无则Cglib。</p><h1 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h1><p>TCP  强调传输字节流，连接可靠；<br>UDP 强调报文包的发送，连接不可靠；<br>UDP包含源端口，目的端口，数据的长度，为了防止数据出错的校验和，发送的数据<br>TCP包包含以上五项，还增加了序号，确保发送的顺序，确认序号几个字段，防止丢包，还有一些状态位，建立连接时的syn，确认响应时的ack，端位连接的fin，还增加窗口大小，用来流量和拥塞控制；</p><p>TCP传输过程，建立连接三次握手，传输数据，释放连接四次挥手；</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 高并发 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring | 高频知识口述</title>
      <link href="/2022/01/23/spring-notes/"/>
      <url>/2022/01/23/spring-notes/</url>
      
        <content type="html"><![CDATA[<h2 id="Q：-IOC-和-AOP"><a href="#Q：-IOC-和-AOP" class="headerlink" title="Q： IOC 和 AOP"></a>Q： IOC 和 AOP</h2><p>spring 要控制和管理bean，就要从bean的配置，实例化，设置属性，初始化，这一套的实现以及操作bean就是控制反转 IOC｡ Aop是切面编程，对局部功能的增强。<br>Spring想要通过IOC来控制反转去创建bean,就需要从XML或注解文件中通过loader读取为 resource,再通过 bean define reader读取为 bean definition,保存在registry｡再通过 stractegy策略来实例化，再使用bean wrapper填充属性，最后初始化完成bean的创建。在实例化和初始化的前后，肯定，是会有生命周期的回调。 InstantationAwareBeanPostProcessor用在实例化前后，beanPostProcessor作用于初始化阶段的前后。</p><p>Aop面向切面编程主要是使用aspectJ实现，并且引入了连接点，置入等概念。但它的实现主要还是用动态代理， 优先使用cjlib，可以改为JDK实现。</p><h2 id="Q：如何解决循环依赖问题？"><a href="#Q：如何解决循环依赖问题？" class="headerlink" title="Q：如何解决循环依赖问题？"></a>Q：如何解决循环依赖问题？</h2><p>引入了AOP动态代理之后，循环依赖的解决方式会更加复杂。<br>就要用到三级缓存才能解决，一级缓存是单例成品的容器。singletonObjects，二级缓存是lazy懒加载的半成品容器earlySingletonObjects，三级缓存是工厂池singletonFactories。<br>如在创建A过程中，引用B，发现B对A是有引用的。<br>首先，A先从一级，二级，三级缓存依次找bean，如果3个缓存没有，会在创建一个FactoryA缓存在第3级的工厂池中，然后A要填充属性时，发现需要创建B。<br>于是，又先创建FactoryB到第3级工厂池，接着B填充属性，需要A，就把FactoryA的半成品Bean或Aop代理对象移动到2级缓存，这里看到，当需要Aop时，代理对象是在2级缓存之前暴露的；接着，把A半成品提供给B注入，在B创建完毕后，B的成品放入1级缓存，并删除掉B的3级缓存。<br>回到A，A此时拿到了B的成品注入，完全创建后，A的成品放入1级缓存，删除A的1级和2级缓存。</p><h2 id="Q：为什么需要三级缓存？-不是二级缓存？"><a href="#Q：为什么需要三级缓存？-不是二级缓存？" class="headerlink" title="Q：为什么需要三级缓存？ 不是二级缓存？"></a>Q：为什么需要三级缓存？ 不是二级缓存？</h2><p>只要两个缓存确实可以做到解决循环依赖的问题，但是有一种情况，就是这个Bean需要AOP切面代理，如果加上AOP，两级缓存是无法解决的。如果不存在Aop的话，可以直接用二级缓存，因为Aop操作，不管是jdk动态代理还是cglib动态代理，都会创建一个bean代理，这个代理bean和原始目标bean属于不同的对象，有不同的内存空间。首先要知道正常流程中Spring希望AOP代理对象的创建是在Bean初始化的后置处理器中，而循坏依赖中会把aop代理对象的创建提前至二级缓存之前完成，下面说明为什么要在循坏依赖中提前完成aop，因为如果没有提前完成aop，那么B对象依赖的是A对象的原始bean，而后期A完成Aop后使用的是代理bean，这里肯定会有问题！所以必须要在循环依赖中提前创建好代理bean，并放到二级缓存中，同时删除三级缓存，避免再一次创建另一个代理bean。<br><strong>3级缓存的value类型是ObjectFactory，是一个函数接口，它能生产两种产品：单例的原始半成品Bean和Bean代理对象，当需要AOP且循环依赖时才会产出Bean代理对象，其存在的意义是保证在整个容器的加载过程中同名的bean对象只能有一个，不能同时使用原始bean和代理bean。在对象A需要被对象B引用注入时，我们不想每次都从3级缓存的工厂中给我产生一个新的A的bean代理对象提供给B，与其走这些复杂流程，不如借助一个2级缓存来保存产生出来的代理对象，需要就从2级缓存获取。2级缓存主要想存入代理bean，为了统一，也会存入原始半成品Bean</strong>。</p><h2 id="Q：为什么Bean代理对象，不一开始放进3级缓存，然后不要2级缓存？"><a href="#Q：为什么Bean代理对象，不一开始放进3级缓存，然后不要2级缓存？" class="headerlink" title="Q：为什么Bean代理对象，不一开始放进3级缓存，然后不要2级缓存？"></a>Q：为什么Bean代理对象，不一开始放进3级缓存，然后不要2级缓存？</h2><p>可以但没必要，bean的加载不一定需要Aop，不一定有循环依赖，所以bean代理对象的创建非必须，3级缓存的意义，更偏向于指对原始Bean的缓存，只是为了适应也能生产Bean代理对象，才缓存ObjectFactory。不让3级缓存去存Bean代理对象的理由，首先，保证对象beanName在整个容器的加载过程中只能有一个，也就是说，不能同时使用原始bean和代理bean，其次，就是想实现懒加载代理Bean，需要代理Bean才创建，不需要就不创建不缓存。<br>Spring希望AOP代理对象的创建是在Bean初始化的后置处理器中。<br>但是，有循环依赖+AOP的情况下，因为Bean代理对象的产生流程被提前暴露在3级缓存之后、2级缓存之前，这样，2级缓存就可以统一了单例的半成品Bean和Bean代理对象的获取，已保证AOP代理对象产生流程只走一次（走多次也没关系，因为内部还有earlyProxyReferences单例缓存），当然了，AOP代理对象流程在Bean初始化的后置处理器中依旧还是会走一次的；<br>2级缓存的存在，避免循环依赖中再次通过工厂获取bean这一复杂流程，提升加载效率；因为从3级缓存获取对象时需要每次都通过工厂去拿，需要遍历所有的后置处理器、判断是否创建代理对象，而判断是否创建代理对象本身也是一个复杂耗时的过程；</p><h2 id="Q：（问题与上题差不多）三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？"><a href="#Q：（问题与上题差不多）三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？" class="headerlink" title="Q：（问题与上题差不多）三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？"></a>Q：（问题与上题差不多）三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</h2><p>答：这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</p><h2 id="Q：A能不能去掉2级缓存，然后代理对象放到1级缓存中，B直接引用1级缓存的A代理对象？"><a href="#Q：A能不能去掉2级缓存，然后代理对象放到1级缓存中，B直接引用1级缓存的A代理对象？" class="headerlink" title="Q：A能不能去掉2级缓存，然后代理对象放到1级缓存中，B直接引用1级缓存的A代理对象？"></a>Q：A能不能去掉2级缓存，然后代理对象放到1级缓存中，B直接引用1级缓存的A代理对象？</h2><p>1级缓存放的是已经初始化完毕的 Bean，要知道 A依赖了B，A准备引用属性B时，这时候，A还没有初始化完毕，此时放到1级缓存，未成品被当成成品暴露，是有问题的。</p><h2 id="Q：B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？"><a href="#Q：B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？" class="headerlink" title="Q：B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？"></a>Q：B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？</h2><p>答：不会。虽然在创建B时会提前给B注入了一个还未初始化的A对象，但是在创建A的流程中一直使用的是注入到B中的A对象的引用，之后会根据这个引用对A进行初始化，所以这是没有问题的。</p><h2 id="Q：初始化的时候是对A对象本身进行一些初始化操作，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？"><a href="#Q：初始化的时候是对A对象本身进行一些初始化操作，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？" class="headerlink" title="Q：初始化的时候是对A对象本身进行一些初始化操作，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？"></a>Q：初始化的时候是对A对象本身进行一些初始化操作，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</h2><p>答：不会，这是因为不管是cglib代理还是jdk动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化<br>（其实初始化A，是对exposedObject初始化吧，上述情况，它也是代理对象吧，所谓A对象本身，就是在代理对象的目标对象？？这是个人想法）</p><h2 id="Q：三级缓存比二级缓存提高了bean加载效率了吗？"><a href="#Q：三级缓存比二级缓存提高了bean加载效率了吗？" class="headerlink" title="Q：三级缓存比二级缓存提高了bean加载效率了吗？"></a>Q：三级缓存比二级缓存提高了bean加载效率了吗？</h2><p>没有，只是加载顺序有些差异。</p><blockquote><p>earlyProxyReferences缓存相对于一般的普通类是不起作用的，所有的类在doCreateBean方法中的applyBeanPostProcessorsAfterInitialization方法（用来判断是否需要创建aop的方法）中去earlyProxyReferences缓存中找有没有这个beanname的bean，但是并不是所有的类的bean都会在earlyProxyReferences这个缓存中，因为只有当的doCreateBean这个方法中addSingletonFactory（把创建当前bean的lamda表达式放进三级缓存）执行之后，有某个地方调用了getSingleton去缓存中再次获取当前这个bean的时候，当前的这个bean才会被放进earlyProxyReferences缓存作为一个备份，那么什么地方有可能去getSingleton获取当前的bean呢，按目前的知识储备来讲，似乎只有 当前bean被循环引用 了。。。<br>所以earlyProxyReferences这个缓存时为了解决，当当前的bean被循环引用的时候，避免重复判断aop流程的（wrapIfNecessary）</p></blockquote><blockquote><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“<br>简答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过AnnotationAwareAspectJAutoProxyCreator这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p></blockquote><p>引用链接：<a href="https://zhuanlan.zhihu.com/p/157314153" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/157314153</a></p><h2 id="SpringMVC流程"><a href="#SpringMVC流程" class="headerlink" title="SpringMVC流程"></a>SpringMVC流程</h2><p>用户发起请求，被前端控制器DispatcherServlet拦截，然后调用处理器映射器HandlerMapping，根据URL去获得一个处理链Handler ExecutionChain，里边包括了拦截器Interceptor和我们写的Controller，通过层层拦截校验最终获得处理器适配器HandlerAdatper，同时真正执行处理器Hander（Controller），处理业务后，返回一个ModelAndView对象给前端控制器，里边包含数据和跳转的路径。然后前端控制器会选择一个合适的视图解析器ViewReslover去进行一个视图的渲染。<br>这里边，可以内部转发和重定向，可以处理文件上传和处理普通HTTP请求。</p><p>这里边，拦截器使用了责任链模式，handler的处理与视图的解析使用了适配器模式，利用反射处理请求入参和返回结果视图。</p><p>这里边，对于@ResponseBody，是在RequestMappingHandlerAdapter中设置了messageConverters的逻辑<br>，根据HTTP头的Accept信息，或默认JSON，通过HttpMessageConverters对消息对象的转化。</p><h2 id="Spring容器启动流程"><a href="#Spring容器启动流程" class="headerlink" title="Spring容器启动流程"></a>Spring容器启动流程</h2><p>部署一个web应用在web容器中，它会提供一个全局的上下文环境，这个上下文就是ServletContext，它为后面的IoC容器提供宿主环境，当web容器启动的时候，会执行web.xml中的ContextLoaderListener监听器初始化contextInitialized方法，调用父类的initWebApplicationContext方法，这个方法里面执行了三个任务：1.创建WebApplicationContext容器，2.加载context-param中spring配置文件，3.初始化配置文件并且创建配置文件中的bean。监听器初始化完毕后，开始初始化web.xml中配置的servlet ，用DispatcherServlet举例，它是一个前端控制器，用来转发、匹配、处理每个servlet 请求。DispatcherServlet上下文在初始化的时候会建立自己的上下文，先从ServletContext 中获取之前的WebApplicationContext作为自己上下文的父类上下文，有了这个父类上下文之后，再初始化自己持有的上下文，创建springmvc相关的bean，初始化处理器映射、视图解析等等，初始化完后，spring把Servlet的相关的属性作为属性key，存到servletcontext中，方便后面使用。这样每个Servlet 都持有自己的上下文，拥有自己独立的bean 空间，各个servlet 共享相同的bean，也就是根上下文定义的那些bean。web容器停止时候会执行ContextLoaderListener的contextDestroyed方法销毁context容器。</p><h2 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h2><p>1、new了一个SpringApplication对象，使用SPI机制扫描spring.factories文件，加载所有的初始化器和监听器。</p><p>2、调用run() 方法，准备上下文环境，创建上下文对象，根据环境insert组件，比如说autowired，configuration等 。</p><p>3，最后刷新环境，启动spring容器和serverlet容器。</p><h2 id="Springboot自动装配原理"><a href="#Springboot自动装配原理" class="headerlink" title="Springboot自动装配原理"></a>Springboot自动装配原理</h2><p>主要是SPI机制。Springboot启动时会扫描Import注解找到Selector类，调用selectImports方法，读取所有spring.factories配置文件，根据文件中定义的自动配置类路径，按需将Bean加载到Spring容器中。</p><p>主要依赖类上的@ springbootapplication注解，它由3个分注解组成，@ComponentScan 扫描当前包和子包，@SpringBootConfiguration 代表当前是一个配置类，第三个数自动装配的核心，@EnableAutoConfiguration ，有两个@Import注解实现，第一个批量注册Bean，第二个是扫描系统中所有spring.factories拿到配置类，根据@Condition 配置是否生效。</p><h2 id="Spring-事务传播机制"><a href="#Spring-事务传播机制" class="headerlink" title="Spring 事务传播机制"></a>Spring 事务传播机制</h2><p>Spring有4个事务机制，它们的区别体现在嵌套时的不同传播策略：<br>对于无事务，要么创建事务，要么不创建，要么抛出异常；<br>对于一个创建事务，有嵌套时加入策略，嵌套时挂起并新建事务，嵌套时挂起并非事务运行，嵌套时抛出异常，嵌套时savePoint机制。</p><h2 id="Mybatis-原理"><a href="#Mybatis-原理" class="headerlink" title="Mybatis 原理"></a>Mybatis 原理</h2><p>读取mybatis-config,xml配置文件，加载Mapper.xml映射文件，里面放置了很多SQL语句，然后通过构造一个单例的会话工厂SqlSessionFactory，开启一个会话对象SqlSession，会话有API执行SQL语句，通过执行器Executor真正去与数据库通信，输入和查询结果通过MappedStatement交互。</p><h2 id="Q：Spring-用到了哪些设计模式？"><a href="#Q：Spring-用到了哪些设计模式？" class="headerlink" title="Q：Spring 用到了哪些设计模式？"></a>Q：Spring 用到了哪些设计模式？</h2><p>1、简单工厂模式：<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。</p><p>2、工厂方法模式：<code>FactoryBean</code>就是典型的工厂方法模式。spring在使用<code>getBean()</code>调用获得该bean时，会自动调用该bean的<code>getObject()</code>方法。每个 Bean 都会对应一个 <code>FactoryBean</code>，如 <code>SqlSessionFactory</code> 对应 <code>SqlSessionFactoryBean</code>。</p><p>3、单例模式：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。</p><p>4、适配器模式：SpringMVC中的适配器<code>HandlerAdatper</code>。由于应用会有多个Controller实现，如果需要直接调用Controller方法，那么需要先判断是由哪一个Controller处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。</p><p>为此，Spring提供了一个适配器接口，每一种 Controller 对应一种 <code>HandlerAdapter</code> 实现类，当请求过来，SpringMVC会调用<code>getHandler()</code>获取相应的Controller，然后获取该Controller对应的 <code>HandlerAdapter</code>，最后调用<code>HandlerAdapter</code>的<code>handle()</code>方法处理请求，实际上调用的是Controller的<code>handleRequest()</code>。每次添加新的 Controller 时，只需要增加一个适配器类就可以，无需修改原有的逻辑。</p><p>常用的处理器适配器：<code>SimpleControllerHandlerAdapter</code>，<code>HttpRequestHandlerAdapter</code>，<code>AnnotationMethodHandlerAdapter</code>。</p><p>5、代理模式：spring 的 aop 使用了动态代理，有两种方式<code>JdkDynamicAopProxy</code>和<code>Cglib2AopProxy</code>。</p><p>6、观察者模式：spring 中 observer 模式常用的地方是 listener 的实现，如<code>ApplicationListener</code>。</p><p>7、模板模式： Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等，就使用到了模板模式。</p><h2 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h2><p>构造器注入，构造器注入会先初始化其依赖对象，而set注入是后初始化其依赖对象；</p><p>字段注入</p><p>Setter注入</p><p>@Autowired是Spring的注解，Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常；@Resource 是JDK1.6支持的注解，默认按照名称(Byname)进行装配，而@Autowired还要结合@Qualifier注解来使用，且@Resource是jdk的注释，可与Spring解耦。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经| 项目面-小公司毕业3年</title>
      <link href="/2022/01/13/10k-interview-skills/"/>
      <url>/2022/01/13/10k-interview-skills/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="129d2f5ebb17ed1049f913c43f76e7ab09f1561b3c8f20681069011c8bd90174">b80e90f5a47de8d40219e41b80d8f3027f3fe6fc21ea9ef9280dbddf772e0600d706e4f9bc0638d0cd409acde6a24d05653ad036b1c255319e6134754f781072884eb6f66d68a6fbba079f120691df6837798b1cbdaac7895f076a23a670608f3637ffa4594d614d844421b375dc455710afaaff6180a2fad90952452d1ed2d719fda93612c5b9ee97f767be7ff91888115dd6df388e7491712125ece10265397bcb3fe5f69a2894714ca9e9c792dff94ee8aca205f5febec1426e9969f6ab5a9ba5f30c2c78c4a4b6b8c60e6e0ce28e42830bed926ca01c778adbc289f04c5d08f42dd215953d9f2571e547b02549bff104aeeaf1eacb5727f7eb29f1810aba2ba2e7611782fdad14b6c3de34a10838f169ef35cc959ade9dbbce4f5598cd6cde5ffb52f5a2fa720d0caf569ad9d0b151df346304918359eb8cc00c646254cd2d904022e52bda958dafb169c86f9ba57ca92c4a439f6f40a0f12ac95d9b022595da1e406359df39a1c613ea3f6bfa90244f2c2d607d3ca18afc2e65bc6f380e56ab53824b7974679794e2c0656731701ccfc937b6ac74d00ee832a343658f25e918c8f04fd5eaeddc4d06cfa4e8d5c180113b23bf42b70736698cfe11693deda40f059f11b5c36b582f66b37cdd8ec865b308615680888f6b56479f84bee2fd75d2f07bb474996bc25a68a906786a1e664dd749682a116e7d8563838dba6f83593bd102e451c052ab47500fa9d95c4a90751e248dfda25766de47b8199c781ad8d0730bedb42086c107f0927919a810f97676daac8244164c6c645d8a944acc6b4551093e393ac2c9724eb4370350b56a6a10f7616934e1c5a9f5ae000e70798b0f2c306774b3ad856e3b6b6f7d197fdc3ee7de8e78eed74673fce036f8efe504d91f3e17899f01e641918cb72d3348288bb99744e1d9f3ca86a1a8c52975796a3e8cf86eea0074a981d36a88e354b94948d5754991c2ba3350b427f6547de90cbd75d328cf57bee74c62212c7e32ecf736c7d6c48f9ba78f1b50e1ee5537594df5b0230cbc9499bc9d6fa74d723e6cace73911e7ce6186a9b6ed0f3f501af2e112415656cdb018364c40319ce3ca95e75e8f35fe082f7ee45c63692d6a056f35a219712441c1ca81edb622b176d9980fb92effa6082fa15b16773008b1de772d3ec6f9113c9b4a7723f07c3f305621deeb7042d33dd7055dd894026c2230d351ca7621bdd6f4b7262121fa5cefd4b8d755aa795bfcd1d4aba46ac543f248ffc4e980f81864193fafa6ddb45a4f0866d6ff35d40ad4203cb1bbf0e31dde299219392ce9f0cb120c24fd23dc731df29c276e269091a30ad7873102f289b5c6bc2fdde0c8011a985ae2db2b4949b7b5c117c03bc2c1b217754e109a330b97b40ba9f9f75ed44b375614a84811af0ae6535d63efbe60c0bc589e5cbfec7d2f922aff3f9944db75385194183bf3c38c8817e4eaa0e1ba18542b20e3e37343ecc47419c5ccd97e0a4419c0347ed15e3c6b575699bc0901ba07f074050b4d7ab3eaf738ba6578dca6130bc89b54124e8372ae7bd2a950071ceb178e21e5e6642eb348f4be86acdd21a17173cd560c65246a971441561e3a424201dc22c0e5fe594cb556640d8c4a9c4d8a0de5488d755180260a50770fa35ecfbcc0485ea8caf4d098be4f0bdfc17d3dd82d764f18136ec90478b61932e66de1f9540d2a0d7ee0a67a30760b37dc1b5a8d288130f2e957b4ea849ffcb5396926ddcf3ca896533217511b544312dccceeb7d794c8df870040ed25e55d970d4f2e85342c63e075c8f41df321153699f3ad842faa58ed3c92e7b776a4735ca0c2c13af775770e6937bc240cada6a932ec896e9d5dd55a3906253e5073ee30166152a632ef060fa37b3f4ed0a29e7e774c146546b0ce07768a3efbc556eb05358d9871662251a01887fd67c36f90fd3cb735d7555890b3d7e4c56f2dbea2af35cbe7211e1724c23e7caf6870ab60834691e2d02d0269341ac6edf0fcca00cbc02f7a395e896764e3a8b056ad87d09308bcd69e96704de5443515cdc916fd2256d2f7b05937853e98fe48dca48c211f77dcc815fb2ee5cee029ab8a659151b8fe7d9dd368f1f2ef2e3d602e1c8259ae8074e6889acfe1a9c3098298ba6d90bbfa2950e1909a7f722dafd95685ecf462bd1f56f2fd8a9b3bc812923e6bfce378eed589b09c8d5f9eaad554013841d6873ba829e4e649a49451ed60a8d63e882d680ea24030a9b386a65885e1679f928f491c0d8bcb33b74c6b6e58252d4de17cc9f99da1818c154e1c01c9d11d55c82097e91de831fecf7f22d4fe13ab918f18cd646d8fcacc94852e392e5028b0eb073bad7757d29fd76ab9244608c2f85c949c72424e546b6fd4c7dbef4eb9fdf5ca5a60f1158ac79242354bd89a7eecc1f82771bd79ec059e73bd35110207bb52a3db0554b5ab76301b36b37e94642d3d1b47b92b224a53c18b9ef3659f2aebffb1903f926e0bc849f3c234377e6f11284885b9ad50272925775f4473f0397dc292ce3eb58c8cb2e48410a34fbfaa26392ea00fa27485fffb8d3b2d5605ee2cd0fa3537db4f608872f4f870e4d6726f3a0478615e732b3ab7b7b5b30ba73130b405f446c1bb19c576fcc9f7e06ca413ac9599ca4576a663be08ae8f81018aa03ec99eb5a2558e5fbbe70311cb1796251a53764195d778667fa545f2f5069165483a69f69e6dc237d92c5babd9b9bd4cbb437b71bac761700b102ea60777aa51279e91c53536e81d80b32e213e09ea914fd356a3fd3b798b711887166a26f373ce4dd01d643a970e1c46fe4d8e612087c898152566ca9a7976d2bda7566c20f78cb00d5662c03fc9a6e2e3afe8cd947e9a657a7d0dc101f8cdbbcdb3f9ce4a29313d2e1cbd0cbc099a0fbf6ce9f6292b51f7f779d27caf98de323ab47fa97408ed16d8e374ff0e8e76099c023aa79226a03b23e0461f66f214382cba051680cc28b54cfc9d1399cc69899265074ffe2b4aa7377a531302c88d756b5b1ce8864e3bd9091a39d5ccd3f9237b5c640c0d6901999ac1601eac1a0a097593098f136251a7c9c2bdf4045cf2dc0e1c380cdf9c48c1171ecc3e7144e60590fae207fa679e9e9080630d812242e6ed2c37534720f7f3e3908b09e2ddc93183159a5d4a3a1ca5a4f5d31d9f47cb49ee457e656dbd5230cbe45c7cbbe74830a41f34f9d8ab6881f0f1eace311b2ff46db8edc73cbefaa41d794bf292ee0eb16b6c80f55febaf81629a428e777c9c493c204d2877f1b85ceff15fb65ee1a5e67a5d9a4c1c85d45ab56909d1ef3e8c51c11689482f9f70ace7a6674a8c11d3309ef7b0ab382840399289333a8c0eba65a907095c2b7a511b81697b2eab897d1d141dca743608581338ec9e7be188f4a1543a1813e7870ee95c2313b21942d0e2d571e4f286c061e4621812fc94709a438e493e98e8a9311e424b12c8f9ecce45993f09bcba784ee9748d93ddf4a583f09ec8bdd5ffdb63807640e818e90f28f5b71b911379b068f15706850b8b8c115a41c9256b811917f74d720d1312b087b09be5504c22a8bbc091cb1b2f4c6b9dcaaf22318d0f27b137571dd2ece6b27e7222f58d0334379d4d541803c57a42281b572f27673dc67847fe58690624c4b2cef341d3d87b2a237c3865faa9e015b604172341f62d4eba8edce2e496414fd59b7ec73eb852e77ff5516b15f7ec37ee5c3230f79cdb3d699815af22f676c3d0d28dd3c242778c5e8ea091ab094711642a6fe1887d9743d8890037f736de81582ac8ccb97c8dd46756e488233814264cfd2ee59fb5ccaeada988f055fe5c7cefe6d48182ee8b28540d003087f1b5aa8659332100c016f1c6f620bcf25881ecf4b45daab72b30391f451d519bae66fd091037f162f1aeaf21ae01cb6171cd390aa04de77c1de386c80ebc2a49f20416f1e7dcfbf26e699a420f9858b358dd20aee6846492638d7306cac3e56f4a03e6a6bd8a87b659eed1fe91fbdfb310054e5147752a639f207d9db1ca33f1b0b87c69f73ca0e7233d7a05df5e2e043b3be67e2f885149ff9061e8cec964ee79f596e9956b54544b41d54aff9d431be40973f36e9fdee1ff3e44677fb66f3c9936663d2c5c04684310ea9bd614ec5f8c297bd373e7cf5b8a000652fab92f41388d51d96944843e6d1d606c128528b2101184fe873ab199fdf72e989e1a47d2efc1be64907b6f849dc241e95667662d7c07f7bb504cca1a86249d7bb8d10aa7f496c820bd7e210956e45ee436f0d573a48ae366c765e4a832523564e554adf64f3c95b13c9b4496f99e905b861bf356f26305262736829ba6162200f2258a1d40f02f9e8484152c952e31ba8d8ee71cf80324cf065f1161317107cde36ded70a72a5e577539999525fb687416b89665019f753d5525f05cd4c6ea56a560b949ccf96316408d32a6805b11110dbb44da0a038d5fd531eb6a6b003d656d4265c1a64f55be08827e5a0d3e385639e2d3f41c472c89328392c170556a2e9de6a2e6755edd69ab9bd6e0a9132ad5e428d6160c13fb2b3bae70495ba2abf3da704ec8bd73ce7b091dff338d2358e5a5c72471ba8dc998809bc0de1ab07f339333ca42b57632686ed0054dd80d33d81643bb55ff438b801fd0b02aaf6ff3b111fa41534a8a34261d4c2966ae9c2b7454834dddf2d85423ca00f2f1df9f2da0284a56ad6d77c57234980fbbe16ea664b313031a8170d58b91bba6ad7181056eec224fe70129bdb7bc88689b2d0f06d87adaf8d11a2284a0189d2fd09d5706f364b2d5fdef7114b905fe7cb62bcc9f179e4d675d1f22797548f39a86e34837c55bbe5bd94ba964273b5745fc2fb9487b6c5b8b0effa3ce324ca062025de1b7ae4fa4568cf90a8b3a2c4b98b12232fbefd93b7ab23cbebb1484392f1b0fbbd282976a18a37c8235c5e71a9c4253d0963be522b249200ca43887447e46a5dda140b997ab7c7687b7d45d5bd67cbb1d9b69e969345e3fd7ef6ea649e24f869b06bae9a8ff9bdb88f72988df3154771dd5d924eaa85664ad057669b8940b39a7df3a894c433cf73a6e40e5f7479068c971cc5980eb8e649fa7679c5095f57742a8a04a06f557a1e6664cf89d8e12479c0ef20c9e244dfefd7fab74a033c9c26a632d165bb4352e9c19528acff248b6605ebd862810a8077003004ef3cf601f719c95e11782aa805cfc783ddc7b5275d24c696fca96b30e3f131e1a7d72d1fb37909c05bdf0af84e3222b36eca5ac09c847deba8fbd80e1e11d3dca8bcf03398ee514de211ef4ef9ca9278c9699b340f511b2221ddbea7773326f7ce4b71b165fdb8455502de9b1cf863bf3a6b60c5b547f1f60eed7117ed41f352d9eb28102c6d7852d640435e6aae2a5a6e58da503cc854e43b8ec02de17951c91ea637455f1069265771eb78117018f049a29d29e57b4845bc48f2dbf57970687d6b8d9a92911d20a276e4d0769e302b54a0cce110aa35bfcd5540abc8db0fdd01945020da6709bc07097a33835fb7a17a319e2a5e00c97b55d921afb5e5d8379c1ff8931a02ae081bf1c9719a5e66c20b030ff87dcead2c3f8b531197eafbcd989b063c22b822f88cf0630706431cb627aa5c924cbd6b997aa5435d7cfd490ec44458bb8b18d71472dbcb2a76447be6e0ad38becf67ac797724e6256b72b39150a4845d81c4996bdc81e1b59acd5867106b04466beb68a933faaba256d39f0ddc056cd6f64e01f127dad7901321d0ce823bb26b2220198546c0182dc2cad8709752f810719836c17b41a01e110f9135d6723bf8a7fb4139e30db4c2396d3b94c738b9af8a8b1ac3d15dd6e374917214a56ae841ee5ddb3f7e26662c5ad31ed0978d405881a366e3fba2b4c94af8eceaa7b3653c973e1cfea21250be2fa6e52ccdfc132b6464f0ede18bed42fbad9832ecf99ff289e058bfc3bed733d88768aa8a418dcf6e25aef9f2714c65cdf40a452688c07c8af9d2e1fe637f9084ac93b107fb54093aa606bffc3fc4c32da474a42d6de3ec15105df3752e912f28a79add8c86199e0e8b05d2c04170ac1715c0ac97c1fe19d2146ec4ab13654bb656ae0f25fc469d9e8dc2ba66590dc882d12457072d5d76465046f833f36ca1c38dd8be4b1c7ff07cf288f803aaf65040e2ed66f3c3732d2cc2c7ab5679d7a2a65e8d4b627e85c36cc51c6e1d77f098d4fff5972b92b2e8c61ee99098e87255539c0ee3ba16221ecbcdd7f15df2364e0e69ccd1bb4f32536467be720802bb6ffae0a6ec1265ef7fa0eb2028bb0a2c6633c09f46dabbba3104b87f35dbffdbf65a5dd8dd9f296a03ff58eaadffe4e7a981c5ce2e081324bf1e7c57281ccec2ee10ed818340cccc067bbfdd47c586e8c4ef25ad9f868b846aabda4482726954e97cb6968f381ab743c03e9ff5cb68baf26f318d44fb1402d0d7d548eed72a4156807263c6e2b5c72739e3c805ca20dcb657a38ec87fb31149c9ecba045d4136e0f8d97f3084225b149d48677864f3358d3cf4c64aa2e0ce39ecde42fb1ac7a78c1c272426a1c79fc94f7190bc0962900f7bad8c926460f866149dcf64e4cc5b2eb0e4c9806b2d7227569af4e346830706371881d79dbba8ecead362cf6a3a376045237d68de09f13783ed624aa76f675a1e8fa3b94697d289e7eeb35877feb3f18e49c6be6bc6d5c474cd33f6cc911e1df911d10693ff9c3078a3c734a00dfbb2b0fc6145de0e9aaca39be2c9f8355771a8280afa10492a1acc55cf5c7cbd83cca2ec468d56007db08744339122241ead42b31295be02ca380915e506e2522ee9bf337d879d6d14cf104ce6db83f9924f93046445acc304f8132a633669bf8407eb662d0b75ae88b6991e36c29270cc9bd3895a803f438cded17e64a3ab5658854f2bbb374fd5ca306662930f000e16b52bc58743599d2b0c58ffba6635fefae99e41ac8c894a2b4faefc3ce60c6450338e6e833af415c1a32b9ec4f3a41f6ed1993a50ba8d85c48a603645af4e1d8bd2e9730f2e4f2c53f9e789101685987d19bd1f83b9fa67853ce00a0373c1f6a1efdabcd47a0394b9cc2f6678cd88c6ea0515c82acd7deaf1654451a3045e529adf0486a24a3382ead5177760b1a6acbae9cbedb21cf871d6c51f87a1af3f04b212f17ae7a2478d4c1bc8a0aa9c501f7639e010cbdb1e871a30b7b2d2f8cc0574c9002e3bc8ae466869123718f9078565b622344ce16c428ea5cbb99372418f0dfd44f16d1652aa4509fbee396573ea3a33cfb1f87de397eab7b22edfeeb54787c35e3016780c190b92ad1fa9c4e9ab9560a9391130268ec88c8e3bca1cb5118323e588e21c2e53496c5fcafa25732419e0b1e26ba79f7dc7ee2a84d9d6373a2d92e28e22784038efddbf1e7fc8af75d828a5f076b38ceab1bd6f5c322de08a8a496cd030cbeb35fd1fa6ca96f068d1e338d9fcc24d7b04741cbdbecd2e016ec7720efa56c4f0a1422b8eb4530f9efa39a3bcaa092f16c80692f98b84f73bcb9916c412f210c9fad5fbdb440de2237a60fbc285be4747ece5fa9e34225986f368cbab5f3e07e89601f6b9c6510bdf37f619e909e03e5aaec2959e27ff0911eab0793bdce645e5f78fa8130e92d75585d43c85717cd6b5a4645885e2e6b092d6499a44db620c774e692fdb85422589029fce68aed9993c79b92c0a39b29af964e0bb5669b8b2631b32e290047a7ef939722f2873597b5e7ba6c2ff3851d918c873a6aac3e2a65e8bc625995ed963f4159fe3e71044bcad1696b69c5fa2639f628eeab491694fb2d006b2dd0e710db262f5e8fde82df0efdcab6b7ed20e9cddc3ec57e3cd300d5217c3f7470489245f275e16af7f2713a6e714e110c63da75b990a08f1caa8a716d448410e89c99bc62934cd4f0d04ec936b0e82cc1ed848fda11135c819f9aec62399b7b7d493ec0a54abacf7a488b45a12b36a487f1587e201f556ad1f61540c3807b0c604b79bb47de5794215d2e9c34c0a714fe6b3cecb78f9d458b5670402ca38ffc6e4ef64b9dbc2ca2515ff84edd30cf4b26b78a40149973c6b9507987715579145a2d88a4f2906b42c5dd1648965e44492fbd5d1ed1f0f7084c09574cae8e210be9edfbe724b9ca315a308edba57fa7098161aac04025a07ba38f43c477d1091545922a03cdf3ac7c2686a61e43d6f4dd3d8e3667615d41fe9f103929f426920171bb638e4fbd102308455cd3527064e1943d8ede9ffe7c6b159202ede690a8eb803a193299ad9389cb0d2bcce9eda775165036ed371bfe4fa81fa3e112f54c955f834e6963bf2ba75904124cd3f32532c395d4da54225792bd4ccfd53db58b6fbb8a0ae98e886129d276ae5c87f396d9ac70f0428d3e2f3439740c2f1874ef9aa0ae156662b47b76f37bf69f97d66f6e2a2901f0ba79bdf5c29a073b97271a2b3226fd66ed33a065595119c0119db36427b081dc32517c960722cc663cc1bba4d4764270c410f2093157f92f663e0d1a950e21179fac1e29789bf9ec2f7c06f8edf01814e239420c14b9ec72cabcc8598debd341891a004b805df06c86e248d429b8abf5ecd316471485aec5e6535e43c5bbc1307f472cb98d45c83189da249170d2cb236efd6b573420b614836c563fa6dd8d79fdd4fbddc96a19df28865a213cdcf1cafa1bdf479bf4df90b343f2deb9670d93cdc44923e006faa900681b9d519ad166e925e9cc8b63069370598a1a1907fef857f69c8f6620b8fc765b3fad6efec67939964a953fa540853b24a5e747143d9eaf20303a803079659aac8231b645e00e7db5c61778c9c4923f70131d7fc0cdb45006ce5e83553bd55bd53c79560daeaec142f9863558d1e8aa065e972483b2601ccfbccba744cb29c61d2d5e2508fb0f59dbe8595b9b97db252b0a877eac02429d79375f662ffb854e39faa92c2cbf8f939ce931fddd612203b9e7dcdcd648f060fdd12c720377257ad6cbdb302c0a09e634087f39c142605a4fd4e23c8bfd552bf83ea2e1295feeb3ba37fe5b2dc66e5f0db367886859335d8aa391645f909a75ece9b9d14917bcf66f9e083004e3abc7af9a66500f6897377c8bfb35cd9c7609755b29f086b3a70436f14e862d3a092810de04b66214f7d5c79b3f0b48b614b6d9bf9e7f6258b46a38d69d79a334f12f472100bf7a6a4f0a8c9bd7479fd59f9442628d6bf4282b20630aa6f8d8ba029f101b75e71ab81538319b69c3f9b3cd9596e8b9079d5fe5f681564cce3b9221d7ef010732db69671a89adfbfbcb5d98062968043bfa17a8b386a3954ce5222c79ff5da72cb58aa08cb3a723b17076a6132ffcd54718361fa194bd89de208bd40aba304710c0ae6ac923a2c31c55f2ef7f8e6650897ebf916d21f472b5836086abcea87d67d908813ecf5696671a1b8840bf26033475dca033959ea9b0950e8ea0361a36f52c62928bf09e199fb8a8e05da589cdf16ccea983183a7f3d70b5c794bfba05715223112a02240d45cb5db092a761634b694b651a0aad60e873399e4df5617fb03a6ba34606678f0c4907b34534c2fd0f19945a175bd0a2aee8528ad58c03571ddb5484682a75dfc4ad81b2ba14bfc04f2a489c8f03b5f33cbaee6a0fa6642560889ba931144a2b1b4708c0628200417ad70de37d26269aed9184c5d374e80a6625e3f18050ac0d6c4d632489a1369188ff45d206a3f28fcb07eb8ec8602c43aa1a3bf75a4229c060ec05e9f6e1ff6cc29e23cb3c12b86bac8dd3d84322a4999eae128a4c3154954063602fb4dd78e06a125fbed69af142bed4942367738e2b516e55b62af26375a660b30ce51f48491d9c134be3b2adf27d8d53026bc7df2e32dd9316fd6bdd60b8fa9d22e34ea27612316886574a1b4ed014946b21aaf7fa7e2fa85d1ba9fcc9d4ac9bdd22aa8be1e3564060824a5bd9396ad4348e5bec05da490b8e6ff795912b1be630a4c4245e3f6255ab2603dde527d1e868105878f79464082b0a357808d4e228311e2ea81512558b623d0b73eef604e73f164ce942fa8d78ab422d53f8a79901801cfa65e864b53ff138bc261315ae7a600d4f0c765e96d0bec878424babcce297ab4f46c2fac96e11d9b116cb2f6fcad246d3b088a6c6a4a5c21c4855e85dd5cf8a9dd2c45df3c12db95823bdd537627a6ae42b5baf085c730a33d6acd0fe56561e71ebb259769e60285c91b7e72c37d9a3811e8bf20ac12fd72121893d038b728e4c1856df56d7dde88a85a2cd4b6e0c303708f68236282be2d6e0145939e6b373b4c33b2ffc2333e1c16b86cd13602ec004fb5d59ad29d43b575ed83d791eea24399f54c7ea286b0cc8db945578f039c6936bb01005eeaeb3856654864cbc809c8ea056ed62e96634223f06a314411e0b7d925539fb1eff304904f562abefeba71e2316696a3842274dc5c311163edee566fa7cc6985bf5695a9c76c4a998cf7472b324a007b0acfc267897ddf5279289c2f700400301479072ada41e5f17fc60aca54a9832e87f6e2262ecc670d4f73949322b0ffb237ab5f31c54c2ab9c66fff05367666bd3ca4412495f43ccfb7855f82952bda9b6b2ada5c9fa65726ebf4b7d8e909208464cf5099f11525e543abfd0b82ef60ff0114d103233d24abd73bd1ce1cdf9acac8eb627731a2a87e2a4f523803d2b9cf336c6d62ddd0e143ee38a2c224a5ea6126dbb28a23fe1b023d8e7184f8113f5a89d036a80180aa3ee05d7920523c8b606e91a3e2d77e988cc32215c2c83496bf38054355fafc4bf36305c490678f598d187dd12d1b2edba623c89b1a1f1a4d5d7c6d3d4796ab19747595eaaba16a64ca5148c211d055ca89d55c7863bf9b0398cf19ed9eb5ef0f5159ffa9c5986a343ddecca993cc3e48198a8e364762bdd9dfd55a58c092697d983e3a0278713ea8415d0802aab1cb43dd8cba1d0570f60a4a71c330605d7c1eb7b40cf3adc299a74c7c53d02ab716109f46f1178dda6971e518fab8b6e7b0053fcac617be2d522c00e5660aab081a0f9f461c2d5326d8fc7b3aecb26882ecf1bab0f7b5fe2d0dfe6ac3c0c9fda742b669a68d49f824d0172e088ca8a94bcec6cbdb33fdb05d5d41ca3ed34b4b48dc55d72061aee8f3962da7e8c06a8a7315c17a893a80e4f9ee580fda8801905b3d3fa64d9bd20ee3fe0bc75acad94bd357048b6dfbd65fc894a54e2a801b3b86c1970ac70dd46eafdde4e86320a6641f5c3fb35d833e3e36c5fe7e8d8526a2b5e3f21ad40ac1f9682c0bb318579b1ee49488757a1f3b72531e3c25bc78412cce7ee885f88e36435fe10cdc6330bcc2410bb6f0647f8a6f4b9c092afef84a317ff384291bb596b979c6bc456eb14b591e8e01f0e6302283c8e10353b1372e885601e34b90d8633409115cd417ef9a85b11e8bc4a6d09e83f67f4706e211add6593bc55777b401a0002e6cc86d47555190b7a4dbb5a96641f3d0fc29f8653c7bf77f09c244586693def91a8863a46afef8d9271b3646f2b75ffc45c964909cc9cf3f1aa9312025ca63e8499f52734bd82b8e7a5c1048c2d7a7726c9d376976a769f4a01bcee09567c218aa1b0b13377e86a17a16f3692589bd7a467928f13c0e1bf92172d6f58d1c3c9f71f132a1074e96e3fe1be5b7e9d7ae85080bddc60a5131dad5ec062ea4f576714159c42bbfe47fe573883d0a3db9d30a1ffffe73a32021ca671b8d09083b3b0510efa2b2a03b29f6ee77c9fcab4c1e302a12d3bcef3bfa031f6837c71bf812101245141f3b8c6906ea6b0b585db896b6da515af895592b161a7c13eb1ac0de976d89e74407baac1481c952d9a52dd23a4ba95ef29845029829549cced7f087bd524e5196f02e44955d6f60b8d2f2a09f052656eb98355ad6910ae11ae5b36af66f2789d3029adc1e6449cb84f5a875df82bd9c01b7f86e0da467cc67d499f19af25a0d280707ee66d79d26170527c94575eb91f7251f5720de1eba4ba6da020bcc3060d8e1b20f53f5bd9e950e436d41b9f93ff987474898743d4427e8a6d99fdee8a8ece6d2f2983d70813615d88b3588e29b5ca4ffbbdf287dfd2e1bb6b0ac95aa8fdcd995b0d4b093e186ba490f02c86d57be205d6df6f0143deec090b1b8c91f41f584708ac3f203ae4adc81902c96cab85621b33ec5a9aac5829166b942a2db438f9b5c3799365cfae8145551e6170e3dbb0c0265273e20af5248d7d9c932feaa622f3af8adc812749e3b52524bf200ff85b994701500254c733aab74ff3998889a3ffd49e30448b8145fdf9aa6d72fe9cbb6bc21979a5c83fe09aab2a917e52a018ec2f7a5535597a10f8cef27f1df9c4265f08b32a08a39a2618f1091ec10f7d16092ea34334ef289eb244d3173c7820e4867c9e2d1fbae87a5d9ea5294df72827c035f8667fb36eee19108ff7e3583bef3f29dd8b898f49851014c134745f9d58481ddc2ee41aecc8b5b5f4374df8643043cd1288d0c3782d779857290b19dcaa40a0e8a38f692e2a28a3fc2090115358be54fcf73df4c7613724d7aad478a6d8245fc20a0dc109318d775e8771007fa857c24ed28854522fdd583d04ff9279fd5b10d2b0f423a0c18b9ff02bf6118ea6d934105e4db5666b5e30438022cc6126182458f6dd6acd86012c9bffed340a771d013d3657bbc62fc00127164c2d29a3376c74028d1a8ddf03dfa695b04167f2a61e02b704f1324e2f4ddd980fc5a936518cf0445d4c49e2e918e1b8c603fa186c50c8c986ae2c89c72751c26bb88bd983d22b5b3b3eea1b8fa090f4c65f07b4e549745387665ad65817c40aba3b58fe763af3e97848d85de0c1905e7c34378bd23e7c4d5fee45568c67882db5fa3b430d13b2edbb3600ba8a4178f3237a805c78f02520fc27120f3569193f46d79fe929d6a6649e125e3bc1fc6e7bfa43db748895e9f66b4f788b049667f6962036e196fcfc17f396e98552a3ace05202085ca4aff2ecd00043fdcae95c0233d62332ddaedb8ba7f8dbf84da861072cad7c5b3108e16517245e205a01b2d3938c21aa6fbae92391613210527815ee082b97c2deac43f996bbffa590b25ee4b8f0ddbdad88662273135c48d8e32ccba464ecc67e8db0af6f60de16cdcf6d053661f8278c3a832889acc7546297f97af0236cf0cd1350b7964a1500f5d559224831fdc25a50f3c64d515f390ba8dfe3df403a980d3492f02cb1ef4fd497d2923b4bd5d8bfc77ba038bac63d5b0dfa109652c77b090be8132c8ae82bdd759d8837a43ae7955a89184274aae476b83d8cb8b159096be0a2424ca308611eb5df923accca4c30fbfccf6a2b8dd10b225b0c9f8ecff0d9f7fdb35c20df611862fa055740d45ced977234e06efe70689f2ff30a20ce32722131c0b6d5c747c0a711d9d1e5075824d5432d1cbba2905a29a796f13bfd852113511955a662f576e52fdbed823480ce564c0ec346517f2c81dee2c170de455648261bb7332de61db5552aa046e2672140038055649df3a4bfa32771cc477cef623a165a945033d7ba5d7ddcf472b15eb44b3929e1d57190dd000dcad4d1443bb4aa24f2a73556aa827b5c138008d8e16c392904dc189547412c38bc27e2748f5e615e6878449ae0b3ef78aa3dfae34509c9bbd450c1044d97f79ea0243aebf47331755f7cb66a4e777e232677c16044c064fb9a2c8166d991ada0b046068f38a1980e0abeeb5fadc1c339fa905d1c43a6358f077d59a23e425b38f95c047ac56e5e04510b9cf1ef214c3152ee0dacc0a57f748e6b3f0afcf1df289b656f1c61535b6c0000bb81e7efc547b66d8cb7f068544130bd838a6fdcc5d7dd7ed99b6a009f7adb67f7936f881a139af342399523d6be106d5a1299ecc9649e9ce01d205a4c08aae2f699406f046a3a93c8ca07b68927482576ca85540a5794cd30887d1a953ee4ffac9db36f6dbccc151f2a4647a9eb9013643acf5dfea98becf1740ac4148aa49a2d3ed680809e40eaa0524feadd21dc88392b16521c6717b90793974febd9efd3fd3deb2f854fdcd6b00cbcadbbeb70d1cd2079a95de102900b4be1385340ae6740aa15f3a9efebeecc60eb880b457c840189152739721cd33841e5ad32103e3138ccdae148fef8b4baaf0c9c180745e19c96b31f7667d8bb387b39c19fe3b8b26ac774583ff59dc15510529fc56c23abf604babdf3fe26208fcfb4d9f4160e5f0cc5e8428d143e03a33106e4bdcef264f8cec1a81af02715e461d075e523794a43f99c3275384d3bd29edbb3a7560d7200b9e3784e2ea7073c748ecd77dd14ad2713fef66557b1bab0bf846034cd9b9320c85797335e71689ae09be8b583c21890273321cf9efdba8a433b6e68f8833b659a08a6de3cbf0c88f6cba4e9be9c7bcc79aa6f71b59f7fa0e36e2fa2b15fc3dcbf61f7961efc6501402707043b627ef84c5903576bb0d4f9f43e1cd082d09b544468fece28320d366a83f094bacfe971d0f14dae29a43358773e685a16980aeb853df3e66387824490450e6d1208207ca7a2b4e450f6404ba6c4676eb6cb17642dcdf9a3109371afa41038db358906cdf3d812aff0eaa89dd34dce3d55e8ff1ed3da30b87a850c8919f38b66b009b44a2230c3e76127574f313eafcd09788f767c3ee514b04707c21b98599c5d7a505559c36615e0c4c7cb4ce65feb83c35acd0f32fe274c5ea5531551cd9004cd2c7e9cc92d82d3f936301065298e0823b483d756f3dfd5e94086682e9f60a9216cbefac97792c824997898361f26310eb40b2b5c07c42a0108f3a5e7a261ece084a21e36a3e60dbe288cb64bd057d59acd2344d796eafe21d13ccf5fe2593f3bcc10f85bbef2d6c337ec9e1fc027fe5b7a4296bfc9e2474fc0e6bc1bbd09be9f3369e9092ea5180ab7d274bcf06af88b0a8c867d0c70b80e2722fa35a5723e7c1cd6032fcd162801001595cb395069ade35edd0f55cb2e817e4fc71fa408af20c4a4c2e6a035f1b889f87d292d0da283ce7727bb7ff7a78f08e18d95f79ebdd80a826d2d7421ecfb529e772189d1589508cc62feed867cf1cb31504ce9296467a5decfe87573fa7f0b54786de9c783359a54270d8ae4aa5ac9ca80adf063c302003089ba12225839e63f41ec58532302762ef081a14a94bb425d99b2fa1539a329fa8855172e433ce2a8b66e7a2757f12831ee557b39d68553ab99587aaa61e67e2a369a2526dbc70447a12c3120cc5a834fa2d8e3d374693b40bf1d1b1bd4688dbe23f9828260f04fdf79fd8a8a35ac69a1f9450a7c45608b1c9fef24d2bdf1208de1914989777cccf744e004187ac641271007004dd719be6cd345036dc06a6af43bb563b0c5342bfa87e0558862ed84c2220c0f7911f56af4fcbbe3d03627449d32d76e1554d3981f2b9a30324379d7b5d268058af5ddf9d00e40e3ececc953dee2dfbc02cf3e6107ac070f6c647f101c5d5f12af5c53dd7e3ef4ccb289b7927a165541d2a50c4d91f9a11919ec5683e3a15d3817a36628fca10873d7e2339b7ba4e90846cdf65ae803b6485046bd5a85a235d1e5c7b182baec8914137e4bd3f8d0880e4980067f78541622b6deb5b8534ceafe22721e694e7ef91e7758b0c6e11dba7159f0e03972da822ccb41bbfeba3c71885b827a12aef399894d0031bdaba4f97ff0c19d1d22030110fef2c8469ff5d558ae9b27f46a2863597734cce149e634a47d27380151a727b58c7ee11ba6c54c762fb7e6ca258cc00f8433a720b54082dd803cb682f1c8b847aa6a3e7bd3e2cb786f527ef8aac144caad6db26ebc4fc61b9519e72d2af61170f0ca8aff9b4402fe688cbf6925366e335c90358d2cadacd6046055ee50d5a96e21ec8771479c9731a39f762ef9a3e029c760b43d397d100f582a209e098ce397523170f9eba62cb9ad9e21a4eb0f7115976358fe3c86dcaf2f25e01a2da34c9c7aae000cf67f0b779045e4c1542e8725c8c2f9b9686c305c3d85bce88e4cbab059b8b46b05e68d557ab47c697c76f2647b7d86ed51daa3bf6147b545dbea4a70aeebc5fa8f055fb8440025405d3e36b53eeea926a826ee472097bc7e6f66349dbe45bff0be260105d2adf7c7efda40e5b4194f380371e9cdec2f5356b18881ef4487bebaf267a67efa325896d29979dbb221708604d40f38290625909a8dd0337704f0ddea223a2da9a6046d51d1154117051bb57cd0b6ab40254a37a8550d3f2f4e54d256c2752bf919c547b0c4601689c0615732874f8e13f3d02f502c57685c693130dae21df1f9ba9c509260a9df3eb3319dd14e9642775e4b3db33fc0c2fd23d2f8e6a405cc2b78400b690657583442f60b4d90b074d90f35fb586783c2af687abda4b950698d8c2a5e9636ee9dbc2d05d1768b1ecc23e10708af71c3273bb13df64eee8f2e8ce7c1211b305e7b91b882146e8d5a7ef912fe7efeb423f82866d4350e41b1105e9b907957763547b64384a581fda6c469f55a762f4b6561cff4005b84714b952d38375c596d5a86fd1fca6f60c0dea2d21b0ced4d42a33ae7f9488116f4195994675216d46e22cd86ea059c267fa1fe310c65bdd62d517d68a05c301648407e6652075a7c4486df7c2316935c1fc0184cc6e909616d503421c3c4414513f4dc83c0e9ca070e1ad75e5cbe8ad2756ca81d9632ff4ce01ca42f7d91cb707269693679de7ed72fc313970b4e036776cc20161ab389ba1b441fc3dff9e080c96f09c0f1fe4b2de76a1ff3c3495b4c8e3f96d980f8787f3f889d82f0adbe111c7f244b26a9344677e00d03769edee1cc7473536e908b12b7c76a7ea50711e4c82a2c64d7db977ed10c87d308cfa0ad1ef31597ba5e4b6073fc8b59a73b48a15eec45111d99d01ed5f9bec112f3d4b54903e315448be8e3fb2af745f055f26f7e824c197b9b5c8fded1e152d0de77f8dcafaf147b0d6bfdbb895d89dbf1d94139b11f71c0cc2a69f5d5522fb301f4636183165464d2ea2ec7de2d386d36e87439374d353eef4c81c3750108ff4c382e6338113b91196b481e14f2557f031335ee2eda8dca55915204da6aae9d4814e3ea7803ea963b37dc5df835e6be97d86343f8d83dda2f89cf948aea452344d6314509eb4b1661bd69b15bf2ccad64824c88b12c47ba17ef69d7af1f213cb71258d6af0e407f39edf3e9f7a723e48d1cf477172c5b8075a17e7ae99016f2dc175b43e9c55fe9ccffb978413727cdb50c1e8adc301e9cfcce73c77953637a7ac80a82dbf37957035be4fd24e9f7d2d9916faab59f602fbf1aff9b6c97b5a336d4ba707153300f0b275d80148c6c84f626a08cbc515e42f4b111ffe295835b81570e92f3f4c3459807f6b074d86ea0e55492deaee50aaadd5a2156f8cec1f536f51388bde8b743b60079fca80c2c31bd5503e456f91de906fbd08952dfabd5a96c16ba880dd7f1cfb1d11ff81af7082022ea83ce45eeb5a828c744454594118e60f6fe4b79b68f1859a50165d6d1b375e6d580f4666d9ee9861eae7e09e24f92260c6d85a0d473458fce9934d10bb49792c4c12a0a50509f9e21b03768bc0bb0021d0706397ed327eed9b77579b28fef9384c0899fa3175c450711adc87a2e4ac5eb3e4df7986b0a7440ef4f5ab0abfc2d4da5f0a29d1d336df636890c65a1189b74eb1f706dde98b5401d81cb88cbb0ed5ba6e2540a17f6fd0749862801c3f9719115e54f074f3c2058c89aa3a4ab3e77fced7ea6601c424a64d466b4921e8f6ae5533439369d6b70e31d60342eee1f5c2c38e5f0ceae97c1c25c7a46830a9197a5a7cf336c02d44aa6ee58fefe6cad627e626771c2874f25fff1efe84f88ca84b35901b1b0da5355998757b5db4510a8a28989064ad891ff15f2a230b1c0f5896425c01f1a59e9096cccbd1de7acd94cf2597c3ba74dffa757c6f2fbc09c4f1266e6f0153edeb0a24ba9769705a935ecead7c2090c69305378cda5852e51194238d567fee0750f9ea4548656b36dc45caa747418c6390a55547bede315797b03a8f4f51e32ef224669ce12eee4921fa89d9c87beece7a835df090228a8016eca94c3d6f1a7fe371ecfa80797fcdd29483c9b6c17a8e74c897e22ba699ad531232c3c163ad5b851bc4440847a8209d2cdb916e63094558b3358a526e49256e9047a587d7d119cb8257e6ef10de243c9bf0b82f8db1f92b2784a18d48587332f02183d45d91b85e832aff571913ca08f3f644d27ce8f9280c592b48be3e9a07b93ddbfb66763a004eb629c47dee7f0788304b112a653c2d898fe65087a71ac344b4be477e5c1f18c54a06e733bc50df5fb87b8c307399feac2c11587b891ae2025562796f2d9df6eb7df0f33c2aa18da9cdbac1a078fa510f6910881839cc11ef1ebbd2b86ceb211df98893615cadaf977b4359a7de3c7417db5d10a84cc00c45472d63af059973a882bc522d39953323d35143aa7642ab31f7fde10c27b1bdda43f36855071acfa8568fbf4699097e2e61d9b92783fe20a590eed394d24bc48e49d1dc48d70241ff2d406adea2055530e1e7ec03407ed07b2eb50cb9074d6bfcddf0cd773957893594ee94dc245dd300dd1e1ad571b4349aaca04527aa9fd7fdaffea9e263f907827a125e53b3edb1d6dca8720333bbd8549a310cd05502837235f065ee1967d4c18aa0c2d2390e96c9add11514fcdb682741a53eec1565496a2c1b4f9d38a446c3b6294ed25206be72df15add77623ffd9a70295483cb8c8e338ef39f47c2bebb6167e503e437602ff7770c1d810d193befd2b7ac26a78bcd4c140b354c3db1f214b896d461b97dade2804991b6e8eba63c6bba50f17731fff7191b41d176ffdf72d3e4b26e9950e0dec8f875a8c5294a9d5648d47670643305f54d5fade824de689df785685e057d5ef89edf0db10ca8c6dbb1ede12329e753d99e58652da9556d990b513378c1460a6c2093b319e4704085c2a0269e1ddb11fca71f2bffd781971a8ad1ed48589a8cb1641247edbabc4484674fb9009a3accf51dd68ccdd3e774a9f06289c0d6fd486daa0445f250f2d1fd2282013040275675873380d283de5d6d4add8ae4c4f187835564a09412fbd8208b1182f2d57df76e3f72ce82c57a88dec063d531cd748aa1fd51a697e07f5c20b52142cf5bd55d5e36258da17040e6cd879dc1e36666e96ed6ed29badf37f5c8a1a252519c527a85f2c9fcdc77c8e5efea738892ee6134843025b7823735435b5ff30a850b6a43f19b003673492a2fc27ce6059e786419ac5532b8e8d9b5c5223a6349780eeceff069b856d8373bd272464db5b155e62b02375f46e62693360fe997b921273bf4cda244a93cc4dccf7734a60d829df8cb46c000b234ff5add92673afa5625772aafcb2f43199c006d2d1655f1412982bb3252440fc75c86195b925831aee75b59c0349c3764e421495d287f7f67a1f0f0c0db9029356dd3929b93f32b5796422ad76d07d273fd677bd248c976b1352dd62260f6fd8e23a387c590e4760555f90210dad5e7aa95a7dce670227f3c9692eef22b7c77efcc40ce165a72f7e9ac10c6ea861383020783ec3170fa573c785930f42307dadd7675945fb03b47f2af1732ed472300f84081e9108cb977d6c25c301f30896193c9c6689eabd26a81c5bbdd3569d0a36af0f1f1f2cdbfce0a34f9d8dfa4d19c05f9dd4de39f83468386f0495a18e863d5fe684c6a29d5e01fe5eda35b88173bde62fc447a82f75cdf4d41d0ca92fe53d46440b5e0451047885a73f0eb44a40f6f4ed8410bfa291257f70643d792b5b97df91a788c5871d0d683aebc5abc9eb4e9bee1efc3eefbb8a0d7d8f34b55e60a16543783e75cbaaa2f26462a7b47929fa2436cf22fae341211602e41acc830b19bbec79ef898e93f03e7b974b833db607795060c1b2efe856f0c8990323c3e3777ec918fd3056733705bfd60603fc14096bdfb9b10fe6ccde918a5dbe8ef76c6a38fccec30afd7807443ac52e275638824c36ce44962da581899c534e7e8b465d8aee7957ddb99007109a5bd17beb0300c59299a3379f402751be61f465c5ae31b15e9723a05c73a4a0d7e9ea99543ff45ed377c607ad4928d96dc9315303a7fbc6033d8d327efdbc59e11c9d07d4868b00502faba39c1511f14defaa256459de7d94de8cb739cf09ea872ce8f41fee74830de980b89abaf6db93b99322f91ceb505a56626e0ea68dfa7ab6523eca83902f4a6b390ee74bd518f8c882f9afd274ba2e9d5d6777af1c3498e3d9c14786a7ed4ba06ee4b795a405ff3214d5641b20912d51b460821b0830e7b92f0319fcec6cbbeb4fc908681a54e693ad34782d4ad71a05240f53e42d06cc6de36d981a73592be2c830d960f374c5a83fca7c2ccd5ae32fad6984740c5a65288700c6f770e9cb937c989ebcf70a3d84933e8d8d8a799830b5c67e3b111fb74ce451cb9e5c18b42fa2246b8bc9cafd4cda4f46b6959b44ed4af24e7e57bc11d52e2050ddf91a888b869cf62ed00c818f79aa22b9e2d50caee4a7d7369e5d133c685ff0c97060043f976554617d196b9ab1ca7bf0c618c98933cf089bf09047b9da9818e94371be887ca6ad9d743abe8ec4bb9ee286091a50d8a69dc9e7cd34aabbcf356ba898287ecb16f7275989b0beaf073b5c5a19cf35daf47faf912e6dc5b22bb8465b4ca22a748d1b87d1ea4c1811c80c4fb53573be598cb117ef6a16605aaf4d79f2b6b77f7ae1c304f5051738185ce4f6ec4240d596f9c19a64a8a392f14d70666d05f596fb2a6b25a6c8c9a75c596dc7662de6938ea6a3d9d913bfda8d282dd7707184973e73692d9bea6c8eb812371947cb178e376578dbca57ae253d65278d6e99408f45d4b5d6f028825cbe29f42862127bba0eecb93e9d2f5a2449b7d6e126c6751295088e034478ff1c66503ecb417173ef5e724e941cc305cd008537f2fa9108e6ce3c0a2185ab59b1ec76df5b21b1244ff8742818ac990e28ddedd4b456cdc1c9f730ab6d1ebbd32e3bd73eef158773f3c3183d1f18eaf3e581ee1f790ef3b1aad64fb3ea1276f91532b57414f03c03f92aa2d22654c965040929e523213437c12bcf0399ed1ce108b0d509d4a55b6f3705954ed5b2019841d327a92a855b78cd641e60c10887dd3777b798dec3404dd8e5e0cd58406aa8bbae4f6ab62e4543d6485c445ffa032e33aa69009bf4b079a1cc2df0e74aeb9bce475105632ae945a1967b642581046b2bdbd3ec9bae4a2c1c8ad41f9800abe2f7e1e016d0a8707f41db1124540a0a019a321bb04956475aa6e9f8ab5c17e6ff1762ff3ee75a338d45f3828edd9ca8be9353d586d553f4bbc34cfd32f2b62bfcd582c8aeda4921bf579112cadcbc878b8b939e697a0986a53171f256024d3851326e427beb50b2c34e125791ad2250fbc5f03d356041e9c9e0b21bf94c9e1e30133ffad1e357de9662dc6e56af8a2849d6c14d98ad803240f2e6fd8982b19de9cc7edb629760af0650c478ffb486d615b5d2707987cf72c794b7eda3b595f4c2190436cb523734c027c707a1608f436130af33fa757b41d5a875cb9e82eaedf1bc34b504a2b8f6da5856a7e5c6e1aa33dda04bb7d65dc1bfc086610955bdcd67e516079f844bfa9026d745bd8fea0f7976ee968ba64ede56a76ab67fe26d1b7110266d96bf5a44f64237c4141fc91ad44d685bec69e5bb66191e8b9d8301ffd08a0acd33d65e5125fbc8d2ef2dfd62b69de2950db0f85bdd528d2bac4a665142716d7ed07ab3d3b34059a7112d4a4d1eac1c2442afff915a8d50f2c0a44ea5fb1724c82bb459f67e01e62cf443baaac1e617158c6d351319b8db4295262d024352372406457e2211d95d9a80b9310ad4f6b09c3e2c3ecb834df6d9f2f826c1c8e2b55108b0be7b90dadbd05c236c389d4ab7f6af84de92775104bcda0b91c6752d5a8d64e4a685c62762f667baf6a7276553889a846a8e3f150ae67009837876bebd7acfc806160c575458dafda90a48d6e8a2f33589defd4d3ce404ac51c2961e60f56f80e75a9eb59b5fb66c25e823bb919ed7c77dd174c43a703407780e8dc6ffad554e29633eadc43826cc78fea3248f64907dbf4fdde1a7480e9715411cc516c851f3e5b4836441a92bace3d0a73c4883e9f1e91bf93d498bad3af355bb8b3d922301b18412b443a8fed950e70fe583d8a4a42785e0f6c9aa0712bcfb3f249721dab7b64020a60eb495467d214c0e8dc487c538d0ccbe0bea2fcc631edf38c5ee38a3f7ab15a1f3fae9746b3a64cc63e130a2b2ebce4a403b783205951d8399c8c7b681710ada3bb0cefeec4baf9a9ec3919c8ead049c76e42e8619e360df947cfecde6ccb2d3619bf7de9c9dcef818aea9b72a6d34535518245e254e826a97d8f81a59f663ddab1f99f774a7b9e1011feaf60abac9cf48a9ab67be151b62d928e0c1420049e498d1d7d6e5bb0bed46980dac073b34acc5751d51a020c78f357081fec78a9b7913c968ee514ed277b2b6e639d76c04fa77630dc09fe9d0b10a065bd692e54806e266c09a29bb8d7a1280aff099ccb28b282f45e85939a596c4a2918f5d794bc60cdd9b4681bbdc92ae327f94478a661cbf2c14731ea7a79729832a91f3be9ce2302b8ae4696e49f19f1bcd04987b0fc35a1683a9f4876b0b4c8fad5f0bd74d144ae2376196b55d02d89696adaef5e6e0af9d85561d18eee1d3ee389e4ab64e6b4012dc8c40767d748619c251cf78598a3e5e0308ef22c87f5b85432a89a970bb0dacaf98df91178df9e8b23154d17e9e3131f6e01958c2889c6571530b8cb52463caa6a6b68625ca4ac90f3a3c98ca8e62685765c235e378228997c6d28c0a04e8b1a6165d731fe4315bdd92350176f8ad0dbb2007ae41167060d84063286350f689ae8a453f42a0e46fda95486ac71299c3fe7fe2a88e308ab309d9fe81dcedff99f7b8c85586492b0496f08e9b8506a086420a8a1453f6456bf54bccd48784a496531951a758d21001411480582b1c890665820bfb4ef00b37f37312d608b95e5a87607ac24f40a4333575c018d800e1bb96aa5ecbcd9d2ce507a5217e277cf56e1c2dc847d968706195aeef6c822dd04e342d667c3819417469cf75dba04d2ac313525408d96a41424eb5f13ae726a5531fbea1b9fdb7a608dca08a85c8b64aebfa7bc67a27a9ab21db6ed5ca8786f243ad76603da27a7c1a61998b1b1e12b7c6f3c3bb58d26ba00ba3b28985706d216ac7987176ee386ad1aca7e9959f9f3899843a56635b2f69c9a6c520441913b1b7c04977b9cdadfc3faf8114317aaada28c715a6bee61fb53183d191b30edcca97c80323bca0adcc429d290d85a483e7bbd54590c7e37977c96d09dbd372db14584cdf71563857e1a335e9509a667019eb78871ff378a28767701c823a6de6bf9fae54af0d3cf9a8cc85eb8a748be35f82e8e3a0ae4f8b21f29aca6aeaa45e45cc4dc45fa101643d7d1421f9750b644c7c7e8ae9318a5aa0458a8dde0a4251d61187646a7753058063151a99cdee920e6a043638abb1cef9c7d612007a2fcff9970577ef9a9e08ccf1dfb9c3cc04483d6e73bbf4d50bcd5ad01a7478881355a20ed3dc9990db838fcd1a715a7a104873ca5c2298f8e34f7f290c812219e7a25675d01552140cd3f46bdced1e8430093a9a103aad55f192252cad71de43648bac4d5916911d116c21b17153862e84d9041166714db6b2db8e8fab63aecbe96facef53b143798fb7aa26a838feba5c814a7e9d6e1e4a43d6f30bfb1a92a41d8504577133cc4cb59944c0fa42abee311a3b9180b53019c541d524b17b223a0fed60cc8fbbd41dbbdd9a5aabec9ee8800f4128927ba197fb2d5880c2782999490b160631ee8772872c8cbf4112065d5f6978307d8591fbf733deac21f1075a7e1199a755a9b1dd8e9c3638f22768cc7bd78d975822448a069296904d0f6142bbb97fa509311319161658e03892febbde4dbfc07f390fce9a35f189b596bea452651be87313353ac831019c542c9ceafe39c87ea610f4e28744f371346e661eb49af0151d865edfc4ac28e35e6c06a008e0122978f7a99588d9b75d13da68834286fe2d50aacffe8157dcc41d5594908402f9fd2d9468138e896dbda1945bb47cbcfd0ffea729af2d9fd1118a9db358c236e0d0cde490934a4041630a70ca801af8812659023f056d823748258e12c3a6048fd0eade1baad9a86c99954e79e8f5db28e928364efc34e55679e3f331c9710f354c927b6bfa47485a6cfe154a595cbb7624f5119f453024fddc92be069ef4cd41f72a390e93ccc7685d665d5c24c9d7b37fc475042562530bff5153f3b1043ee006d32d7368bcb37d53bc6b249d8af9bc49c0557a8efa7d41e60d4c41b249c83c0dd2133d829bba14d88774c2101e072f493a298c7dbfac1cb8090210752391cfb9a1abf2afaedc4467d82163eccf95ce12e3e762ca8ce5dec539c9497e180c589f81fffcbd474da9fd9c16761b85d7282db39b3fc669c57c0774df4701fb279dec13785514f5280a122443743199682aacf117ff148942e92e7b37ca847e7ce4acfb81689498087b8804ba05fff69f6edfeea3bdcaa495549f9d4ee3ffbb9e6764a3921237343ef9b3832f940142e30d9c43315eaa929c7d894be4e1a839da145e37e19f5f6a198875721f778566799d0384f14f65180cd857a11a712615e2636fddf6ba25ba1d6113d295356dee679a840dc8355eeea4b9dcc79f0d8a10f35b8bf485d3d051730c9a9e35532875526170d3ef6cfa1e97f245628b7e0e995db7b82f54f1124fe691c3862f28b65fd3f5e0421de553439345df4d60a080aed8deb5af06e84affe035568fbef78d1e8ba67022f4db3cf18d5b8ece486ddbf18127efe5e9f5ac2d964d7dd96d738e5043ed56ec2c2d13dd9afc7a4c9eb3c6aff56af9ae3dc48d74be04aa2ede03e18f2472e3b244c6b883634a3daadd622854785fae56b931df529b448ddd34e6894c14854fb00bed661f7a43d300d4e3f2d630cf1b1284a44480313844abedc620342398e9cd27bcbff8c3fc71f81dae5276624076d83aa612f9ba25364e26eb5cb111938eed60a3dda7f3bc1f42a59af472b1708d07e440f1263bedfb9698a2d120e7ee515795c534a01cfda116c8a2b85ca8df0c83d4f98ee22c6c4fefc57ee2c940a054ac92b2fc4febdc24ad7de40512ab58a3f48fa1825915ee541b35ec30734612bb6954372a9933052f7168a80e18d9242ce4ce667dea9f6184708e4b90fd4ef858165b66da2e66c25cbbcf1f5ab9799db7498f404936885c36107040e1445a65006c6af71e5e3b13e657c98441fb3458200b91461d32c4a6b67f382c354af9baff0c43a473fedec2665ef4e05bc2909fe15f07582fe4968cfc99d926fb53563753eb2b524c71cc98b7ae3e270322cb84877c9000b42d6e85f07ff1e21164d5e3e7197480cd067fcf1c5d70cee01297a5feaf6f9da8b6c1749c1ed16396d26400cba4dbc9ad53ea7cac43cbce43cf95afde3549edf645c98472e60e36ecd2829fc1ee9d1ecea9043913def3d6934870c045a8a9c53728a7b9efd4b9a54e66a6070bab9ba94119d3620bc6d721f13baf20ec4ba6bf054cd1d87ba297de3b37be7025fe5e24b7b91f2a4ebc35518986c790fcf8af2d3824873f2411e89a90c36623a3a4e5cb3f782895d151401989d9206abd2be1659e8c81ae510e47ba50c0899e385726b8aa88f1ec61f258cd32e1875c70494f66b227cb53b08ab2ad1607bdd8b7e7480247a800527546b7720a6e74adb18f1c9493ce998ee32d071a2c3ce21113cb5daf72319a64ee72a1de396877e18391894191ee9f66aef5ec470a4d36c9ad53cd8596b16d072407896bb8fd6fab7660565f709be01e7c3ece17926ef4768037bd4dd3b585d470e6d35308cb87f3aed347afe3bdb51ac2ac4162c22605ba164c0d495a274633c9a933f747242beac474edb657a166c3d19d37b4459538efda10fdaf099ab9dc27341f896db0b7053226bdf4ca7f30711de0bb86f8c1503b59ef6f06f21a4f5938c0939840f2843b8d56d882939ed66fd37dd20884a101c9b26e54f81cdaf88dec70f0a25348ed0b6b6cffedb3e81a38ad750fc71d7053e6b3708e36f5e7c7af3bfb0b823a7cefde0b2344ff495c151ce328933385584ecbde29e00ec1b7775911e3e6cf142c5d426d8ba6896e25a84b8902f145c636f50427c3a7ecdf680a3f3dd9e35077029fe9bea929f4e7cc78b18bdea62b106426b56b78280bedf25b39e1468db270d9ec8afe151ec6adf59934727e6d02c01ee5274433095026a1b1bae3e22356f0260b69e5fb2f6cdbf3421cc9b47b6513c43d7eb0b95e18df491931c53b03556aa2c5ee786c00dc912b2d455e05e3b14143712a21c5d007a879ecb2d290f7730976fc939c6978d6c53596656c4e45abe4a4ded54d5e687b3b916de12fefd0f9252121832948eaf358b4397e1670700145270d8ac5cc419907cb8698e52c1d6e9b2bb7dd6b3fcd2a124719550e29be8028182388c20b6cf5c3fbb1ed3bea1748ddaa7c8b22f24405ef9125d3b8630f758ab8f991aac1613d73b16afe10df912fb19947739345fbf9eff4b01b975d0edee7eebebc6da58fe4ff78a2156dae2ad15f20be2624341f34421b6bd9cd03aece7e7789ee27dc14a014c0866375571cbbc4050edb758b748295bffe8231a453b6a2157be84c7b6366bdfb4f17fa55efd4ed36c95722ca20f09a2782bcf2a60c69464033901ff91a6d3f48aaaa30ce481c42e1c6bd168fcc229e5ddf453390d5119414d7599958d11e7cfaad388204f1ee9c920c900b48f7ebd153a42831bbb8b6b419f4e1c9078df91206b1de3fbed27107c43cc44552a1c5762272c9ca3e5c5c15d47d399394c01981770977e712559eb7c466255b9e1907afaba868e40efdbd75b47b6b390f840a86215e212fed488703ff01a25999e212b1a78658588937a550868fb38ecb8a61dbfcedec89ea05dc6f2d78d612211155965be18c4ca9c76fde8ac07bf466ef0f6a08d22659b4533b4485c51ccc4375097eebeca628baff998ebff68116614d73b3993d0cf24e0dc46378dc31ad63718bc33afc3e65769082be4df840db3438358c22ff51a006dd63bbe9047e1b343fa228c051198959c7d6fbc69f87293badefd0c8aa86b0eb6404228a542ae5681e3295bbad9b9a1d0e851e227cefb16262465feb701ca4974388a162c393cf3f8f1b276a1690a2b98d8442d701ea870fe04626e4635745b37c5a8725820d64b487cb5feaf64b929dc03a26babb097b960779aa281b21fa8a37bff79640c550af4db9303ea009f3e10fc40f247c8ecbb8f2bd7286a11df96742e1038c7bc88c21f3f6e13f9fe98f461206d417aec5e93e139d3841a7acee2a03069c1ad5e2b28438be142d59d7e44a3fde7eb0e6c961b2443fb4faf2b2c90d7f4585ca08d486fa40ec41ad0a26013eb161e5def9f409ab845a4e9436c78adf8d205f7f5eed7f210a9545ef819c9ba5493a1e2e69f5729947aa9e6b828dff847ed3ae11764cc702133f2480ef143aed87973e5a0bba160b65fb603a1c320359f2811a994aff4cf12937a2ae2696033c07c095818d17ab0ed0fa3df9c119b8f19072419cb139a113418910fbbf24076e971706094c7f6b456225ec4e5a0821ba70151790397e3bcfffb4269de8f7a1715a6a5a818b572021b1a96c994a08cff143f64ca115dbb1e8183561cc4ef70b4ba665ae6e2559c15b0dbc303939a876aec88e01dfe70f5a19fa082d41e7804c20120bdf6433fa6ac1a686ada33fcdeea2e7e7863e61642a665e49bf3146db3b5eb22d9f85d2bb22d86117da44a36aadd530c06ddd49bd6e5e616144b8c42d813273eeb6ce7c833862b1acc2cc5ba82d653f11990acacbf82e153d677fabded544c76eea699ffd215982c12be32f4ccb9d70b29daa4a6c10ff1e4fba5e6766319be0ec5662646939476e8c454b6e6f884fb6512e9f250037c2bac82</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-surge">      <input class="hbe hbe-input-field hbe-input-field-surge" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-surge" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-surge" data-content="文章私密：Please enter the password to read.">文章私密：Please enter the password to read.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-surge" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M1200,9c0,0-305.005,0-401.001,0C733,9,675.327,4.969,598,4.969C514.994,4.969,449.336,9,400.333,9C299.666,9,0,9,0,9v43c0,0,299.666,0,400.333,0c49.002,0,114.66,3.484,197.667,3.484c77.327,0,135-3.484,200.999-3.484C894.995,52,1200,52,1200,52V9z"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> java </tag>
            
            <tag> MQ </tag>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计栈 |  模拟栈的压入、弹出序列</title>
      <link href="/2022/01/13/zhan-de-ya-ru-dan-chu-xu-lie-lcof/"/>
      <url>/2022/01/13/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 31. 栈的压入、弹出序列<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></blockquote><blockquote><p>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p></blockquote><blockquote><p>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。</p></blockquote><blockquote><p>提示：<br>0 &lt;= pushed.length == popped.length &lt;= 1000<br>0 &lt;= pushed[i], popped[i] &lt; 1000<br>pushed 是 popped 的排列。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>既然本题需要模栈的压入、弹出序列，就要模拟到底，自己设计一个简单的栈</p><ol><li>设计栈：定义一个长度为pushed.length数组作为栈，定义一个整型变量作为栈顶</li><li>枚举压栈，当栈顶元素和出栈的第一个元素相同，则弹栈，出栈列表指针后移并继续判断。</li><li>最后判断出栈列表指针是否指向出栈列表的末尾。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++)&#123;</span><br><span class="line">            stack[top] = pushed[i]; <span class="comment">// push</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &lt; popped.length &amp;&amp; top &gt;= <span class="number">0</span> &amp;&amp; stack[top] == popped[j])&#123;</span><br><span class="line">                top--; <span class="comment">// pop</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j==popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>空间优化：把已经枚举过的pushed[]前部分作为栈</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++)&#123;</span><br><span class="line">            pushed[top] = pushed[i]; <span class="comment">// push</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(j &lt; popped.length &amp;&amp; top &gt;= <span class="number">0</span> &amp;&amp; pushed[top] == popped[j])&#123;</span><br><span class="line">                top--; <span class="comment">// pop</span></span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j==popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP粘包是什么？ 如何解决？</title>
      <link href="/2022/01/12/zhan-bao/"/>
      <url>/2022/01/12/zhan-bao/</url>
      
        <content type="html"><![CDATA[<p>事情从一个健身教练说起吧。</p><p>李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件<strong>琛琛</strong>上发布广告。</p><p>键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！</p><p>还记得<strong>四层网络协议</strong>长什么样子吗？</p><figure class="image-box">                <img src="v2-3ce2ef6cc4a7f288941ade57c9799450_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>四层网络模型每层各司其职，消息在进入每一层时都会多加一个<strong>报头</strong>，每多一个报头可以理解为<strong>数据报多戴一顶帽子</strong>。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，<strong><code>mac头部</code>记录的是硬件的唯一地址，<code>IP头</code>记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程</strong>。</p><p>在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。</p><figure class="image-box">                <img src="v2-a74a8e2932a412ffdbcb98f884fc086f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="为什么要将数据切片"><a href="#为什么要将数据切片" class="headerlink" title="为什么要将数据切片"></a><strong>为什么要将数据切片</strong></h3><p>软件<strong>琛琛</strong>是属于<strong>应用层</strong>上的。</p><p>而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是<strong>传输层上的 TCP 协议</strong>。消息在进入<strong>传输层（TCP）</strong>时会被切片为一个个数据包。这个数据包的长度是<code>MSS</code>。</p><p>可以把网络比喻为一个水管，是有一定的<strong>粗细</strong>的，这个粗细由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>，一般认为是的<code>MTU</code>（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。</p><figure class="image-box">                <img src="v2-5db7c25baee72ee2b77ca3bcbee97312_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="MTU-和-MSS-有什么区别"><a href="#MTU-和-MSS-有什么区别" class="headerlink" title="MTU 和 MSS 有什么区别"></a><strong>MTU 和 MSS 有什么区别</strong></h3><figure class="image-box">                <img src="v2-ce18e60cfc7a9bbe120b85ac4a7077ec_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</li><li><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</li></ul><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a><strong>什么是粘包</strong></h3><p>那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。</p><figure class="image-box">                <img src="v2-1daa1040cda53b3015f7001a2a72897f_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的<strong>字节流（stream）</strong>。</p><figure class="image-box">                <img src="v2-17ecf0e357371feddf343f93b658ec84_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>但由于聊天软件<strong>琛琛</strong>是新开发的，而且开发者叫<strong>小白</strong>，完了，是个<strong>臭名昭著的造 bug 工程师</strong>。经过他的代码，在处理<strong>字节流</strong>的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的<strong>粘包</strong>。</p><figure class="image-box">                <img src="v2-b57e49bce332079e2a62c656b2d422e5_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>一个号称<strong>健康终结者</strong>的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a><strong>为什么会出现粘包</strong></h3><p>那就要从 TCP 是啥说起。</p><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-e2a59fa4a549dadabd73e202ad0fe6e8_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>其中跟<strong>粘包</strong>关系最大的就是<strong>基于字节流</strong>这个特点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间<strong>没有任何边界</strong>。</p><figure class="image-box">                <img src="v2-7b36d6b7eae993081244621846b11704_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p><h3 id="为什么要组装发送的数据"><a href="#为什么要组装发送的数据" class="headerlink" title="为什么要组装发送的数据"></a><strong>为什么要组装发送的数据</strong></h3><p>上面提到 TCP <strong>切割</strong>数据包是为了能顺利通过网络这根水管。相反，还有一个<strong>组装</strong>的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较<strong>浪费</strong>网络 io 。</p><figure class="image-box">                <img src="image-20220112222810497.png" alt="image-20220112222810497" title class>                <p>image-20220112222810497</p>            </figure><p>比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。</p><p>优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先<strong>等待</strong>，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。</p><p>上面说的其实就是<code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><figure class="image-box">                <img src="v2-495ef2712c3b542cf277a5121cfe3ab4_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>由于启动了<strong>Nagle算法</strong>， msg1 小于 mss ，此时等待<code>200ms</code>内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为<code>MSS</code>。此时发送出去。</li><li>剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。</li><li>剩余的 msg3(2) 长度不足<code>mss</code>，同时在<code>200ms</code>内没有等到下一个包，等待超时，直接发送。</li><li>此时三个包虽然在图里<strong>颜色不同</strong>，但是实际场景中，他们都是<strong>一整个 01 串</strong>，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就<strong>像是两个包粘在一起</strong>，就会导致<strong>粘包问题</strong>。</li></ul><h3 id="关掉-Nagle-算法就不会粘包了吗？"><a href="#关掉-Nagle-算法就不会粘包了吗？" class="headerlink" title="关掉 Nagle 算法就不会粘包了吗？"></a><strong>关掉 Nagle 算法就不会粘包了吗？</strong></h3><p><strong>Nagle</strong> 算法其实是个<strong>有些年代</strong>的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。</p><p>但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。</p><p>所以现在<strong>一般也会把它关掉</strong>。</p><p>看起来，Nagle 算法的优化作用貌似不大，还会导致<strong>粘包”问题”</strong>。那么是不是关掉这个算法就可以解决掉这个<strong>粘包”问题”</strong>呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP_NODELAY = 1</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-53dd931a4d8ea89ea1fbc0bbcfa50072_r.jpg" alt="preview" title class>                <p>preview</p>            </figure><ul><li>接受端应用层在收到 <strong>msg1</strong> 时立马就取走了，那此时 <strong>msg1</strong> 没粘包问题</li><li><strong>msg2 </strong>到了后，应用层在忙，没来得及取走，就呆在 <strong>TCP Recv Buffer</strong> 中了</li><li><strong>msg3 </strong>此时也到了，跟 <strong>msg2</strong> 和 <strong>msg3</strong> 一起放在了 <strong>TCP Recv Buffer</strong> 中</li><li>这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中<strong>都是 01 串</strong>，此时一起取走，发现还是粘包。</li></ul><p>因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。</p><h3 id="怎么处理粘包"><a href="#怎么处理粘包" class="headerlink" title="怎么处理粘包"></a><strong>怎么处理粘包</strong></h3><p>粘包出现的根本原因是不确定<strong>消息的边界</strong>。接收端在面对<strong>“无边无际”的二进制流</strong>的时候，根本不知道收了多少 01 才算<strong>一个消息</strong>。一不小心拿多了就说是<strong>粘包</strong>。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong>，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。</p><p>常见的方法有</p><ul><li>加入特殊标志</li></ul><figure class="image-box">                <img src="image-20220112222646626.png" alt="image-20220112222646626" title class>                <p>image-20220112222646626</p>            </figure><p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p><ul><li>加入消息长度信息</li></ul><figure class="image-box">                <img src="v2-67108ed6fe1b9f89f4c831882ff9ff1c_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时。</p><p>可能这时候会有朋友会问，采用<code>0xfffffe</code>标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？</p><p>是的，<strong>怕</strong>，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（<code>校验和</code>或者对整段完整数据进行 <code>CRC</code> 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。</p><figure class="image-box">                <img src="v2-a12fe05290289991e6d3fc4ed2137664_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="UDP-会粘包吗"><a href="#UDP-会粘包吗" class="headerlink" title="UDP 会粘包吗"></a><strong>UDP 会粘包吗</strong></h3><p>跟 <code>TCP</code> 同为传输层的另一个协议，<strong>UDP，User Datagram Protocol</strong>。用户数据包协议，是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议。</p><figure class="image-box">                <img src="v2-cb14cd4ee7817c81e0140fb0466e26ce_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p>我们先看下<strong>IP报头</strong></p><figure class="image-box">                <img src="v2-8d684c81269540bc81237b343755f7fc_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 <strong>UDP 的报头</strong>。</p><figure class="image-box">                <img src="v2-a62f8fa5871ce69211fa809032e633b6_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>在报头中有<code>16bit</code>用于指示 <strong>UDP 数据报文的长度</strong>，假设这个长度是 n ，以此作为<strong>数据边界</strong>。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个<strong>完整的</strong>数据报，从而避免粘包和拆包的问题。</p><p>当然，就算没有这个位（<strong>16位 UDP 长度</strong>），因为 IP 的头部已经包含了数据的<strong>总长度</strong>信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个<strong>总长度</strong>其实就包含了 UDP 的头部和 UDP 的数据。</p><p>因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了<code>数据和选项</code>以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。</p><figure class="image-box">                <img src="v2-0640a5a91302b68c71aafde8aeae2722_720w.jpg" alt="img" title class>                <p>img</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="v2-4fdde9161d9f6be4fe2a372c1ff6d49b_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>TCP首部里是没有长度这个信息的，跟UDP类似，同样可以通过下面的公式获得当前包的TCP数据长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220112223526763.png" alt="img" title class>                <p>img</p>            </figure><p>跟 UDP 不同在于，TCP 发送端在发的时候就<strong>不保证发的是一个完整的数据报</strong>，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。</p><h3 id="为什么长度字段冗余还要加到-UDP-首部中"><a href="#为什么长度字段冗余还要加到-UDP-首部中" class="headerlink" title="为什么长度字段冗余还要加到 UDP 首部中"></a><strong>为什么长度字段冗余还要加到 UDP 首部中</strong></h3><p>关于这一点，查了很多资料，<code>《 TCP-IP 详解（卷2）》</code>里说可能是因为要用于计算校验和。也有的说是因为UDP底层使用的可以不是IP协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是IP层协议，而是其他网络层协议，就不能继续这么计算了。</p><p>但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，<strong>如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢</strong>？</p><p>因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。</p><figure class="image-box">                <img src="image-20220112223547322.png" alt="image-20220112223547322" title class>                <p>image-20220112223547322</p>            </figure><p>面试的时候咱就把这些全说出去，<strong>显得</strong>咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，<strong>加分加分</strong>。</p><p>如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！</p><h3 id="IP-层有粘包问题吗"><a href="#IP-层有粘包问题吗" class="headerlink" title="IP 层有粘包问题吗"></a><strong>IP 层有粘包问题吗</strong></h3><p>IP 层会对大包进行切片，是不是也有粘包问题？</p><p>先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。</p><p>先看看 IP 层的切片分包是怎么回事。</p><figure class="image-box">                <img src="v2-1f597892a79da54e5830c2e64c2fcb4a_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>如果消息过长，<code>IP层</code>会按 <strong>MTU 长度</strong>把消息分成 <strong>N 个切片</strong>，每个切片带有自身在<strong>包里的位置（offset）</strong>和<strong>同样的IP头信息</strong>。</li><li>各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后<strong>在最后的终点汇合后再组装</strong>。</li><li>在接收端收到第一个切片包时会申请一块新内存，创建IP包的数据结构，等待其他切片分包数据到位。</li><li>等消息全部到位后就把整个消息包给到上层（传输层）进行处理。</li></ul><p>可以看出整个过程，<code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。</p><p><code>IP 层</code>表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。</p><p>听起来就像 “<strong>我不管产品的需求傻不傻X，我实现了就行，我不问，也懒得争了</strong>”，这思路值得每一位优秀的划水程序员学习，<strong>respect</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。</p><ul><li>TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。</li><li>TCP 粘包跟Nagle算法有关系，但关闭 Nagle 算法并不解决粘包问题。</li><li>UDP 是基于数据报的传输协议，不会有粘包问题。</li><li>IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。</li><li><code>TCP</code> 发送端可以发 <code>10 次</code>字节流数据，接收端可以分 <code>100 次</code>去取；<code>UDP</code> 发送端发了 <code>10 次</code>数据报，那接收端就要在 <code>10 次</code>收完。</li></ul><p>数据包也只是按着 TCP 的方式进行组装和拆分，<strong>如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 粘包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全背包思路| 剪绳子 （java）</title>
      <link href="/2022/01/12/jian-sheng-zi-lcof/"/>
      <url>/2022/01/12/jian-sheng-zi-lcof/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>剑指 Offer 14- I. 剪绳子<br>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><blockquote><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1</p></blockquote><blockquote><p>示例 2:<br>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</p></blockquote><blockquote><p>提示：<br>2 &lt;= n &lt;= 58</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code> 完全背包问题对于大于等于4的数，拆成每个数都越靠近e，收益越大，由于是整数，那么，拆成2或3收益最大比如：n=4，收益最大[2,2]n=5, 收益最大[2,3]n=6, 收益最大[3,3]n=7, 收益最大[2,2,3]n=8, 收益最大[2,3,3]...我们抽象出来，得到：物品重量：2，3物品价值：2，3背包容量：n最大价值：最大乘积</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     完全背包问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里dp最大乘积，包括不剪绳子的情况，这是等于原值，不是等于0</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">2</span>;w&lt;=<span class="number">3</span>;w++)&#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=n;i++)&#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i-w]*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包 | 分割等和子集</title>
      <link href="/2022/01/09/partition-equal-subset-sum/"/>
      <url>/2022/01/09/partition-equal-subset-sum/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="416"><li>分割等和子集<br>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</li></ol></blockquote><blockquote><p>示例 1：<br>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。</p></blockquote><blockquote><p>示例 2：<br>输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>转成01背包问题:</strong></p><ul><li>物品重量：数组元素各数值， 如[1,5,11,5]</li><li>物品价值：数组元素各数值， 如[1,5,11,5]</li><li>背包容量：target = sum / 2</li><li>求：是否存在背包正好装满的情况，存在则说明找到了总和为 sum / 2 的子集</li><li>递推公式：dp[j] = max(dp[j], dp[j-num] + num);</li></ul><p><strong>步骤：</strong></p><ol><li><p>定义dp一维滚动数组<br>01背包中，dp[j] 表示：背包容量为j的背包，所背的物品价值可以最大为dp[j]。</p></li><li><p>确定递推公式<br>01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>该题的物品i的重量是nums[i]，其价值也是nums[i]。<br>所以递推公式：dp[j] = max(dp[j], dp[j-num] + num);<br>3.dp数组如何初始化<br>由于题目给的价值都是正整数那么非0下标都初始化为0；<br>如果题目给的价值有负数，那么非0下标就要初始化为负无穷。<br><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖</strong>。</p></li><li><p>确定遍历顺序<br>01背包一维滚动数组：先遍历物品，再遍历背包</p></li><li>确定返回结果<br>dp[j]的数值一定是小于等于j的。<br>如果dp[target] == target， 说明存在背包正好装满的价值总和，存在则说明找到了总和为 sum / 2 的子集。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        转成01背包问题:</span></span><br><span class="line"><span class="comment">        物品重量：数组元素各数值， 如[1,5,11,5]</span></span><br><span class="line"><span class="comment">        物品价值：数组元素各数值， 如[1,5,11,5]</span></span><br><span class="line"><span class="comment">        背包容量：target = sum / 2</span></span><br><span class="line"><span class="comment">        求：是否存在背包正好装满的情况，说明找到了总和为 sum / 2 的子集</span></span><br><span class="line"><span class="comment">        递推公式：dp[j] = max(dp[j], dp[j-num] + num);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总和为奇数，不能平分</span></span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j &gt;= num; j--)&#123; <span class="comment">//倒叙保证使用1次物品，正序会覆盖上一层左侧值</span></span><br><span class="line">                <span class="comment">//物品 i 的重量是 nums[i]，其价值也是 nums[i]</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-num] + num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 01背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划 |  双串题 | 不同的子序列</title>
      <link href="/2022/01/05/distinct-subsequences/"/>
      <url>/2022/01/05/distinct-subsequences/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="115"><li>不同的子序列<br>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</li></ol><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p><p>题目数据保证答案符合 32 位带符号整数范围。</p></blockquote><blockquote><p>示例 1：<br>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>rabbbit<br>rabbbit<br>rabbbit</p></blockquote><blockquote><p>示例 2：<br>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>babgbag<br>babgbag<br>babgbag<br>babgbag<br>babgbag</p></blockquote><blockquote><p>提示：<br>0 &lt;= s.length, t.length &lt;= 1000<br>s 和 t 由英文字母组成</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>s, t引入头部””空字符；定义m、n分别是s、t长度，定义二维数组dp[m+1][n+1]，值表示s[0：i]可以组成t[0：j]的子序列最大数量；<br><code>（i，j泛指符合题目不超边界的相关变量，[0：i]表示枚举从0到i）</code></li><li>初始化</li></ol><ul><li>s[0：i]全部删除取得子序列“”，成功组成t[0]即“” ，所以dp[0：m][0] = 1</li><li>s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</li></ul><ol start="3"><li>递推过程</li></ol><ul><li>结尾字符相等，取两种情况的结合<br>第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等<br>第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</li><li>结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]<br><code>tips：由于引入“”的关系，s的当前字符指针是i-1，t的当前字符指针是j-1，与dp的i-1，j-1区别开</code></li></ul><ol start="4"><li>剪枝优化，限制t[0：j]长度不可能大于s[0：i]</li><li>返回结果</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s[0：i]全部删除取得子序列“”，成功组成t[0]“” ，所以dp[0：m][0] = 1</span></span><br><span class="line">        <span class="comment">//s[0]是“”，无法组成非“”字符串t[1：i] ，所以dp[0][1：n] = 0，默认已初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Math.min(i,n);j++)&#123; <span class="comment">// 剪枝操作，t[0：j]长度不可能大于s[0：i]</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">// 结尾字符相等，取两种情况的结合</span></span><br><span class="line">                    <span class="comment">//第一种，用到s[i-1]的结尾字符，则数量与dp[i-1][j-1]相等</span></span><br><span class="line">                    <span class="comment">//第二种，不用到s[i-1]的结尾字符，则数量与dp[i-1][j]相等</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//结尾字符不相等，不用到s[i-1]的结尾字符, 则等于dp[i-1][j]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心| 大根堆 | 最长快乐字符串 | 取合法的剩余最多的字符进行拼接</title>
      <link href="/2022/01/03/longest-happy-string/"/>
      <url>/2022/01/03/longest-happy-string/</url>
      
        <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>贪心思路</strong>：<br>在同一字符相邻小于3的情况下，取剩余最多的字符进行拼接，否则不用第3个字符，取剩余数第二多的字符拼接。<br><strong>步骤</strong>：</p><ol><li>定义大根堆，目的是进行字符剩余数量的排序</li><li>定义结果字符串</li><li>遍历堆的取出操作，直至堆空</li><li>判断取出字段是否可能组成同一字符相邻出现3个的情况，如果是，则不用第3个字符，取剩余数第二多的字符拼接<br>（注意发生堆空的情况：不存在剩余数第二多的字符）</li><li>如果字符数量大于0，拼接字符</li><li>使用掉1个字符后，如果数量大于0，即仍有剩余就重新放入堆</li><li>返回String结果<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><a href="https://leetcode-cn.com/problems/longest-happy-string/" target="_blank" rel="noopener">the leetcode link</a><blockquote><ol start="1405"><li>最长快乐字符串<br>如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</li></ol><p>给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：</p><p>s 是一个尽可能长的快乐字符串。<br>s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。<br>s 中只含有 ‘a’、’b’ 、’c’ 三种字母。<br>如果不存在这样的字符串 s ，请返回一个空字符串 “”。</p></blockquote></li></ol><blockquote><p>示例 1：<br>输入：a = 1, b = 1, c = 7<br>输出：”ccaccbcc”<br>解释：”ccbccacc” 也是一种正确答案。</p></blockquote><blockquote><p>示例 2：<br>输入：a = 2, b = 2, c = 1<br>输出：”aabbc”</p></blockquote><blockquote><p>示例 3：<br>输入：a = 7, b = 1, c = 0<br>输出：”aabaa”<br>解释：这是该测试用例的唯一正确答案。</p></blockquote><blockquote><p>提示：<br>0 &lt;= a, b, c &lt;= 100<br>a + b + c &gt; 0</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      贪心：在同一字符相邻小于3的情况下，取剩余最多的字符进行拼接，否则不用第3个字符，取剩余数第二多的字符拼接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 定义大根堆，目的是进行字符剩余数量的排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; mostCountQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y)-&gt;y[<span class="number">1</span>]-x[<span class="number">1</span>]);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'a'</span>, a&#125;);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'b'</span>, b&#125;);</span><br><span class="line">        mostCountQueue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="string">'c'</span>, c&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 定义结果字符串</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 遍历堆的取出操作，直至堆空</span></span><br><span class="line">        <span class="keyword">while</span> (!mostCountQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = mostCountQueue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 判断取出字段是否可能组成同一字符相邻出现3个的情况，如果是，则不用第3个字符，取剩余数第二多的字符拼接</span></span><br><span class="line">            <span class="keyword">int</span> n =sb.length();</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= <span class="number">2</span> &amp;&amp; sb.charAt(n - <span class="number">1</span>)== cur[<span class="number">0</span>] &amp;&amp; sb.charAt(n - <span class="number">2</span>)== cur[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mostCountQueue.isEmpty()) <span class="keyword">break</span>; <span class="comment">//注意堆空的情况：不存在剩余数第二多的字符</span></span><br><span class="line">                <span class="keyword">int</span>[] temp = cur; <span class="comment">// temp暂存旧cur</span></span><br><span class="line">                cur = mostCountQueue.poll(); <span class="comment">// 取剩余数第二多的字符作为新cur</span></span><br><span class="line">                mostCountQueue.add(temp); <span class="comment">// temp重新放入堆</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 如果数量大于0，拼接字符</span></span><br><span class="line">            <span class="keyword">if</span> (cur[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>)cur[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 使用掉1个字符后，如果数量大于0，即仍有剩余就重新放入堆</span></span><br><span class="line">                <span class="keyword">if</span> (--cur[<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    mostCountQueue.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题 | 看懂鸡蛋掉落的本质 + 滚动数组优化</title>
      <link href="/2022/01/03/super-egg-drop/"/>
      <url>/2022/01/03/super-egg-drop/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><ol start="887"><li>鸡蛋掉落<br>给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。</li></ol><p>已知存在楼层 f ，满足 0 &lt;= f &lt;= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。</p><p>请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？</p></blockquote><blockquote><p>示例 1：<br>输入：k = 1, n = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。</p></blockquote><blockquote><p>示例 2：<br>输入：k = 2, n = 6<br>输出：3</p></blockquote><blockquote><p>示例 3：<br>输入：k = 3, n = 14<br>输出：4</p></blockquote><p>提示：<br>1 &lt;= k &lt;= 100<br>1 &lt;= n &lt;= 104</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>本题解主要告诉你：这题目就是0-1背包问题的抽象</strong></p><ul><li>物品重量：1次操作数；(物品不超n个)</li><li>背包容量：鸡蛋数k个；</li><li>价值：确定楼层</li></ul><p>一般的背包问题：已知每个物品的重量及其价值、背包容量，求最大价值。<br>这题的背包问题：已知不超n个的物品（不超n次操作数），所有物品重量均为1（1次操作数）、背包容量（鸡蛋数k），求价值(确定楼层)为n时有多少物品。</p><p><code>看本题解，千万别纠结在第几楼层扔鸡蛋，因为它与01背包的思想无关</code></p><h4 id="1-确定dp数组以及下标的含义"><a href="#1-确定dp数组以及下标的含义" class="headerlink" title="1. 确定dp数组以及下标的含义"></a>1. 确定dp数组以及下标的含义</h4><p> dp[i][j] 表示： 容量（鸡蛋数）为i的背包，放入物品重量（操作数）为j时，价值(确定楼层)是多少。<br> 初始化：dp[0][0]=0，鸡蛋0，操作数0，确定楼层0</p><h4 id="2-确定递推公式"><a href="#2-确定递推公式" class="headerlink" title="2. 确定递推公式"></a>2. 确定递推公式</h4><p>当第i个鸡蛋、第count次扔出操作时，蛋要么碎，要么不碎，所能确定的楼层都+1</p><ul><li>dp[i][count]：表示你还剩 i 个蛋，且已操作 count 次，所能确定的楼层。</li><li>dp[i][count-1]：当蛋没碎，情况为少1次操作数，所能确定的楼层</li><li>dp[i-1][count-1]：当蛋碎了，情况为少1个蛋，少1次操作数，所能确定的楼层<br>当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1<br><code>dp[i][count] = dp[i-1][count-1]+dp[i][count-1]+1;</code></li></ul><h3 id="二维背包代码"><a href="#二维背包代码" class="headerlink" title="二维背包代码"></a>二维背包代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        01背包问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//背包：鸡蛋数（k个）； 物品：操作数（n个）；价值：确定楼层</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有人问了，为什么不是鸡蛋作为物品，最小操作数作为背包？</span></span><br><span class="line">        <span class="comment">// 背包问题往往物品与价值有正相关关系。</span></span><br><span class="line">        <span class="comment">// 鸡蛋有k个，但实际不一定全都用上，限制一定的最小操作数，鸡蛋增加，确定楼层（价值）不一定增加</span></span><br><span class="line">        <span class="comment">// 而取一定的鸡蛋，最小操作数每增加1，确定楼层(价值)就会一定增加</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(;dp[k][count]&lt;n;)&#123; <span class="comment">// 遍历物品，这里直到价值为n就结束</span></span><br><span class="line">             count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;=<span class="number">1</span>; i--) &#123; <span class="comment">// 遍历背包，二维数组可以正序或倒叙</span></span><br><span class="line">                <span class="comment">//当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1</span></span><br><span class="line">                dp[i][count] = dp[i-<span class="number">1</span>][count-<span class="number">1</span>]+dp[i][count-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维滚动数组代码"><a href="#一维滚动数组代码" class="headerlink" title="一维滚动数组代码"></a>一维滚动数组代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        01背包问题， 滚动数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 背包：鸡蛋数（k个）；物品：操作数（n个）；价值：确定楼层</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有人问了，为什么不是鸡蛋作为物品，操作数作为背包？</span></span><br><span class="line">        <span class="comment">// 背包问题往往物品与价值有正相关关系。</span></span><br><span class="line">        <span class="comment">// 鸡蛋有k个，但实际不一定全都用上，限制一定的操作数，鸡蛋增加，确定楼层（价值）不一定增加</span></span><br><span class="line">        <span class="comment">// 而取一定的鸡蛋，操作数每增加1，确定楼层 (价值)就会一定增加</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(;dp[k]&lt;n;)&#123; <span class="comment">// 遍历物品，这里直到价值为n就结束</span></span><br><span class="line">             count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt;=<span class="number">1</span>; i--) &#123; <span class="comment">// 遍历背包，一维滚动数组一定倒叙</span></span><br><span class="line">                <span class="comment">//当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+dp[i]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 对于背包问题不了解的同学，推荐看看代码随想录的背包问题合集；<br>目前没看到其他人运用到背包的思路，此题解是本人学习过程中的野生想法，如有问题，欢迎指正</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 01背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计实战应用篇 | 常见的业务场景</title>
      <link href="/2022/01/03/java-design/"/>
      <url>/2022/01/03/java-design/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#一es篇">一、ES篇</a><ul><li><a href="#1概述">1、概述</a><ul><li><a href="#特点">特点</a></li><li><a href="#功能">功能</a></li><li><a href="#场景">场景</a></li><li><a href="#竞品分析">竞品分析</a></li><li><a href="#对比">对比</a></li></ul></li><li><a href="#2基本概念">2、基本概念</a><ul><li><a href="#ik分词器">IK分词器</a></li><li><a href="#索引类数据库">索引（类数据库）</a></li><li><a href="#映射类表设计">映射（类表设计）</a></li><li><a href="#文档数据">文档（数据）</a></li></ul></li><li><a href="#3高级特性">3、高级特性</a><ul><li><a href="#映射高级">映射高级</a><ul><li><a href="#地理坐标点数据类型"><strong>地理坐标点数据类型</strong></a></li><li><a href="#动态映射">动态映射</a></li></ul></li><li><a href="#dsl高级">DSL高级</a></li><li><a href="#聚合分析"><strong>聚合分析</strong></a></li><li><a href="#智能搜索"><strong>智能搜索</strong></a></li></ul></li><li><a href="#4实战">4、实战</a><ul><li><a href="#写优化">写优化</a></li><li><a href="#读优化">读优化</a></li><li><a href="#零停机索引重建方案">零停机索引重建方案</a></li><li><a href="#deeppaging性能解决方案">DeepPaging性能解决方案</a></li></ul></li></ul></li><li><a href="#二dockerk8s篇">二：Docker&amp;K8S篇</a><ul><li><a href="#why-docker">Why Docker</a></li><li><a href="#核心概念">核心概念</a></li><li><a href="#基本操作">基本操作</a></li><li><a href="#实战">实战</a></li></ul></li><li><a href="#三netty篇">三、Netty篇</a><ul><li><a href="#核心组件">核心组件</a><ul><li><a href="#1整体结构">1、整体结构</a></li><li><a href="#2逻辑架构">2、逻辑架构</a></li></ul></li><li><a href="#网络传输">网络传输</a><ul><li><a href="#1五种io模型的区别"><strong>1、五种IO模型的区别</strong></a></li><li><a href="#2reactor多线程模型">2、Reactor多线程模型</a></li><li><a href="#3拆包粘包问题">3、拆包粘包问题</a></li><li><a href="#4自定义协议">4、自定义协议</a></li><li><a href="#5writeandflush">5、WriteAndFlush</a></li></ul></li><li><a href="#内存管理">内存管理</a><ul><li><a href="#1堆外内存">1、堆外内存</a></li><li><a href="#2数据载体bytebuf">2、<strong>数据载体ByteBuf</strong></a></li><li><a href="#3内存分配jemalloc">3、<strong>内存分配jemalloc</strong></a></li><li><a href="#4jemalloc-架构">4、jemalloc 架构</a></li><li><a href="#5内存池设计待补充">5、内存池设计（待补充）</a></li><li><a href="#6recycle对象池待补充">6、Recycle对象池（待补充）</a></li><li><a href="#7零拷贝技术">7、零拷贝技术</a></li></ul></li><li><a href="#高性能数据结构">高性能数据结构</a><ul><li><a href="#1fastthreadlocal">1、FastThreadLocal</a></li><li><a href="#2hashedtimerwheel">2、<strong>HashedTimerWheel</strong></a></li><li><a href="#3mpscqueue">3、MpscQueue</a></li><li><a href="#4selectpollepoll的区别">4、select、poll、epoll的区别</a></li></ul></li></ul></li><li><a href="#四leetcode">四、LEETCODE</a><ul><li><a href="#python语法">【Python语法】</a></li><li><a href="#背包模板">【背包模板】</a></li><li><a href="#回溯模板">【回溯模板】</a></li><li><a href="#并查集模板">【并查集模板】</a></li><li><a href="#拓扑排序模板">【拓扑排序模板】</a></li><li><a href="#单调栈模板"><strong>【单调栈模板】</strong></a></li><li><a href="#二分模板">【二分模板】</a></li><li><a href="#动态规划模板">【动态规划模板】</a><ul><li><a href="#单串问题">「<strong>单串问题</strong>」</a></li><li><a href="#单串加状态问题">「<strong>单串加状态问题</strong>」</a></li><li><a href="#经典双串lcs问题">「<strong>经典双串LCS问题</strong>」</a></li><li><a href="#区间动态规划">「区间动态规划」</a></li><li><a href="#区间分治动态规划"><strong>「区间分治动态规划」</strong></a></li></ul></li><li><a href="#滑动窗口">【滑动窗口】</a></li><li><a href="#前缀和">【前缀和】</a></li><li><a href="#双指针">【双指针】</a></li><li><a href="#深度优先">【深度优先】</a></li><li><a href="#广度优先">【广度优先】</a></li><li><a href="#图论">【图论】</a></li></ul></li><li><a href="#五实战算法篇">五、实战算法篇</a><ul><li><a href="#1url黑名单布隆过滤器"><strong>1、</strong>URL黑名单（布隆过滤器）</a></li><li><a href="#2词频统计分文件">2、词频统计（分文件）</a></li><li><a href="#3未出现的数bit数组"><strong>3、未出现的数</strong>（bit数组）</a></li><li><a href="#4重复url分机器"><strong>4、重复URL</strong>（分机器）</a></li><li><a href="#5topk搜索小根堆"><strong>5、TOPK搜索（小根堆）</strong></a></li><li><a href="#6中位数单向二分查找"><strong>6、中位数（单向二分查找）</strong></a></li><li><a href="#7短域名系统缓存"><strong>7、短域名系统（缓存）</strong></a></li><li><a href="#8海量评论入库消息队列"><strong>8、海量评论入库（消息队列）</strong></a></li><li><a href="#9在线并发用户数redis"><strong>9、在线/并发用户数（Redis）</strong></a></li><li><a href="#10热门字符串前缀树">10、热门字符串（前缀树）</a></li><li><a href="#11红包算法">11、红包算法</a></li><li><a href="#11手写快排">11、手写快排</a></li><li><a href="#12手写归并">12、手写归并</a></li><li><a href="#13手写堆排">13、手写堆排</a></li><li><a href="#14手写单例">14、手写单例</a></li><li><a href="#15手写lrucache">15、手写LRUcache</a></li><li><a href="#16手写线程池"><strong>16、手写线程池</strong></a></li><li><a href="#17手写消费者生产者模式"><strong>17、手写消费者生产者模式</strong></a></li><li><a href="#18手写阻塞队列"><strong>18、手写阻塞队列</strong></a></li><li><a href="#19手写多线程交替打印abc"><strong>19、手写多线程交替打印ABC</strong></a></li><li><a href="#20交替打印foobar">20、交替打印FooBar</a></li></ul></li><li><a href="#六个人项目"><strong>六、个人项目</strong></a><ul><li><a href="#一一站到底"><strong>一、一站到底</strong></a><ul><li><a href="#1如何设计排行榜">1、如何设计排行榜</a><ul><li><a href="#性能优化过程">性能优化过程</a></li><li><a href="#方案优化过程">方案优化过程</a></li><li><a href="#方案1每日一个滚动榜当日汇聚费时间">方案1：每日一个滚动榜，当日汇聚（费时间）</a></li><li><a href="#方案2全局n个滚动榜同时写费空间">方案2：全局N个滚动榜同时写（费空间）</a></li><li><a href="#方案3实时更新常数次写操作">方案3：实时更新，常数次写操作</a></li></ul></li><li><a href="#2如何解决重复答题">2、<strong>如何解决重复答题</strong></a></li><li><a href="#3一个题目被多个人抢答"><strong>3、一个题目被多个人抢答</strong></a></li><li><a href="#4如何管理昵称重复"><strong>4、如何管理昵称重复</strong></a></li><li><a href="#5如何管理出题定时任务"><strong>5、如何管理出题定时任务</strong></a></li><li><a href="#6如何解决客户端断连"><strong>6：如何解决客户端断连</strong></a></li></ul></li><li><a href="#二秒杀项目">二、秒杀项目</a><ul><li><a href="#技术选型"><strong>技术选型</strong></a></li><li><a href="#方案设计">方案设计</a></li><li><a href="#1如何解决超卖"><strong>1、如何解决超卖？</strong></a></li><li><a href="#2如何解决重复下单"><strong>2、如何解决重复下单？</strong></a></li><li><a href="#3如何防刷"><strong>3、如何防刷？</strong></a></li><li><a href="#4热key问题如何解决"><strong>4、热key问题如何解决？</strong></a></li><li><a href="#5应对高并发的读请求"><strong>5、应对高并发的读请求</strong></a></li><li><a href="#6应对高并发的写请求"><strong>6、应对高并发的写请求</strong></a></li><li><a href="#7如何保证数据一致性"><strong>7、如何保证数据一致性</strong></a></li><li><a href="#8可靠性如何保障">8、可靠性如何保障**</a></li><li><a href="#9秒杀系统瓶颈-日志">9、秒杀系统瓶颈-日志</a></li></ul></li><li><a href="#三即时通信">三、即时通信</a><ul><li><a href="#1单聊消息可靠传输">1、<strong>单聊消息可靠传输</strong></a></li><li><a href="#2群聊消息如何保证不丢不重"><strong>2、群聊消息如何保证不丢不重</strong></a></li><li><a href="#3如何保证消息的时序性">3、<strong>如何保证消息的时序性</strong></a></li><li><a href="#4推拉结合"><strong>4：推拉结合</strong></a></li><li><a href="#5好友推荐">5、好友推荐</a></li></ul></li><li><a href="#四智慧社区">四、智慧社区</a><ul><li><a href="#物联网架构"><strong>物联网架构</strong></a><ul><li><a href="#dcm系统架构">DCM系统架构</a></li><li><a href="#三要素"><strong>三要素</strong></a></li><li><a href="#云--边--端协同">云 / 边 / 端协同</a></li><li><a href="#物联网平台接入">物联网平台接入</a></li><li><a href="#门锁接入">门锁接入</a></li><li><a href="#各种协议">各种协议</a></li></ul></li><li><a href="#iot流量洪峰">IOT流量洪峰</a></li><li><a href="#社区直播带货">社区直播带货</a><ul><li><a href="#产品的背景"><strong>产品的背景</strong></a></li><li><a href="#面临的挑战">面临的挑战</a></li><li><a href="#协议的比较">协议的比较</a></li><li><a href="#整体流程">整体流程</a></li><li><a href="#直播流程"><strong>直播流程</strong></a></li><li><a href="#播放流程">播放流程</a></li></ul></li><li><a href="#直播高可用方案"><strong>直播高可用方案</strong></a></li><li><a href="#性能优化方案"><strong>性能优化方案</strong></a></li><li><a href="#流量回放自动化测试">流量回放自动化测试</a></li></ul></li></ul></li><li><a href="#七架构设计"><strong>七、架构设计</strong></a><ul><li><a href="#1社区系统的架构">1、社区系统的架构</a></li><li><a href="#2商城系统-亿级商品如何存储">2、商城系统-亿级商品如何存储</a></li><li><a href="#3对账系统-分布式事务一致性">3、对账系统-分布式事务一致性</a></li><li><a href="#4用户系统-多线程数据割接">4、用户系统-多线程数据割接</a></li><li><a href="#5秒杀系统场景设计">5、秒杀系统场景设计</a></li><li><a href="#6统计系统-海量计数"><strong>6、统计系统-海量计数</strong></a></li><li><a href="#7系统设计---微软">7、系统设计 - 微软</a><ul><li><a href="#1需求收集"><strong>1、需求收集</strong></a></li><li><a href="#2顶层设计"><strong>2、顶层设计</strong></a></li><li><a href="#3系统核心指标"><strong>3、系统核心指标</strong></a></li><li><a href="#4数据存储">4、数据存储</a></li></ul></li><li><a href="#7如何设计一个微博">7、如何设计一个微博</a></li></ul></li><li><a href="#八领域模型落地">八、领域模型落地</a><ul><li><a href="#1拆分微服务">1、拆分微服务</a></li><li><a href="#2关联微服务">2、关联微服务</a></li><li><a href="#3微服务的落地"><strong>3、微服务的落地</strong></a></li><li><a href="#4领域模型的意义">4、领域模型的意义</a></li><li><a href="#5战略建模">5、战略建模</a></li><li><a href="#6相关名词"><strong>6、相关名词</strong></a></li></ul></li></ul><h1 id="一、ES篇"><a href="#一、ES篇" class="headerlink" title="一、ES篇"></a>一、ES篇</h1><blockquote><p>Elasticsearch可以实现<strong>秒级</strong>的搜索，cluster是一种分布式的部署，极<strong>易扩展(scale )</strong>这样很容易使它处理PB级的数据库容量。最重要的是Elasticsearch是它搜索的结果可以按照分数进行排序，它能提供我们最<strong>相关</strong>的搜索结果（<strong>relevance</strong>) 。</p></blockquote><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>安装方便</strong>：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</p></li><li><p><strong>JSON</strong>：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</p></li><li><p><strong>RESTful</strong>：基本所有操作 ( 索引、查询、甚至是配置 ) 都可以通过 HTTP 接口进行</p></li><li><p><strong>分布式</strong>：节点对外表现对等（每个节点都可以用来做入口） 加入节点自动负载均衡</p></li><li><p><strong>多租户</strong>：可根据不同的用途分索引，可以同时操作多个索引</p></li><li><p><strong>支持超大数据</strong>： 可以扩展到 PB 级的结构化和非结构化数据 海量数据的近实时处理</p></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>分布式的搜索引擎</strong></p><p>分布式：Elasticsearch自动将海量数据分散到多台服务器上去存储和检索</p></li><li><p><strong>全文检索</strong></p><p>提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能</p></li><li><p><strong>数据分析引擎（分组聚合）</strong></p><p>社区网站，最近一周用户登录、最近一个月各功能使用情况</p></li><li><p><strong>对海量数据进行近实时（秒级）的处理</strong></p><p>海量数据的处理：因为是分布式架构，可以采用大量的服务器去存储和检索数据</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p><strong>搜索类</strong>场景</p><p>比如说人员检索、设备检索、App内的搜索、订单搜索。</p></li><li><p><strong>日志分析</strong>类场景</p><p>经典的ELK组合（<strong>Elasticsearch</strong>/<strong>Logstash</strong>/<strong>Kibana</strong>），实现<strong>日志收集</strong>，<strong>日志存储</strong>，<strong>日志分析</strong></p></li><li><p><strong>数据预警平台</strong>及数据分析场景</p><p>例如社区团购提示，当优惠的价格低于某个值时，自动触发通知消息，通知用户购买。</p><p>分析竞争对手商品销量Top10，供运营分析等等。</p></li><li><p><strong>商业BI(Business Intelligence)</strong>系统</p><p>比如社区周边，需要分析某一地区用户消费金额及商品类别，输出相应的报表数据，并预测该地区的热卖商品，通过区域和人群特征划分进行定向推荐。Elasticsearch执行数据分析和挖掘，Kibana做数据可视化。</p></li></ul><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p><strong>Lucene</strong></p><p>Java编写的信息搜索工具包（Jar包），Lucene只是一个框架，熟练运用Lucene非常复杂。</p><p><strong>Solr</strong></p><p>基于<strong>Lucene</strong>的HTTP接口查询服务器，是一个封装了很多Lucene细节搜索引擎系统</p><p><strong>Elasticsearch</strong></p><p>基于<strong>Lucene</strong>分布式海量数据近实时搜索引擎。采用的策略是将每一个字段都编入索引，使其可以被搜索。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>1）Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能</p><p>2）Solr比Elasticsearch实现更加全面，而Elasticsearch本身更注重于核心功能， 高级功能多由第三方插件提供</p><p>3）Solr在传统的搜索应用中表现好于Elasticsearch，而Elasticsearch在实时搜索应用方面比Solr表现好</p><p>目前主流依然是<strong>Elasticsearch</strong>7.x 最新的是7.8</p><p>​    优化：<strong>默认集成JDK</strong>、升级Lucene8大幅提升<strong>TopK性能</strong>、引入熔断机制<strong>避免OOM</strong>发生</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p><p>IK分词器3.0的特性如下：</p><ol><li>采用了特有的“正向迭代<strong>最细粒度</strong>切分算法“，具有<strong>60万</strong>字/秒的高速处理能力。</li><li>采用了<strong>多子处理器</strong>分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。</li><li>支持<strong>个人词条的优化</strong>的词典存储，更小的内存占用。</li><li>针对Lucene<strong>全文检索优化</strong>的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索</li><li>排列组合，能极大的提高Lucene检索的命中率。</li></ol><ul><li><strong>扩展词典</strong>：ext_dict</li><li><strong>停用词典</strong>：stop_dict</li><li><strong>同义词典</strong>：same_dict</li></ul><h3 id="索引（类数据库）"><a href="#索引（类数据库）" class="headerlink" title="索引（类数据库）"></a>索引（类数据库）</h3><p>settings：设置索引库，定义索引库的分片数副本数等</p><h3 id="映射（类表设计）"><a href="#映射（类表设计）" class="headerlink" title="映射（类表设计）"></a>映射（类表设计）</h3><ul><li>字段的数据类型</li><li>分词器类型</li><li>是否要进行存储或者创造索引</li></ul><h3 id="文档（数据）"><a href="#文档（数据）" class="headerlink" title="文档（数据）"></a>文档（数据）</h3><ul><li>全量更新用Put</li><li>局部更新用Post</li></ul><h2 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h2><h3 id="映射高级"><a href="#映射高级" class="headerlink" title="映射高级"></a>映射高级</h3><h4 id="地理坐标点数据类型"><a href="#地理坐标点数据类型" class="headerlink" title="地理坐标点数据类型"></a><strong>地理坐标点数据类型</strong></h4><blockquote><p>地理坐标点是指地球表面可以用经纬度描述的一个点。 地理坐标点可以用来计算两个坐标间的距离，还可以判断一个坐标是否在一个区域中。地理坐标点需要显式声明对应字段类型为 geo_point</p></blockquote><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><blockquote><p>使用dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射</p></blockquote><h3 id="DSL高级"><a href="#DSL高级" class="headerlink" title="DSL高级"></a>DSL高级</h3><ul><li><strong>查询所有(match_all query)</strong></li><li><p><strong>全文搜索(full-text query)</strong></p><ul><li>匹配搜索(match query)</li><li>短语搜索(match phrase query)</li><li>默认查询(query string)</li><li>多字段匹配搜索(multi match query)</li></ul></li><li><p><strong>词条级搜索(term-level query)</strong></p><ul><li>精确搜索term</li><li>集合搜索idx</li><li>范围搜索range</li><li>前缀搜索prefix</li><li>通配符搜索wildcard</li><li>正则搜索regexp</li><li>模糊搜索fuzzy</li></ul></li><li><p>复合搜索</p></li><li>排序<strong>sort</strong>&amp;分页<strong>size</strong>&amp;高亮<strong>highLight</strong>&amp;批量<strong>bluk</strong></li></ul><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a><strong>聚合分析</strong></h3><blockquote><p>聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出某字段（或计算表达式的结果）的最大值、最小值，计算和、平均值等</p></blockquote><ul><li>对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为<strong>指标聚合</strong> <strong>metric</strong></li><li>对查询出的数据进行<strong>分桶</strong>group by，再在<strong>桶</strong>上进行指标<strong>桶聚合</strong> <strong>bucketing</strong></li></ul><h3 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a><strong>智能搜索</strong></h3><ul><li>Term Suggester</li><li>Phrase Suggester</li><li>Completion Suggester</li><li>Context Suggester</li></ul><p>如果<strong>Completion Suggester</strong>已经到了零匹配，可以猜测用户有输入错误，这时候可以尝试一下<strong>Phrase Suggester</strong>。如果还是未匹配则尝试<strong>Term Suggester</strong>。</p><p>精准程度上(<strong>Precision</strong>)看： <strong>Completion &gt; Phrase &gt; Term</strong>， 而召回率上(Recall)则反之。</p><p>从性能上看，Completion Suggester是最快的，如果能满足业务需求，只用Completion Suggester做前缀匹配是最理想的。 Phrase和Term由于是做倒排索引的搜索，相比较而言性能应该要低不少，应尽量控制Suggester用到的索引的数据量，最理想的状况是经过一定时间预热后，索引可以全量map到内存。</p><h2 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h2><h3 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h3><ul><li><p><strong>副本数量</strong>0</p><p>首次 初始化数据时，将副本设置为0，写入完毕再改回，避免了副本建立索引的过程</p></li><li><p><strong>自动生成id</strong></p><p>可以避免写前判断是否存在的过程</p></li><li><p><strong>合理使用分词器</strong></p><p>binary类型不适用，title和text使用不同的分词器加快速度</p></li><li><p><strong>禁用评分，延长索引刷新间隔</strong></p></li><li><p><strong>将多个索引操作放入到batch进行处理</strong></p></li></ul><h3 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h3><ul><li><p>使用<strong>Filter</strong>代替Query，减少打分缓解，使用<strong>bool</strong>组合query和filter查询</p></li><li><p>对数据进行<strong>分组</strong>，按照日，月，年不同维度分组，查询可集中在局部index中</p></li></ul><h3 id="零停机索引重建方案"><a href="#零停机索引重建方案" class="headerlink" title="零停机索引重建方案"></a>零停机索引重建方案</h3><ul><li><p><strong>外部数据导入</strong></p><ul><li>通过MQ的web控制台或cli命令行，发送指定的MQ消息</li><li>MQ消息被微服务模块的消费者消费，触发ES数据重新导入功能</li><li>微服务模块从数据库里查询数据的总数及分页信息，并发送至MQ</li><li>微服务从MQ中根据分页信息从数据库获取到数据后，根据索引结构的定义，将数据组装成ES支持的JSON格式，并通过bulk命令将数据发送给Elasticsearch集群进行索引的重建工作。</li></ul></li><li><p><strong>基于Scroll+bulk+索引别名的方案</strong></p><ul><li><p>新建索引book_new，将mapping信息，settings信息等按新的要求全部定义好</p></li><li><p>使用scroll api将数据批量查询出来，指定scroll查询持续时间</p></li><li><p>采用bulk api将scoll查出来的一批数据，批量写入新索引</p></li><li><p>查询一批导入一批，注意每次都使用上次结束时的scoll_id</p></li><li><p>切换别名book_alias到新的索引book_new上面，此时Java客户端仍然使用别名访问，也不需要修</p><p>改任何代码，不需要停机。验证别名查询的是否为新索引的数据</p></li></ul></li><li><p><strong>Reindex API方案</strong></p><ul><li>Elasticsearch v6.3.1已经支持Reindex API，它对scroll、bulk做了一层封装，能够 对文档重建索引而不需要任何插件或外部工具。</li></ul></li></ul><p><strong>参与度</strong> &amp; <strong>灵活性</strong>：自研 &gt; scroll+bulk &gt; reindex</p><p><strong>稳定性</strong> &amp; <strong>可靠性</strong>：自研 &lt; scroll+bulk &lt; reindex</p><h3 id="DeepPaging性能解决方案"><a href="#DeepPaging性能解决方案" class="headerlink" title="DeepPaging性能解决方案"></a>DeepPaging性能解决方案</h3><blockquote><p>比如超级管理员，要给某个省份用户发送公告或者广告，最容易想到的就是利用 from + size 来实现，但这是不现实的</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gne4vx9hu4j30x60gw0w5.jpg" alt="image-20210206212712493" style="zoom:60%;"></p><h1 id="二：Docker-amp-K8S篇"><a href="#二：Docker-amp-K8S篇" class="headerlink" title="二：Docker&amp;K8S篇"></a>二：Docker&amp;K8S篇</h1><blockquote><p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p></blockquote><p><strong>虚拟化技术_VMware 、VirtualBox、KVM</strong></p><p>虚拟化技术就是在操作系统上多加了一个虚拟化层（Hypervisor），可以将物理机的CPU、内存、硬盘、网络等资源进行虚拟化，再通过虚拟化出来的空间上安装操作系统，构建虚拟的应用程序执行环境。这就是我们通常说的虚拟机。</p><p>虚拟机的优点：</p><ul><li>提升IT效率、降低运维成本</li><li>更快地部署工作负责</li><li>提高服务器可用性</li></ul><p>虚拟机的缺点：</p><ul><li>占用资源较多、性能较差</li><li>扩展、迁移能力较差</li></ul><h3 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker"></a>Why Docker</h3><p><strong>场景</strong></p><ul><li>开发人员在本地编写代码，并使用Docker容器与其他同事共享劳动成果。</li><li>使用Docker将应用程序推送到测试环境中，并执行自动和手动测试。</li><li>开发人员可以在开发环境中对其进行修复，然后将其重新部署到测试环境中以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境就像将更新的镜像推送到生产环境一样简单。</li></ul><p><strong>需求</strong></p><blockquote><p>快速，一致地交付应用程序、镜像打包环境，避免了环境不一致的问题，简化开发的生命周期，适合于快速迭代敏捷开发的场景</p></blockquote><p><img src="https://i.loli.net/2021/02/20/7hx2RcvUPKgXpma.png" alt="image-20210220140837929" style="zoom: 50%;"></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Docker引擎-守护进程</strong></p><p>​    Docker使用C / S架构 ：用户通过<strong>Docker客户端</strong>与Docker守护进程（Docker引擎）通过Unix套接字或者RESTAPI进行通信，<strong>Docker引擎</strong>完成了构建，运行和分发Docker容器的繁重工作</p><p><strong>Docker镜像-Dockerfile</strong></p><p>​    Docker镜像类似于虚拟机镜像，是一个只读的模板，是创建Docker容器的基础</p><p>​    镜像是基于联合（Union）文件系统的一种层式的结构，由一系列指令一步一步构建出来。</p><p>​    比如：拷贝文件、执行命令</p><p><strong>Docker仓库-Hub</strong></p><p>Docker仓库可以分为<strong>公开仓库 （Public）</strong>和<strong>私有仓库（Private）</strong>两种形式。</p><p>最大的公开仓库是官方提供的<strong>Docker Hub</strong>，其中存放了数量庞大的镜像供用户下载。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>镜像</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7.30</span></span><br><span class="line"><span class="number">5.7</span>.<span class="number">30</span>: Pulling <span class="keyword">from</span> library/mysql ……</span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker tag mysql:5.7.30 mysql5</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED SIZE</span><br><span class="line">mysql5 latest <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">mysql <span class="number">5.7</span>.<span class="number">30</span> <span class="number">9</span>cfcce23593a <span class="number">6</span> weeks ago <span class="number">448</span>MB</span><br><span class="line">[root@localhost ~]<span class="comment"># docker inspect mysql:5.7.30</span></span><br><span class="line">[&#123;显示docker 详细信息&#125;]</span><br><span class="line">[root@localhost ~]<span class="comment"># docker search mysql</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker rmi mysql:5.7.30</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker push mysql[:TAG]</span></span><br></pre></td></tr></table></figure><p><strong>容器</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker create -it nginx</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker start 9cfcce23593a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看运行的容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps</span></span><br><span class="line"><span class="comment">#查看所有容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker ps -a</span></span><br><span class="line"><span class="comment">#新建并启动容器</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -it --rm --network host tomcat:8.5.56-jdk8-openjdk</span></span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li><p>创建一个卷，待后边使用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="bash"> create test_volume</span></span><br></pre></td></tr></table></figure></li><li><p>分别启动2个容器挂在上卷,</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在<span class="number">2</span>个终端窗口启动<span class="number">2</span>个容器</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -it --rm -v test_volume:/<span class="built_in">test</span> nginx:latest /bin/bash</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -it --rm -v test_volume:/<span class="built_in">test</span> nginx:latest /bin/bash</span></span><br><span class="line">cd /test;</span><br><span class="line">touch a.txt</span><br><span class="line">ls /test <span class="comment"># 在两个容器中我们均可以看到我们创建的文件，shixian在多个容器之间实现数据共享</span></span><br></pre></td></tr></table></figure></li></ol><p>挂载在容器 /test 目录内创建。 Docker <strong>不支持容器内安装点的相对路径</strong>。 多个容器可以在同一时间段内使用相同的卷。如果两个容器需要访问共享数据，例如，如果一个容器写入而另一个容器读取数据。 卷名 在驱动程序test必须唯一。这意味着不能将<strong>相同的卷名</strong>与两个不同的驱动程序一起使用。 如果我们指定了当前test_volume程序上已在使用的卷名，则Docker会假定我们要重用现有卷，并且不会返回错误。如果开始无 test_volume 则会创建这个卷当然除了使用卷，也可以使用将宿主机的文件映射到容器的卷，命令类似，只不过不用提前创建卷，而且数据会映射到宿主机上注意如果宿主机上的目录可以不存在，会在启动容器的时候创建</p><h1 id="三、Netty篇"><a href="#三、Netty篇" class="headerlink" title="三、Netty篇"></a>三、Netty篇</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijej9w7j30p00doaim.jpg" alt="image-20210504171606057" style="zoom:50%;"></p><p>​</p><p>​    <strong>Core 核心层</strong><br>​    Core 核心层是 Netty 最精华的内容，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的 ByteBuf 等。</p><p>​    <strong>Protocol Support 协议支持层</strong><br>​    协议支持层基本上覆盖了主流协议的编解码实现，如 HTTP、Protobuf、WebSocket、二进制等主流协议，此外 Netty 还支持自定义应用层协议。Netty 丰富的协议支持降低了用户的开发成本，基于 Netty 我们可以快速开发 HTTP、WebSocket 等服务。</p><p>​    <strong>Transport Service 传输服务层</strong><br>​    传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道、虚拟机管道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。</p><h4 id="2、逻辑架构"><a href="#2、逻辑架构" class="headerlink" title="2、逻辑架构"></a>2、逻辑架构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iiju6h8j30ry0o6dj0.jpg" alt="image-20210504171514089" style="zoom:50%;"></p><p>​        </p><p>​    <strong>网络通信层</strong><br>​    网络通信层的职责是执行网络 I/O 的操作。它支持多种网络协议和 I/O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。</p><p>网络通信层的核心组件包含<strong>BootStrap、ServerBootStrap、Channel</strong>三个组件。</p><p>​    Bootstrap 是“引导”的意思，负责 Netty <strong>客户端程序</strong>的启动、初始化、服务器连接等过程，串联了 Netty 的其他核心组件。</p><p>​    ServerBootStrap 用于<strong>服务端启动</strong>绑定本地端口，会绑定Boss 和 Worker两个 EventLoopGroup。</p><p>​    Channel 的是“<strong>通道</strong>”，Netty Channel提供了基于NIO更高层次的抽象，如 register、bind、connect、read、write、flush 等。</p><p>​</p><p>​    <strong>事件调度层</strong><br>​    事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件（ I/O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。</p><p>事件调度层的核心组件包括 <strong>EventLoopGroup、EventLoop</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijuqesxj30ke0ekgpj.jpg" alt="image-20210504171631793" style="zoom:50%;"></p><p>​                        </p><p>​    <strong>EventLoop</strong> 负责处理 Channel 生命周期内的所有 I/O 事件，如 accept、connect、read、write 等 I/O 事件</p><p>​        ①一个 EventLoopGroup 往往包含<strong>一个或者多个</strong> EventLoop。</p><p>​        ②EventLoop 同一时间会与一个Channel绑定，每个 EventLoop 负责<strong>处理一种类型 Channel</strong>。</p><p>​        ③Channel 在生命周期内可以对和多个 EventLoop 进行<strong>多次绑定和解绑</strong>。        </p><p>​    <strong>EventLoopGroup</strong> 是Netty 的<strong>核心处理引擎</strong>，本质是一个线程池，主要负责接收 I/O 请求，并分配线程执行处理请求。通过创建不同的 EventLoopGroup 参数配置，就可以支持 Reactor 的三种线程模型：</p><p>​        <strong>单线程模型</strong>：EventLoopGroup 只包含一个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>主从多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 是主 Reactor，Worker 是从 Reactor，它们分别使用不同的 EventLoopGroup，主 Reactor 负责新的网络连接 Channel 创建，然后把 Channel 注册到从 Reactor。</p><p>​    <strong>服务编排层</strong><br>​    服务编排层的职责是负责组装各类服务，它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p><p>服务编排层的核心组件包括 <strong>ChannelPipeline、ChannelHandler、ChannelHandlerContext</strong>。</p><p>​    <strong>ChannelPipeline</strong> 是 Netty 的核心编排组件，负责组装各种 ChannelHandler，ChannelPipeline 内部通过双向链表将不同的 ChannelHandler 链接在一起。当 I/O 读写事件触发时，Pipeline 会依次调用 Handler 列表对 Channel 的数据进行拦截和处理。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6il759apj313s068abj.jpg" alt="image-20210504171749533" style="zoom:50%;"></p><p>​</p><p>​    客户端和服务端都有各自的 ChannelPipeline。客户端和服务端一次完整的请求：客户端出站（Encoder 请求数据）、服务端入站（Decoder接收数据并执行业务逻辑）、服务端出站（Encoder响应结果）。</p><p>​    <strong>ChannelHandler</strong> 完成数据的编解码以及处理工作。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ilvuhupj30ye08e0vd.jpg" alt="image-20210504171829071" style="zoom:50%;"></p><p>​    <strong>ChannelHandlerContext</strong> 用于保存Handler 上下文，通过 HandlerContext 我们可以知道 Pipeline 和 Handler 的关联关系。HandlerContext 可以实现 Handler 之间的交互，HandlerContext 包含了 Handler 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。同时，HandlerContext 实现了Handler通用的逻辑的模型抽象。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6imu2khlj31080gu0xc.jpg" alt="image-20210504171924019" style="zoom:50%;"></p><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><h4 id="1、五种IO模型的区别"><a href="#1、五种IO模型的区别" class="headerlink" title="1、五种IO模型的区别"></a><strong>1、五种IO模型的区别</strong></h4><p><strong>阻塞I/O：（BIO）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ingki0yj30kw0d6gmr.jpg" alt="image-20210504171959821" style="zoom:50%;"></p><p>​</p><p>​        应用进程向内核发起 I/O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I/O 请求称为BIO（Blocking IO，阻塞 I/O），所以 BIO 在实现异步操作时，只能使用多线程模型，一个请求对应一个线程。但是，<strong>线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。</strong></p><p><strong>同步非阻塞I/O（NIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6inzsk9xj30lg0cign1.jpg" alt="image-20210504172029418" style="zoom:50%;"></p><p>​        </p><p>​        应用进程向内核发起 I/O 请求后不再会同步等待结果，而是会立即返回，通过轮询的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I/O 时效率并不高，而且<strong>随着并发量的提升，非阻塞 I/O 会存在严重的性能浪费。</strong></p><p><strong>多路复用I/O（select和poll）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iogl9x0j30ja0cqdh7.jpg" alt="image-20210504172057237" style="zoom:50%;"></p><p>​        </p><p>​        多路复用实现了<strong>一个线程处理多个 I/O 句柄的操作</strong>。多路指的是多个数据通道，复用指的是使用一个或多个固定线程来处理每一个 Socket。select、poll、epoll 都是 I/O 多路复用的具体实现，线程一次 select 调用可以获取内核态中多个数据通道的数据状态。其中，select只负责等，recvfrom只负责拷贝，阻塞IO中可以对多个文件描述符进行阻塞监听，是一种非常高效的 I/O 模型。</p><p><strong>信号驱动I/O（SIGIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ioxthajj30ii0cemyk.jpg" alt="image-20210504172124965" style="zoom:50%;"></p><p>​        </p><p>​        信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p><p><strong>异步I/O（Posix.1的aio_系列函数）：</strong></p><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipcc12jj30lg0coabe.jpg" alt="image-20210504172148095" style="zoom:50%;"></p><p>​        当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。</p><h4 id="2、Reactor多线程模型"><a href="#2、Reactor多线程模型" class="headerlink" title="2、Reactor多线程模型"></a>2、Reactor多线程模型</h4><p>​        Netty 的 I/O 模型是基于<strong>非阻塞 I/O</strong> 实现的，底层依赖的是 NIO 框架的<strong>多路复用器 Selector</strong>。采用 <strong>epoll 模式</strong>后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个<strong>事件分发器</strong>（Event Dispather），它负责将读写事件分发给对应的读写<strong>事件处理器</strong>（Event Handler）。事件分发器有两种设计模式：<strong>Reactor 和 Proactor</strong>，Reactor 采用同步 I/O， Proactor 采用异步 I/O。</p><p>​</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipob6wjj30we0i4jz2.jpg" alt="image-20210504172207142" style="zoom:50%;"></p><p>​        Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I/O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 <strong>select 或 epoll</strong> 来实现。</p><h4 id="3、拆包粘包问题"><a href="#3、拆包粘包问题" class="headerlink" title="3、拆包粘包问题"></a>3、拆包粘包问题</h4><p><strong>拆包</strong>TCP 传输协议是面向流的，没有数据包界限。<br><strong>MTU（Maxitum Transmission Unit）</strong> 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iq4xdjtj30q407egnk.jpg" alt="image-20210504172233844" style="zoom:50%;"></p><p>如上图所示，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是<strong>拆包现象</strong>。</p><p><strong>Nagle 算法</strong><br>Nagle 算法可以理解为批量发送，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。Netty 中为了使数据<strong>传输延迟最小化</strong>，就默认<strong>禁用了 Nagle 算法</strong>。</p><p><strong>拆包/粘包的解决方案</strong></p><p>在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。需要确定边界：</p><p><strong>消息长度固定</strong><br><strong>特定分隔符</strong><br><strong>消息长度 + 消息内容</strong>(Netty)</p><h4 id="4、自定义协议"><a href="#4、自定义协议" class="headerlink" title="4、自定义协议"></a>4、自定义协议</h4><p>Netty 常用编码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MessageToByteEncoder <span class="comment">//对象编码成字节流；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageEncoder <span class="comment">//一种消息类型编码成另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>Netty 常用解码器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteToMessageDecoder/ReplayingDecoder <span class="comment">//将字节流解码为消息对象；</span></span><br><span class="line"></span><br><span class="line">MessageToMessageDecoder <span class="comment">//将一种消息类型解码为另外一种消息类型。</span></span><br></pre></td></tr></table></figure><p>编解码器可以分为<strong>一次解码器</strong>和<strong>二次解码器</strong>，一次解码器用于解决 <strong>TCP 拆包/粘包问题</strong>，按协议解析后得到的字节数据。如果你需要对解析后的<strong>字节数据做对象模型</strong>的转换，这时候便需要用到二次解码器，同理编码器的过程是反过来的。</p><p><strong>Netty自定义协议内容：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | </span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">|                   数据内容 （长度不定）                          |</span></span><br><span class="line"><span class="comment">+---------------------------------------------------------------+</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>如何判断 ByteBuf 是否存在完整的报文？最常用的做法就是通过读取消息长度 dataLength 进行判断。如果 ByteBuf 的可读数据长度小于 dataLength，说明 ByteBuf 还不够获取一个完整的报文。</p><h4 id="5、WriteAndFlush"><a href="#5、WriteAndFlush" class="headerlink" title="5、WriteAndFlush"></a>5、WriteAndFlush</h4><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iqnas8fj31400lkaj2.jpg" alt="image-20210504172303465" style="zoom:50%;"></p><p>​    ①writeAndFlush 属于出站操作，它是从 Pipeline 的 Tail 节点开始进行事件传播，一直向前传播到 Head 节点。不管在 write 还是 flush 过程，Head 节点都中扮演着重要的角色。</p><p>​    ②write 方法并没有将数据写入 Socket 缓冲区，只是将数据写入到 ChannelOutboundBuffer 缓存中，ChannelOutboundBuffer 缓存内部是由单向链表实现的。</p><p>​    ③flush 方法才最终将数据写入到 Socket 缓冲区。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1、堆外内存"><a href="#1、堆外内存" class="headerlink" title="1、堆外内存"></a>1、堆外内存</h4><p>​    在 Java 中对象都是在堆内分配的，通常我们说的<strong>JVM 内存</strong>也就指的<strong>堆内内存</strong>，<strong>堆内内存</strong>完全被<strong>JVM 虚拟机</strong>所管理，JVM 有自己的垃圾回收算法，对于使用者来说不必关心对象的内存如何回收。<strong>堆外内存</strong>与堆内内存相对应，对于整个机器内存而言，除<strong>堆内内存以外部分即为堆外内存</strong>。堆外内存不受 JVM 虚拟机管理，直接由操作系统管理。使用堆外内存有如下几个优点：</p><ol><li>堆内内存由 JVM GC 自动回收内存，降低了 Java 用户的使用心智，堆外内存由于不受 JVM 管理，所以在一定程度上可以降低 GC 对应用运行时带来的影响。</li><li>堆外内存需要手动释放，这一点跟 C/C++ 很像，稍有不慎就会造成应用程序内存泄漏，当出现内存泄漏问题时排查起来会相对困难。</li><li>当进行网络 I/O 操作、文件读写时，堆内内存都需要转换为堆外内存，然后再与底层设备进行交互，所以直接使用堆外内存可以减少一次内存拷贝。</li><li>堆外内存可以方便实现进程之间、JVM 多实例之间的数据共享。</li></ol><p>​    在堆内存放的 DirectByteBuffer 对象并不大，仅仅包含堆外内存的地址、大小等属性，同时还会创建对应的 Cleaner 对象，通过 ByteBuffer 分配的堆外内存不需要手动回收，它可以被 JVM 自动回收。当堆内的 DirectByteBuffer 对象被 GC 回收时，Cleaner 就会用于回收对应的堆外内存。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    从 DirectByteBuffer 的构造函数中可以看出，真正分配堆外内存的逻辑还是通过 unsafe.allocateMemory(size)，Unsafe 是一个非常不安全的类，它用于执行内存访问、分配、修改等<strong>敏感操作</strong>，可以越过 JVM 限制的枷锁。Unsafe 最初并不是为开发者设计的，使用它时虽然可以获取对底层资源的控制权，但也失去了安全性的保证，使用 Unsafe 一定要慎重（Java 中是不能直接使用 Unsafe 的，但是可以通过反射获取 Unsafe 实例）。Netty 中依赖了 Unsafe 工具类，是因为 Netty 需要与底层 Socket 进行交互，Unsafe 提升 Netty 的性能</p><p>​     因为DirectByteBuffer 对象的回收需要依赖 Old GC 或者 Full GC 才能触发清理，如果长时间没有 GC执行，那么堆外内存即使不再使用，也会一直在占用内存不释放，很容易将机器的物理内存耗尽。-XX:MaxDirectMemorySize 指定堆外内存的上限大小，超出时触发GC，仍无法释放抛出OOM异常。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    当初始化堆外内存时，内存中的对象引用情况如下图所示，first 是 Cleaner 类中的静态变量，Cleaner 对象在初始化时会加入 Cleaner 链表中。DirectByteBuffer 对象包含堆外内存的地址、大小以及 Cleaner 对象的引用，ReferenceQueue 用于保存需要回收的 Cleaner 对象。</p><p>​</p><h4 id="2、数据载体ByteBuf"><a href="#2、数据载体ByteBuf" class="headerlink" title="2、数据载体ByteBuf"></a>2、<strong>数据载体ByteBuf</strong></h4><p>JDK NIO 的 <strong>ByteBuffer</strong></p><ul><li>mark：为某个读取过的关键位置做标记，方便回退到该位置；</li><li>position：当前读取的位置；</li><li>limit：buffer 中有效的数据长度大小；</li><li>capacity：初始化时的空间容量。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6irlptv0j30z408wabn.jpg" alt="image-20210504172358702" style="zoom:50%;"></p><p>​    第一，ByteBuffer 分配的长度是固定的，无法动态扩缩容，每次在存放数据的时候对容量大小做校验，扩容需要将已有的数据迁移。</p><p>​    第二，ByteBuffer 只能通过 position 获取当前可操作的位置，因为读写共用的 position 指针，所以需要频繁调用 flip、rewind 方法切换读写状态。</p><p>Netty中的ByteBuf</p><ul><li><strong>废弃字节</strong>，表示已经丢弃的无效字节数据。</li><li><strong>可读字节</strong>，表示 ByteBuf 中可以被读取的字节内容，可以通过 writeIndex - readerIndex 计算得出。当读写位置重叠时时，表示 ByteBuf 已经不可读。</li><li><strong>可写字节</strong>，向 ByteBuf 中写入数据都会存储到可写字节区域。当 writeIndex 超过 capacity，表示 ByteBuf 容量不足，需要扩容。</li><li><strong>可扩容字节</strong>，表示 ByteBuf 最多还可以扩容多少字节，最多扩容到 maxCapacity 为止，超过 maxCapacity 再写入就会出错。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j1t85zuj31020ds42m.jpg" alt="image-20210504173347000" style="zoom:50%;"></p><p><strong>引用计数</strong></p><p>​    当byteBuf当引用计数为 0，该 ByteBuf 可以被放入到对象池中，避免每次使用 ByteBuf 都重复创建。</p><p>​    JVM 并不知道 Netty 的引用计数是如何实现的，当 ByteBuf 对象不可达时，一样会被 GC 回收掉，但是如果此时 ByteBuf 的引用计数不为 0，那么该对象就不会释放或者被放入对象池，从而发生了内存泄漏。Netty 会对分配的 ByteBuf 进行抽样分析，检测 ByteBuf 是否已经不可达且引用计数大于 0，判定内存泄漏的位置并输出到日志中，<strong>通过关注日志中 LEAK 关键字可以找到内存泄漏的具体对象</strong>。</p><h4 id="3、内存分配jemalloc"><a href="#3、内存分配jemalloc" class="headerlink" title="3、内存分配jemalloc"></a>3、<strong>内存分配jemalloc</strong></h4><p>​    为了减少分配时产生的内部碎片和外部碎片，常见的内存分配算法<strong>动态内存分配</strong>、<strong>伙伴算法</strong>和<strong>Slab 算法</strong></p><p><strong>动态内存分配（DMA）</strong></p><p>​    <strong>⾸次适应算法（first fit）</strong>，空闲分区链以地址递增的顺序将空闲分区以双向链表的形式连接在一起，从空闲分区链中找到第一个满足分配条件的空闲分区，然后从空闲分区中划分出一块可用内存给请求进程，剩余的空闲分区仍然保留在空闲分区链中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j26fh88j30ni0ea41c.jpg" alt="image-20210504173407923" style="zoom:50%;"></p><p>​    <strong>循环首次适应算法（next fit）</strong>不再是每次从链表的开始进行查找，而是从上次找到的空闲分区的以后开始查找。查找效率提升，会产生更多的碎片。</p><p>​    <strong>最佳适应算法（best fit）</strong>，空闲分区链以空闲分区大小递增的顺序将空闲分区以双向链表的形式连接在一起，每次从空闲分区链的开头进行查找。</p><p><strong>伙伴算法</strong>（外部碎片少，内部碎片多）</p><p>​    是一种非常经典的内存分配算法，它采用了<strong>分离适配的设计思想</strong>，将物理内存按照 2 的次幂进行划分，内存分配时也是按照 2 的次幂大小进行按需分配</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j2m0rr1j30ly0iugnk.jpg" alt="image-20210504173433749" style="zoom:50%;"></p><ol><li>首先需要找到存储 2^4 连续 Page 所对应的链表，即数组下标为 4；</li><li>查找 2^4 链表中是否有空闲的内存块，如果有则分配成功；</li><li>如果 2^4 链表不存在空闲的内存块，则继续沿数组向上查找，即定位到数组下标为 5 的链表，链表中每个节点存储 2^5 的连续 Page；</li><li>如果 2^5 链表中存在空闲的内存块，则取出该内存块并将它分割为 2 个 2^4 大小的内存块，其中一块分配给进程使用，剩余的一块链接到 2^4 链表中。</li></ol><p><strong>Slab 算法（解决伙伴算法内部碎片问题）</strong></p><p>​    Slab 算法在伙伴算法的基础上，对小内存的场景专门做了优化，采用了内存池的方案，解决内部碎片问题。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p>在 Slab 算法中维护着大小不同的 Slab 集合，将这块内存划分为大小相同的 slot，不会对内存块再进行合并，同时使用位图 bitmap 记录每个 slot 的使用情况。</p><p>​    kmem_cache 中包含三个 Slab 链表：<strong>完全分配使用 slab_full</strong>、<strong>部分分配使用 slab_partial</strong>和<strong>完全空闲 slabs_empty</strong>，这三个链表负责内存的分配和释放。Slab 算法是基于对象进行内存管理的，它把相同类型的对象分为一类。当分配内存时，从 Slab 链表中划分相应的内存单元；单个 Slab 可以在不同的链表之间移动，例如当一个 Slab 被分配完，就会从 slab_partial 移动到 slabs_full，当一个 Slab 中有对象被释放后，就会从 slab_full 再次回到 slab_partial，所有对象都被释放完的话，就会从 slab_partial 移动到 slab_empty。当<strong>释放内存时，Slab 算法并不会丢弃已经分配的对象，而是将它保存在缓存中，当下次再为对象分配内存时，直接会使用最近释放的内存块</strong>。</p><h4 id="4、jemalloc-架构"><a href="#4、jemalloc-架构" class="headerlink" title="4、jemalloc 架构"></a>4、jemalloc 架构</h4><ul><li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li><li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li><li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li><li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li><li>每个 tcache 对应一个 arena，tcache 中包含多种类型的 bin。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p><strong>内存管理Arena</strong> ，内存由一定数量的 arenas 负责管理。每个用户线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配。</p><p><strong>分级管理Bin</strong>，每个 bin 管理的内存大小是按分类依次递增。<strong>jemalloc 中小内存的分配是基于 Slab 算法</strong>完成的，会产生不同类别的内存块。</p><p><strong>Page集合chunk</strong>，chunk 以 Page 为单位管理内存。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</p><p><strong>实际分配单位run</strong>，run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</p><p><strong>run 细分region</strong>，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</p><p><strong>tcache 是每个线程私有的缓存</strong>，tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，避免锁竞争，分配失败才会通过 run 执行内存分配。</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u1jn9b3j31e80hqjt5.jpg" alt="image-20211205121406792" title class>                <p>image-20211205121406792</p>            </figure><p>Small 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p><p>Large 场景的内存分配与 Smalll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p><p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p><h4 id="5、内存池设计（待补充）"><a href="#5、内存池设计（待补充）" class="headerlink" title="5、内存池设计（待补充）"></a>5、内存池设计（待补充）</h4><h4 id="6、Recycle对象池（待补充）"><a href="#6、Recycle对象池（待补充）" class="headerlink" title="6、Recycle对象池（待补充）"></a>6、Recycle对象池（待补充）</h4><h4 id="7、零拷贝技术"><a href="#7、零拷贝技术" class="headerlink" title="7、零拷贝技术"></a>7、零拷贝技术</h4><ol><li>当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA 引擎从文件中读取数据，并存储到内核态缓冲区，这里是<strong>第一次数据拷贝</strong>。</li><li>请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。<strong>第二次数据拷贝</strong>的过程同时，会导致上下文从内核态再次切换到用户态。</li><li>用户进程调用 send() 方法期望将数据发送到网络中，用户态会再次切换到内核态，<strong>第三次数据拷贝</strong>请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区。</li><li>最终 send() 系统调用结束返回给用户进程，发生了第四次上下文切换。<strong>第四次拷贝会异步执行</strong>，从 Socket 缓冲区拷贝到协议引擎中。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jlghxe0j30t00fsjtw.jpg" alt="image-20210504175240348" style="zoom:50%;"></p><p>​    <strong>在 Linux 中</strong>系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术。</p><p>​    <strong>在 Java 中</strong>也使用了零拷贝技术，它就是 NIO FileChannel 类中的 transferTo() 方法，它可以将数据从 FileChannel 直接传输到另外一个 Channel。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jm8q3yej311c0h6q7v.jpg" alt="image-20210504175323875" style="zoom:50%;"></p><p><strong>Netty 中的零拷贝</strong>技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li>堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝。</li></ul><h3 id="高性能数据结构"><a href="#高性能数据结构" class="headerlink" title="高性能数据结构"></a>高性能数据结构</h3><h4 id="1、FastThreadLocal"><a href="#1、FastThreadLocal" class="headerlink" title="1、FastThreadLocal"></a>1、FastThreadLocal</h4><p>​    ThreadLocal 可以理解为线程本地变量。ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。</p><p>​    既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本，那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map，记录线程与实例之间的映射关系。当新增线程和销毁线程时都需要更新 Map 中的映射关系，因为会存在多线程并发修改，所以需要保证 Map 是线程安全的。但是在高并发的场景并发修改 Map 需要加锁，势必会降低性能。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmqtl1hj30q60dmtck.jpg" alt="image-20210504175349901" style="zoom:50%;"></p><p>​    JDK 为了避免加锁，采用了相反的设计思路。以 Thread 入手，在 Thread 中维护一个 Map，记录 ThreadLocal 与实例之间的映射关系，这样在同一个线程内，Map 就不需要加锁了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmyxnylj30ns06adgu.jpg" alt="image-20210504175406824" style="zoom:50%;"></p><p>​    ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据，通过魔数0x61c88647来使散列更加平衡。ThreadLocalMap 初始化一个长度为 16 的 Entry 数组。与 HashMap 不同的是，Entry 的 key 就是 ThreadLocal对象本身，value 就是用户具体需要存储的值。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jncecy1j30yy0eejtq.jpg" alt="image-20210504175428964" style="zoom:50%;"></p><p>​    Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。那么为什么 Entry 的 key 要设计成弱引用呢？如果 key 都是强引用，当线 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4umi0759j30hi0a03zd.jpg" alt="img" style="zoom: 67%;"></p><p>​    虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal不再使用(<strong>业务逻辑走完，但是由于线程复用导致线程并没有结束</strong>)被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？ThreadLocal 已经帮助我们做了一定的保护措施，在执行 ThreadLocal.set()/get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，应在 finally 代码块中进行清理，保持良好的编码意识。在Netty中，可以方便的使用FashThreadLocal来防止内存泄漏</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4ux5gohpj30hs0ajjs1.jpg" alt="img" style="zoom:67%;"></p><p><strong>FastThreadLocal</strong></p><p>​    FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal&lt;?&gt;&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。主要是针对set方法，增加了两个额外的行为。</p><ol><li>找到数组下标 index 位置，设置新的 value。</li><li>将 <strong>FastThreadLocal 对象保存到待清理的 Set 中</strong>。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jnu8l6aj315k060wfi.jpg" alt="image-20210504175457264" style="zoom:50%;"></p><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，<strong>任务执行完毕后一定会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉</strong></li></ul><h4 id="2、HashedTimerWheel"><a href="#2、HashedTimerWheel" class="headerlink" title="2、HashedTimerWheel"></a>2、<strong>HashedTimerWheel</strong></h4><p>​    生成月统计报表、每日得分结算、邮件定时推送</p><p>​    定时任务三种形式：</p><p>​        1、按固定周期定时执行</p><p>​        2、延迟一定时间后执行</p><p>​        3、指定某个时刻执行</p><p>​    定时任务的三个关键方法：</p><p>​        Schedule 新增任务至任务集合；</p><p>​        Cancel 取消某个任务；</p><p>​        Run 执行到期的任务</p><p>JDK自带的三种定时器：<strong>Timer</strong>、<strong>DelayedQueue</strong> 和 <strong>ScheduledThreadPoolExecutor</strong></p><pre><code>Timer小根堆队列，deadline 任务位于堆顶端，弹出的始终是最优先被执行的任务。Run 操作时间复杂度 O(1)，Schedule 和Cancel 操作的时间复杂度都是 O(logn)。</code></pre><p>不论有多少任务被加入数组，始终由 异步线程TimerThread 负责处理。TimerThread 会定时轮询 TaskQueue 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 TaskQueue 中删除。</p><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DelayedQueue 采用优先级队列 PriorityQueue延迟获取对象的阻塞队列。DelayQueue中的每个对象都必须实现Delayed 接口，并重写 compareTo 和 getDelay 方法。</span><br></pre></td></tr></table></figure><p>DelayQueue 提供了 put() 和 take() 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 DelayQueue 后，会根据 compareTo() 方法进行优先级排序。getDelay() 方法用于计算消息延迟的剩余时间，只有 getDelay &lt;=0 时，该对象才能从 DelayQueue 中取出。</p><p>DelayQueue 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 DelayQueue，通过一个异步线程 take() 取出对象然后继续进行重试。如果还是请求失败，继续放回 DelayQueue。可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。DelayQueue的时间复杂度和Timer基本一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了解决 Timer 的设计缺陷，JDK 提供了功能更加丰富的 ScheduledThreadPoolExecutor，多线程、相对时间、对异常</span><br></pre></td></tr></table></figure><p>​    Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</p><p>​    Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</p><p>​    TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</p><p><strong>时间轮原理分析</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jo7abpbj30wi0ciacs.jpg" alt="image-20210504175518335" style="zoom:50%;"></p><p>根据任务的到期时间进行取余和取模，然后根据取余结果将任务分布到不同的 slot 中，每个slot中根据round值决定是否操作，每次轮询到指定slot时，总时遍历最少round的对象进行执行，这样新增、执行两个操作的时间复杂度都近似O(1)。如果冲突较大可以增加数组长度，或者采用多级时间轮的方式处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory, //线程池，但是只创建了一个线程</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> tickDuration, //时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit, //表示 tickDuration 的时间单位，tickDuration * unit</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> ticksPerWheel,  //时间轮上一共有多少个 slot，默认 <span class="number">512</span> 个。</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;<span class="comment">//最大允许等待任务数</span></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    wheel = createWheel(ticksPerWheel); <span class="comment">// 创建时间轮的环形数组结构</span></span><br><span class="line">    mask = wheel.length - <span class="number">1</span>; <span class="comment">// 用于快速取模的掩码</span></span><br><span class="line">    <span class="keyword">long</span> duration = unit.toNanos(tickDuration); <span class="comment">// 转换成纳秒处理</span></span><br><span class="line">    workerThread = threadFactory.newThread(worker); <span class="comment">// 创建工作线程</span></span><br><span class="line">    leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>; <span class="comment">// 是否开启内存泄漏检测</span></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts; <span class="comment">// 最大允许等待任务数，HashedWheelTimer 中任务超出该阈值时会抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jofq9r4j315i0fmq96.jpg" alt="image-20210504175531294" style="zoom:50%;"></p><p>​    <strong>时间轮空推进问题</strong></p><p>​    Netty 中的时间轮是通过固定的时间间隔 tickDuration 进行推动的，如果长时间没有到期任务，那么会存在时间轮空推进的现象，从而造成一定的性能损耗。此外，如果任务的到期时间跨度很大，例如 A 任务 1s 后执行，B 任务 6 小时之后执行，也会造成空推进的问题。</p><p><strong>Kafka解决方案</strong></p><p>​    <strong>为了解决空推进的问题</strong>，Kafka 借助 JDK 的 DelayQueue 来负责推进时间轮。DelayQueue 保存了时间轮中的每个 Bucket，并且根据 Bucket 的到期时间进行排序，最近的到期时间被放在 DelayQueue 的队头。Kafka 中会有一个线程来读取 DelayQueue 中的任务列表，<strong>如果时间没有到，那么 DelayQueue 会一直处于阻塞状态</strong>，从而解决空推进的问题。虽然DelayQueue 插入和删除的性能不是很好，但这其实就是一种权衡的策略，但是DelayQueue 只存放了 Bucket，Bucket 的数量并不多，相比空推进带来的影响是利大于弊的。</p><p>​    <strong>为了解决任务时间跨度很大的问题</strong>，Kafka 引入了层级时间轮，如下图所示。当任务的 deadline 超出当前所在层的时间轮表示范围时，就会尝试将任务添加到上一层时间轮中，跟钟表的时针、分针、秒针的转动规则是同一个道理。</p><h4 id="3、MpscQueue"><a href="#3、MpscQueue" class="headerlink" title="3、MpscQueue"></a>3、MpscQueue</h4><h4 id="4、select、poll、epoll的区别"><a href="#4、select、poll、epoll的区别" class="headerlink" title="4、select、poll、epoll的区别"></a>4、select、poll、epoll的区别</h4><p><strong>select</strong> （windows）<strong>poll </strong>(linux)本质上和select没有区别，查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</p><p><strong>epoll </strong>支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>Epoll空轮询漏洞</strong></p><p>在 JDK 中， Epoll 的实现是存在漏洞的，即使 Selector 轮询的事件列表为空，NIO 线程一样可以被唤醒，导致 CPU 100% 占用。实际上 Netty 并没有从根源上解决该问题，而是巧妙地规避了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/*事件轮询的持续时间大于等于 timeoutMillis*/</span>) &#123;</span><br><span class="line">    selectCnt = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/*不正常的次数 selectCnt 达到阈值 512*/</span>) &#123;</span><br><span class="line">    <span class="comment">//重建Select并且SelectionKey重新注册到新Selector上</span></span><br><span class="line">  selector = selectRebuildSelector(selectCnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop 线程的可靠性至关重要，一旦 NioEventLoop 发生阻塞或者陷入空轮询，就会导致整个系统不可用。</p><h1 id="四、LEETCODE"><a href="#四、LEETCODE" class="headerlink" title="四、LEETCODE"></a>四、LEETCODE</h1><h3 id="【Python语法】"><a href="#【Python语法】" class="headerlink" title="【Python语法】"></a>【Python语法】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x * y,ns) <span class="comment"># 数组之乘积 (ns[0] * ns[1]) * ns[2]</span></span><br><span class="line">    reduce(<span class="keyword">lambda</span> x,y:x + y,ns) <span class="comment"># 数组之和</span></span><br><span class="line"><span class="comment"># 记忆化搜索</span></span><br><span class="line"><span class="meta">@functools.lru_cache(None)</span></span><br><span class="line">res = helper(<span class="number">0</span>,N,<span class="number">0</span>)</span><br><span class="line">helper.cache_clear()</span><br><span class="line">tuple(ns) 可以hash做参数</span><br><span class="line"><span class="comment"># 大根堆</span></span><br><span class="line">q = list(map(<span class="keyword">lambda</span> x:-x,ns))</span><br><span class="line">heapq.heapify(q)</span><br><span class="line">key = -heapq.heappop(q)</span><br><span class="line"><span class="comment"># 过滤函数</span></span><br><span class="line">filter(function, iterable)</span><br><span class="line">    filter(<span class="keyword">lambda</span> x: <span class="number">2</span> &lt; x &lt; <span class="number">10</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>, range(<span class="number">18</span>))</span><br><span class="line">    filter(dfs, range(len(graph)))</span><br><span class="line"><span class="comment"># 除数</span></span><br><span class="line">div, mod = divmod(sum(ns), <span class="number">4</span>)</span><br><span class="line">random.randint(i,len(self.ns)<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#第一个降序，第二个升序</span></span><br><span class="line">sorted(pss,key = <span class="keyword">lambda</span> x:[x[<span class="number">0</span>],-x[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不可变str 常见函数</span></span><br><span class="line">split(sep=<span class="literal">None</span>, maxsplit=<span class="number">-1</span>)  <span class="comment"># 以sep来分割字符串</span></span><br><span class="line">strip([chars])  <span class="comment"># 去除首末两端的字符, 默认是 \r,\n," "</span></span><br><span class="line">join(iterable)  <span class="comment"># 将iterable内的元素拼接成字符串,如','.join(['leet', 'code'])="leet,code"</span></span><br><span class="line">replace(old, new[, count])  <span class="comment"># 字符串替换, old to new</span></span><br><span class="line">count(sub[, start[, end]])  <span class="comment"># 统计子字符串sub的个数</span></span><br><span class="line">startswith(prefix[, start[, end]])  <span class="comment"># 以prefix开始的字符串</span></span><br><span class="line">endswith(suffix[, start[, end]])  <span class="comment"># 以suffix结束的字符串</span></span><br><span class="line">cs <span class="keyword">in</span> chrs: <span class="comment"># chrs 中包含 cs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deque 常见函数</span></span><br><span class="line">queue = deque([iterable[, maxlen]])</span><br><span class="line">queue.append(val)  <span class="comment"># 往右边添加一个元素</span></span><br><span class="line">queue.appendleft(val)  <span class="comment"># 往左边添加一个元素</span></span><br><span class="line">queue.clear()  <span class="comment"># 清空队列</span></span><br><span class="line">queue.count(val)  <span class="comment"># 返回指定元素的出现次数</span></span><br><span class="line">queue.insert(val[, start[, stop]])  <span class="comment"># 在指定位置插入元素</span></span><br><span class="line">queue.pop()  <span class="comment"># 获取最右边一个元素，并在队列中删除</span></span><br><span class="line">queue.popleft()  <span class="comment"># 获取最左边一个元素，并在队列中删除</span></span><br><span class="line">queue.reverse()  <span class="comment"># 队列反转</span></span><br><span class="line">queue.remove(val)  <span class="comment"># 删除指定元素</span></span><br><span class="line">queue.rotate(n=<span class="number">1</span>)  <span class="comment"># 把右边元素放到左边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list 常见函数</span></span><br><span class="line">lst.sort(*, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">lst.append(val)  <span class="comment"># 也可以 lst = lst + [val]</span></span><br><span class="line">lst.clear()  <span class="comment"># 清空列表</span></span><br><span class="line">lst.count(val)  <span class="comment"># val个数</span></span><br><span class="line">lst.pop(val=lst[<span class="number">-1</span>])  <span class="comment"># (默认)从末端移除一个值</span></span><br><span class="line">lst.remove(val)  <span class="comment"># 移除 val</span></span><br><span class="line">lst.reverse()  <span class="comment"># 反转</span></span><br><span class="line">lst.insert(i, val)  <span class="comment"># 在 i 处插入 val</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典dict 常见函数</span></span><br><span class="line">d = defaultdict(<span class="keyword">lambda</span> : value) <span class="comment"># 取到不存在的值时不会报错，用&#123;&#125;时、需要设置get的default值</span></span><br><span class="line">pop(key[, default])  <span class="comment"># 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))</span></span><br><span class="line">setdefault(key[, default])  <span class="comment"># 设置默认值</span></span><br><span class="line">update([other])  <span class="comment"># 批量添加</span></span><br><span class="line">get(key[, default])  <span class="comment"># 通过键获取值(若没有该键可设置默认值, 预防报错)</span></span><br><span class="line">clear()  <span class="comment"># 清空字典</span></span><br><span class="line">keys()  <span class="comment"># 将字典的键组成新的可迭代对象</span></span><br><span class="line">values()  <span class="comment"># 将字典中的值组成新的可迭代对象</span></span><br><span class="line">items()  <span class="comment"># 将字典的键值对凑成一个个元组, 组成新的可迭代对象</span></span><br><span class="line">dict1 = dict2 <span class="comment">#两个字典完全相等，滑窗时可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合set 常见函数</span></span><br><span class="line">s = set(<span class="keyword">lambda</span> : value)</span><br><span class="line">add(elem)  <span class="comment"># 向集合中添加数据</span></span><br><span class="line">update(*others)  <span class="comment"># 迭代着增加</span></span><br><span class="line">clear()  <span class="comment"># 清空集合</span></span><br><span class="line">discard(elem)  <span class="comment"># 删除集合中指定的值(不存在则不删除)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆heapq 常见函数</span></span><br><span class="line">heap = []  <span class="comment"># 建堆</span></span><br><span class="line">heapq.heappush(heap,item)  <span class="comment"># 往堆中插入新值</span></span><br><span class="line">heapq.heappop(heap)  <span class="comment"># 弹出最小的值</span></span><br><span class="line">heap[<span class="number">0</span>]  <span class="comment"># 查看堆中最小的值, 不弹出</span></span><br><span class="line">heapq.heapify(x)  <span class="comment"># 以线性时间将一个列表转为堆</span></span><br><span class="line">heapq.heappoppush(heap, item)  <span class="comment"># 弹出最小的值.并且将新的值插入其中.</span></span><br><span class="line">heapq.merge(*iterables, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  <span class="comment"># 将多个堆进行合并</span></span><br><span class="line">heapq.nlargest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</span></span><br><span class="line">heapq.nsmallest(n, iterable, key=<span class="literal">None</span>)  <span class="comment"># 从堆中找出最小的 n 个数, 与 nlargest 相反</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二分查找函数</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=len(ns))  <span class="comment">#二分左边界</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=len(ns)) <span class="comment">#二分右边界</span></span><br><span class="line">bisect.insort_left(a, x, lo=<span class="number">0</span>, hi=len(a))  <span class="comment"># 二分插入到左侧</span></span><br><span class="line">bisect.insort_right(a, x, lo=<span class="number">0</span>, hi=len(a)) <span class="comment"># 二分插入到右侧</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bit操作</span></span><br><span class="line">&amp; 符号，x &amp; y ，会将两个十进制数在二进制下进行与运算</span><br><span class="line">| 符号，x | y ，会将两个十进制数在二进制下进行或运算</span><br><span class="line">^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算</span><br><span class="line">&lt;&lt; 符号，x &lt;&lt; y 左移操作，最右边用 <span class="number">0</span> 填充</span><br><span class="line">&gt;&gt; 符号，x &gt;&gt; y 右移操作，最左边用 <span class="number">0</span> 填充</span><br><span class="line">~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数集合set位运算</span></span><br><span class="line"><span class="comment"># 整数集合做标志时，可以做参数加速运算</span></span><br><span class="line">vstd 访问 i ：vstd | (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 离开 i ：vstd &amp; ~(<span class="number">1</span> &lt;&lt; i)</span><br><span class="line">vstd 不包含 i : <span class="keyword">not</span> vstd &amp; (<span class="number">1</span> &lt;&lt; i)</span><br><span class="line"></span><br><span class="line">并集 ：A | B</span><br><span class="line">交集 ：A &amp; B</span><br><span class="line">全集 ：(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span></span><br><span class="line">补集 ：((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) ^ A</span><br><span class="line">子集 ：(A &amp; B) == B</span><br><span class="line">判断是否是 <span class="number">2</span> 的幂 ：A &amp; (A - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">最低位的 <span class="number">1</span> 变为 <span class="number">0</span> ：n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">最低位的 <span class="number">1</span>：A &amp; (-A)，最低位的 <span class="number">1</span> 一般记为 lowbit(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ^     ：匹配字符串开头</span></span><br><span class="line"><span class="comment"># [\+\-]：代表一个+字符或-字符</span></span><br><span class="line"><span class="comment"># ?     ：前面一个字符可有可无</span></span><br><span class="line"><span class="comment"># \d    ：一个数字</span></span><br><span class="line"><span class="comment"># +     ：前面一个字符的一个或多个</span></span><br><span class="line"><span class="comment"># \D    ：一个非数字字符</span></span><br><span class="line"><span class="comment"># *     ：前面一个字符的0个或多个</span></span><br><span class="line">matches = re.match(<span class="string">'[ ]*([+-]?\d+)'</span>, s)</span><br></pre></td></tr></table></figure><h3 id="【背包模板】"><a href="#【背包模板】" class="headerlink" title="【背包模板】"></a>【背包模板】</h3><p><strong>「力扣」上的 0-1 背包问题：</strong></p><ul><li><p>组合问题模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0-1背包，不可重复</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(T, n<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        dp[i] = max(dp[i], dp[i - n] + ws[i])</span><br><span class="line"><span class="comment">#完全背包，可重复，无序，算重量</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, T+<span class="number">1</span>):</span><br><span class="line">        dp[i] = max(dp[i], dp[i - n] + ws[i])</span><br><span class="line"><span class="comment">#完全背包，可重复，有序，算次数     </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, T+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> ns:</span><br><span class="line">dp[i] += dp[i-n]</span><br></pre></td></tr></table></figure><p><strong>✅377</strong> 组合总和 Ⅳ<br>✅<strong>494</strong> 目标和<br>✅<strong>518</strong> 零钱兑换 II</p></li><li><p>True、False问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] |= dp[i-num]</span><br></pre></td></tr></table></figure><p><strong>✅139</strong> 单词拆分<br><strong>✅416</strong> 分割等和子集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#特殊的可以使用bit数组</span></span><br></pre></td></tr></table></figure></li><li><p>最大最小问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i], dp[i-num]+<span class="number">1</span>)</span><br><span class="line">dp[i] = max(dp[i], dp[i-num]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>✅<strong>474</strong> 一和零<br>✅<strong>322</strong> 零钱兑换</p></li></ul><p>「力扣」第 <strong>879</strong> 题：盈利计划（困难）；<br>「力扣」第 <strong>1449</strong> 题：数位成本和为目标值的最大数字（困难）。</p><h3 id="【回溯模板】"><a href="#【回溯模板】" class="headerlink" title="【回溯模板】"></a>【回溯模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯算法，复杂度较高2^n或者N！，因为回溯算法就是暴力穷举，可用lru剪枝</span></span><br><span class="line"><span class="meta">@functools.lru_cache(None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        结果.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:    <span class="comment"># 核心代码段</span></span><br><span class="line">      <span class="keyword">if</span> vst[i]:   <span class="comment"># 辅助数组，减枝</span></span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        做出选择</span><br><span class="line">        递归执行backtrack</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>「<strong>剪枝</strong>」第 <strong>46</strong> 题 全排列 第 <strong>47</strong> 题 全排列②</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 剪枝</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(temp_list, length)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> length == n:</span><br><span class="line">      res.append(temp_list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">          visited[i] = <span class="number">1</span></span><br><span class="line">          backtrack(temp_list + [nums[i]], length + <span class="number">1</span>)</span><br><span class="line">          visited[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>「<strong>索引遍历</strong>」第 <strong>78</strong> 题 子集 | 第 <strong>47</strong> 题 子集② | 第 <strong>131</strong> 题 分割字符串</p><pre><code>第 **39 **题 组合 | 第 **40** 题 组合②  | 第 **216** 题 组合③</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 索引遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(idx, n, temp_list)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> temp_list <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">    res.append(temp_list)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(idx, n):</span><br><span class="line">    helper1(i + <span class="number">1</span>, n, temp_list + [nums[i]])</span><br></pre></td></tr></table></figure><p>「 <strong>资源消耗</strong>」第 <strong>22</strong> 题 夸号生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(S, L, R)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">and</span> <span class="keyword">not</span> R:</span><br><span class="line">    ans.append(<span class="string">''</span>.join(S))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> L :     backtrack(S + [<span class="string">'('</span>], L<span class="number">-1</span>, R)</span><br><span class="line">  <span class="keyword">if</span> R &gt; L : backtrack(S + [<span class="string">')'</span>], L, R<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>93</strong> 题 复原IP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">资源消耗</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(i, tmp, flag)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> i == n <span class="keyword">and</span> flag == <span class="number">0</span>:</span><br><span class="line">    res.append(tmp[:<span class="number">-1</span>])</span><br><span class="line">  <span class="keyword">elif</span> i&lt;n <span class="keyword">and</span> s[i] == <span class="string">'0'</span>:</span><br><span class="line">    backtrack(i + <span class="number">1</span>, tmp + s[i] + <span class="string">"."</span>, flag - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">elif</span> flag :</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, min(n,i + <span class="number">3</span>)):</span><br><span class="line">      <span class="keyword">if</span> <span class="number">0</span> &lt; int(s[i:j + <span class="number">1</span>]) &lt;= <span class="number">255</span>:</span><br><span class="line">        backtrack(j + <span class="number">1</span>, tmp + s[i:j + <span class="number">1</span>] + <span class="string">"."</span>, flag - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>资源消耗</strong>」第 <strong>17</strong> 题 电话号码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源消耗</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, remains)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> remains:</span><br><span class="line">    res.append(path[:])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remains)):</span><br><span class="line">    dfs(path + [remains[i]], remains[:i] + remains[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 套模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(pth,idx)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> idx == len(ds):</span><br><span class="line">        res.append(pth)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> dic[ds[idx]]:</span><br><span class="line">        dfs(pth + c, idx + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>「<strong>多重限制</strong>」第 <strong>37</strong> 题 解数独  | 第 <strong>51</strong> 题 N皇后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多重限制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(pos)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> pos == n:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  i, j = empty[pos]</span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> row[i] &amp; col[j] &amp; block[bidx(i, j)]:</span><br><span class="line">    row[i].remove(num)</span><br><span class="line">    col[j].remove(num)</span><br><span class="line">    block[bidx(i, j)].remove(num)</span><br><span class="line">    board[i][j] = str(num)</span><br><span class="line">    <span class="keyword">if</span> backtrack(pos + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    row[i].add(num)</span><br><span class="line">    col[j].add(num)</span><br><span class="line">    block[bidx(i, j)].add(num)</span><br></pre></td></tr></table></figure><p>「<strong>递归</strong>」第 <strong>10</strong> 题 正则匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">  f = bool(s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;)</span><br><span class="line">  <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">"*"</span>:</span><br><span class="line">    <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> f <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> f <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="【并查集模板】"><a href="#【并查集模板】" class="headerlink" title="【并查集模板】"></a>【并查集模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虚拟节点用以连接某一特征的全部节点，类似于链表的preHead</span></span><br><span class="line">dummy</span><br><span class="line">parent = &#123;&#125;</span><br><span class="line">size = collections.defaultdict(<span class="keyword">lambda</span>:<span class="number">1</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(x)</span>:</span></span><br><span class="line">    parent.setdefault(x,x)</span><br><span class="line">    <span class="keyword">while</span> x != parent[x]:</span><br><span class="line">        x = parent[x]</span><br><span class="line">        <span class="comment">#路径压缩 parent[x] = parent[parent[x]];</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">nonlocal</span> cnt</span><br><span class="line">    <span class="keyword">if</span> connected(x,y): <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 小的树挂到大的树上， 使树尽量平衡</span></span><br><span class="line">    xP = find(x)</span><br><span class="line">    yP = find(y)</span><br><span class="line">    <span class="keyword">if</span> size[hP] &lt; size[yP]:</span><br><span class="line">        parent[xP] = yP</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parent[yP] = xP</span><br><span class="line">    size[xP] += size[yP]</span><br><span class="line">    <span class="comment"># 优化结束</span></span><br><span class="line">    parent[find(x)] = find(y)</span><br><span class="line">    <span class="comment"># 不优化</span></span><br><span class="line">    cnt -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> size[xP]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self,x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> parent:</span><br><span class="line">        parent[x] = <span class="literal">None</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line"><span class="comment"># 检查是否有环</span></span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> edges:</span><br><span class="line">    <span class="keyword">if</span> connected(a, b):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    union(a, b)</span><br><span class="line"><span class="comment"># 将每个集合组成以头为key的字典</span></span><br><span class="line">res = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> e2n:</span><br><span class="line">    res[uf.find(e)].append(e)</span><br></pre></td></tr></table></figure><h3 id="【拓扑排序模板】"><a href="#【拓扑排序模板】" class="headerlink" title="【拓扑排序模板】"></a>【拓扑排序模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 【拓扑排序模板】</span></span><br><span class="line">ins = [<span class="number">0</span>] * n</span><br><span class="line">ous = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> cur, pre <span class="keyword">in</span> ps:</span><br><span class="line">    ins[cur] += <span class="number">1</span>  <span class="comment">#入度</span></span><br><span class="line">    ous[pre].append(cur)<span class="comment">#出度</span></span><br><span class="line">res = list(filter(<span class="keyword">lambda</span> x:ins[x]==<span class="number">0</span>, range(n)))</span><br><span class="line">q = collections.deque(res)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    pre = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> cur <span class="keyword">in</span> ous[pre]:   <span class="comment">#释放出度队列</span></span><br><span class="line">        ins[cur] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ins[cur]:</span><br><span class="line">            q.append(cur)  <span class="comment">#入度为0解锁</span></span><br><span class="line">            res.append(cur)</span><br></pre></td></tr></table></figure><h3 id="【单调栈模板】"><a href="#【单调栈模板】" class="headerlink" title="【单调栈模板】"></a><strong>【单调栈模板】</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s中一般存索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> ns[stack[<span class="number">-1</span>]] &lt;= ns[i]: <span class="comment"># 单调递减栈</span></span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 业务逻辑</span></span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增</strong>」第 <strong>84</strong> 题 求最大矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **84** 题 求最大矩形</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hs)):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> hs[i] &lt; hs[s[<span class="number">-1</span>]]:</span><br><span class="line">        base = s.pop()</span><br><span class="line">        <span class="keyword">if</span> s:</span><br><span class="line">            H = hs[base]</span><br><span class="line">            W = i - s[<span class="number">-1</span>] - <span class="number">1</span> <span class="comment"># 当前弹出的做高，当前与次小做宽</span></span><br><span class="line">            res = max(res, H * W)</span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递增,考虑剩余</strong>」第 <strong>316</strong> 题 去除重复字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **316** 题 去除重复字符</span></span><br><span class="line"><span class="keyword">for</span> i,c <span class="keyword">in</span> enumerate(ss):</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">while</span> s <span class="keyword">and</span> c &lt; s[<span class="number">-1</span>] <span class="keyword">and</span> s[<span class="number">-1</span>] <span class="keyword">in</span> ss[i:]:</span><br><span class="line">            s.pop()</span><br><span class="line">        s.append(c)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>42</strong> 题 接雨水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **42** 题 接雨水</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(hgt)):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> hgt[i] &gt; hgt[stack[<span class="number">-1</span>]]: <span class="comment">#递减栈</span></span><br><span class="line">        base = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            LH = hgt[stack[<span class="number">-1</span>]]</span><br><span class="line">            W = i - stack[<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">            H = min(LH,hgt[i]) - hgt[base]</span><br><span class="line">            res += W * H</span><br><span class="line">    stack.append(i)</span><br></pre></td></tr></table></figure><p>「<strong>单调递减</strong>」第 <strong>739</strong> 题 每日温度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第 **739** 题 每日温度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">and</span> T[s[<span class="number">-1</span>]] &lt;= T[i] :   <span class="comment">#递减栈</span></span><br><span class="line">        s.pop()</span><br><span class="line">    res[i] = s[<span class="number">-1</span>] - i <span class="keyword">if</span> s <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    s.append(i)</span><br></pre></td></tr></table></figure><h3 id="【二分模板】"><a href="#【二分模板】" class="headerlink" title="【二分模板】"></a>【二分模板】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13(5)55579 返回2</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt; ps[i] &lt;= ps[i+1]</span></span><br><span class="line">bisect.bisect_left(ps, T, L=<span class="number">0</span>, R=len(ns))  </span><br><span class="line"><span class="comment"># 1355579 T=5 =&gt; 13555(5)79 返回5</span></span><br><span class="line"><span class="comment"># ps[i-1] &lt;= ps[i] &lt; ps[i+1]</span></span><br><span class="line">bisect.bisect_right(ps, T, L=<span class="number">0</span>, R=len(ns))  </span><br><span class="line">bisect.bisect(ps, T, L=<span class="number">0</span>, R=len(ns))</span><br></pre></td></tr></table></figure><p>「<strong>中位返回</strong>」第 <strong>33</strong> 题 搜索旋转排序数组 | 第<strong>374</strong>题 猜数字大小 | 第<strong>69</strong>题  x平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中位返回</span></span><br><span class="line"><span class="keyword">while</span> L &lt;= R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nums[M] == T:</span><br><span class="line">        <span class="keyword">return</span> M</span><br><span class="line">    <span class="keyword">elif</span> nums[M] &lt; T:</span><br><span class="line">        L = M + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        R = M - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>区域压缩</strong>」第<strong>278</strong>题 第一个错误版本| 第<strong>162</strong>题 寻找峰值 | 第<strong>153</strong>题 寻找数组最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区域压缩</span></span><br><span class="line"><span class="keyword">while</span> L &lt; R:</span><br><span class="line">    M = (L + R) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> need <span class="keyword">in</span> s[L:M]:</span><br><span class="line">        R = M</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        L = M + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="【动态规划模板】"><a href="#【动态规划模板】" class="headerlink" title="【动态规划模板】"></a>【动态规划模板】</h3><h4 id="「单串问题」"><a href="#「单串问题」" class="headerlink" title="「单串问题」"></a>「<strong>单串问题</strong>」</h4><ul><li>70 爬楼梯问题</li><li>801 使序列递增的最小交换次数</li><li>746 使用最小花费爬楼梯</li><li>300 最长上升子序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖前单个元素</span></span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>] + ns[i]</span><br><span class="line"><span class="comment"># 依赖前部区域元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i)</span><br><span class="line">        dp[i] = min(dp[i], f(dp[j])</span><br></pre></td></tr></table></figure><h4 id="「单串加状态问题」"><a href="#「单串加状态问题」" class="headerlink" title="「单串加状态问题」"></a>「<strong>单串加状态问题</strong>」</h4><ul><li><p>887 鸡蛋掉落</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 鸡蛋掉落</span></span><br><span class="line"><span class="keyword">while</span> cur[K] &lt; N:             <span class="comment"># 还剩 j 个蛋 测 ans 次 覆盖多少层</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>): <span class="comment"># 覆盖总层数 碎了 -1 次层数 + 1 + 没碎 -1 次层数</span></span><br><span class="line">        cur[j] = prev[j - <span class="number">1</span>] + <span class="number">1</span> + prev[j]</span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">    prev = copy.deepcopy(cur)</span><br></pre></td></tr></table></figure></li><li><p>813 最大平均值分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 813 最大平均值分组</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(K<span class="number">-1</span>):            <span class="comment">#循环k次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):          <span class="comment">#每次均依赖上次的结果</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, N):</span><br><span class="line">            dp[i] = max(dp[i], avrg(i, j) + dp[j])</span><br></pre></td></tr></table></figure></li><li><p>410 分割数组最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 410 分割数组最大值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,K):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="comment"># 0~i中分 k 段最大 即为</span></span><br><span class="line">            <span class="comment"># 0~j中分k-1段最大 和 j到i的前缀和的最大</span></span><br><span class="line">            dp[i][k] = min(dp[i][k], max(dp[j][k<span class="number">-1</span>], ps[i+<span class="number">1</span>] - ps[j+<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li></ul><h4 id="「经典双串LCS问题」"><a href="#「经典双串LCS问题」" class="headerlink" title="「经典双串LCS问题」"></a>「<strong>经典双串LCS问题</strong>」</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典双串LCS问题</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(M):</span><br><span class="line">        <span class="keyword">if</span> t1[i] == t2[j] : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> : dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j])</span><br></pre></td></tr></table></figure><h4 id="「区间动态规划」"><a href="#「区间动态规划」" class="headerlink" title="「区间动态规划」"></a>「区间动态规划」</h4><ul><li>5 最长回文子串</li><li>647 最多回文子串</li><li>516 最长回文子序列</li><li>1312 最长回文插入次数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] 代表从 i 到 j 的最长子串满足条件的数量</span></span><br><span class="line"><span class="comment"># i-- &lt; j++  ==&gt; i 在 0~j 范围内 --</span></span><br><span class="line">dp = [[<span class="number">0</span>] * (N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">    dp[j][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(j<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> ss[i] == ss[j]:</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] +<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h4 id="「区间分治动态规划」"><a href="#「区间分治动态规划」" class="headerlink" title="「区间分治动态规划」"></a><strong>「区间分治动态规划」</strong></h4><p><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486 预测赢家</a></p><p><a href="***https://leetcode-cn.com/problems/burst-balloons/***">312 戳气球</a></p><p><a href="***https://leetcode-cn.com/problems/strange-printer/***">664 奇怪的打印机</a></p><p><a href="***https://leetcode-cn.com/problems/remove-boxes/***">546 移除盒子</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 区间分治动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, ns: List[int])</span> :</span></span><br><span class="line">    N = len(ns)</span><br><span class="line">    dp = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(N): <span class="comment"># 长度从小到大</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N-l): <span class="comment"># 以 i 为 开头</span></span><br><span class="line">            j = i + l           <span class="comment"># 以 j 为 终点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(i,j): <span class="comment"># 以 k 为分割点，进行分治         </span></span><br><span class="line">                // Todo 业务逻辑</span><br></pre></td></tr></table></figure><p>「<strong>卡特兰数</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卡特兰数</span></span><br><span class="line">g(n) = g(<span class="number">0</span>)*g(n<span class="number">-1</span>) + g(<span class="number">1</span>)*g(n<span class="number">-2</span>) ...g(n<span class="number">-1</span>)*g(<span class="number">0</span>)</span><br><span class="line">dp=[<span class="number">1</span>] + [<span class="number">0</span>] * n</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        dp[i] += dp[j<span class="number">-1</span>] * dp[i-j]</span><br></pre></td></tr></table></figure><h3 id="【滑动窗口】"><a href="#【滑动窗口】" class="headerlink" title="【滑动窗口】"></a>【滑动窗口】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""给定待查串s和目标串t"""</span></span><br><span class="line">nd, wd = &#123;&#125;, &#123;&#125;</span><br><span class="line">nd = collections.Counter(s1)</span><br><span class="line">L, R = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">cnt = <span class="number">0</span> <span class="comment"># 满足条件个数</span></span><br><span class="line"><span class="keyword">while</span> R &lt; len(s):        <span class="comment"># 窗口右边界不断扩大，本质是搜索问题的可能解</span></span><br><span class="line">    c = s[R]      <span class="comment"># 即将加入到窗口中的字符</span></span><br><span class="line">    R += <span class="number">1</span></span><br><span class="line">    更新窗口中的数据</span><br><span class="line">    <span class="keyword">while</span> 满足窗口收缩条件：  <span class="comment"># 窗口的左边界收缩，本质是优化可行解</span></span><br><span class="line">        记录或返回结果</span><br><span class="line">        d = s[L]   <span class="comment"># 即将从窗口中删除的字符</span></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">        更新窗口中的数据</span><br><span class="line"><span class="keyword">return</span> 结果</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定窗口 ,比滑动窗口更快一些</span></span><br><span class="line">i = j = cnt = <span class="number">0</span>      </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt &gt; K: <span class="comment">#不满足时 平移</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> j - i + <span class="number">1</span>        </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(A)):</span><br><span class="line">    <span class="keyword">if</span> A[j] == <span class="number">0</span>:</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> cnt &gt; K:</span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">0</span>:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    res = max(res, j - i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【前缀和】"><a href="#【前缀和】" class="headerlink" title="【前缀和】"></a>【前缀和】</h3><p>「<strong>累加和存位置</strong>」</p><p>1371 最长偶数元音子数组</p><p>525 最长相等01子数组</p><p>325 最长和为k 子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前缀和初始化</span></span><br><span class="line">psd = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">    t ^= cd.get(s[i], <span class="number">0</span>) <span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[t] = i       <span class="comment"># 第一次存入数组</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans = max(ans, i - psd[t]) <span class="comment">#已存入则开始计算</span></span><br></pre></td></tr></table></figure><p>「<strong>累加和存数量</strong>」</p><p>560 和为K的子数组数量</p><p> 统计优美子数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 累加和存数量</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns)):</span><br><span class="line">    s += ns[i]</span><br><span class="line">    <span class="keyword">if</span> s - T <span class="keyword">in</span> psd:</span><br><span class="line">        ans += psd[s - T] <span class="comment"># 存数量</span></span><br><span class="line">    psd[s] = psd.get(s,<span class="number">0</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>「<strong>模K状态前缀和</strong>」</p><p>523 连续和为 k 倍 的子数组（存索引）</p><p>974 和被k 整除 子数组数量（存数量）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模K状态前缀和</span></span><br><span class="line">psd = &#123;<span class="number">0</span>:<span class="number">-1</span>&#125;</span><br><span class="line">ans = s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(ns)):</span><br><span class="line">    s += ns[i]<span class="comment"># 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> T != <span class="number">0</span>: s %= abs(T)<span class="comment"># 模k状态做key，索引做值</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> psd:</span><br><span class="line">        psd[s] = i</span><br><span class="line">    <span class="keyword">elif</span> i - psd[s] &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>「矩阵前缀和」</strong></p><ul><li>363 不超过K的最大数值和</li><li>1074 和为目标值的子矩阵数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵前缀和</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):        <span class="comment">#固定左边界</span></span><br><span class="line">    ps = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i, m): <span class="comment">#固定右边界</span></span><br><span class="line">    psS = <span class="number">0</span></span><br><span class="line">        dct = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;       <span class="comment">#初始只有一种可能</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n): <span class="comment"># 以高做前缀和</span></span><br><span class="line">            ps[k] += mtx[j][k]          <span class="comment"># 每行前缀和</span></span><br><span class="line">            psS += ps[k]                <span class="comment"># n行前缀和</span></span><br><span class="line">            cnt += dct.get(psS - T, <span class="number">0</span>)  <span class="comment"># 满足条件cnt</span></span><br><span class="line">            dct[psS] = dct.get(psS,<span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 保存当前状态</span></span><br><span class="line"><span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="【双指针】"><a href="#【双指针】" class="headerlink" title="【双指针】"></a>【双指针】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双指针</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, ns: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    n = len(ns)</span><br><span class="line">    <span class="keyword">for</span> fast <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> ns[fast] != val:</span><br><span class="line">            ns[slow] = ns[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="【深度优先】"><a href="#【深度优先】" class="headerlink" title="【深度优先】"></a>【深度优先】</h3><p>「<strong>二叉树遍历模板</strong>」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归1：二叉树遍历最易理解和实现版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 前序递归</span></span><br><span class="line">        <span class="keyword">return</span> [root.val] + self.preOrd(root.left) + self.preOrd(root.right)</span><br><span class="line">        <span class="comment"># # 中序递归</span></span><br><span class="line">        <span class="comment"># return self.inOrd(root.left) + [root.val] + self.inOrd(root.right)</span></span><br><span class="line">        <span class="comment"># # 后序递归</span></span><br><span class="line">        <span class="comment"># return self.postOrd(root.left) + self.postOrd(root.right) + [root.val]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cur)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span>      </span><br><span class="line">            <span class="comment"># 前序递归</span></span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            dfs(cur.left)</span><br><span class="line">            dfs(cur.right)</span><br><span class="line">            <span class="comment"># # 中序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># # 后序递归</span></span><br><span class="line">            <span class="comment"># dfs(cur.left)</span></span><br><span class="line">            <span class="comment"># dfs(cur.right)</span></span><br><span class="line">            <span class="comment"># res.append(cur.val)      </span></span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span></span><br><span class="line"><span class="comment"># 迭代1：前序遍历最常用模板（后序同样可以用）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        res = []</span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="comment"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span></span><br><span class="line">        <span class="comment"># while stack:</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     if cur.left:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.left)</span></span><br><span class="line">        <span class="comment">#     if cur.right:</span></span><br><span class="line">        <span class="comment">#         stack.append(cur.right)</span></span><br><span class="line">        <span class="comment">#     res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代1：层序遍历最常用模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q :</span><br><span class="line">            l = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(q)) :</span><br><span class="line">                t = q.popleft()</span><br><span class="line">                l.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">            res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 前序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.left</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.right</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 后序，相同模板</span></span><br><span class="line">        <span class="comment"># while stack or cur:</span></span><br><span class="line">        <span class="comment">#     while cur:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment">#         stack.append(cur)</span></span><br><span class="line">        <span class="comment">#         cur = cur.right</span></span><br><span class="line">        <span class="comment">#     cur = stack.pop()</span></span><br><span class="line">        <span class="comment">#     cur = cur.left</span></span><br><span class="line">        <span class="comment"># return res[::-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span></span><br><span class="line"><span class="comment"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span></span><br><span class="line"><span class="comment"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(<span class="number">0</span>, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            flag, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 前序，标记法</span></span><br><span class="line">                stack.append((<span class="number">0</span>, cur.right))</span><br><span class="line">                stack.append((<span class="number">0</span>, cur.left))</span><br><span class="line">                stack.append((<span class="number">1</span>, cur))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># # 后序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># # 中序，标记法</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.right))</span></span><br><span class="line">                <span class="comment"># stack.append((1, cur))</span></span><br><span class="line">                <span class="comment"># stack.append((0, cur.left))  </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)  </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 层序，标记法</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># queue = [(0, root)]</span></span><br><span class="line">        <span class="comment"># while queue:</span></span><br><span class="line">        <span class="comment">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span></span><br><span class="line">        <span class="comment">#     if not cur: continue</span></span><br><span class="line">        <span class="comment">#     if flag == 0:</span></span><br><span class="line">                  <span class="comment"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span></span><br><span class="line">        <span class="comment">#         queue.append((1, cur))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.left))</span></span><br><span class="line">        <span class="comment">#         queue.append((0, cur.right))</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res.append(cur.val)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span></span><br><span class="line"><span class="comment"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span></span><br><span class="line"><span class="comment"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span></span><br><span class="line"><span class="comment"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span></span><br><span class="line"><span class="comment"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span></span><br><span class="line"><span class="comment"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrd</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># cur = pre = TreeNode(None)</span></span><br><span class="line">        cur = root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                <span class="comment"># print(cur.val)</span></span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right != cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    <span class="comment"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val)</span><br><span class="line">                    <span class="comment"># print(cur.val)</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树遍历</span></span><br><span class="line"><span class="comment"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span></span><br><span class="line"><span class="comment"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span></span><br><span class="line"><span class="comment"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树简洁递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = [root.val]</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> root.children:</span><br><span class="line">            res.extend(self.preorder(node))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树通用递归模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">                helper(child)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># N叉树迭代方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = [root]</span><br><span class="line">        <span class="comment"># s.append(root)</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            node = s.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># for child in node.children[::-1]:</span></span><br><span class="line">            <span class="comment">#     s.append(child)</span></span><br><span class="line">            s.extend(node.children[::<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【广度优先】"><a href="#【广度优先】" class="headerlink" title="【广度优先】"></a>【广度优先】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**无向图的遍历**」</span></span><br><span class="line">q = collections.deque([i])</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    cur = q.popleft()</span><br><span class="line">    <span class="keyword">for</span> nxt <span class="keyword">in</span> dt[cur]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vst[nxt]:</span><br><span class="line">            vstd[nxt] = <span class="literal">True</span></span><br><span class="line">            q.append(nxt)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 「**二叉树层序遍历**」</span></span><br><span class="line">q = deque([root])</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">while</span> q :</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(q)) :</span><br><span class="line">        t = q.popleft()</span><br><span class="line">        l.append(t.val)</span><br><span class="line">        <span class="keyword">if</span> t.left : q.append(t.left)</span><br><span class="line">        <span class="keyword">if</span> t.right : q.append(t.right)</span><br><span class="line">    res.append(l)</span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="【图论】"><a href="#【图论】" class="headerlink" title="【图论】"></a>【图论】</h3><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#「Dijkstra最短路径」</span></span><br><span class="line">dic = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">    dic[u].append([v, w])</span><br><span class="line">    dic[v].append([u, w])</span><br><span class="line">q = [(<span class="number">0</span>, n)]</span><br><span class="line">dist = [<span class="number">-1</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">    dis, cur = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> dist[cur] &lt; <span class="number">0</span>:</span><br><span class="line">        dist[cur] = dis</span><br><span class="line">        <span class="keyword">for</span> nxt, wi <span class="keyword">in</span> dic[cur]:</span><br><span class="line">            heapq.heappush(q, [dis + wi, nxt])</span><br></pre></td></tr></table></figure><p><strong>「Floyd 求图中路径」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Floyd算法 求图中任意2点距离</span></span><br><span class="line">ds = defaultdict(int)</span><br><span class="line">st = set()</span><br><span class="line"><span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> enumerate(ess):</span><br><span class="line">    ds[(x, y)] = vs[i]</span><br><span class="line">    ds[(y, x)] = <span class="number">1</span> / vs[i]</span><br><span class="line">    st.update(&#123;x,y&#125;)</span><br><span class="line">arr = list(st)</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> ds[(i, k)] <span class="keyword">and</span> ds[(k, j)]:</span><br><span class="line">                ds[(i, j)] = ds[(i, k)] * ds[(k, j)]</span><br></pre></td></tr></table></figure><h1 id="五、实战算法篇"><a href="#五、实战算法篇" class="headerlink" title="五、实战算法篇"></a>五、实战算法篇</h1><h3 id="1、URL黑名单（布隆过滤器）"><a href="#1、URL黑名单（布隆过滤器）" class="headerlink" title="1、URL黑名单（布隆过滤器）"></a><strong>1、</strong>URL黑名单（布隆过滤器）</h3><p><strong>100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中</strong></p><p>​    <strong>散列表：</strong></p><p>​        如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p><p>​    <strong>布隆过滤器：</strong></p><p>​        它实际上是一个很长的二进制矢量和一系列随机映射函数。</p><p>​        它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>​        在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ul><h3 id="2、词频统计（分文件）"><a href="#2、词频统计（分文件）" class="headerlink" title="2、词频统计（分文件）"></a>2、词频统计（分文件）</h3><p><strong>2GB内存在20亿整数中找到出现次数最多的数</strong></p><p>​        通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。</p><p>​        当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿/2^30,1GB== 2 ^30个字节 == 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。</p><p>​        解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。</p><h3 id="3、未出现的数（bit数组）"><a href="#3、未出现的数（bit数组）" class="headerlink" title="3、未出现的数（bit数组）"></a><strong>3、未出现的数</strong>（bit数组）</h3><p><strong>40亿个非负整数中找到没有出现的数</strong></p><p>​        对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B = 160亿个字节，一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。</p><p>　　我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿/8 = 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，例如，遇到20，则bitArray[20] = 1；遇到666，则bitArray[666] = 1,遍历完所有的数，将数组相应位置变为1。</p><p><strong>40亿个非负整数中找到一个没有出现的数，内存限制10MB</strong></p><p>​        10亿个字节的数据大概需要1GB空间处理，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit / 0.8亿bit = 50，那么这样最少也得分50块来处理，下面就以64块来进行分析解答吧。</p><p><strong>总结一下进阶的解法：</strong></p><p>1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</p><p>2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p><p>3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。</p><p><strong>自己的想法</strong></p><p>如果只是找一个数，可以高位模运算，写到64个不同的文件，然后在最小的文件中通过bitArray一次处理掉。</p><p><strong>40亿个无符号整数，1GB内存，找到所有出现两次的数</strong></p><p>​        对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num<em>2 + 1]和bitArr[num</em>2]设置为01，如果第二次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为10，如果第三次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为11。以后再遇到num，发现此时bitArr[num<em>2+1]和bitArr[num</em>2]已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i<em>2+1]和bitArr[i</em>2]设置为10，那么i 就是出现了两次的数。</p><h3 id="4、重复URL（分机器）"><a href="#4、重复URL（分机器）" class="headerlink" title="4、重复URL（分机器）"></a><strong>4、重复URL</strong>（分机器）</h3><p><strong>找到100亿个URL中重复的URL</strong></p><p>​        原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。</p><p>​        例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，<strong>同时哈希函数的性质决定了同一条URL不可能分给不同的机器；</strong>或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p><h3 id="5、TOPK搜索（小根堆）"><a href="#5、TOPK搜索（小根堆）" class="headerlink" title="5、TOPK搜索（小根堆）"></a><strong>5、TOPK搜索（小根堆）</strong></h3><p><strong>海量搜索词汇，找到最热TOP100词汇的方法</strong></p><p>​        最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。</p><p>​        处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p><h3 id="6、中位数（单向二分查找）"><a href="#6、中位数（单向二分查找）" class="headerlink" title="6、中位数（单向二分查找）"></a><strong>6、中位数（单向二分查找）</strong></h3><p><strong>10MB内存，找到100亿整数的中位数</strong></p><p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？</p><p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。</p><p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。</p><p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中）</p><p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。</p><p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。</p><p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。</p><p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p><h3 id="7、短域名系统（缓存）"><a href="#7、短域名系统（缓存）" class="headerlink" title="7、短域名系统（缓存）"></a><strong>7、短域名系统（缓存）</strong></h3><p><strong>设计短域名系统，将长URL转化成短的URL.</strong></p><p>（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。</p><p>（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：<a href="http://t.cn/sBc。" target="_blank" rel="noopener">t.cn/sBc。</a></p><p>（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。</p><h3 id="8、海量评论入库（消息队列）"><a href="#8、海量评论入库（消息队列）" class="headerlink" title="8、海量评论入库（消息队列）"></a><strong>8、海量评论入库（消息队列）</strong></h3><p><strong>假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</strong></p><p>前端页面直接给用户展示、通过消息队列异步方式入库</p><p>读可以进行读写分离、同时热点评论定时加载到缓存</p><h3 id="9、在线-并发用户数（Redis）"><a href="#9、在线-并发用户数（Redis）" class="headerlink" title="9、在线/并发用户数（Redis）"></a><strong>9、在线/并发用户数（Redis）</strong></h3><p>​    <strong>显示网站的用户在线数的解决思路</strong></p><p>​        维护在线用户表</p><p>​        使用Redis统计</p><p><strong>显示网站并发用户数</strong></p><ol><li>每当用户访问服务时，把该用户的 ID 写入ZSORT队列，权重为当前时间</li><li>根据权重(即时间)计算一分钟内该机构的用户数Zrange</li><li>删掉一分钟以上过期的用户Zrem</li></ol><h3 id="10、热门字符串（前缀树）"><a href="#10、热门字符串（前缀树）" class="headerlink" title="10、热门字符串（前缀树）"></a>10、热门字符串（前缀树）</h3><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><p><strong>HashMap 法</strong></p><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p><p><strong>前缀树法</strong></p><p>当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用<strong>小顶堆</strong>来对字符串的出现次数进行排序。</p><h3 id="11、红包算法"><a href="#11、红包算法" class="headerlink" title="11、红包算法"></a>11、红包算法</h3><p>线性切割法，一个区间切N-1刀。越早越多</p><p>二倍均值法，【0 ~ 剩余金额 / 剩余人数 * 2】中随机，相对均匀</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpbvl5pvj30qu0gcgm0.jpg" alt="img"></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpc3hz9dj31450ggq8k.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="11、手写快排"><a href="#11、手写快排" class="headerlink" title="11、手写快排"></a>11、手写快排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常规快排 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L , <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> M = partition(arr, L, R);</span><br><span class="line">quickSort1(arr, L, M - <span class="number">1</span>);</span><br><span class="line">quickSort1(arr, M + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> L;</span><br><span class="line"><span class="keyword">int</span> lessEqual = L - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; R) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] &lt;= arr[R])</span><br><span class="line">swap(arr, index, ++lessEqual);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, ++lessEqual, R);</span><br><span class="line"><span class="keyword">return</span> lessEqual;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 荷兰国旗 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R)  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">quickSort2(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">quickSort2(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherlandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (L == R) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; L, R &#125;;</span><br><span class="line"><span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> more = R;</span><br><span class="line"><span class="keyword">int</span> index = L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">swap(arr, index++, ++less);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, index, --more);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, more, R);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> testTime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxSize = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> maxValue = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">long</span> T1=<span class="number">0</span>,T2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="keyword">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line"><span class="keyword">int</span>[] arr3 = copyArray(arr1);</span><br><span class="line"><span class="comment">//int[] arr1 = &#123;9,8,7,6,5,4,3,2,1&#125;;</span></span><br><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">quickSort1(arr1,<span class="number">0</span>,arr1.length-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">quickSort2(arr2,<span class="number">0</span>,arr2.length-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">long</span> t3 = System.currentTimeMillis();</span><br><span class="line">T1 += (t2-t1);</span><br><span class="line">T2 += (t3-t2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2) || !isEqual(arr2, arr3)) &#123;</span><br><span class="line">succeed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(T1+<span class="string">" "</span>+T2);</span><br><span class="line"><span class="comment">//System.out.println(succeed ? "Nice!" : "Oops!");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random())</span><br><span class="line">                - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">res[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> &amp;&amp; arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (arr1.length != arr2.length)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line"><span class="keyword">if</span> (arr1[i] != arr2[i])</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、手写归并"><a href="#12、手写归并" class="headerlink" title="12、手写归并"></a>12、手写归并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M)</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R)</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++)</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    process(arr, L, mid);</span><br><span class="line">    process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    printArray(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13、手写堆排"><a href="#13、手写堆排" class="headerlink" title="13、手写堆排"></a>13、手写堆排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        heapify(arr, i, arr.length);</span><br><span class="line">    <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">    swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">    <span class="comment">// O(N*logN)</span></span><br><span class="line">    <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]刚来的数，往上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arr[index]位置的数，能否往下移动</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line">        <span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line">        <span class="comment">// 1）只有左孩子，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line">        <span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line">        <span class="keyword">int</span> largest = left+<span class="number">1</span> &lt; heapSize &amp;&amp; arr[left+<span class="number">1</span>]&gt; arr[left] ? left+<span class="number">1</span> : left;</span><br><span class="line">        <span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">        largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">        <span class="keyword">if</span> (largest == index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, largest, index);</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    heapSort(arr1);</span><br><span class="line">    printArray(arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、手写单例"><a href="#14、手写单例" class="headerlink" title="14、手写单例"></a>14、手写单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">              singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15、手写LRUcache"><a href="#15、手写LRUcache" class="headerlink" title="15、手写LRUcache"></a>15、手写LRUcache</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于linkedHashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer,Integer&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;   <span class="comment">//容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//缓存中不存在此key，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = cache.get(key);</span><br><span class="line">        cache.remove(key);   <span class="comment">//先从链表中删除</span></span><br><span class="line">        cache.put(key,res);  <span class="comment">//再把该节点放到链表末尾处</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(key); <span class="comment">//已经存在，在当前链表移除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity == cache.size()) &#123;</span><br><span class="line">            <span class="comment">//cache已满，删除链表头位置</span></span><br><span class="line">            Set&lt;Integer&gt; keySet = cache.keySet();</span><br><span class="line">            Iterator&lt;Integer&gt; iterator = keySet.iterator();</span><br><span class="line">            cache.remove(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key,value);  <span class="comment">//插入到链表末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写双向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DNode</span> </span>&#123;</span><br><span class="line">        DNode prev;</span><br><span class="line">        DNode next;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Integer, DNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    DNode head, tail;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> DNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            DNode node = map.get(key);</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            DNode node = map.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DNode newNode = <span class="keyword">new</span> DNode();</span><br><span class="line">            newNode.val = value;</span><br><span class="line">            newNode.key = key;</span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            map.put(key, newNode);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; cap) &#123;</span><br><span class="line">                map.remove(tail.prev.key);</span><br><span class="line">                removeNode(tail.prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DNode node)</span> </span>&#123;</span><br><span class="line">        DNode prevNode = node.prev;</span><br><span class="line">        DNode nextNode = node.next;</span><br><span class="line">        prevNode.next = nextNode;</span><br><span class="line">        nextNode.prev = prevNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DNode node)</span> </span>&#123;</span><br><span class="line">        DNode firstNode = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = firstNode;</span><br><span class="line">        firstNode.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16、手写线程池"><a href="#16、手写线程池" class="headerlink" title="16、手写线程池"></a><strong>16、手写线程池</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfThreadPool</span> </span>&#123;</span><br><span class="line"><span class="comment">//默认线程池中的线程的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORK_NUM = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//默认处理任务的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_NUM = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> workNum;<span class="comment">//线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> taskNum;<span class="comment">//任务数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;WorkThread&gt; workThreads;<span class="comment">//保存线程的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; taskQueue;<span class="comment">//阻塞有序队列存放任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySelfThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(WORK_NUM, TASK_NUM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MySelfThreadPool</span><span class="params">(<span class="keyword">int</span> workNum, <span class="keyword">int</span> taskNum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (workNum &lt;= <span class="number">0</span>) workNum = WORK_NUM;</span><br><span class="line"><span class="keyword">if</span> (taskNum &lt;= <span class="number">0</span>) taskNum = TASK_NUM;</span><br><span class="line">taskQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(taskNum);</span><br><span class="line"><span class="keyword">this</span>.workNum = workNum;</span><br><span class="line"><span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">workThreads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//启动一定数量的线程数，从队列中获取任务处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;workNum;i++) &#123;</span><br><span class="line">WorkThread workThread = <span class="keyword">new</span> WorkThread(<span class="string">"thead_"</span>+i);</span><br><span class="line">workThread.start();</span><br><span class="line">workThreads.add(workThread);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">taskQueue.put(task);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ready close thread pool..."</span>);</span><br><span class="line"><span class="keyword">if</span> (workThreads == <span class="keyword">null</span> || workThreads.isEmpty()) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span> (WorkThread workThread : workThreads) &#123;</span><br><span class="line">workThread.stopWork();</span><br><span class="line">workThread = <span class="keyword">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125;</span><br><span class="line">workThreads.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WorkThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">setName(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Runnable runnable = taskQueue.take();<span class="comment">//获取任务</span></span><br><span class="line"><span class="keyword">if</span> (runnable !=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(getName()+<span class="string">" readyexecute:"</span>+runnable.toString());</span><br><span class="line">runnable.run();<span class="comment">//执行任务</span></span><br><span class="line">&#125;</span><br><span class="line">runnable = <span class="keyword">null</span>;<span class="comment">//help gc</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">interrupt();</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.concurrent.pool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMySelfThreadPool</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_NUM = <span class="number">50</span>;<span class="comment">//任务的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MySelfThreadPool myPool = <span class="keyword">new</span> MySelfThreadPool(<span class="number">3</span>,<span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;TASK_NUM;i++) &#123;</span><br><span class="line">myPool.execute(<span class="keyword">new</span> MyTask(<span class="string">"task_"</span>+i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"task :"</span>+name+<span class="string">" end..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"name = "</span>+name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17、手写消费者生产者模式"><a href="#17、手写消费者生产者模式" class="headerlink" title="17、手写消费者生产者模式"></a><strong>17、手写消费者生产者模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() + num &gt; MAX_VALUE) &#123;</span><br><span class="line">                System.out.println(<span class="string">"暂时不能执行生产任务"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> Object());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"已生产产品数"</span>+num+<span class="string">" 仓库容量"</span>+list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &lt; num) &#123;</span><br><span class="line">                System.out.println(<span class="string">"暂时不能执行消费任务"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"已消费产品数"</span>+num+<span class="string">" 仓库容量"</span> + list.size());</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        storage.produce(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Storage storage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storage = storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        storage.consume(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p2 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p3 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Producer p4 = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        Customer c2 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        Customer c3 = <span class="keyword">new</span> Customer(storage);</span><br><span class="line">        p1.setNum(<span class="number">10</span>);</span><br><span class="line">        p2.setNum(<span class="number">20</span>);</span><br><span class="line">        p3.setNum(<span class="number">80</span>);</span><br><span class="line">        c1.setNum(<span class="number">50</span>);</span><br><span class="line">        c2.setNum(<span class="number">20</span>);</span><br><span class="line">        c3.setNum(<span class="number">20</span>);</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">        c3.start();</span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">        p3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18、手写阻塞队列"><a href="#18、手写阻塞队列" class="headerlink" title="18、手写阻塞队列"></a><strong>18、手写阻塞队列</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">blockQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isNull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition isFull = lock.newCondition();</span><br><span class="line">    blockQueue(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size &gt;= capacity) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"阻塞队列满了"</span>);</span><br><span class="line">                    isFull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isFull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ++size;</span><br><span class="line">            container.add(data);</span><br><span class="line">            isNull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"阻塞队列空了"</span>);</span><br><span class="line">                    isNull.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                isNull.signal();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">int</span> res = container.get(<span class="number">0</span>);</span><br><span class="line">            container.remove(<span class="number">0</span>);</span><br><span class="line">            isFull.signal();</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AxinBlockQueue queue = <span class="keyword">new</span> AxinBlockQueue(<span class="number">5</span>);</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            System.out.println(<span class="string">"塞入"</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费"</span>+queue.take());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19、手写多线程交替打印ABC"><a href="#19、手写多线程交替打印ABC" class="headerlink" title="19、手写多线程交替打印ABC"></a><strong>19、手写多线程交替打印ABC</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.test;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syncPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打印次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRINT_COUNT = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition thisCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition nextCondtion;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">syncPrinter</span><span class="params">(ReentrantLock reentrantLock, Condition thisCondtion, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reentrantLock = reentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.nextCondtion = nextCondition;</span><br><span class="line">        <span class="keyword">this</span>.thisCondtion = thisCondtion;</span><br><span class="line">        <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取打印锁 进入临界区</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连续打印PRINT_COUNT次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PRINT_COUNT; i++) &#123;</span><br><span class="line">                <span class="comment">//打印字符</span></span><br><span class="line">                System.out.print(printChar);</span><br><span class="line">                <span class="comment">// 使用nextCondition唤醒下一个线程</span></span><br><span class="line">                <span class="comment">// 因为只有一个线程在等待，所以signal或者signalAll都可以</span></span><br><span class="line">                nextCondtion.signal();</span><br><span class="line">                <span class="comment">// 不是最后一次则通过thisCondtion等待被唤醒</span></span><br><span class="line">                <span class="comment">// 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; PRINT_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 本线程让出锁并等待唤醒</span></span><br><span class="line">                        thisCondtion.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition conditionA = lock.newCondition();</span><br><span class="line">        Condition conditionB = lock.newCondition();</span><br><span class="line">        Condition conditionC = lock.newCondition();</span><br><span class="line">        Thread printA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionA, conditionB,<span class="string">'A'</span>));</span><br><span class="line">        Thread printB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionB, conditionC,<span class="string">'B'</span>));</span><br><span class="line">        Thread printC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> syncPrinter(lock, conditionC, conditionA,<span class="string">'C'</span>));</span><br><span class="line">        printA.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printB.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        printC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20、交替打印FooBar"><a href="#20、交替打印FooBar" class="headerlink" title="20、交替打印FooBar"></a>20、交替打印FooBar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手太阴肺经 BLOCKING Queue</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; bar = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; foo = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.put(i);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            bar.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.take();</span><br><span class="line">            printBar.run();</span><br><span class="line">            foo.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手阳明大肠经CyclicBarrier 控制先后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar6</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!fin);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cb.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;&#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            fin = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阴心经 自旋 + 让出CPU</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar5</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> permitFoo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(permitFoo) &#123;</span><br><span class="line">            printFoo.run();</span><br><span class="line">            i++;</span><br><span class="line">            permitFoo = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!permitFoo) &#123;</span><br><span class="line">        printBar.run();</span><br><span class="line">        i++;</span><br><span class="line">        permitFoo = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手少阳三焦经 可重入锁 + Condition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition foo = lock.newCondition();</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(flag) &#123;</span><br><span class="line">                    foo.await();</span><br><span class="line">            &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                foo.signal();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手厥阴心包经 synchronized + 标志位 + 唤醒</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// 标志位，控制执行顺序，true执行printFoo，false执行printBar</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> type = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object foo=  <span class="keyword">new</span> Object(); <span class="comment">// 锁标志</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printFoo.run();</span><br><span class="line">                type = <span class="keyword">false</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (foo) &#123;</span><br><span class="line">                <span class="keyword">while</span>(type)&#123;</span><br><span class="line">                    foo.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                printBar.run();</span><br><span class="line">                type = <span class="keyword">true</span>;</span><br><span class="line">                foo.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手太阳小肠经 信号量 适合控制顺序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore foo = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore bar = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            foo.acquire();</span><br><span class="line">        printFoo.run();</span><br><span class="line">            bar.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            bar.acquire();</span><br><span class="line">        printBar.run();</span><br><span class="line">            foo.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、个人项目"><a href="#六、个人项目" class="headerlink" title="六、个人项目"></a><strong>六、个人项目</strong></h1><h2 id="一、一站到底"><a href="#一、一站到底" class="headerlink" title="一、一站到底"></a><strong>一、一站到底</strong></h2><p>​    采用SpringBoot构建项目，主要通过分布式缓存、队列、限流保证系统高可用，Netty、缓存、反向代理保证高并发。</p><blockquote><p>双人对战答题、公司对战抢答</p></blockquote><h3 id="1、如何设计排行榜"><a href="#1、如何设计排行榜" class="headerlink" title="1、如何设计排行榜"></a>1、如何设计排行榜</h3><ul><li>个人总得分和总排名实时更新</li><li>个人排行榜按分数、时间、次数、正确率展示</li><li>日榜、过去N日榜滚动更新</li></ul><h4 id="性能优化过程"><a href="#性能优化过程" class="headerlink" title="性能优化过程"></a>性能优化过程</h4><p>​    第一条需求很简单，使用了Redis的<strong>Zset</strong>实现不过这里总得分采用了基于<strong>分数、时间、次数和正确率</strong>的混合加权。考虑到数据的<strong>持久化</strong>，以及<strong>关系数据库和缓存的一致性</strong>导致的设计的复杂性，使用了<strong>谷歌</strong>开源的<strong>JamsRanking</strong></p><p>​    优点<strong>是可以直接使用现成的setScores和getRanking接口封装了Redis和Mysql和消息队列的完成</strong>事务和一致性<strong>的使用细节。缺点是</strong>并发比较低<strong>使用Jmeter进行压测，单机只有</strong>20<strong>左右的</strong>TPS**</p><p>​    后来看了下源码，主要是它针对每一次设置都进行了分布式事务处理，并且会返回事务提交或回滚的结果。了解了底层实现以后就去谷歌的<strong>开源社区</strong>去查阅了相关的解决方案，当时官方对这个问题并没有通过<strong>配置能直接解决问题</strong>的快捷方式，不过推荐了使用者自身如果对响应时间不高的场景下可以采用<strong>批量合并事务</strong>的方式进行优化。基于这个思路，我们把写操作进行了封装并放入了<strong>队列</strong>，然后在消费者端批量取得数据后进行事务的批量处理，压测环境下整体性能达到了<strong>500TPS</strong>。已经基本满足了线上更新的需求，但是当时压测的过程中，队列偶尔的吞吐量会<strong>大范围波动</strong>，经常会持续数十秒，然后业务一次性处理完再响应，导致<strong>局部响应时间大幅度增长</strong></p><p>​    后来也是在官网上查询，了解到谷歌开源组件使用的<strong>队列服务</strong>底层是使用<strong>BigTable</strong>作为持久层，但是当BigTable分片过大时，会触发<strong>再分片</strong>的过程，再分片的过程中，是<strong>不会进行任务分发</strong>的，所以就会导致先前的问题。针对这个问题，谷歌官方的建议是提前<strong>配置队列的数量、负载策略和最大容量</strong>等信息，保证所有队列<strong>不同时触发</strong>再分片</p><p>​    进行两次优化后，压测环境已经基本可以满足预期了，在实际生产环境的部署中，发现对于事务更新失败时，JamsRanking会对失败的事务进行<strong>切分和重试</strong>，整个过程对于研发人员是<strong>透明</strong>的，不利于线上问题排查，所以我们当时特地写了一个watchdog的工具，监控事务回滚达到十次以上的事务，查明原因后通过后台管理系统进行相应补偿，保证<strong>最终一致性</strong></p><p><strong>最终结果：</strong></p><ul><li>高效快速：能在数百毫秒内找到玩家排名以及进行更新</li><li>强一致性以及持久化、排名准确</li><li><p>可以扩展到任意数量的玩家</p></li><li><p>吞吐量有限制，只能支持约每秒 500次更新。</p></li></ul><p>针对这个缺点谷歌官方也是给出了使用分片树和近似排名的解决方案，当然复杂的方案有更高的运维成本，所以我们优化工作也就到此为止</p><h4 id="方案优化过程"><a href="#方案优化过程" class="headerlink" title="方案优化过程"></a>方案优化过程</h4><h4 id="方案1：每日一个滚动榜，当日汇聚（费时间）"><a href="#方案1：每日一个滚动榜，当日汇聚（费时间）" class="headerlink" title="方案1：每日一个滚动榜，当日汇聚（费时间）"></a>方案1：每日一个滚动榜，当日汇聚（费时间）</h4><p>​    首先记录每天的排行榜和一个滚动榜，加分时同时写入这两个榜单，每日零点后跑工具将前几天数据累加写入当日滚动榜，该方案缺点是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受</p><h4 id="方案2：全局N个滚动榜同时写（费空间）"><a href="#方案2：全局N个滚动榜同时写（费空间）" class="headerlink" title="方案2：全局N个滚动榜同时写（费空间）"></a>方案2：全局N个滚动榜同时写（费空间）</h4><p>​    要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。可以写当天的滚动榜的同时，写往后N-1天的滚动榜一起写入该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，但是对于百日榜，空间消耗无法接受，1000万榜单大约消耗1G内存</p><h4 id="方案3：实时更新，常数次写操作"><a href="#方案3：实时更新，常数次写操作" class="headerlink" title="方案3：实时更新，常数次写操作"></a>方案3：实时更新，常数次写操作</h4><p>有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？</p><p>​    仍然是记录每天的排行榜和一个滚动榜，加分操作也还是同时操作当日榜和全局榜，但每日零点的离线作业改为从全局榜中减去之前过期的数据，从而实现先滚动更新。  此方案每次只需读取一个日榜做减法，时间复杂度为O(1)；但是无法做到实时更新。 这个方案的优点是在十二点前提前准备好差分榜，到了十二点直接加上当天数据就是滚动榜内容 ，这样就在常数次写操作的前提下，实现了滚动榜的实时更新</p><h3 id="2、如何解决重复答题"><a href="#2、如何解决重复答题" class="headerlink" title="2、如何解决重复答题"></a>2、<strong>如何解决重复答题</strong></h3><p>​    <strong>利用setnx防止重复答题</strong><br>​    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁推荐使用set的方式</span></span><br><span class="line">String result = jedis.set(lockKey, requestId, <span class="string">"NX"</span>, <span class="string">"EX"</span>, expireTime);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐使用redis+lua脚本</span></span><br><span class="line">String lua = <span class="string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span>;</span><br><span class="line">Object result = jedis.eval(lua, Collections.singletonList(lockKey)</span><br></pre></td></tr></table></figure><h3 id="3、一个题目被多个人抢答"><a href="#3、一个题目被多个人抢答" class="headerlink" title="3、一个题目被多个人抢答"></a><strong>3、一个题目被多个人抢答</strong></h3><p>​    <strong>利用redis来实现乐观锁（抢答）</strong>，好处是答错的人不影响状态，第一个秒杀答对的人才能得分。</p><p>1、利用redis的watch功能，监控这个 Corp:Activ:Qust: 的状态值<br>2、获取Corp:Activ:Qust: 的值，创建redis事务，给这个key的值-1<br>3、执行这个事务，如果key的值被修改过则回滚，key不变</p><h3 id="4、如何管理昵称重复"><a href="#4、如何管理昵称重复" class="headerlink" title="4、如何管理昵称重复"></a><strong>4、如何管理昵称重复</strong></h3><p>​    <strong>使用布隆过滤器：</strong></p><p>​    它实际上是一个很长的二进制矢量数组和 K 个哈希函数。当一个昵称加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。 Na</li></ul><p>​    用户新增昵称时需要首先计算K个哈希值，如果K个哈希值有一个不为0则通过，否则不通过，不通过时通过加随机字符串再次检验，检测通过后返回给前端，帮助用户自动填写。</p><p>​    布隆过滤器的好处是它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>BloomFilter 的优势是，全内存操作，性能很高。另外空间效率非常高，<strong>要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1/10，即平均单条记录占用 1.8 字节，误判率可以达到 1/1000；平均单条记录占用 2.4 字节，误判率可以到 1/10000，以此类推</strong>。这里的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0</p><p>​        </p><h3 id="5、如何管理出题定时任务"><a href="#5、如何管理出题定时任务" class="headerlink" title="5、如何管理出题定时任务"></a><strong>5、如何管理出题定时任务</strong></h3><p>​    压测环境中服务器通过Netty的主从Reactor多路复用NIO事件模型，单机可以<strong>轻松应对十万长连接</strong>，但是每个业务中，由于每个用户登录系统后需要按照指定顺序答题，例如一共要答十道，那么服务器针对这一个用户就会产生十个定时任务，所以对于系统来说，定时器的<strong>数量就是百万级别的</strong>。</p><p>​    通过压测结果发现：JDK自带的Timer，在大概三万并发时性能就急剧下降了。也是此时根据业务场景的需要，将定时任务改成了Netty自带的HashedWheelTimer时间轮方案，通过压测单机在50万级别下依然能够平滑的执行。</p><p>​    也是这个强烈的反差，使我在强烈的好奇心促使下，阅读源码了解到常规的JDK 的Timer 和 DelayedQueue 等工具类，可实现简单的定时任务，单底层用的是<strong>堆数据结构</strong>，存取复杂度都是 <strong>O(NlogN)</strong>，无法支撑海量定时任务。<strong>Netty经典的时间轮方案</strong>，正是通过将任务存取及取消操作时间复杂度降为 O(1)，而广泛应用在定时<strong>任务量大、性能要求高</strong>的场景中。</p><p>​    <img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvl9c3hp2j30py0d7q4i.jpg" alt="img" style="zoom:50%;"></p><p>​    基于Netty的Websocket底层，服务器端维护一个高效批量管理定时任务的调度模型。时间轮一般会实现成一个<strong>环形数组结构</strong>，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用<strong>双向链表</strong>存储定时任务。指针<strong>周期性地跳动</strong>，跳动到一个槽位，就执行该槽位的定时任务。</p><p>​    单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，可以考虑使用多级时间轮以及持久化存储与时间轮结合的方案。时间轮的<strong>定时任务处理逻辑</strong>如下：</p><ol><li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中</li><li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务，从链表头部开始迭代：<ul><li>属于当前时钟周期则取出运行</li><li>不属于则将其剩余的时钟周期数减一</li></ul></li><li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。</li></ol><h3 id="6：如何解决客户端断连"><a href="#6：如何解决客户端断连" class="headerlink" title="6：如何解决客户端断连"></a><strong>6：如何解决客户端断连</strong></h3><p>​    使用Netty的<strong>重连检测狗</strong>ConnectionWatchdog</p><p>​    服务端定义refreshTime，当我们从channel中read到了服务端发来的心跳响应消息的话，就刷新refreshTime为当前时间</p><p>​    客户端在state是WRITER_IDLE的时候每隔一秒就发送一个心跳包到sever端，告诉server端我还活着。</p><p>当重连成功时，会触发channelActive方法，在这里我们开启了一个定时任务去判断refreshTime和当前时间的时间差，超过5秒说明断线了，要进行重连，最后计算重连次数，尝试连接2次以上连不上就会修改header信息强制重连去连另一个服务器。</p><h2 id="二、秒杀项目"><a href="#二、秒杀项目" class="headerlink" title="二、秒杀项目"></a>二、秒杀项目</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h3><p>秒杀用到的基础组件，主要有<strong>框架、KV 存储、关系型数据库、MQ</strong>。</p><p>框架主要有 Web 框架和 RPC 框架。</p><p>其中，Web 框架主要用于提供 HTTP 接口给浏览器访问，所以 Web 框架的选型在秒杀服务中非常重要。在这里，我<strong>推荐Gin</strong>，它的性能和易用性都不错，在 <strong>GitHub 上的 Star 达到了 44k</strong>。对比性能最好的 fasthttp，虽然 fasthttp 在请求延迟低于 10ms 时性能优势明显，但其底层使用的对象池容易让人踩坑，导致其易用性较差，所以没必要过于追求性能而忽略了稳定性</p><p>至于 RPC 框架，我推荐选用 <strong>gRPC</strong>，因为它的扩展性和性能都非常不错。在秒杀系统中，Redis 中的数据主要是给秒杀接口服务使用，以便将配置从管理后台同步到 Redis 缓存中。</p><p>KV 存储方面，秒杀系统中主要是用 <strong>Redis 缓存活动配置</strong>，用 <strong>etcd 存储集群信息</strong>。</p><p>关系型数据库中，<strong>MySQL</strong> 技术成熟且稳定可靠，秒杀系统用它存储活动配置数据很合适。主要 原因还是秒杀活动信息和库存数据都缓存在 Redis 中，活动过程中秒杀服务不操作数据库， 使用 MySQL 完全能够满足需求。</p><p>MQ 有很多种，其中 <strong>Kafka</strong> 在业界认可度最高，技术也非常成熟，性能很不错，非常适合用在秒杀系统中。Kafka 支持自动创建队列，秒杀服务各个节点可以用它自动创建属于自己的队列</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p><strong>背景</strong></p><ul><li>秒杀业务简单，每个秒杀活动的商品是事先定义好的，商品有明确的类型和数量，卖完即止<br>-<br>秒杀活动定时上架，消费者可以在活动开始后，通过秒杀入口进行抢购秒杀活动</li></ul><p>-<br>  秒杀活动由于商品物美价廉，开始售卖后，会被快速抢购一空。</p><p><strong>现象</strong></p><p>-<br>  秒杀活动持续时间短，访问冲击量大，秒杀系统需要应对这种爆发性的访问模型</p><p>-<br>  业务的请求量远远大于售卖量，大部分是陪跑的请求，秒杀系统需要提前规划好处理策略</p><p>-<br>  前端访问量巨大，系统对后端数据的访问量也会短时间爆增，对数据存储资源进行良好设计</p><p>-<br>  活动期间会给整个业务系统带来超大负荷，需要制定各种策略，避免系统过载而宕机</p><p>-<br>  售卖活动商品价格低廉，存在套利空间，各种非法作弊手段层出，需要提前规划预防策略</p><p><strong>秒杀系统设计</strong></p><p>​    首先，要<strong>尽力将请求拦截在系统上游</strong>，层层设阻拦截，过滤掉无效或超量的请求。因为访问量远远大于商品数量，所有的请求打到后端服务的最后一步，其实并没有必要，反而会严重拖慢真正能成交的请求，降低用户体验。</p><p>​    秒杀系统专为秒杀活动服务，售卖商品确定，因此可以在设计秒杀商品页面时，将商品信息提前设计为静态信息，将静态的商品信息以及常规的 CSS、JS、宣传图片等静态资源，一起<strong>独立存放到 CDN 节点</strong>，加速访问，且降低系统访问压力，在访问前端也可以<strong>制定种种限制策略，</strong>比如活动没开始时，抢购按钮置灰，避免抢先访问，用户抢购一次后，也将按钮置灰，让用户排队等待，避免反复刷新。</p><p>​    其次，要<strong>充分利用缓存</strong>，提升系统的性能和可用性。</p><p>​    用户所有的请求进入秒杀系统前，通过<strong>负载均衡策略</strong>均匀分发到不同 Web 服务器，避免节点过载。在 Web 服务器中，首先检查用户的访问权限，识别并发刷订单的行为。如果发现售出数量已经达到秒杀数量，则直接返回结束，要将秒杀业务系统和其他业务系统进行功能分拆，尽量将秒杀系统及依赖服务<strong>独立分拆部署</strong>，避免影响其他核心业务系统。</p><p>​    秒杀系统需要构建访问记录缓存，记录访问 IP、用户的访问行为，发现异常访问，提前进行阻断及返回。同时还需要<strong>构建用户缓存</strong>，并针对历史数据分析，提前缓存僵尸强刷专业户，方便在秒杀期间对其进行策略限制。这些访问记录、用户数据，通过缓存进行存储，可以加速访问，另外，对用户数据还进行缓存预热，避免活动期间大量穿透。</p><h3 id="1、如何解决超卖？"><a href="#1、如何解决超卖？" class="headerlink" title="1、如何解决超卖？"></a><strong>1、如何解决超卖？</strong></h3><p>mysql乐观锁+redis预减库存+redis缓存卖完标记</p><p>第一是基于<strong>数据库乐观锁</strong>的方式保证数据并发扣减的强一致性；</p><p>第二是基于<strong>数据库的事务</strong>实现批量扣减部分失败时的数据回滚。</p><p>​    在扣减指定数量前应先做一次前置数量校验的读请求（参考<strong>读写分离</strong> + <strong>全缓存方案</strong>）</p><blockquote><p>纯数据库乐观锁+事务的方式性能比较差，但是如果不计成本和考虑场景的话也完全够用，因为任何没有机器配置的指标，都是耍流氓。如果我采用 Oracle 的数据库、100 多核的刀锋服务器、SSD 的硬盘，即使是纯数据库的扣减方案，也是可以达到单机上万的 TPS 的。</p></blockquote><p><strong>单线程Redis 的 lua 脚本实现批量扣减</strong></p><p>当用户调用扣减接口时，将扣减的 对应数量 + 脚本标示传递至 Redis 即可，所有的扣减判断逻辑均在 Redis 中的 lua 脚本中执行，lua 脚本执行完成之后返还是否成功给客户端。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j9dkq6vj30w20kowku.jpg" alt="image-20210504174103769" style="zoom:50%;"></p><p>Redis 中的 lua 脚本执行时，首先会使用 get 命令查询 uuid 进行查重。当防重通过后，会<strong>批量获取对应的剩余库存状态并进行判断</strong>，如果一个扣减的数量大于剩余数量，则返回错误并提示数量不足。</p><p>Redis 的单线程模型，确保<strong>不会出现当所有扣减数量在判断均满足后，在实际扣减时却数量不够</strong>。同时，单线程保证判断数量的步骤和后续扣减步骤之间，没有其他任何线程出现并发的执行。</p><p>当 Redis 扣减成功后，扣减接口会<strong>异步的将此次扣减内容保存至数据库</strong>。异步保存数据库的目的是防止出现极端情况—— Redis 宕机后数据未持久化到磁盘，此时我们可以使用数据库恢复或者校准数据</p><p>最后，运营后台直连数据库，是运营和商家修改库存的入口。商家在运营后台进货物进行补充。同时，运营后台的实现需要将此数量<strong>同步的增加至 Redis</strong>，因为当前方案的所有实际扣减都在 Redis 中</p><blockquote><p>纯缓存方案虽<strong>不会导致超卖</strong>，但因<strong>缓存不具备事务特性</strong>，极端情况下会存在缓存里的数据<strong>无法回滚</strong>，导致出现<strong>少卖</strong>的情况。且架构中的异步写库，也可能发生失败，导致多扣的数据丢失</p></blockquote><p>可以借助<strong>顺序写</strong>的特性，将扣减任务同步<strong>插入</strong>任务表，发现异常时，将任务表作为<strong>undolog</strong>进行回滚</p><p>可以解决由于<strong>网络不通</strong>、调用缓存<strong>扣减超时</strong>、在扣减到一半时缓存<strong>突然宕机</strong>（故障 failover）了。针对上述请求，都有相应的异常抛出，根据异常进行<strong>数据库回滚</strong>即可，最终任务库里的数据都是准的</p><p>更进一步：由于任务库是无状态的，可以进行水平分库，提升整体性能</p><h3 id="2、如何解决重复下单？"><a href="#2、如何解决重复下单？" class="headerlink" title="2、如何解决重复下单？"></a><strong>2、如何解决重复下单？</strong></h3><p>mysql唯一索引+分布式锁</p><h3 id="3、如何防刷？"><a href="#3、如何防刷？" class="headerlink" title="3、如何防刷？"></a><strong>3、如何防刷？</strong></h3><p>IP限流 | 验证码 | 单用户 | 单设备 | IMEI | 源IP |均设置规则</p><h3 id="4、热key问题如何解决？"><a href="#4、热key问题如何解决？" class="headerlink" title="4、热key问题如何解决？"></a><strong>4、热key问题如何解决？</strong></h3><p>redis集群+本地缓存+限流+key加随机值分布在多个实例中</p><p>1、<strong>缓存集群</strong>可以单节点进行<strong>主从复制和垂直扩容</strong></p><p>2、利用应用内的<strong>前置缓存</strong>，但是需注意需要设置上限</p><p>3、延迟不敏感，<strong>定时刷新</strong>，实时感知用主动刷新</p><p>4、和缓存穿透一样，限制逃逸流量，单请求进行数据<strong>回源并刷新前置</strong></p><p>5、无论如何设计，最后都要写一个<strong>兜底逻辑</strong>，千万级流量说来就来</p><h3 id="5、应对高并发的读请求"><a href="#5、应对高并发的读请求" class="headerlink" title="5、应对高并发的读请求"></a><strong>5、应对高并发的读请求</strong></h3><p>使用缓存策略将请求挡在上层中的缓存中</p><p>使用CDN，能静态化的数据尽量做到静态化，</p><p>加入限流（比如对短时间之内来自某一个用户，某一个IP、某个设备的重复请求做丢弃处理）</p><p><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。</p><ul><li><p>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</p></li><li><p>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</p></li><li><p>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</p></li><li><p>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</p><p>流量控制效果从好到差依次是：<strong>漏桶限流 &gt; 令牌桶限流 &gt; 滑动窗口限流 &gt; 计数器限流</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ja736ekj316o06640u.jpg" alt="image-20210504174148831" style="zoom:50%;"></p><p>其中，只有漏桶算法<strong>真正实现了恒定速度处理请求</strong>，能够绝对<strong>防止突发流量超过下游系统承载能力</strong>。<br>不过，漏桶限流也有个不足，就是需要分<strong>配内存资源缓存请求</strong>，这会增加内存的使用率。而<strong>令牌桶限流</strong>算法中的“桶”可以用一个整数表示，<strong>资源占用相对较小</strong>，这也让它成为最常用的限流算法。正是因为这些特点，<strong>漏桶限流和令牌桶限流</strong>经常在一些大流量系统中结合使用。</p></li></ul><h3 id="6、应对高并发的写请求"><a href="#6、应对高并发的写请求" class="headerlink" title="6、应对高并发的写请求"></a><strong>6、应对高并发的写请求</strong></h3><ul><li><p><strong>削峰</strong>：恶意用户拦截</p><p>对于单用户多次点击、单设备、IMEI、源IP均设置规则</p></li><li><p>采用比较成熟的<strong>漏桶算法、令牌桶</strong>算法，也可以使用<strong>guava</strong>开箱即用的限流算法</p><p>可以集群限流，但单机限流更加简洁和稳定</p></li><li><p>当前层<strong>直接过滤</strong>一定比例的请求，最大承载值前需要加上<strong>兜底逻辑</strong></p></li><li><p>对于已经无货的产品，<strong>本地缓存</strong>直接返回</p></li><li><p><strong>单独部署，减少对系统正常服务的影响，方便扩缩容</strong></p></li></ul><p>对于<strong>一段时间内的秒杀活动，需要保证写成功</strong>，我们可以使用 <strong>消息队列</strong>。</p><ul><li>削去秒杀场景下的峰值写流量——<strong>流量削峰</strong></li><li>通过异步处理简化秒杀请求中的业务流程——<strong>异步处理</strong></li><li>解耦，实现秒杀系统模块之间松耦合——<strong>解耦</strong></li></ul><p><strong>削去秒杀场景下的峰值写流量</strong></p><ul><li><strong>将秒杀请求暂存于消息队列</strong>，业务服务器响应用户“秒杀结果正在处理中。。。”，释放系统资源去处理其它用户的请求。</li><li><strong>削峰填谷</strong>，削平短暂的流量高峰，消息堆积会造成请求延迟处理，但秒杀用户对于短暂延迟有一定容忍度。秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到秒杀的结果，这是可以接受的。这时会<strong>并发 10 个</strong>请求到达数据库，并不会对数据库造成很大的压力。</li></ul><p><strong>通过异步处理简化秒杀请求中的业务流程</strong></p><p>​    先处理主要的业务，异步处理次要的业务。</p><ul><li>如主要流程是<strong>生成订单</strong>、<strong>扣减库存</strong>；</li><li>次要流程比如购买成功之后会给用户<strong>发优惠券</strong>，<strong>增加用户的积**</strong>分**。</li><li>此时秒杀只要处理生成订单，扣减库存的耗时，发放优惠券、增加用户积分异步去处理了。</li></ul><p><strong>解耦</strong></p><p>​    实现秒杀系统模块之间松耦合将秒杀数据同步给数据团队，有两种思路：</p><ul><li>使用 HTTP 或者 RPC 同步调用，即提供一个接口，实时将数据推送给数据服务。<strong>系统的耦合度高</strong>，如果其中一个服务有问题，可能会导致另一个服务不可用。</li><li>使用消息队列<strong>将数据全部发送给消息队列</strong>，然后<strong>数据服务订阅这个消息队列</strong>，接收数据进行处理。</li></ul><h3 id="7、如何保证数据一致性"><a href="#7、如何保证数据一致性" class="headerlink" title="7、如何保证数据一致性"></a><strong>7、如何保证数据一致性</strong></h3><p><strong>CacheAside旁路缓存</strong>读请求不命中查询数据库，查询完成写入缓存，写请求更新数据库后删除缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line">redis.delKey(key);</span><br><span class="line">db.updateData(data);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为防缓存失效这一信息丢失，可用消息队列确保。</p><ul><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>另起一段非业务代码，程序订阅提取出所需要的数据以及key；</li><li>尝试删除缓存操作，若删除失败，将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作；</li></ul><p>订阅<strong>binlog程序在mysql中有现成的中间</strong>件叫canal，重试机制，主要采用的是消息队列的方式。</p><p><strong>终极方案：请求串行化</strong></p><p>真正靠谱非秒杀的方案：将访问操作串行化</p><ol><li>先删缓存，将更新数据库的<strong>写操作放进有序队列中</strong></li><li>从缓存查不到的<strong>读操作也进入有序队列</strong></li></ol><p>需要解决的问题：</p><ol><li>读请求积压，大量超时，导致数据库的压力：限流、熔断</li><li>如何避免大量请求积压：将队列水平拆分，提高并行度。</li></ol><h3 id="8、可靠性如何保障"><a href="#8、可靠性如何保障" class="headerlink" title="8、可靠性如何保障**"></a>8、可靠性如何保障**</h3><p>​    由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;"></p><p>​    当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p><h3 id="9、秒杀系统瓶颈-日志"><a href="#9、秒杀系统瓶颈-日志" class="headerlink" title="9、秒杀系统瓶颈-日志"></a>9、秒杀系统瓶颈-日志</h3><blockquote><p>秒杀服务单节点需要处理的请求 QPS 可能达到 10 万以上。一个请求从进入秒杀服务到处理失败或者成功，至少会产生两条日志。也就是说，高峰期间，一个秒杀节点每秒产生的日志可能达到 <strong>30 万条</strong>以上</p></blockquote><p>​    一块性能比较好的固态硬盘，每秒写的IOPS 大概在 3 万左右。也就是说，一个秒杀节点的每秒日志条数是固态硬盘 IOPS 的 10 倍，磁盘都扛不住，更别说通过网络写入到监控系统中。</p><ul><li><strong>每秒日志量远高于磁盘 IOPS</strong>，直接写磁盘会影响服务性能和稳定性</li><li>大量日志导致服务频繁分配，<strong>频繁释放内存，影响服务性能</strong>。</li><li>服务异常退出<strong>丢失大量日志</strong>的问题</li></ul><p><strong>解决方案</strong></p><ul><li><strong>Tmpfs</strong>，即临时文件系统，它是一种基于内存的文件系统。我们可以将秒杀服务写日志的文件放在临时文件系统中。相比直接写磁盘，在临时文件系统中写日志的性能至少<strong>能提升 100 倍</strong>，每当日志文件达到 20MB 的时候，就将<strong>日志文件转移到磁盘上</strong>，并将临时文件系统中的日志文件清空。</li><li>可以参考内存池设计，将给logger分配缓冲区，每一次的新写可以复用Logger对象</li><li>参考kafka的缓冲池设计，当缓冲区达到大小和间隔时长临界值时，调用Flush函数，减少丢失的风险</li></ul><p><strong>10、池化技术</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6japwof2j31520na4mh.jpg" alt="image-20210504174220668" title class>                <p>image-20210504174220668</p>            </figure><p>​    通常可以采用<strong>循环队列</strong>来保存空闲连接。使用的时候，可以从队列头部取出连接，用完后将空闲连接放到队列尾部。Netty中利用带缓冲区的 channel 来充当队列。</p><h2 id="三、即时通信"><a href="#三、即时通信" class="headerlink" title="三、即时通信"></a>三、即时通信</h2><h3 id="1、单聊消息可靠传输"><a href="#1、单聊消息可靠传输" class="headerlink" title="1、单聊消息可靠传输"></a>1、<strong>单聊消息可靠传输</strong></h3><p>TCP保证消息可靠传输三板斧：超时、重传、确认。服务端和客户端通信MSG和ACK的共计6个报文</p><ul><li>请求报文（request，后简称为为R），客户端主动发送给服务端。</li><li>应答报文（acknowledge，后简称为A），服务器被动应答客户端的报文。</li><li>通知报文（notify，后简称为N），服务器主动发送给客户端的报文</li></ul><p><strong>在线消息流程：</strong></p><p>​        A 消息请求  <strong>MSG:R</strong>  =&gt; S 消息应答  <strong>MSG:A</strong>  =&gt; S 消息通知B  <strong>MSG:N</strong></p><p>​        S 确认通知  <strong>ACK:N</strong>  &lt;=  S 确认应答  <strong>ACK:A</strong>  &lt;=  B确认请求S  <strong>ACK:R</strong></p><p><strong>超时与重传、确认和去重：</strong></p><p>​    A发出了 <strong>MSG:R</strong> ，收到了<strong>MSG:A</strong>之后，在一个期待的时间内，如果没有收到<strong>ACK:N</strong>，A会尝试将 <strong>MSG:R</strong>  重发。可能A同时发出了很多消息，所以A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到<strong>ACK:N</strong>，定时重发。确认ACK<strong>保证必达</strong>，去重保证<strong>唯一</strong></p><p><strong>离线消息流程</strong></p><p>​    原方案：根据离线好友的标识，交互拉取指定的消息</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8kxci29zj30b305974z.jpg" alt="IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png" title class>                <p>IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png</p>            </figure><p>优化的方案：</p><ul><li>如用户<strong>勾选全量</strong>则返回计数，在用户点击时拉取。</li><li>如用户未勾选全量则返回<strong>最近全部离线消息</strong>，客户端针对<strong>用户id进行计算</strong>。</li><li>全量离线信息可以通过客户端异步线程分页拉取，减少卡顿</li><li>将ACK和分页第二次拉取的报文重合，可以较少离线消息拉取交互的次数</li></ul><h3 id="2、群聊消息如何保证不丢不重"><a href="#2、群聊消息如何保证不丢不重" class="headerlink" title="2、群聊消息如何保证不丢不重"></a><strong>2、群聊消息如何保证不丢不重</strong></h3><blockquote><p>在线的群友能第一时间收到消息；<br>离线的群友能在登陆后收到消息。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8jswr3poj30hh078dg2.jpg" alt="IM群聊消息如此复杂，如何保证不丢不重？_1.jpg"></p><ul><li>群消息发送者x向server发出群消息；</li><li>server去db中查询群中有多少用户(x,A,B,C,D)；</li><li>server去cache中查询这些用户的在线状态；</li><li>对于群中在线的用户A与B，群消息server进行实时推送；</li><li>对于群中离线的用户C与D，群消息server进行离线存储。</li></ul><p>​    对于同一份群消息的内容，多个离线用户存储了很多份。假设群中有200个用户离线，离线消息则冗余了200份，这极大的增加了数据库的存储压力</p><ul><li>离线消息表只存储用户的群离线消息msg_id，降低数据库的冗余存储量</li><li>加入应用层的ACK，才能保证群消息一定到达，服务端幂等性校验及客户端去重，保证不重复</li><li><p>每条群消息都ACK，会给服务器造成巨大的冲击，通过批量ACK减少消息风暴扩散系数的影响</p></li><li><p>群离线消息过多：拉取过慢，可以通过分页懒拉取改善。</p></li></ul><h3 id="3、如何保证消息的时序性"><a href="#3、如何保证消息的时序性" class="headerlink" title="3、如何保证消息的时序性"></a>3、<strong>如何保证消息的时序性</strong></h3><p>方案：</p><ul><li>Id通过借鉴微信号段+跳跃的方式保证趋势递增</li><li>单聊借鉴数据库设计，单点序列化同步到其他节点保证多机时序</li><li>群聊消息使用单点序列化保证各个发送者的消息相对时序</li></ul><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8m1ge2ksj30j707gt96.jpg" alt="如何保证IM实时消息的“时序性”与“一致性”？_10.jpg" title class>                <p>如何保证IM实时消息的“时序性”与“一致性”？_10.jpg</p>            </figure><p>优化：</p><ul><li>利用服务器单点序列化时序，可能出现服务端收到消息的时序，与发出序列不一致</li><li>在A往B发出的消息中，加上发送方A本地的一个绝对时序，来表示接收方B的展现时序。</li><li>群聊消息保证一个群聊落在一个service上然后通过本地递增解决全局递增的瓶颈问题</li></ul><h3 id="4：推拉结合"><a href="#4：推拉结合" class="headerlink" title="4：推拉结合"></a><strong>4：推拉结合</strong></h3><p>历史方案：</p><ul><li>服务器在缓存集群里存储所有用户的在线状态 -&gt; 保证状态可查</li><li>用户状态实时变更，任何用户登录/登出时，需要推送所有好友更新状态</li><li>A登录时，先去数据库拉取自己的好友列表，再去缓存获取所有好友的在线状态</li></ul><p><strong>“消息风暴扩散系数”</strong>是指一个消息发出时，变成N个消息的扩散系数，这个系数与业务及数据相关，一定程度上它的大小决定了技术采用推送还是拉取。</p><p>优化方案：</p><ul><li><strong>好友状态推拉结合</strong>，首页置顶亲密、当前群聊，采用推送，否则可以采用轮询拉取的方式同步；</li><li><strong>群友的状态</strong>，由于消息风暴扩散系数过大，可以采用按需拉取，延时拉取的方式同步；</li><li><strong>系统消息/开屏广告等</strong>这种实时产生的消息，可以采用推送的方式获取消息；</li></ul><h3 id="5、好友推荐"><a href="#5、好友推荐" class="headerlink" title="5、好友推荐"></a>5、好友推荐</h3><p>Neo4j 图谱数据库</p><h2 id="四、智慧社区"><a href="#四、智慧社区" class="headerlink" title="四、智慧社区"></a>四、智慧社区</h2><p>​    18年初，针对我们Dubbo框架的智慧楼宇项目的单体服务显得十分笨重，需要采用微服务的形式进行架构的重新设计，当时，我阅读了<em>Eric Evans</em> 写的《领域驱动设计：软件核心复杂性应对之道》和<em>Martin</em> <em>fowler</em>的《微服务架构：<em>Microservice</em>》两本重量级书籍，书中了解到转型微服务的重要原因之一就是利用<strong>分治的思想</strong>减少系统的复杂性，是一种针对<strong>复杂问题的宏观设计</strong>，来应对系统后来规模越来越大，维护越来越困难的问题。然而，拆分成微服务以后，并<strong>不意味着每个微服务都是各自独立地运行</strong>，而是彼此协作地组织在一起。这就好像一个团队，<strong>规模越大越需要一些方法来组织</strong>，这正是我们需要DDD模型为我们的架构设计提供理论并实践的方法。</p><p>​    当时每次版本更新迭代动辄十几个微服务同时修改，有时一个简单的数据库字段变更，也需要同时变更多个微服务，引起了团队的反思：微服务化看上去并没有减少我们的工作量。《企业架构设计》中对于微服务的定义是<strong>小而专</strong>，但在起初的设计时，我们只片面的<strong>理解了小却忽视了专</strong>，此时我们才意识到拆分的关键是要保证微服务内高内聚，微服务间低耦合。</p><h3 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a><strong>物联网架构</strong></h3><blockquote><p>物联网是互联网的<strong>外延</strong>。将用户端<strong>延伸</strong>和扩展到物与人的连接。物联网模式中，所有<strong>物品与网络连接</strong>，并进行通信和场景联动。互联网通过<strong>电脑、移动终端</strong>等设备将参与者联系起来，形成的一种全新的<strong>信息互换方式</strong></p></blockquote><h4 id="DCM系统架构"><a href="#DCM系统架构" class="headerlink" title="DCM系统架构"></a>DCM系统架构</h4><ul><li><strong>设备感知层</strong>（Device）：利用射频识别、二维码、传感器等技术进行数据采集</li><li><strong>网络传输层</strong>（Connect）：依托通信网络和协议，实现可信的信息交互和共享</li><li><strong>应用控制层</strong>（Manage）：分析和处理海量数据和信息，实现智能化的决策和控制</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jc1stt3j31380lswso.jpg" alt="image-20210504174337327" style="zoom:50%;"></p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h4><ul><li><strong>设备联网</strong>：通过不同的网络协议和通信标准，实现设备与控制端的连接</li><li><strong>云端分析</strong>：提供监控、存储、分析等数据服务，以及保障客户的业务数据安全</li><li><strong>云边协同</strong>：云端接受设备上报数据，下发设备管控指令</li></ul><h4 id="云-边-端协同"><a href="#云-边-端协同" class="headerlink" title="云 / 边 / 端协同"></a>云 / 边 / 端协同</h4><p><strong>云端计算</strong>、<strong>终端计算</strong>和<strong>边缘计算</strong>是一个协同的系统，根据用户场景、资源约束程度、业务实时性等进行动态调 配，形成可靠、低成本的应用方案。从过去几年的发展积累来看，AI 已在物联网多个层面进行融合，比我们合作的海康威视、旷视宇视、商汤科技等纷纷发布了物联网AI相关平台和产品，和移动和小区进行了紧密的融合。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9kwux9vjj312w0li138.jpg" alt="image-20210202225351673" style="zoom:50%;"></p><h4 id="物联网平台接入"><a href="#物联网平台接入" class="headerlink" title="物联网平台接入"></a>物联网平台接入</h4><p><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/3199158061/p132750.png" alt="企业基于物联网平台的业务链路" style="zoom:50%;"></p><p>向下连接海量设备，支撑设备<strong>数据采集上云</strong>；</p><p>向上通过调用<strong>云端API</strong>将指令下发至设备端，实现<strong>远程控制</strong>。</p><p><strong>上行数据链路</strong></p><ul><li>设备建立<strong>MQTT</strong>长连接，上报数据（发布Topic和Payload）到物联网平台</li><li>物联网平台通过<strong>配置</strong>规则，通过<strong>RocketMQ</strong>、<strong>AMQP</strong>等队列转发到业务平台</li></ul><p><strong>下行指令链路</strong></p><ul><li>业务服务器基于<strong>HTTPS</strong>协议调用的API接口，发布Topic指令到物联网平台。</li><li>物联网平台通过<strong>MQTT</strong>协议，使用发布（指定Topic和Payload）到<strong>设备端</strong>。</li></ul><h4 id="门锁接入"><a href="#门锁接入" class="headerlink" title="门锁接入"></a>门锁接入</h4><p><strong>WIFI门锁</strong>：<strong>非保活</strong> 平常处于断电休眠状态，需要<strong>MCU</strong> <strong>唤醒</strong>才能传输和发送数据</p><p><strong>蓝牙门锁</strong>：<strong>MCU串口对接</strong>和<strong>SDK对接</strong>，近距离<strong>单点登录</strong>和远距离<strong>网关登录</strong></p><p><strong>Zigbee门锁</strong>：<strong>非保活</strong> 但是保持心跳，<strong>MCU</strong>对接，<strong>Zigbee协议</strong>控制。</p><p><strong>NB-Iot门锁</strong>：可以通过<strong>公网</strong>连接，把门禁变成<strong>SAAS</strong>服务，<strong>MCU</strong></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Software-as-a-Service</strong> ，提供给客户的服务是运营商运行在云计算基础设施上的应用程序。<strong>用户可以在各种设备上通过客户端界面访问应用</strong>，例如计算机浏览器。用户不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等资源，一切由 SaaS 提供商管理和运维。</td></tr><tr><td><strong>PaaS</strong></td><td><strong>Platform-as-a-Service</strong>，表示平台即服务理念，客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但<strong>客户能控制部署的应用程序</strong>，也可能控制运行应用程序的托管环境配置。</td></tr><tr><td><strong>IaaS</strong></td><td>I<strong>nfrastructure-as-a-Service</strong> ，表示基础设施即服务理念，提供的服务是对所有计算基础设施的利用，包括 CPU、内存、存储、网络等其它计算资源。<strong>用户能够部署和运行任意软件，包括操作系统和应用程序。</strong></td></tr></tbody></table><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><p><strong>HTTP协议（CS用户上网）</strong></p><p>HTTP协议是典型的CS通讯模式，由<strong>客户端主动</strong>发起连接，向服务器请求<strong>XML或JSON数据</strong>。该协议最早是为了适用web浏览器的<strong>上网浏览场景</strong>和设计的，目前在<strong>PC、手机、pad</strong>等终端上都应用广泛，但并<strong>不适用于物联网场景</strong></p><ul><li>由于必须由设备主动向服务器发送数据，难以主动向设备推送数据。</li><li>物联网场景中的<strong>设备多样</strong>，运算<strong>受限的设备</strong>，难以实现JSON数据格式的解析</li></ul><p><strong>RESTAPI（松耦合调用）</strong></p><p>REST/HTTP主要为了<strong>简化</strong>互联网中的系统架构，<strong>快速实现</strong>客户端和服务器之间交互的<strong>松耦合</strong>，降低了客户端和服务器之间的<strong>交互延迟</strong>。因此适合在物联网的应用层面，通过REST<strong>开放</strong>物联网中资源，实现服务被其他应用所调用。</p><p><strong>CoAP协议（无线传感）</strong></p><blockquote><p>简化了HTTP协议的<strong>RESTful API</strong>，它适用于在<strong>资源受限</strong>的通信的IP网络。</p></blockquote><p><strong>MQTT协议（低带宽）</strong></p><blockquote><p>MQTT协议采用<strong>发布/订阅</strong>模式，物联网终端都通过TCP连接到云端，云端通过主题的方式管理各个设备关注的通讯内容，<strong>负责</strong>将设备与设备之间<strong>消息的转发</strong></p></blockquote><p>适用范围：在低带宽、不可靠的集中<strong>星型网络架构</strong>（hub-and-spoke），不适用设备与设备之间通信，设备<strong>控制能力弱</strong>，另外<strong>实时性较差</strong>，一般都在<strong>秒级</strong>。协议要<strong>足够轻量</strong>，方便嵌入式设备去快速地解析和响应。具备<strong>足够的灵活性</strong>，使其足以为 IoT 设备和服务的多样化提供支持。应该设计为<strong>异步消息协议</strong>，这么做是因为大多数 IoT 设备的网络延迟很可能非常不稳定，若使用同步消息协议，IoT 设备需要等待服务器的响应，必须是<strong>双向通信</strong>，服务器和客户端应该可以互相发送消息。</p><p><strong>AMQP协议（互操作性）</strong></p><blockquote><p>用于业务系统例如PLM，ERP，MES等进行数据交换。</p></blockquote><p>　　适用范围：最早应用于金融系统之间的交易消息传递，在物联网应用中，主要适用于移动手持设备与后台数据中心的通信和分析。</p><p><strong>XMPP协议（即时通信）</strong></p><blockquote><p>开源形式组织产生的网络即时通信协议。被IETF国际标准组织完成了标准化工作</p></blockquote><p>　　适用范围：<strong>即时通信</strong>的应用程序，还能用在<strong>协同工具</strong>、游戏等。</p><p>​    XMPP在通讯的业务流程上是更适合物联网系统的，开发者不用花太多心思去解决设备通讯时的业务通讯流程，相对开发成本会更低。但是HTTP协议中的安全性以及计算资源消耗的硬伤并没有得到本质的解决。</p><p><strong>JMS （Java消息服务）</strong></p><p>​    Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p><strong>Zigbee协议</strong></p><p>​    低功耗，它保持IEEE 802.15.4（2003）标准</p><h3 id="IOT流量洪峰"><a href="#IOT流量洪峰" class="headerlink" title="IOT流量洪峰"></a>IOT流量洪峰</h3><p>智慧社区IOT领域，不管是嵌入式芯片还是应用服务器都需要传递消息，常见上行的消息有：<strong>人脸识别开门、烟感雾感告警</strong>、共享充电桩充电，下行的<strong>广告下发、NB门禁开门指令、</strong>超级门板显示等，由于物联网设备时不时会<strong>故障和断网导致大量的流量洪峰</strong>，传统消息队列需要针对性优化。</p><ul><li><p><strong>上下行拆分</strong></p><p>上行消息特征：并发量<strong>高</strong>、可靠性和<strong>时延性要求低</strong></p><p>下行消息特征：并发量<strong>低</strong>、控制指令的<strong>成功率要求高</strong></p></li><li><p><strong>海量Topic下性能</strong></p><p><strong>Kafka</strong>海量Topic性能会<strong>急剧下降</strong>，Zookeeper协调也有瓶颈</p><p><strong>多泳道消息队列</strong>可以实现IoT消息队列的故障<strong>隔离</strong></p></li><li><p><strong>实时消息优先处理</strong></p><p>NB门禁实时产生的开门指令必须<strong>第一优先级处理</strong>，堆积的消息降级</p><p>设计成<strong>无序、不持久化</strong>的，并与传统的FIFO队列隔离</p></li><li><p><strong>连接、计算、存储分离</strong></p><p>Broker只做<strong>流转分发</strong>，实现<strong>无状态</strong>和<strong>水平扩展</strong></p><p>计算交给<strong>Flink</strong>，存储交给nosqlDB，实现<strong>高吞吐写</strong></p></li><li><p><strong>消息策略-推拉结合</strong></p><p>MQTT针对电池类物联网设备，AMQP针对安全性较高的门禁设备</p><p>消费端离线时存到queue，在线时将<strong>实时消息和从queue中拉取的消息</strong>一起推送</p></li></ul><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goboitd4h2j30u00ciq3i.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>如果解决海量Topic</strong></p><p>​    首先要做的就是分区、分组等水平拆分的方式，接下来考虑单实例如何处理更多Topic，传统消息队列在海量Topic下顺序写会退化成随机写，性能大幅下降</p><ul><li><p><strong>人工Sharding</strong>：部署多个Kafka集群，通过不同mq连接来隔离</p></li><li><p><strong>合并Topic</strong>，客户端封装subTopic。比如一个服务的N个统计项，会消费到无关消息</p><p>​    基于这个思路，使用<strong>Kafka Streams</strong>或者<strong>Hbase列</strong>存储来聚合</p></li></ul><p>针对单个Topic海量订阅的问题，<strong>可以在上层封装广播组件来协调批量发送</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobohzda8fj30u00cgaax.jpg" alt="img" title class>                <p>img</p>            </figure><h3 id="社区直播带货"><a href="#社区直播带货" class="headerlink" title="社区直播带货"></a>社区直播带货</h3><blockquote><p>使用<strong>端 / 边 / 云</strong>三级架构，客户端加密传输，边缘节点转发、云侧转码并持久化</p></blockquote><h4 id="产品的背景"><a href="#产品的背景" class="headerlink" title="产品的背景"></a><strong>产品的背景</strong></h4><blockquote><p>上线时间，从调研到正式上线用了 3个月时间，上线后一个月内就要经历双十二挑战。在这么紧的上线时间要求下，需要用到公司提供的所有优势，包括<strong>cdn网络，直播牌照</strong>等</p></blockquote><h4 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h4><ul><li>直播数据是<strong>实时</strong>生成的，所有不能够进行<strong>预缓存</strong></li><li>直播随时会发生，举办热点活动，相关服务器资源需要<strong>动态分配</strong></li><li><p>直播的延迟对于用户体验影响很大，需要控制在<strong>秒级</strong></p></li><li><p>直播sdk是内嵌在社区应用里的，整体要求不能超过5M</p></li></ul><h4 id="协议的比较"><a href="#协议的比较" class="headerlink" title="协议的比较"></a>协议的比较</h4><table><thead><tr><th>协议</th><th>上线时间</th><th>网络兼容</th><th>端对端延迟</th><th>应用大小</th><th>问题</th></tr></thead><tbody><tr><td>WebRTC</td><td></td><td>✗</td><td></td><td></td><td>Webrtc 基于 UDP，和社区应用的网络架构不兼容</td></tr><tr><td>HTTP Upload</td><td></td><td></td><td>✗</td><td></td><td>会导致网络高延迟</td></tr><tr><td>Custom Protocol</td><td>✗</td><td></td><td></td><td></td><td>工程师需要实现自己的客户端与服务端的库，无法按时上线</td></tr><tr><td>Proprietary</td><td></td><td></td><td></td><td>✗</td><td>协议就需要几兆的空间，超出额度</td></tr><tr><td>RTMPS</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>TCP实时传输消息协议，更安全更可靠</td></tr></tbody></table><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><strong>RTMPS</strong>：基于TCP实时传输消息协议，更安全更可靠</p><p><strong>MPEG-DASH</strong>：是一种基于HTTP协议自适应比特率流媒体技术，应对复杂的环境</p><figure class="image-box">                <img src="https://i.loli.net/2021/01/25/zjwC7B8fdcpDytA.png" alt="image-20210125145103417" title class>                <p>image-20210125145103417</p>            </figure><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播数据到<strong>边缘节点</strong>（POP）</p></li><li><p>POP 使用<strong>RTMP</strong>发送数据到数据中心（DC）</p></li><li><p>DC 将数据编码成<strong>不同的清晰度</strong>并进行持久化存储</p><p><strong>云端转码</strong>主要有<strong>两种分辨率</strong>400x400 和 720x720.</p></li><li><p>播放端通过 <strong>MPEG-DASH</strong> / RTMPS 协议接收直播数据</p><p>如果用户网络不好<strong><a href="https://www.cloudflare.com/zh-cn/learning/video/what-is-mpeg-dash/" target="_blank" rel="noopener">MPEG-DASH</a></strong>会自动转换成低分辨率</p></li></ol><h4 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a><strong>直播流程</strong></h4><p><img src="https://i.loli.net/2021/01/25/GITnbhDqPdtZY2k.png" alt="image-20210125153606264" style="zoom:50%;"></p><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播流数据到 POP 内的就近的代理服务器</p></li><li><p>代理服务器<strong>转发</strong>直播流数据到数据中心的网关服务器（<strong>443转80</strong>）</p></li><li><p>网关服务器使用<strong>直播 id 的一致性哈希算法</strong>发送直播数据到指定的编码服务器</p></li><li><p>编码服务器有几项职责：</p><ul><li><p>4.1 <strong>验证直播数据</strong>的格式是否正确。</p></li><li><p>4.2 <strong>关联</strong>直播 id 以及编码服务器第一映射，保证客户端即使连接中断或者服务器扩容时，在<strong>重新连接</strong>的时候依然能够连接到相同的编码服务器</p></li><li><p>4.3 使用直播数据<strong>编码成不同解析度</strong>的输出数据</p></li><li><p>4.4 使用 <strong>DASH</strong> 协议输出数据并<strong>持久化</strong>存储</p></li></ul></li></ol><h4 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h4><p><img src="https://i.loli.net/2021/01/25/Lo5N8QYlI2DPjyO.png" alt="image-20210125154758184" style="zoom:50%;"></p><ol><li>播放端使用 HTTP <strong>DASH</strong> 协议向 POP 拉取直播数据</li><li>POP 里面的代理服务器会检查数据是否已经在 POP 的<strong>缓存</strong>内。如果是的话，缓存会返回数据给播放端，否则，代理服务器会向 DC 拉取直播数据</li><li>DC 内的代理服务器会检查数据是否在 DC 的缓存内，如果是的话，缓存会返回数据给 POP，并更新 POP 的缓存，再返回给播放端。不是的话，代理服务器会使用一致性哈希算法向对应的编码服务器请求数据，并更新 DC 的缓存，返回到 POP，再返回到播放端。</li></ol><p><strong>收获</strong></p><ol><li>项目的成功不，代码只是内功，考虑适配不同的网络、利用可利用的资源</li><li>惊群效应在热点服务器以及许多组件中都可能发生</li><li>开发大型项目需要对<strong>吞吐量和时延</strong>、<strong>安全和性能</strong>做出妥协</li><li>保证架构的灵活度和可扩展性，为内存、服务器、带宽耗尽做好规划</li></ol><h3 id="直播高可用方案"><a href="#直播高可用方案" class="headerlink" title="直播高可用方案"></a><strong>直播高可用方案</strong></h3><p><strong>网络可靠性</strong>：</p><ul><li>根据<strong>网络连接速度</strong>来自动调整视频质量</li><li>使用<strong>短时间的数据缓存</strong>来解决直播端不稳定，瞬间断线的问题</li><li>根据<strong>网络质量自动降级</strong>为音频直播以及播放</li></ul><p><strong>惊群效应：</strong></p><ul><li>当多个播放端向同一个 POP 请求直播数据的时候，如果数据不在缓存中</li><li>这时候只有一个请求 A 会到 DC 中请求数据，其他请求会等待结果</li><li>但是如果请求 A 超时没有返回数据的话，所有请求会一起向 DC 访问数据</li><li>这时候就会加大 DC 的压力，触发惊群效应</li><li>解决这个问题的方法就是通过<strong>实际的情况</strong>来调整请求超时的时间。这个时间如果太长的话会带来直播的延迟，太短的话会经常触发惊群效应（<strong>每个时间窗口只允许触发一次</strong>，设置允许最大回源数量）</li></ul><h3 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a><strong>性能优化方案</strong></h3><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobogaxxjkj304v0e7t93.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>数据库优化：</strong> 数据库是最容易成为瓶颈的组件，考虑从 SQL 优化或者数据库本身去提高它的性能。如果瓶颈依然存在，则会考虑分库分表将数据打散，如果这样也没能解决问题，则可能会选择缓存组件进行优化</p><p><strong>集群最优：</strong>存储节点的问题解决后，计算节点也有可能发生问题。一个集群系统如果获得了水平扩容的能力，就会给下层的优化提供非常大的时间空间，由最初的 3 个节点，扩容到最后的 200 多个节点，但由于人力问题，服务又没有什么新的需求，下层的优化就一直被搁置着。</p><p><strong>硬件升级：</strong>水平扩容不总是有效的，原因在于单节点的计算量比较集中，或者 JVM 对内存的使用超出了宿主机的承载范围。在动手进行代码优化之前，我们会对节点的硬件配置进行升级。</p><p><strong>代码优化</strong>：代码优化是提高性能最有效的方式，但需要收集一些数据，这个过程可能是服务治理，也有可能是代码流程优化。比如JavaAgent 技术，会无侵入的收集一些 profile 信息，供我们进行决策。</p><p><strong>并行优化：</strong>并行优化是针对速度慢的接口进行并行调用。所以我们通常使用 ContDownLatch 对需要获取的数据进行并行处理，效果非常不错，比如在 200ms 内返回对 50 个耗时 100ms 的下层接口的调用。</p><p><strong>JVM 优化</strong>： JVM 发生问题时，优化会获得巨大的性能提升。但在 JVM 不发生问题时，它的优化效果有限。但在代码优化、并行优化、JVM 优化的过程中，JVM 的知识却起到了关键性的作用</p><p><strong>操作系统优化：</strong>操作系统优化是解决问题的杀手锏，比如像 HugePage、SWAP、“CPU 亲和性”这种比较底层的优化。但就计算节点来说，对操作系统进行优化并不是很常见。运维在背后会做一些诸如文件句柄的调整、网络参数的修改，这对于我们来说就已经够用了</p><h3 id="流量回放自动化测试"><a href="#流量回放自动化测试" class="headerlink" title="流量回放自动化测试"></a>流量回放自动化测试</h3><blockquote><p>系统级的重构，测试回归的工作量至少都是以月为单位，对于人力的消耗巨大。一种应对方案是，先不改造，到系统实在扛不住了再想办法。另一种应对方案是，先暂停需求，全力进行改造。但在实际工作场景中，上述应对策略往往很难实现。</p></blockquote><p>场景：</p><p>1、读服务均是查询，它是无状态的。</p><p>2、不管是架构升级还是日常需求，读服务对外接口的出入参格式是没有变化的</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jd95rpij315g0hqn5q.jpg" alt="image-20210504174447049" style="zoom:50%;"></p><ul><li><p><strong>日志收集</strong>，主要作用是收集被测系统的真实用户请求，基于一定规则处理后作为系统用例；</p><p>Spring 里的 Interceptor 、Servlet 里的 Filter 过滤器，对所有请求的入参和出参进行记录，并通过 MQ 发送出去。（注意错峰、过滤写、去重等）</p></li><li><p>数据回放是基于收集的用例，对被测系统进行数据回放，发起自动化测试回归；</p><p><strong>离线回放：</strong>只调用新服务，将返回的数据和日志里的出参进行比较，<strong>日志比较大</strong></p><p><strong>实时回放：</strong>去实时调用线上系统和被测系统，并存储实时返回回放的结果信息，<strong>线上有负担</strong></p><p><strong>并行回放：</strong>新版本不即时上线，每次调用老版本接口时概率实时回放新版本接口，<strong>耗时间周期</strong></p></li><li><p><strong>差异对比</strong>，通过差异对比自动发现与预期不一致的用例，进而确定 Bug。</p><p>采用文本对比，可以直观地看到哪个字段数据有差异，从而更快定位到问题。正常情况下，只要存在差异的数据，均可认为是 Bug，是需要进行修复的。</p></li></ul><p><strong>方法论</strong></p><p><strong>Discovery</strong></p><p>​                考虑企业战略，分析客户需求，制定产品目标</p><p>​                    由外到内：竞争对手的方案，为什么做，以后怎么发展，如何去优化。</p><p>​                    自上而下：基于公司的战略，考虑自身能力和所处环境。</p><p>​                    自下而上：从资源、历史问题、优先级出发，形成一套可行性实施方法。</p><p><strong>Define</strong></p><p>​                基于收集的信息，综合跨业务线的抽象能力和服务，先做什么后做什么，怎么做</p><p>​                    设计新的架构，重点设计解决痛点问题。</p><p>​                    拆分业务领域，重点划分工作临界上下文。</p><p><strong>Design</strong></p><p>​                详细的业务设计，功能设计，交付计划，考核计划</p><p>​                    产品愿景，产品形态，相关竞品方案对比，价值、优势、收益</p><p>​                    梳理业务范围，要知道电商领域四大流（信息流、商流、资金流、物流）</p><p>​                    MVP最小可用比，让客户和老大看到结果，最后通编写story把故事编圆</p><p><strong>Delivery</strong></p><p>​                交付阶段，根据反馈及时调整中台战略，减少损失和增大收益</p><p>​                    合理制定每个阶段的绩效考核目标：</p><p>​                40%稳定+25%业务创新+20%服务接入+15%用户满意度</p><h1 id="七、架构设计"><a href="#七、架构设计" class="headerlink" title="七、架构设计"></a><strong>七、架构设计</strong></h1><h2 id="1、社区系统的架构"><a href="#1、社区系统的架构" class="headerlink" title="1、社区系统的架构"></a>1、社区系统的架构</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmqv8zyhkqj311s0u0q7s.jpg" alt="image-20210117182546782" style="zoom:40%;"></p><p><strong>系统拆分</strong></p><p>​        通过DDD领域模型，对服务进行拆分，将一个系统拆分为多个子系统，做成SpringCloud的微服务。微服务设计时要尽可能做到少扇出，多扇入，根据服务器的承载，进行客户端负载均衡，通过对核心服务的上游服务进行限流和降级改造。</p><p>​    一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>​    大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成<strong>订单系统、商品系统、采购系统、仓储系统、用户系统</strong>等等吧。</p><p>​    但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了<strong>供应商管理系统、采购单管理系统</strong>，订单系统又拆分成了<strong>购物车系统、价格系统、订单管理</strong>系统。</p><p><strong>CDN、Nginx静态缓存、JVM缓存</strong></p><p>​    利用Java的模板thymeleaf可以将页面和数据动态渲染好，然后通过Nginx直接返回。动态数据可以从redis中获取。其中redis里的数据由一个缓存服务来进行消费指定的变更服务。</p><p>​    商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><p><strong>缓存</strong></p><p>Redis cluster，10 台机器，5主5从，5 个节点对外提供读写服务，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，<strong>5 台机器最多是 25 万读写</strong>请求每秒。</p><p>​    <strong>32G 内存+ 8 核 CPU + 1T</strong> 磁盘，但是分配给 <strong>Redis 进程的是 10g 内存</strong>，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>​    因为每个主实例都挂了一个从实例，所以是<strong>高可用</strong>的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例<strong>会自动变成主实例</strong>继续提供读写服务。</p><p><strong>MQ</strong></p><p>​    可以通过消息队列对微服务系统进行<a href="#1、拆分微服务">解耦</a>，异步调用的更适合微服务的扩展</p><p>​    同时可以应对秒杀活动中<a href="# 6、应对高并发的写请求">应对高并发写请求</a>，比如kafka在毫秒延迟基础上可以实现10w级吞吐量</p><p>​    针对<a href="#IOT流量洪峰">IOT流量洪峰</a>做了一些特殊的优化，保证消息的及时性</p><p>​    同时可以使用消息队列保证分布式系统<a href="#7、如何保证数据一致性">最终一致性</a></p><p><strong>分库分表</strong></p><p>​        分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。<strong>在通讯录、订单和商城商品模块超过千万级别都应及时考虑分表分库</strong></p><p><strong>读写分离</strong></p><p>​        读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。比如<strong>统计监控类的微服务</strong>通过读写分离，只需访问从库就可以完成统计，例如ES</p><p><strong>ElasticSearch</strong></p><p>​        Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的<strong>查询、统计类</strong>的操作，比如<strong>运营平台上</strong>的各地市的汇聚统计，还有一些<strong>全文搜索类</strong>的操作，比如<strong>通讯录和订单</strong>的查询。</p><h2 id="2、商城系统-亿级商品如何存储"><a href="#2、商城系统-亿级商品如何存储" class="headerlink" title="2、商城系统-亿级商品如何存储"></a>2、商城系统-亿级商品如何存储</h2><p>基于 Hash 取模、一致性 Hash 实现分库分表</p><p>高并发读可以通过<a href="5、应对高并发的读请求">多级缓存</a>应对</p><p>大促销热key读的问题通过<a href="**4、热key问题如何解决？**">redis集群+本地缓存+限流+key加随机值</a>分布在多个实例中</p><p>高并发写的问题通过<strong>基于 Hash 取模、一致性 Hash 实现分库分表</strong>均匀落盘</p><p>业务分配不均导致的<strong>热key</strong>读写问题，可以根据业务场景进行range分片，将热点范围下的子key打散</p><p>具体实现：预先设定主键的生成规则，根据规则进行数据的分片路由，但这种方式会侵入商品各条线主数据的业务规则，更好的方式是基于<strong>分片元数据服务器</strong>（即每次访问分片前先询问分片元服务器在路由到实际分片）不过会带来复杂性，比如保证元数据服务器的<strong>一致性</strong>和可用性。</p><h2 id="3、对账系统-分布式事务一致性"><a href="#3、对账系统-分布式事务一致性" class="headerlink" title="3、对账系统-分布式事务一致性"></a>3、对账系统-分布式事务一致性</h2><blockquote><p>尽量避免分布式事务，单进程用数据库事务，跨进程用消息队列</p></blockquote><p>主流实现分布式系统事务一致性的方案：</p><ol><li><strong>最终一致性</strong>：也就是基于 MQ 的可靠消息投递的机制，</li><li>基于重试加确认的的<strong>最大努力通知方案</strong>。</li></ol><p>理论上也可以使用（2PC两阶段提交、3PC三阶段提交、TCC短事务、SAGA长事务方案），但是这些方案工业上落地代价很大，不适合互联网的业界场景。针对金融支付等需要强一致性的场景可以通过前两种方案实现。（<strong>展开说的话参考分布式事务</strong>）</p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh4oifej30xq0auq7p.jpg" alt="image-20210321212516364" title class>                <p>image-20210321212516364</p>            </figure><p>本地数据库事务原理：<strong>undo log</strong>（原子性） + <strong>redo log</strong>（持久性） + <strong>数据库锁</strong>（原子性&amp;隔离性） + <strong>MVCC</strong>（隔离性）</p><p>分布式事务原理：<strong>全局事务协调器（原子性）</strong> + 全局锁（隔离性） + <strong>DB本地事务（原子性、持久性）</strong></p><p>一、我们公司账单系统和第三方支付系统对账时，就采用“<strong>自研补偿/MQ方案 + 人工介入</strong>”方式</p><p>落地的话：方案最“轻”，性能损失最少。可掌控性好，简单易懂，易维护。<br>考虑到分布式事务问题是小概率事件，留有补救余地就行，性能的损失可是实打实的反应在线上每一个请求上</p><p>二、也了解到业界比如阿里成熟<strong>Seata AT</strong>模式，平均性能会降低35%以上</p><p>我觉得不是特殊的场景不推荐</p><p>三、RocketMQ事务消息</p><p>听起来挺好挺简单的方案，但它比较挑业务场景，同步性强的处理链路不适合。<br>【重要】要求下游MQ消费方一定能成功消费消息。否则转人工介入处理。<br>【重要】千万记得实现幂等性。</p><h2 id="4、用户系统-多线程数据割接"><a href="#4、用户系统-多线程数据割接" class="headerlink" title="4、用户系统-多线程数据割接"></a>4、用户系统-多线程数据割接</h2><p>由于项目需要进行数据割接，保证用户多平台使用用户感知的一致，将广东项目的几百万用户及业务数据按照一定的逻辑灌到社区云平台上，由于依赖了第三方统一认证和省侧crm系统，按照之前系统内割接的方法，通过数据库将用户的唯一标识查出来然后使用多线程向省侧crm系统获取结果。</p><p>但是测试的过程中，发现每个线程请求的数据发生了错乱，导致每个请求处理的数据有重复，于是立即停止了脚本，当时怀疑是多线程对资源并发访问导致的，于是把ArrayList 改成了CopyOnWriteArrayList，但是折腾了一晚上，不管怎么修改，线程之间一直有重复数据，叫了一起加班的同事也没看出问题来，和同事估算了一下不使用多线程，大概30-40个小时能跑完，想了下也能接受，本来已经准备放弃了。</p><p>不过回到家，我还是用多线程仔细单步模拟了下，整个处理的过程，发现在起线程的时候，有些子线程并没有把分配给他的全部id的list处理完，导致最终状态没更新，新线程又去执行了一遍，然后我尝试通过修改在线程外深拷贝一个List再作为参数传入到子线程里，（后续clear的时候也是clear老的List）果然，整个测试过程中再也没出现过重复处理的情况。</p><p>事后，我也深究了下原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayBuffer.length == <span class="number">99</span>) &#123;</span><br><span class="line"> val asList = arrayBuffer.toList</span><br><span class="line"> exec.execute ( openIdInsertMethod(asList) )</span><br><span class="line"> arrayBuffer.clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。不过主线程先启动占用了cpu资源，因此主线程总是优于子线程。然而，即使设置了优先级，也无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>所以主线程上的clear操作有可能先执行，那么子线程中未处理完的数据就变成一个空的数组，所以就出现了多个线程出现了重复数据的原因，所以我们要保证的是子线程每次执行完后再进行clear即可。而不是一开始定位的保证ArrayList的安全性。所以将赋值(buffer-&gt;list)操作放在外面去执行后，多线程数据就正常了。</p><h2 id="5、秒杀系统场景设计"><a href="#5、秒杀系统场景设计" class="headerlink" title="5、秒杀系统场景设计"></a>5、秒杀系统场景设计</h2><p><a href="# 二、秒杀项目">见秒杀项目方案设计</a></p><h2 id="6、统计系统-海量计数"><a href="#6、统计系统-海量计数" class="headerlink" title="6、统计系统-海量计数"></a><strong>6、统计系统-海量计数</strong></h2><p><strong>中小规模的计数服务</strong>（万级）</p><p>最常见的计数方案是采用缓存 + DB 的存储方案。当计数变更时，先变更计数 DB，计数加 1，然后再变更计数缓存，修改计数存储的 Memcached 或 Redis。这种方案比较通用且成熟，但在高并发访问场景，支持不够友好。在互联网社交系统中，有些业务的计数变更特别频繁，比如微博 feed 的阅读数，计数的变更次数和访问次数相当，每秒十万到百万级以上的更新量，如果用 DB 存储，会给 DB 带来巨大的压力，DB 就会成为整个计数服务的瓶颈所在。即便采用聚合延迟更新 DB 的方案，由于总量特别大，同时请求均衡分散在大量不同的业务端，巨大的写压力仍然是 DB 的不可承受之重。</p><p><strong>大型互联网场景</strong>（百万级）</p><p>直接把计数全部存储在 Redis 中，通过 hash 分拆的方式，可以大幅提升计数服务在 Redis 集群的写性能，通过主从复制，在 master 后挂载多个从库，利用读写分离，可以大幅提升计数服务在 Redis 集群的读性能。而且 Redis 有持久化机制，不会丢数据</p><p>一方面 Redis 作为通用型存储来存储计数，内存存储效率低。以存储一个 key 为 long 型 id、value 为 4 字节的计数为例，Redis 至少需要 65 个字节左右，不同版本略有差异。但这个计数理论只需要占用 12 个字节即可。内存有效负荷只有 12/65=18.5%。如果再考虑一个 long 型 id 需要存 4 个不同类型的 4 字节计数，内存有效负荷只有 (8+16)/(65*4)= 9.2%。</p><p>另一方面，Redis 所有数据均存在内存，单存储历史千亿级记录，单份数据拷贝需要 10T 以上，要考虑核心业务上 1 主 3 从，需要 40T 以上的内存，再考虑多 IDC 部署，轻松占用上百 T 内存。就按单机 100G 内存来算，计数服务就要占用上千台大内存服务器。存储成本太高。</p><p><strong>微博、微信、抖音</strong>（亿级）</p><p>定制数据结构，共享key 紧凑存储，提升计数有效负荷率</p><p>超过阈值后数据保存到SSD硬盘，内存里存索引</p><p>冷key从SSD硬盘中读取后，放入到LRU队列中</p><p>自定义主从复制的方式，海量冷数据异步多线程并发复制</p><h2 id="7、系统设计-微软"><a href="#7、系统设计-微软" class="headerlink" title="7、系统设计 - 微软"></a>7、系统设计 - 微软</h2><h3 id="1、需求收集"><a href="#1、需求收集" class="headerlink" title="1、需求收集"></a><strong>1、需求收集</strong></h3><p>确认<strong>使用的对象</strong>（ToC：高并发，ToB：高可用）</p><p><strong>系统的服务场景</strong>（<strong>即时通信</strong>：低延迟，<strong>游戏</strong>：高性能，<strong>购物</strong>：秒杀-一致性）</p><p><strong>用户量级</strong>（<strong>万级</strong>：双机、<strong>百万</strong>：集群、<strong>亿级</strong>：弹性分布式、容器化编排架构）</p><p><strong>百万读</strong>：3主6从，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，可以实现15万，30万读性能</p><p><strong>亿级读</strong>，通过CDN、静态缓存、JVM缓存等多级缓存来提高读并发</p><p><strong>百万写</strong>，通过消息队列削峰填谷，通过hash分拆，水平扩展分布式缓存</p><p><strong>亿级写</strong>，redis可以定制数据结构、SSD+内存LRU、冷数据异步多线程复制</p><p>持久化，（Mysql）承受量约为 1K的QPS，读写分离提升<strong>读并发</strong>，分库分表提升<strong>写并发</strong></p><h3 id="2、顶层设计"><a href="#2、顶层设计" class="headerlink" title="2、顶层设计"></a><strong>2、顶层设计</strong></h3><p>核心功能包括什么：</p><p>写功能：发送微博</p><p>读功能：热点资讯</p><p>交互：点赞、关注</p><h3 id="3、系统核心指标"><a href="#3、系统核心指标" class="headerlink" title="3、系统核心指标"></a><strong>3、系统核心指标</strong></h3><ul><li>系统<strong>性能</strong>和<strong>延迟</strong><ul><li>边缘计算 | 动静分离 | 缓存 |  多线程 |</li></ul></li><li><strong>可扩展性</strong>和<strong>吞吐量</strong><ul><li>负载均衡 | 水平扩展 | 垂直扩展 | 异步 | 批处理 | 读写分离</li></ul></li><li><strong>可用性</strong>和<strong>一致性</strong><ul><li>主从复制 | 哨兵模式 | 集群 | 分布式事务</li></ul></li></ul><h3 id="4、数据存储"><a href="#4、数据存储" class="headerlink" title="4、数据存储"></a>4、数据存储</h3><p>键值存储 : Redis ( 热点资讯 )</p><p>文档存储 : MongoDB ( 微博文档分类)</p><p>分词倒排：Elasticsearch（搜索）</p><p>列型存储：Hbase、BigTable（大数据）</p><p>图形存储：Neo4j （社交及推荐）</p><p>多媒体：FastDfs（图文视频微博）</p><h2 id="7、如何设计一个微博"><a href="#7、如何设计一个微博" class="headerlink" title="7、如何设计一个微博"></a>7、如何设计一个微博</h2><p><strong>实现哪些功能：</strong></p><p>筛选出核心功能（Post a Tweet，Timeline，News Feed，Follow/Unfollow a user，Register/Login）</p><p><strong>承担多大QPS：</strong></p><p>QPS = 100，那么用我的笔记本作Web服务器就好了</p><p>QPS = 1K，一台好点的Web 服务器也能应付，需要考虑单点故障；</p><p>QPS = 1m，则需要建设一个1000台Web服务器的集群，考虑动态扩容、负载分担、故障转移</p><p>一台 SQL Database （Mysql）承受量约为 1K的QPS；</p><p>一台 NoSQL Database (Redis) 约承受量是 20k 的 QPS；</p><p>一台 NoSQL Database (Memcache) 约承受量是 200k 的 QPS；</p><p><strong>微服务战略拆分</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqql81gj30p20c5q45.jpg" alt="img" style="zoom:67%;"></p><p><strong>针对不同服务选择不同存储</strong></p><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-13cab4d5f56e3ecb682c351c0eb4a24b_1440w.jpg?source=1940ef5c" alt="img" title class>                <p>img</p>            </figure><p><strong>设计数据表的结构</strong></p><figure class="image-box">                <img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruu4homyj31400ht405.jpg" alt="img" title class>                <p>img</p>            </figure><p>基本差不多就形成了一个解决方案，但是并不是完美的，仍然需要小步快跑的不断的针对<strong>消息队列、缓存、分布式事务、分表分库、大数据、监控、可伸缩</strong>方面进行优化</p><h1 id="八、领域模型落地"><a href="#八、领域模型落地" class="headerlink" title="八、领域模型落地"></a>八、领域模型落地</h1><h3 id="1、拆分微服务"><a href="#1、拆分微服务" class="headerlink" title="1、拆分微服务"></a>1、拆分微服务</h3><blockquote><p>​    微服务内高内聚，微服务间低耦合</p></blockquote><p><strong>微服务内高内聚</strong>即单一职责原则</p><p>​    每个微服务中的代码变化都是同一类原因。因这类原因而需要变更的代码都在这个微服务中，与其他微服务无关，那么就可以将代码修改的范围缩小到这个微服务内。把这个微服务修改好了，独立修改、独立发布，该需求就实现了。这样，微服务的优势才能发挥出来。</p><p><strong>微服务间低耦合</strong>开放封闭原则</p><p>​    就是说在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，就应当将这些过程交给其他微服务去实现，你只需要对它的接口进行调用。这样，微服务之间的调用就实现了解耦。</p><p>​    <strong>领域建模</strong>就是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景，每个子域的边界就是“<strong>限界上下文</strong>”。该业务场景会涉及许多领域对象，但<strong>分析建模</strong>始终需要围绕着业务场景的上下文进行。</p><p>​    <strong>领域事件通知机制</strong>最有效的方式就是通过消息队列，实现领域事件在微服务间的通知。</p><blockquote><p>“核心通讯录”微服务只负责发送变更消息到消息队列，不管谁会接收并处理这些消息；</p><p>“门禁管理”微服务只负责接收照片变更消息，不管谁发送的这个消息。</p></blockquote><h3 id="2、关联微服务"><a href="#2、关联微服务" class="headerlink" title="2、关联微服务"></a>2、关联微服务</h3><ol><li><p>按照<strong>限界上下文</strong>进行微服务的拆分，将领域模型<strong>划分到多个问题子域</strong></p></li><li><p>基于<strong>充血模型</strong>与<strong>贫血模型</strong>设计各个微服务的业务领域层（Service、Entity、Value）</p></li><li><p>通过<strong>领域事件通知机制</strong>和<strong>微服务调用</strong>的推拉结合，将各个子域进行解耦关联</p><ul><li><strong>核心</strong>：</li></ul></li></ol><ul><li><p>通讯录 | 短信 | 推送通知 | 支付 | 文件服务</p></li><li><p><strong>智慧通行</strong></p><blockquote><p>解决物业多品牌、多系统应用造成的<strong>信息孤岛</strong>，<strong>数据混乱</strong>的问题</p></blockquote><ul><li>人脸门禁 | 可视对讲 | 电梯梯控 | 停车系统 | 访客预约</li></ul></li><li><p><strong>安全社区</strong></p><blockquote><p>通过<strong>图像视频识别</strong>、<strong>传感数据采集</strong>，实现<strong>报警联动</strong>和<strong>风险预警</strong></p></blockquote><ul><li>视频监控 | 周界报警 | 高空抛物 | 跨域追踪</li></ul></li><li><p><strong>全屋智能</strong></p><blockquote><p>围绕业主需求，逐步引入社区医疗、社区养老、<strong>社区团购</strong>、<strong>社区家政</strong>等服务</p></blockquote><ul><li>超级面板 | 无线门锁 | 烟感雾感</li></ul></li><li><p><strong>增值服务</strong></p><blockquote><p>实现跨品牌的产品体验，支持基于<strong>matrix引擎</strong>的智能生活场景裂变能力</p></blockquote><ul><li>智能充电 | 云广播 | 出入提醒 | 定向投放</li></ul></li></ul><h3 id="3、微服务的落地"><a href="#3、微服务的落地" class="headerlink" title="3、微服务的落地"></a><strong>3、微服务的落地</strong></h3><blockquote><p>​    通过合理的微服务设计，尽量让每次的需求变更都交给某个小团队独立完成，让需求变更落到某个微服务上进行变更。唯有这样，每次变更只需独立地修改这个微服务，独立打包、独立升级，新需求独立实现，才能发挥微服务的优势。</p></blockquote><ul><li><strong>数据隔离：</strong>数据库中用户信息表的读写只有<strong>通讯录</strong>微服务。当其他微服务需要读写用户信息时，就不能直接读取用户信息表，而是通过 API 接口去调用<strong>通讯录</strong>微服务。</li><li><strong>接口复用：</strong>因此，当多个团队向你提需求时，必须要对这些接口进行规划，通过复用<strong>尽可能少的接口满足他们的需求；</strong>当有新的接口提出时，要尽量通过现有接口解决问题。</li><li><strong>向前兼容：</strong>当调用方需要接口变更时怎么办？变更现有接口应当尽可能向前兼容，即接口的名称与参数都不变，只是在内部增加新的功能。<strong>宁愿增加一个新的接口也最好不要去变更原有的接口。</strong></li><li><strong>本地调用：</strong>在<strong>访客申请</strong>微服务的本地，增加一个<strong>查询用户Service</strong>的 feign 接口。这样，<strong>访客申请Service</strong>就像本地调用一样调用<strong>查询用户Service</strong>，再通过 feign 接口实现远程调用。这种<strong>防腐层</strong>的设计，可以隔离当前微服务以外的其他微服务拆分变更导致的接口的失效的影响。</li><li><p><strong>数据库去中心化：</strong></p><ul><li>微服务中<strong>通讯录服务</strong>与<strong>健康码服务</strong>分别对应的<strong>用户库与权限库</strong>，它们的共同特点是数据量小但频繁读取，可以选用小型的 MySQL 数据库并在前面架设 Redis 来提高查询性能；</li><li>微服务中<strong>访客通行</strong>与<strong>生活缴费</strong>分别对应的<strong>通行记录库、订单库</strong>，其特点是数据量大并且高并发写，选用一个数据库显然扛不住这样的压力，因此可以选用了 TiDB 这样的 NewSQL 数据库进行分布式存储，将数据压力分散到多个数据节点中，从而解决 I/O 瓶颈；</li><li>微服务中<strong>数据分析</strong>与<strong>通讯录查询</strong>这样的查询分析业务，则选用 <strong>NoSQL 数据库</strong>或<strong>大数据平台</strong>，通过读写分离将生产库上的数据同步过来进行分布式存储，然后宽表一系列的预处理，应对海量历史数据的决策分析与秒级查询。（ NoSQL 为空的字段是不占用空间的，因此字段再多都不影响查询性能）</li></ul></li></ul><h3 id="4、领域模型的意义"><a href="#4、领域模型的意义" class="headerlink" title="4、领域模型的意义"></a>4、领域模型的意义</h3><p>​    <strong>贫血模型、充血模型、策略模式、装饰者模式</strong>只是DDD实现的方式，而DDD的真谛是<strong>领域建模</strong>。</p><p>​    做事不能仅凭一腔热血，一定要符合自然规律。其实软件的设计开发过程也是这样。对业务理解不深刻全局架构设计往往是过度设计，这时候<strong>应该抓主要流程</strong>，开始领域建模。</p><ul><li>接着，每次添加新功能的时候，一方面要满足当前的需求，另一方面业务相关的<strong>领域建模设计</strong>刚刚满足需求，从而使设计最简化、代码最少。</li><li>这样的设计过程叫<strong>小步快跑</strong>。采用小步快跑的设计方法，一开始不用思考那么多问题，从简单问题开始逐步深入。<strong>领域模型</strong>就像小树一样一点儿一点儿成长，最后完成所有的功能。</li></ul><blockquote><p>保持软件设计不退化的关键在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计，才能保证软件以一种良性循环的方式不断维护下去。</p></blockquote><p>​    有没有一种方法，让我们在第十次变更、第二十次变更、第三十次变更时，依然能够找到正确的设计呢？有，那就是<strong>领域驱动设计</strong></p><p>​    那么在每次需求变更时，将变更还原到真实世界中，看看真实世界是什么样子的，根据真实世界进行变更。</p><h3 id="5、战略建模"><a href="#5、战略建模" class="headerlink" title="5、战略建模"></a>5、战略建模</h3><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jet6kizj310c0ngtp4.jpg" alt="image-20210504174616848" style="zoom:50%;"></p><h3 id="6、相关名词"><a href="#6、相关名词" class="headerlink" title="6、相关名词"></a><strong>6、相关名词</strong></h3><p><strong>领域和子域（Domain/Subdomain）</strong></p><p>​    在<strong>上下文地图</strong>构建的领域中，对应模块，使用<strong>限界上下文</strong>划分领域，对应微服务</p><p><strong>限界上下文（Bounded Context）</strong></p><p>​    在一个领域/子域中，有概念上的领域边界，任何<strong>领域对象</strong>在该边界内部的有不依赖外部的确切含义。</p><p><strong>领域对象</strong></p><p>​    服务、实体与值对象是领域驱动设计的领域对象，可以通过<strong>贫血模型</strong>和<strong>充血模型</strong>转换为程序设计</p><p><strong>实体和值对象</strong></p><p>​    通过一个<strong>唯一标识字段来区分</strong>真实世界中的每一个个体的领域对象，称为实体。真实世界中那些<strong>一成不变的</strong>、本质性的事物的领域对象，称为值对象。    <strong>可变性</strong>是实体的特点，而<strong>不变性</strong>则是值对象的本质。</p><p><strong>贫血模型与充血模型</strong></p><p>​    POJO对象中只保存get/set方法，没有任何业务逻辑，这样的设计被称为<strong>贫血模型</strong></p><p>​    <strong>充血模型</strong>是封装和继承思想的体现，门禁设备实体中，包含特征值下发、广告下发、通行记录回调等方法，不同厂商的实体针对多态进行<strong>聚合</strong>，并通过<strong>工厂或仓库</strong>对外提供服务。在充血模型中， Service 只干一件非常简单的事，就是直接去调用对象中的<strong>工厂方法</strong>生成不同产品，其他的什么都不干。</p><p><strong>聚合</strong></p><p>​    聚合体现的是一种<strong>整体与部分</strong>的关系。正是因为有这样的关系，在操作整体的时候，整体就封装了对部分的操作。如何正确理解是否存在聚合的关系：就是当<strong>整体不存在</strong>时，部分就变得<strong>没有了意义</strong>。部分是整体的一个部分，与<strong>整体有相同的生命周期</strong>。</p><p><strong>工厂</strong></p><p><strong>通过装配，创建领域对象，是领域对象生命周期的起点。</strong>譬如，系统要通过 ID 装载一个访客申请：</p><ol><li><p>表单工厂分别调用表单信息DAO、表单明细 DAO 和用户DAO 去进行查询；</p></li><li><p>将得到的表单明细对象、用户对象进行装配，分别 set 到<strong>表单信息对象</strong>的<strong>表单明细</strong>与<strong>用户属性</strong>中；</p></li><li>最后，表单工厂将装配好的表单对象返回给表单仓库。</li></ol><p><strong>仓库</strong></p><p>​    如果服务器是一个非常强大的服务器，那么我们不需要任何数据库。系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。</p><ul><li><p>当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到<strong>缓存中进行查找</strong>：</p></li><li><p>查找到了，则<strong>直接返回</strong>，不需要查询数据库；</p></li><li><p>没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后<strong>装配成领域对象返回给仓库</strong>。</p></li><li><p>仓库在收到这个领域对象以后，在返回给客户程序的同时，将该<strong>对象放到缓存中</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> 面试 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理 | 浮点数二进制表示问题</title>
      <link href="/2022/01/02/double-problem/"/>
      <url>/2022/01/02/double-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="浮点数问题"><a href="#浮点数问题" class="headerlink" title="浮点数问题"></a>浮点数问题</h2><p>关于浮点的问题，大概问题就是 <strong>0.1 + 0.2 == 0.3 ？ 0.8-0.6 == 0.6-0.4 ？</strong></p><p><img src="640.png" alt="图片"></p><p>今天，我就借机会，再跟大家一起来探讨探讨关于浮点数的几个问题：</p><ul><li>为什么负数要用补码表示？</li><li>十进制小数怎么转成二进制？</li><li>计算机是怎么存小数的？</li><li>0.1 + 0.2 == 0.3 吗？</li><li>…</li></ul><p>你能清晰的回答上述的问题吗，本篇文章将为你揭晓。详细原理请看完原文（值得收藏），<strong>文末有精简版回答，</strong>另送一份不错的计算机基础总结。</p><p>##</p><h3 id="为什么负数要用补码表示？"><a href="#为什么负数要用补码表示？" class="headerlink" title="为什么负数要用补码表示？"></a>为什么负数要用补码表示？</h3><p>十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，贴心的小林在和你一起回忆一下。</p><p>十进制数转二进制采用的是<strong>除 2 取余法</strong>，比如数字 8 转二进制的过程如下图：<br><figure class="image-box">                <img src="image-20220317221134764.png" alt="image-20220317221134764" title class>                <p>image-20220317221134764</p>            </figure></p><p>接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。</p><p>我们以 <code>int</code> 类型的数字作为例子，int 类型是 <code>32</code> 位的，其中<strong>最高位是作为「符号标志位」</strong>，正数的符号位是 <code>0</code>，负数的符号位是 <code>1</code>，<strong>剩余的 31 位则表示二进制数据</strong>。</p><p>那么，对于 int 类型的数字 1 的二进制数表示如下：</p><figure class="image-box">                <img src="image-20220317221206091.png" alt="image-20220317221206091" title class>                <p>image-20220317221206091</p>            </figure><p>而负数就比较特殊了点，负数在计算机中是以「补码」表示的，<strong>所谓的补码就是把正数的二进制全部取反再加 1</strong>，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：<br><figure class="image-box">                <img src="image-20220317221229902.png" alt="image20220317221229902" title class>                <p>image20220317221229902</p>            </figure></p><p>不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：</p><figure class="image-box">                <img src="image-20220317221331114.png" alt="image-20220317221331114" title class>                <p>image-20220317221331114</p>            </figure><p>如果采用这种方式来表示负数的二进制的话，试想一下 <code>-2 + 1</code> 的运算过程，如下图：</p><figure class="image-box">                <img src="image-20220317221349797.png" alt="image-20220317221349797" title class>                <p>image-20220317221349797</p>            </figure><p>按道理，<code>-2 + 1 = -1</code>，但是上面的运算过程中得到结果却是 <code>-3</code>，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。</p><p>到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。</p><p>如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，<strong>还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法</strong>，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。</p><p><strong>而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的</strong>。你可以看到下图，用补码表示的负数在运算 <code>-2 + 1</code> 过程的时候，其结果是正确的：</p><figure class="image-box">                <img src="image-20220317221501759.png" alt="image-20220317221501759" title class>                <p>image-20220317221501759</p>            </figure><hr><h3 id="十进制小数与二进制的转换"><a href="#十进制小数与二进制的转换" class="headerlink" title="十进制小数与二进制的转换"></a>十进制小数与二进制的转换</h3><p>好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是<strong>乘 2 取整法</strong>，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。</p><p>话不多说，我们就以 <code>8.625</code> 转二进制作为例子，直接上图：<figure class="image-box">                <img src="image-20220317221415903.png" alt="image-20220317221415903" title class>                <p>image-20220317221415903</p>            </figure></p><p>最后把「整数部分 + 小数部分」结合在一起后，其结果就是 <code>1000.101</code>。</p><p>但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制，如果我们用相同的方式，来把 <code>0.1</code> 转换成二进制，过程如下：</p><figure class="image-box">                <img src="image-20220317221533644.png" alt="image-20220317221533644" title class>                <p>image-20220317221533644</p>            </figure><p>可以发现，<code>0.1</code> 的二进制表示是无限循环的，<strong>由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况</strong>。</p><p>对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是<strong>负数</strong>，比如二进制 <code>0.1</code> 转成十进制就是 <code>2^(-1)</code>，也就是十进制 <code>0.5</code>，二进制 <code>0.01</code> 转成十进制就是 <code>2^-2</code>，也就是十进制 <code>0.25</code>，以此类推。</p><p>举个例子，二进制 <code>1010.101</code> 转十进制的过程，如下图：</p><figure class="image-box">                <img src="image-20220317221547757.png" alt="image-20220317221547757" title class>                <p>image-20220317221547757</p>            </figure><h3 id="计算机是怎么存小数的？"><a href="#计算机是怎么存小数的？" class="headerlink" title="计算机是怎么存小数的？"></a>计算机是怎么存小数的？</h3><p><code>1000.101</code> 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。</p><p>然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是<strong>浮点数</strong>，名字里的「浮点」表示小数点是可以浮动的，比如 <code>1000.101</code> 这个二进制数，可以表示成 <code>1.000101 x 2^(-3)</code>，类似于数学上的科学记数法。</p><p>既然提到了科学计数法，我再帮大家复习一下，比如有个很大的十进制数 1230000，我们可以也可以表示成 <code>1.23 x 10^6</code>，这种方式就称为科学记数法，该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为<strong>规格化</strong>，比如 <code>1.0 x 10^(-9)</code> 是规格化的科学记数法，而 <code>0.1 x 10^(-9)</code> 和 <code>10.0 x 10^(-9)</code> 就不是了。</p><p>因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1，所以通常将 <code>1000.101</code> 这种二进制数，表示成 <code>1.000101 x 2^(-3)</code>，其中，最为关键的是 000101 和 -3 这两个东西，它就可以包含了这个二进制小数的所有信息，<code>000101</code> 称为<strong>尾数</strong>，即小数点后面的数字，<code>-3</code> 称为<strong>指数</strong>，指定了小数点在数据中的位置。</p><p>现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：</p><figure class="image-box">                <img src="image-20220317221604642.png" alt="image-20220317221604642" title class>                <p>image-20220317221604642</p>            </figure><p>这三个重要部分的意义如下：</p><ul><li><em>符号位</em>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li><em>指数位</em>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<strong>指数位的长度越长则数值的表达范围就越大</strong>；</li><li><em>尾数位</em>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<strong>尾数的长度决定了这个数的精度</strong>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p>用 <code>32</code> 位来表示的浮点数，则称为<strong>单精度浮点数</strong>，也就是我们编程语言中的 <code>float</code> 变量，而用 <code>64</code> 位来表示的浮点数，称为<strong>双精度浮点数</strong>，也就是 <code>double</code> 变量，它们的结构如下：</p><figure class="image-box">                <img src="image-20220317221617081.png" alt="image-20220317221617081" title class>                <p>image-20220317221617081</p>            </figure><p>可以看到：</p><ul><li>double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 <code>log10(2^53)</code> 约等于 <code>15.95</code> 和 <code>log10(2^24)</code>约等于 <code>7.22</code> 位，因此 double 的有效数字是 <code>15~16</code> 位，float 的有效数字是 <code>7~8</code>位，这些是有效位是包含整数部分和小数部分；</li><li>double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；</li></ul><p>那二进制小数，是如何转换成二进制浮点数的呢？我们就以 <code>10.625</code> 作为例子，看看这个数字在 float 里是如何存储的。</p><figure class="image-box">                <img src="image-20220317221632966.png" alt="image-20220317221632966" title class>                <p>image-20220317221632966</p>            </figure><p>首先，我们计算出 10.625 的二进制小数为 1010.101，然后<strong>把小数点，移动到第一个有效数字后面</strong>，即将 1010.101 右移 <code>3</code> 位成 <code>1.010101</code>，右移 3 位就代表 +3，左移 3 位就是 -3，<strong>float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了</strong>，即指数位这 8 位存的是 <code>10000010</code>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。</p><p><code>1.010101</code> 这<strong>小数点右侧的数字就是 float 里的「尾数位」</strong>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <code>01010100000000000000000</code>。</p><p>在算指数的时候，你可能会有疑问为什么要加上偏移量呢？</p><p>前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<strong>无符号整数</strong>，float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <code>-127 ~ +128</code>，于是为了把指数转换成无符号整数，就要加个<strong>偏移量</strong>，比如 float 的指数偏移量是 <code>127</code>，这样指数就不会出现负数了。</p><p>比如，指数如果是 8，则实际存储的指数是 8 + 127 = 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去偏移量即可。</p><p>细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里，这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<strong>既然这一位永远都是 1，那就可以不用存起来了</strong>，于是就让 23 位尾数只存储小数部分，电路在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。</p><p>那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：</p><figure class="image-box">                <img src="image-20220317221704420.png" alt="image-20220317221704420" title class>                <p>image-20220317221704420</p>            </figure><hr><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 == 0.3 ?"></a>0.1 + 0.2 == 0.3 ?</h3><p>前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。</p><p>因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值，现在基本都是用 IEEE 754 规范的单精度浮点类型或双精度浮点类型来存储小数的，根据精度的不同，近似值也会不同。</p><p>那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？偷个懒，我就不自己手动算了，可以使用 binaryconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：</p><figure class="image-box">                <img src="640-164752616810917" alt="图片" title class>                <p>图片</p>            </figure><p>可以看到，8 位指数部分是 <code>01111011</code>，23 位的尾数部分是 <code>10011001100110011001101</code>，可以看到尾数部分是 <code>0011</code> 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。</p><p>接下来，我们看看 0.2 的 float 浮点数：</p><figure class="image-box">                <img src="image-20220317221801214.png" alt="image-20220317221801214" title class>                <p>image-20220317221801214</p>            </figure><p>可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101 和 0.1 的尾数部分是相同的，也是一个近似值。</p><p>0.1 的二进制浮点数转换成十进制的结果是</p><figure class="image-box">                <img src="image-20220317221818356.png" alt="image-20220317221818356" title class>                <p>image-20220317221818356</p>            </figure><figure class="image-box">                <img src="image-20220317221850892.png" alt="image-20220317221850892" title class>                <p>image-20220317221850892</p>            </figure><p>所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3，这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p><p>我们在 JavaScript 里执行 0.1 + 0.2，你会得到下面这个结果：</p><figure class="image-box">                <img src="640.png" alt="图片" title class>                <p>图片</p>            </figure><p>结果和我们前面推到的类似，因为 JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的，而我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是例如 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。</p><p>我们人类熟悉的十进制运算系统，可以精准表达 2 和 5 除尽的数字，例如1/2, 1/4, 1/5(0.2), 1/8, 1/10(0.1)。当然，十进制也有无法除尽的地方，例如 1/3, 1/7，也需要根据精度舍入。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，再来回答开头多问题。</p><blockquote><p>为什么负数要用补码表示？</p></blockquote><p>负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。</p><blockquote><p>十进制小数怎么转成二进制？</p></blockquote><p>十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。</p><blockquote><p>计算机是怎么存小数的？</p></blockquote><p>计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：</p><ul><li>符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；</li><li>指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；</li><li>尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；</li></ul><p>用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。</p><blockquote><p>0.1 + 0.2 == 0.3 吗？</p></blockquote><p>不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。</p><p>因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。</p><p>0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求众数II （摩尔投票法）用类似俄罗斯方块消除的游戏例子讲解</title>
      <link href="/2021/12/14/majority-element-ii/"/>
      <url>/2021/12/14/majority-element-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>求众数 II<br>给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。<br>示例 1：</p><p>输入：[3,2,3]<br>输出：[3]<br>示例 2：</p><p>输入：nums = [1]<br>输出：[1]</p><p>示例 3：<br>输入：[1,1,1,3,3,2,2,2]<br>输出：[1,2]</p><p>提示：<br>1 &lt;= nums.length &lt;= 5 * 104<br>-109 &lt;= nums[i] &lt;= 109<br>进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p></blockquote><h1 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我从设计一个游戏入手，为你讲解摩尔投票的思路。</p><h3 id="设计一款类似俄罗斯方块的简单消除游戏"><a href="#设计一款类似俄罗斯方块的简单消除游戏" class="headerlink" title="设计一款类似俄罗斯方块的简单消除游戏"></a>设计一款类似俄罗斯方块的简单消除游戏</h3><p>游戏主板块是<strong>三个纵向列队槽</strong>组成的无上限空间，如图。设计一下落方块数组，比如 [A,A,A,B,B,C]，一个方块能占一个槽位。</p><p>元素方块按数组顺序轮流出现，落入板块中。你将左右移动操作下落中的方块，直到下降至其中一个槽位，完成方块堆叠。<em>（其实就是俄罗斯方块的玩法）</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|口口口|    &lt;--方块从上向下堆叠</span><br><span class="line">|口口口|</span><br><span class="line">|口口口|      </span><br><span class="line">|口口口|       </span><br><span class="line">|口口口|    &lt;--&quot;口&quot;是槽位，有三列           </span><br><span class="line">--------</span><br></pre></td></tr></table></figure></p><p>我们的规则是：<strong>当一层填满，且元素均不相同，该层立马发生消除</strong>。消除后剩余方块最少则胜利。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|口口口|        |口口口|</span><br><span class="line">|口口口|  ==&gt;   |口口口|</span><br><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|        |A 口口|</span><br><span class="line">|A̶ ̶B̶ ̶C̶ | 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>根据规则，一旦同一层出现相同元素，则无法消除，因此我们要保证同一层均不相同，采取攻略：<strong>遇到相同元素叠在一起，遇到不同元素则放在其他槽位，最后使一层填满并完成消除</strong>。这样会发现，底层总是在消除，所以<strong>必定会有一列是空队槽</strong>。</p><p>试一局就清楚了，数组：[A,B,C,A,B,C,A,B,C,A,A,B]<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,B,C 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,A   相同，堆叠在左边槽位，此时面板左边存储了AA<br>B    与A不相同，放在不同槽位，此时面板左边存储了AA，中间存储B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|  ==&gt;   |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |A 口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ | 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>按照图中堆叠，<strong>抵消后剩下结果A B，由于数组只有ABC三种元素，那么剩下结果都是个数超过N/3的元素。</strong></p><p>再试一局，数组：[X,Y,B,Q,R,T,A,A,B,C,A,B]<br>X,Y,B 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>Q,R,T 不相同，各放在不同槽位，一层满则消除，此时面板存储为空<br>A,A   相同，堆叠在左边槽位，此时面板左边存储了AA<br>B    与A不相同，放在不同槽位，此时面板左边存储了AA，中间存储B<br>C    与A，B不相同，放在不同槽位，A,B,C一层满消除，，此时面板左边存储了AA，中间存储B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|A 口口|        |口口口|</span><br><span class="line">|A B 口|  ==&gt;   |口口口|</span><br><span class="line">|A̶̶̶ ̶B̶ ̶C̶ |        |口口口|</span><br><span class="line">|̶Q̶ ̶R̶ ̶T̶ |        |A 口口|</span><br><span class="line">|̶X̶ ̶Y̶ ̶B̶ ̶| 消除   |A B 口|  ↓</span><br><span class="line">--------        --------</span><br></pre></td></tr></table></figure></p><p>按照图中堆叠，<strong>抵消后剩下结果A B，由于数组本身没有个数超过N/3的元素，说明剩下的元素也没有个数超过N/3的</strong>。</p><p>就是说，在每遇3个不同元素就互相抵消的玩法下，如果存在数量超过N/3的元素，抵消后一定有此元素的剩余；但剩余的，不一定都是数量超过N/3的元素。</p><p><strong>所以，我们只需要取得消除后剩余的元素，通过遍历数组对其计数，判断个数是否满足大于N/3即可得到本题的答案</strong></p><h3 id="游戏替换成摩尔投票"><a href="#游戏替换成摩尔投票" class="headerlink" title="游戏替换成摩尔投票"></a>游戏替换成摩尔投票</h3><p>每次元素方块下落，就相当于对其元素的一次投票。<br>当一层的每个槽位（候选人）都有一票，因为这些票不影响最终结果，互相进行抵消。<br>被投票个数超过N/3一定会留到最后不被消除。</p><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ol><li>初始化两个槽位以及其存储元素个数。<br><em>（为什么不定义三个槽位？ 有一个槽位必然用于抵消掉其他槽位，存储元素必是0，只需关注其他槽位存储情况即可）</em></li><li>优先进槽位1，当前元素与槽位1相同元素则堆叠，不符合则入槽位2</li><li>入槽位2时，当前元素与槽位2相同元素则堆叠；不符合则入空队槽</li><li>优先入空槽1，否则空槽2，否则入剩余槽</li><li>入剩余槽时，会与其他槽发生一次抵消，此槽又变回空槽</li><li>最后获得剩下在队槽的元素，并数出对应元素在数组中的个数是否满足大于 N/3<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化两个槽位以及其存储元素个数。</span></span><br><span class="line">        <span class="comment">//（为什么不定义三个槽位？ 有一个槽位必然用于抵消掉其他槽位，存储元素必是0，只需关注其他槽位存储情况即可）</span></span><br><span class="line">        <span class="keyword">int</span> slot1 = nums[<span class="number">0</span>], count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slot2 = nums[<span class="number">0</span>], count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 摩尔投票法</span></span><br><span class="line">        <span class="comment">// 入队槽和抵消过程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slot1 == num) &#123; <span class="comment">// 相同元素入相同的队槽</span></span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (slot2 == num) &#123; <span class="comment">// 相同元素入相同的队槽</span></span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123; <span class="comment">// 存储在候选空槽</span></span><br><span class="line">                slot1 = num;</span><br><span class="line">                count1++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123; <span class="comment">// 存储在候选空槽</span></span><br><span class="line">                slot2 = num;</span><br><span class="line">                count2++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;      <span class="comment">// 入最后剩余的空槽，且与其他槽发生一次抵消，此槽又变回空槽</span></span><br><span class="line">                count1--;</span><br><span class="line">                count2--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数过程</span></span><br><span class="line">        <span class="comment">// 此时，获得剩下在队槽的元素，并数出对应元素在数组中的个数是否满足大于 N/3</span></span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slot1 == num) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (slot2 == num) count2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count1 &gt; nums.length / <span class="number">3</span>)&#123;</span><br><span class="line">            res.add(slot1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 &gt; nums.length / <span class="number">3</span>)&#123;</span><br><span class="line">            res.add(slot2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 摩尔投票法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双串题 | kmp算法的简单理解 （java）</title>
      <link href="/2021/12/12/kmp-algorithm/"/>
      <url>/2021/12/12/kmp-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>实现 strStr()<br>给你两个字符串&nbsp;<code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回&nbsp; <code>-1</code><strong> </strong>。<br><strong>说明：</strong><br>当&nbsp;<code>needle</code>&nbsp;是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当&nbsp;<code>needle</code>&nbsp;是空字符串时我们应当返回 0 。这与 C 语言&gt; &gt; 的&nbsp;<a href="https://baike.baidu.com/item/strstr/811469" target="_blank" rel="noopener">strstr()</a>&nbsp;以及 Java 的&nbsp;<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String" target="_blank" rel="noopener">indexOf()</a>)&nbsp;定义相符。</p></blockquote><blockquote><p><strong>示例 1：</strong></p><p><strong>输入：</strong>haystack = “hello”, needle = “ll”<br><strong>输出：</strong>2</p></blockquote><blockquote><p><strong>示例 2：</strong></p><p><strong>输入：</strong>haystack = “aaaaa”, needle = “bba”<br><strong>输出：</strong>-1</p></blockquote><blockquote><p><strong>示例 3：</strong></p><p><strong>输入：</strong>haystack = “”, needle = “”<br><strong>输出：</strong>0</p></blockquote><blockquote><p>&nbsp;</p><p><strong>提示：</strong></p><ul><li><code>0 &amp;lt;= haystack.length, needle.length &amp;lt;= 5 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先，想想暴力解法的大致思路。<br>可以用两个指针分别在两字符串上游走，让p和s一个一个字符遍历匹配。<br>匹配过程中，s被看作分成四个区域：<code>已放弃匹配</code>，<code>完成匹配</code>，<code>正在匹配</code>，<code>未匹配</code>。tips: 正在匹配区域是1个字符。<br>p被看作分成两个区域：<code>匹配</code>，<code>未匹配（包括正在匹配）</code>。<br>如果发现字符匹配失败，就s要丢弃掉此次匹配情况，进入下一个匹配情况：<br>即完成匹配区域清0，已放弃匹配区域+1，正在匹配区域回退至已放弃匹配区域末端+1，剩下就是被增大的未匹配区域。<br>此时相应的，指针也都要回退： s回退到上次完成匹配区间的开始字符的下一个，p回退到开始，再遍历一个个匹配。</p><p><strong>kmp其实是对回退过程的优化。</strong><br>在发生匹配失败的时候，它能够通过观察p的当前<code>匹配区域</code>，看其前后<strong>两端</strong>是否具备镜像字符串。<br>记下最长的镜像字符串，p要回退到前边的最长镜像字符串末端+1，s不用回退<br>也就是说，要在p的匹配前缀的区域内，找<strong>最长相等前后缀</strong>，p上指针回退到最长相等前缀的末端+1，s不用回退；</p><hr><p><strong>Q:为什么找p匹配的两端镜像字符串（找最长相等前后缀）能够优化回退过程？</strong><br><strong>A：</strong> p匹配区的末端部分与s匹配区的末端部分原本确定是匹配吻合；<br>如果找到镜像字符串后，即p匹配区的前端镜像字符串部分=p匹配区的末端镜像字符串部分，也就可以确定p匹配区的前端镜像字符串部分与s匹配区末端部分也能匹配吻合。<br><code>tips：这里说s匹配区不包括正在匹配的字符，是指s匹配前缀。</code><br>那么在回退时，就可以巧妙地跳过这一已知吻合部分的比对匹配操作，直接从p匹配区的前端镜像字符串部分末尾+1与s当前匹配字符进行比对，节省时间。若比对匹配失败再回退。</p><p><strong>Q: 回退过程如何找到跳跃落地点？</strong><br><strong>A:</strong> 这需要提前完成模式串p前缀表的初始化，我们会定义一个next数组，记下每一段的最长相等前后缀长度。<br><code>tips：其实该值真正的表示是：最长相等前缀末尾+1元素的下标。</code><br>匹配失败时，找p当前匹配区末端的对应的next元素值进行跳跃，则回退到正在匹配字符能够匹配成功的情况，没有就回到p的开始。</p><hr><p>以上简单地理解了kmp的思想，至于如何实现，具体细节要回到代码当中。</p><hr><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><ol><li>要初始化前缀表，记下每一段的最长相等前后缀长度，存入next数组，其实该长度值真正的表示是：最长相等前缀末尾+1元素的下标<br>1.1 定义左右指针，右指针递增<br>1.2 如果左右字符不相等，则回退到相等的情况，没有相等就回到p的开始<br>1.3 相等则最长相等前后缀长度增加，左指针负责增加，右指针负责记录</li><li>文本串s和模式串p匹配<br>2.1 定义两个指针i，j分别在两字符串中游走<br>2.2 当匹配失败时，p通过next数组进行回退到匹配相等的情况<br>2.3 否则，逐个匹配，增加匹配长度，一直到完全匹配成功</li><li>完全匹配不了，返回-1</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] s = haystack.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] p = needle.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">// next 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">1</span>;right&lt;len;right++)&#123; <span class="comment">//right go forward</span></span><br><span class="line">            <span class="comment">//left 回退</span></span><br><span class="line">            <span class="keyword">while</span>(left&gt;<span class="number">0</span> &amp;&amp; p[left] != p[right])&#123;</span><br><span class="line">                left= next[left-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配长度增加</span></span><br><span class="line">            <span class="keyword">if</span>(p[left] == p[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[right] = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.length;i++)&#123; <span class="comment">//s go forward</span></span><br><span class="line">            <span class="comment">//p回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != p[j])&#123;</span><br><span class="line">                j= next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//匹配长度增加</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j])&#123;</span><br><span class="line">                j++;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//完全匹配</span></span><br><span class="line">            <span class="keyword">if</span>(j == len) <span class="keyword">return</span> i-len+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> kmp </tag>
            
            <tag> 双串题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 | 硬核图文讲解</title>
      <link href="/2021/12/10/os-notes/"/>
      <url>/2021/12/10/os-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="1-冯诺伊曼体系"><a href="#1-冯诺伊曼体系" class="headerlink" title="1 冯诺伊曼体系"></a>1 冯诺伊曼体系</h1><h3 id="1-1-冯诺伊曼体系简介"><a href="#1-1-冯诺伊曼体系简介" class="headerlink" title="1.1 冯诺伊曼体系简介"></a>1.1 冯诺伊曼体系简介</h3><p>现代计算机之父<code>冯诺伊曼</code>最先提出程序存储的思想，并成功将其运用在计算机的设计之中，该思想约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是<strong>中央处理器（CPU）、内存、输入设备、输出设备、总线</strong>。</p><figure class="image-box">                <img src="image-20220208105256415.png" alt="image-20220208105256415" title class>                <p>image-20220208105256415</p>            </figure><ol><li><strong>存储器</strong>：代码跟数据在RAM跟ROM中是线性存储， 数据存储的单位是一个二进制位。最小的存储单位是字节。</li><li><strong>总线</strong>：总线是用于 CPU 和内存以及其他设备之间的通信，总线主要有三种：</li></ol><blockquote><ol><li><code>地址总线</code>：用于指定 CPU 将要操作的内存地址。</li><li><code>数据总线</code>：用于读写内存的数据。</li><li><code>控制总线</code>：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后响应，这时也需要控制总线。</li></ol></blockquote><ol><li><strong>输入/输出设备</strong>：输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。比如键盘按键时需要和 CPU 进行交互，这时就需要用到控制总线。</li><li><strong>CPU</strong>：中央处理器，类比人脑，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。CPU用寄存器存储计算时所需数据，寄存器一般有三种：</li></ol><blockquote><ol><li><code>通用寄存器</code>：用来存放需要进行运算的数据，比如需进行加法运算的两个数据。</li><li><code>程序计数器</code>：用来存储 CPU 要执行下一条指令所在的内存地址。</li><li><code>指令寄存器</code>：用来存放程序计数器指向的指令本身。</li></ol></blockquote><p><strong>在冯诺伊曼体系下电脑指令执行的过程</strong>：</p><ol><li>CPU读取程序计数器获得指令内存地址，CPU控制单元操作地址总线从内存地址拿到数据，数据通过数据总线到达CPU被存入指令寄存器。</li><li>CPU分析指令寄存器中的指令，如果是计算类型的指令交给逻辑运算单元，如果是存储类型的指令交给控制单元执行。</li><li>CPU 执行完指令后程序计数器的值通过自增指向下个指令，比如32位CPU会自增4。</li><li>自增后开始顺序执行下一条指令，不断循环执行直到程序结束。</li></ol><p><strong>CPU位宽</strong>：32位CPU一次可操作计算4个字节，64位CPU一次可操作计算8个字节，这个是硬件级别的。平常我们说的32位或64位操作系统指的是软件级别的，指的是程序中指令多少位。<br><strong>线路位宽</strong>：CPU操作指令数据通过高低电压变化进行数据传输，传输时候可以串行传输，也可以并行传输，多少个并行等于多少个位宽。</p><h3 id="1-2-CPU-简介"><a href="#1-2-CPU-简介" class="headerlink" title="1.2 CPU 简介"></a>1.2 CPU 简介</h3><p><code>Central Processing Unit 中央处理器，作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</code>。</p><figure class="image-box">                <img src="image-20220208105332463.png" alt="cpu" title class>                <p>cpu</p>            </figure><p>  CPU</p><ol><li><p><code>CPU核心</code>：一般一个CPU会有多个CPU核心，平常说的多核是指在一枚处理器中集成两个或多个完整的计算引擎。核跟CPU的关系是：核属于CPU的一部分。</p></li><li><p><code>寄存器</code>：最靠近CPU对存储单元，32位CPU寄存器可存储4字节，64位寄存器可存储8字节。寄存器访问速度一般是半个CPU时钟周期，属于纳秒级别，</p></li><li><p><code>L1缓存</code>：每个CPU核心都有，用来缓存数据跟指令，访问空间大小一般在32～256KB，访问速度一般是2～4个CPU时钟周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index0/size # L1 数据缓存</span><br><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index1/size # L1 指令缓存</span><br></pre></td></tr></table></figure></li><li><p><code>L2缓存</code>：每个CPU核心都有，访问空间大小在128KB～2MB，访问速度一般是10～20个CPU时钟周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index2/size # L2 缓存容量大小</span><br></pre></td></tr></table></figure></li><li><p><code>L3缓存</code>：多个CPU核心共用，访问空间大小在2MB～64MB，访问速度一般是20～60个CPU时钟周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/devices/system/cpu/cpu0/cache/index3/size # L3 缓存容量大小</span><br></pre></td></tr></table></figure></li><li><p><code>内存</code>：多个CPU共用，现在一般是4G～512G，访问速度一般是200～300个CPU时钟周期。</p></li><li><p><code>固体硬盘SSD</code>：现在台式机主流都会配备，上述的寄存器、缓存、内存都是断电数据立马丢失的，而SSD里不会丢失，大小一般是128G～1T，比内存慢10～1000倍。</p></li><li><p><code>机械盘HDD</code>：很早以前流行的硬盘了，容量可在512G～8T不等，访问速度比内存慢10W倍不等。</p></li><li><p><code>访问数据顺序</code>：CPU在拿数据处理的时候几乎也是按照上面说得流程来操纵的，只有上面一层找不到才会找下一层。</p></li><li><p><code>Cache Line</code> :  CPU读取数据时会按照 Cache Line 方式把数据加载到缓存中，每个Cacheline = 64KB，因为L1、L2是每个核独有到可能会触发<strong>伪共享</strong>，就是 所以可能会将数据划分到不同到CacheLine中来避免伪共享，比如在JDK8 新增加的 LongAdder 就涉及到此知识点。</p></li></ol><blockquote><ol><li><strong>伪共享</strong>：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</li></ol></blockquote><ol><li><code>JMM</code>: 数据经过种种分层会导致访问速度在不断提升，同时也带来了各种问题，多个CPU同时操作相同数据可能会造成各种BU个，需要加锁，这里在<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489439&amp;idx=1&amp;sn=df404e70a8e55b4019317ef2036fbe7d&amp;chksm=ebdef6a7dca97fb1e1a0dfd2eab194fa87f4971cd6b88645db072bcc9c98614b0ad30dc43399&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JUC</a>并发已详细探讨过。</li></ol><h3 id="1-3-CPU-访问方式"><a href="#1-3-CPU-访问方式" class="headerlink" title="1.3 CPU 访问方式"></a>1.3 CPU 访问方式</h3><figure class="image-box">                <img src="image-20220208105404666.png" alt="image-20220208105404666" title class>                <p>image-20220208105404666</p>            </figure><p>  CPU访问方式</p><p>内存数据映射到CPU Cache 时通过公式<code>Block N % CacheLineMax</code>决定内存Block数据放到那个CPU Cache Line 里。CPU Cache 主要有4部分组成。</p><ol><li><strong>Cache Line Index</strong> ：CPU缓存读取数据时不是按照字节来读取的，而是按照CacheLine方式存储跟读取数据的。</li><li><strong>Valid Bit</strong> : 有效位标志符，值为0时表示无论 CPU Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</li><li><strong>Tag</strong>：组标记，用来标记内存中不同BLock映射到相同CacheLine，用Tag来区分不同的内存Block。</li><li><strong>Data</strong>：真实到内存数据信息。</li></ol><p>CPU真实访问内存数据时只需要指定三个部分即可。</p><ol><li><strong>Cache Line Index</strong> ：要访问到Cache Line 位置。</li><li><strong>Tag</strong>：表示用那个数据块。</li><li><strong>Offset</strong>：CPU从CPU Cache 读取数据时不是直接读取Cache Line整个数据块，而是读取CPU所需的数据片段，称为Word。如何找到Word就需要个偏移量Offset。</li></ol><h3 id="1-4-CPU-访问速度"><a href="#1-4-CPU-访问速度" class="headerlink" title="1.4 CPU 访问速度"></a>1.4 CPU 访问速度</h3><figure class="image-box">                <img src="image-20220208105417253.png" alt="image-20220208105417253" title class>                <p>image-20220208105417253</p>            </figure><p>访问耗时对比</p><p>如上图所示，CPU访问速度是逐步变慢，所以CPU访问数据时需尽量在距离CPU近的高速缓存区访问，根据摩尔定律CPU访问速度每18个月就会翻倍，而内存的访问每18个月也就增长10% 左右，导致的结果就是CPU跟内存访问性能差距逐步变大，那如何尽可能提高CPU缓存命中率呢？</p><p>\1. <code>数据缓存</code>：遍历数据时候按照内存布局顺序访问，因为CPU Cache是根据Cache Line批量操作数据的，所以你顺序读取数据会提速，道理跟磁盘顺序写一样。</p><ol><li><code>指令缓存</code>：尽可能的提供有规律的条件分支语句，让 CPU 的分支预测器发挥作用，进一步提高执行的效率，因为CPU是自带<code>分支预测器</code>，自动提前将可能需要的指令放到指令缓存区。</li><li><code>线程绑定到CPU</code>：一个任务A在前一个时间片用CPU核心1 运行，后一个时间片用CPU核心2 运行，这样缓存L1、L2就浪费了。因此操作系统提供了将进程或者线程绑定到某一颗 CPU 上运行的能力。如 Linux 上提供了 sched_setaffinity 方法实现这一功能，其他操作系统也有类似功能的 API 可用。当多线程同时执行密集计算，且 CPU 缓存命中率很高时，如果将每个线程分别绑定在不同的 CPU 核心上，性能便会获得非常可观的提升。</li></ol><h3 id="1-5-操作系统"><a href="#1-5-操作系统" class="headerlink" title="1.5  操作系统"></a>1.5  操作系统</h3><figure class="image-box">                <img src="image-20220208105427891.png" alt="image-20220208105427891" title class>                <p>image-20220208105427891</p>            </figure><p>有了冯诺伊曼计算机体系后，电脑想要为用户提供便捷的服务还需要安装个操作系统<code>Operation System</code>，操作系统是覆盖在硬件上的一层特殊软件，它管理计算机的硬件和软件资源，为其他应用程序提供大量服务。可以理解为操作系统是日常应用程序跟硬件之间的接口。日常你经常在用Windows/Linux 系统，操作系统给我们提供了超级大的便利，但是你了解操作系统么？操作系统是如何进行<strong>内存管理</strong>、<strong>进程管理</strong>、<strong>文件管理</strong>、<strong>输入输出管理</strong>的呢？</p><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><p>你的电脑是32位操作系统，那可支持的最大内存就是4G，你有没有好奇为什么可以同时运行2个以上的2G内存的程序。应用程序不是直接使用的物理地址，操作系统为每个运行的进程分配了一套<code>虚拟地址</code>，每个进程都有自己的<code>虚拟内存地址</code>，进程是无法直接进行<code>物理内存地址</code>的访问的。至于虚拟地址跟物理地址的映射，进程是感知不到的！<code>操作系统自身会提供一套机制将不同进程的虚拟地址和不同内存的物理地址进行映射</code>。</p><figure class="image-box">                <img src="image-20220208105446194.png" alt="image-20220208105446194" title class>                <p>image-20220208105446194</p>            </figure><h3 id="2-1-MMU"><a href="#2-1-MMU" class="headerlink" title="2.1  MMU"></a>2.1  MMU</h3><p><code>Memory Management Unit 内存管理单元</code>是一种负责处理CPU内存访问请求的计算机硬件。它的功能包括<strong>虚拟地址到物理地址的转换、内存保护、中央处理器高速缓存的控制</strong>。现代 CPU 基本上都选择了使用 MMU。</p><p>当进程持有虚拟内存地址的时候，CPU执行该进程时会操作虚拟内存，而MMU会自动的将虚拟内存的操作映射到物理内存上。</p><figure class="image-box">                <img src="image-20220208105504831.png" alt="image-20220208105504831" title class>                <p>image-20220208105504831</p>            </figure><p>这里提一下，Java操作的时候你看到的地址是<code>JVM地址</code>，不是真正的物理地址。</p><h3 id="2-2-内存管理方式"><a href="#2-2-内存管理方式" class="headerlink" title="2.2  内存管理方式"></a>2.2  内存管理方式</h3><p>操作系统主要采用<code>内存分段</code>和<code>内存分页</code>来管理虚拟地址与物理地址之间的关系，其中分段是很早前的方法了，现在大部分用的是分页，不过分页也不是完全的分页，是在分段的基础上再分页。</p><h5 id="2-2-1-内存分段"><a href="#2-2-1-内存分段" class="headerlink" title="2.2.1 内存分段"></a>2.2.1 内存分段</h5><figure class="image-box">                <img src="image-20220208105534576.png" alt="image-20220208105534576" title class>                <p>image-20220208105534576</p>            </figure><p>我们以上图的<a href="https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489183&amp;idx=1&amp;sn=02ab3551c473bd2c8429862e3689a94b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JVM</a>内存模型举例，程序员会认为我们的代码是由代码段、数据段、栈段、堆段组成。不同的段是有不同的属性的，用户并不关心这些元素所在内存的位置，而分段就是支持这种用户视图的内存管理方案。逻辑地址空间是由一组段构成。每个段都有名称和长度。地址指定了段名称和段内偏移。因此用户<code>段编号</code>和<code>段偏移</code>来指定不同属性的地址。而虚拟内存地址跟物理内存地址中间是通过段表进行映射的，口说无凭，看图吧。</p><figure class="image-box">                <img src="image-20220208105557349.png" alt="image-20220208105557349" title class>                <p>image-20220208105557349</p>            </figure><p>如上虚拟地址有 5 个段，各段按如图所示来存储。每个段都在段表中有一个条目，它包括段在物理内存内的开始的基地址和该段的界限长度。例如段 2 为 400 字节长，开始于位置 4300。因此对段 2 字节 53 的引用映射成位置 4300 + 53 = 4353。对段 3 字节 852 的引用映射成位置 3200 + 852 = 4052。</p><p>分段映射很简单，但是会导致<code>内存碎片</code>跟<code>内存交互效率低</code>。这里先普及下在内存管理中主要有<code>内部内存碎片</code>跟<code>外部内存碎片</code>。</p><ol><li><strong>内部碎片</strong>：已经被分配出去的的内存空间不经常使用，并且分配出去的内存空间大于请求所需的内存空间。</li><li><strong>外部碎片</strong>：指可用空间还没有分配出去，但是可用空间由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。</li></ol><p>以上图为例，现在系统空闲是1400 +  800 + 600 = 2800。那如果有个程序想要连续的使用2000，内存分段模式下提供不了啊！上述三个是<code>外部内存碎片</code>。当然可以使用系统的<code>Swap</code>空间，先把段0写入到磁盘，然后再重新给段0分配空间。这样可以实现最终可用，可是但凡涉及到磁盘读写就会导致<code>内存交互效率低</code>。</p><figure class="image-box">                <img src="image-20220208105626772.png" alt="image-20220208105626772" title class>                <p>image-20220208105626772</p>            </figure><p>swap空间利用</p><h5 id="2-2-2-内存分页"><a href="#2-2-2-内存分页" class="headerlink" title="2.2.2 内存分页"></a>2.2.2 内存分页</h5><p>内存分页，<code>整个虚拟内存和物理内存切成一段段固定尺寸的大小</code>。每个固定大小的尺寸称之为<code>页Page</code>，在 Linux 系统中Page = 4KB。然后虚拟内存跟物理内存之间通过<code>页表</code>来实现映射。</p><p>采用<strong>内存分页</strong>时内存的释放跟使用都是以页为单位的，也就不会产生内存碎片了。当空间还不够时根据操作系统调度算法，可能将最少用的内存页面 swap-out换出到磁盘，用时候再swap-in换入，尽可能的减少磁盘刷写量，提高内存交互效率。</p><p>分页模式下虚拟地址主要有<code>页号</code>跟<code>页内偏移量</code>两部分组成。通过页号查询页表找到物理内存地址，然后再配合页内偏移量就找到了真正的物理内存地址。</p><figure class="image-box">                <img src="image-20220208105654323.png" alt="image-20220208105654323" title class>                <p>image-20220208105654323</p>            </figure><p>32位操作系统环境下进程可操作的虚拟地址是4GB，假设一个虚拟页大小为4KB，那需要4GB/4KB = <code>2^20</code> 个页信息。一行页表记录为4字节，<code>2^20</code>等价于4MB页表存储信息。这只是一个进程需要的，如果10个、100个、1000个呢？仅仅是页表存储都占据超大内存了。</p><p>为了解决这个问题就需要用到 <code>多级页表</code>，核心思想就是<strong>局部性</strong>分配。在32位的操作系统中将将4G空间分为 1024 行页目录项目(4KB)，每个页目录项又对应1024行页表项。如下图所示：</p><figure class="image-box">                <img src="image-20220208105706021.png" alt="image-20220208105706021" title class>                <p>image-20220208105706021</p>            </figure><p>控制寄存器cr3中存放了页目录的物理地址，通过cr3寄存器可以找到页目录，而32位线性地址中的Directory部分决定页目录中的目录项，而页目录项中存放了要找的页表的物理基地址，再结合线性地址中的中间10位页表项，就可以找到页框的页表项。线性地址中的Offset部分占12位，因此页框的物理地址 + 线性地址Offset部分 = 页框中的任何一个字节。</p><p>分页后一级页就等价于4G虚拟地址空间，并且如果一级页表中那些地址没有就不需要再创建二级页表了！核心思想就是按需创建，当系统给每个进程分配4G空间，进程不可能占据全部内存的，如果一级目录页只有10%用到了，此时页表空间 = 一级页表4KB + 0.1 * 4MB  。这比单独的每个进程占据4M好用多了！</p><p>多层分页的弊端就是访问时间的<strong>增加</strong>。</p><ol><li>使用页表时读取内存中一页内容需要2次访问内存，访问页表项 + 并读取的一页数据。</li><li>使用二级页表的话需要三次访问，访问页目录项 + 访问页表项 + 访问并读取的一页数据。访存次数的增加也就意味着访问数据所花费的总时间增加。</li></ol><p>而对于64位系统，二级分页就无法满足了，Linux 从2.6.11开始采用四级分页模型。</p><ol><li>Page Global Directory 全局页目录项</li><li>Page Upper Directory 上层页目录项</li><li>Page Middle Directory 中间页目录项</li><li>Page Table Entry 页表项</li><li>Offset 偏移量。</li></ol><figure class="image-box">                <img src="image-20220208105725267.png" alt="image-20220208105725267" title class>                <p>image-20220208105725267</p>            </figure><h5 id="2-2-2-TLB"><a href="#2-2-2-TLB" class="headerlink" title="2.2.2 TLB"></a>2.2.2 TLB</h5><p>Translation Lookaside Buffer 可翻译为<code>地址转换后援缓冲器</code>，简称为<code>快表</code>，属于CPU内部的一个模块，TLB是MMU的一部分，实质是cache，它所缓存的是最近使用的数据的页表项（虚拟地址到物理地址的映射）。他的出现是为了加快访问数据（内存）的速度，减少重复的页表查找。当然它不是必须要有的，但有它，速度就更快。</p><figure class="image-box">                <img src="image-20220208105732620.png" alt="image-20220208105732620" title class>                <p>image-20220208105732620</p>            </figure><p>TLB很小，因此缓存的东西也不多。主要缓存最近使用的数据的数据映射。TLB结构如下图：</p><figure class="image-box">                <img src="image-20220208105743431.png" alt="image-20220208105743431" title class>                <p>image-20220208105743431</p>            </figure><p>如果一个需要访问内存中的一个数据，给定这个数据的虚拟地址，查询TLB，发现有hit，直接得到物理地址，在内存根据物理地址取数据。如果TLB没有这个虚拟地址miss，那么只能费力的通过页表来查找了。日常CPU读取一个数据的流程如下：</p><figure class="image-box">                <img src="image-20220208105753365.png" alt="image-20220208105753365" title class>                <p>image-20220208105753365</p>            </figure><p>当进程地址空间进行了<code>上下文切换</code>时，比如现在是进程1运行，TLB中放的是进程1的相关数据的地址，突然切换到进程2，TLB中原有的数据不是进程2相关的，此时TLB刷新数据有两种办法。</p><ol><li><strong>全部刷新</strong>：很简单，但花销大，很多不必刷新的数据也进行刷新，增加了无畏的花销。</li><li><strong>部分刷新</strong>：根据标志位，刷新需要刷新的数据，保留不需要刷新的数据。</li></ol><h5 id="2-2-3-段页式管理"><a href="#2-2-3-段页式管理" class="headerlink" title="2.2.3 段页式管理"></a>2.2.3 段页式管理</h5><p><code>内存分段</code>跟<code>内存分页</code>不是对立的，这俩可以组合起来在同一个系统中使用的，那么组合起来后通常称为<code>段页式内存管理</code>。段页式内存管理实现的方式：</p><ol><li>先对数据不同划分出不同的段，也就是前面说的分段机制。</li><li>然后再把每一个段进行分页操作，也就是前面说的分页机制。</li><li>此时 地址结构 = 段号 + 段内页号 + 页内位移。</li></ol><p>每一个进程有一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号。</p><figure class="image-box">                <img src="image-20220208105806478.png" alt="image-20220208105806478" title class>                <p>image-20220208105806478</p>            </figure><p>  段页式管理</p><p>同时我们经常看到两个专业词<code>逻辑地址</code>跟<code>线性地址</code>。</p><ol><li><code>逻辑地址</code>：指的是没被段式内存管理映射的地址。</li><li><code>线性地址</code>：通过段式内存管理映射且页式内存管理转换前的地址，俗称虚拟地址。</li></ol><p>目前 Intel X86 CPU 采用的是内存分段 +  内存分页的管理方式，其中分页的意思是在由段式内存管理所映射而成的的地址上再加上一层地址映射。</p><figure class="image-box">                <img src="image-20220208105815982.png" alt="image-20220208105815982" title class>                <p>image-20220208105815982</p>            </figure><h5 id="2-2-4-Linux-内存管理"><a href="#2-2-4-Linux-内存管理" class="headerlink" title="2.2.4 Linux 内存管理"></a>2.2.4 Linux 内存管理</h5><p>先说结论：Linux系统基于X86 CPU 而做的操作系统，所以也是用的段页式内存管理方式。</p><figure class="image-box">                <img src="image-20220208105825019.png" alt="image-20220208105825019" title class>                <p>image-20220208105825019</p>            </figure><p>我们知道32位的操作系统可寻址范围是4G，操作系统会将4G的可访问内存空间分为<strong>用户空间</strong>跟<strong>内核空间</strong>。</p><ol><li><code>内核空间</code>：操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。内核态下CPU可执行任何指令，可自由访问任何有效地址。</li><li><code>用户空间</code>：普通应用程序可访问的内存区域。被执行代码会受到CPU众多限制，进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。</li></ol><p>那为啥要搞俩空间呢?现在嵌入式环境跟以前的WIN98系统是没有区分俩空间的，须知俩空间是CPU分的，而操作系统是在上面运行的，单一用户、单一任务服务的操作系统，是没有分所谓用户态和内核态的必要。用户态和内核态是因为有多用户，多任务的需求，然后在CPU硬件厂商配合之后，产生的一个操作系统解决多用户多任务需求的方案。方案就是<strong>限制</strong>，通过硬件手段（也只能硬件手段才能做到），限制某些代码，使其无法控制整个物理硬件，进而使各个不同用户，不同任务的代码，无权修改整个物理硬件，再进而保护操作系统的核心底层代码和其他用户的数据不被无意或者有意地破坏和盗取。</p><figure class="image-box">                <img src="image-20220208105839460.png" alt="image-20220208105839460" title class>                <p>image-20220208105839460</p>            </figure><p>后来研究者根据<strong>CPU</strong>的运行级别，分成了Ring0~Ring3四个级别。Ring0是最高级别，Ring1次之，Rng2更次之，拿Linux+x86来说，  操作系统内核的代码运行在最高运行级别Ring0上，可以使用特权指令，控制中断、修改页表、访问设备等。 应用程序的代码运行在最低运行级别上Ring3上，不能做受控操作，只能访问用户被分配的空间。如果要做访问磁盘跟写文件等操作，那就要通过执行系统调用函数，执行系统调用的时候，CPU的运行级别会发生从Ring3到Ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从Ring0返回Ring3。这个过程也称作<strong>用户态和内核态的切换</strong>。</p><p>用户态想要使用计算机设备或IO需通过系统调用完成sys call，系统调用就是让内核来做这些操作。而系统调用是影响整个当前进程上下文的，ＣＰＵ提供了个软中断来是实现保护线程，获取系统调用号跟参数，交给内核对应系统调用函数执行。</p><figure class="image-box">                <img src="image-20220208105855383.png" alt="image-20220208105855383" title class>                <p>image-20220208105855383</p>            </figure><p>可以看到每个应用程序都各自有独立的虚拟内存地址，但每个虚拟内存中对应的内核地址其实是相同的一大块，这样当进程切换到内核态后可以很方便地访问内核空间内存。比如Java代码创建线程<code>new Thread</code>调用<code>start</code>方法后跟踪<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489183&amp;idx=1&amp;sn=02ab3551c473bd2c8429862e3689a94b&amp;chksm=ebdef7a7dca97eb17194c3d935c86ade240d3d96bbeaf036233a712832fb94af07adeafa098b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><code>JVM</code></a>源码你会发现是调用<code>pthread_create</code>来创建线程的，这就涉及到了用户态到内核态的切换。</p><h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h1><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><p>进程是程序的一次执行，是一个程序及其数据在机器上顺序执行时所发生的活动，是具有独立功能的程序在一个数据集合上的一次运行过程，是系统进行资源分配和调度的一个基本单位。进程的<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247489439&amp;idx=1&amp;sn=df404e70a8e55b4019317ef2036fbe7d&amp;chksm=ebdef6a7dca97fb1e1a0dfd2eab194fa87f4971cd6b88645db072bcc9c98614b0ad30dc43399&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">调度状态</a>如下：</p><figure class="image-box">                <img src="640.png" alt="图片" title class>                <p>图片</p>            </figure><p>状态变化图</p><p>重点说下<code>挂起</code>跟<code>阻塞</code>：</p><ol><li>阻塞一般是当系统执行IO操作时，此时进程进入阻塞状态，等待某个事件的返回。</li><li>挂起是指进程没有占有物理内存，被写到磁盘上了。这时进程状态是挂起状态。</li></ol><blockquote><p> <code>阻塞挂起</code>：进程被写入硬盘并等待某个事件的出现。<br> <code>就绪挂起</code>：进程被写入硬盘，进入内存可直接进入就绪状态。</p></blockquote><hr><h3 id="3-2-PCB"><a href="#3-2-PCB" class="headerlink" title="3.2 PCB"></a>3.2 PCB</h3><p>为了描述跟控制进程的运行，系统为每个进程定义了一个数据结构——<code>进程控制块 Process Control Block</code>，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。</p><p>PCB 的作用是<strong>使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程</strong> :</p><ol><li>作为独立运行基本单位的标志</li><li>实现间断性的运行方式</li><li>提供进程管理所需要的信息</li><li>提供进程调度所需要的信息</li><li>实现与其他进程的同步与通信</li></ol><h5 id="3-2-1-PCB-信息"><a href="#3-2-1-PCB-信息" class="headerlink" title="3.2.1 PCB 信息"></a>3.2.1 PCB 信息</h5><p>PCB为实现上述功能，内部包含众多信息：</p><ol><li><strong>进程标识符</strong>：用于唯一地标识一个进程，一个进程通常有两种标识符：</li></ol><blockquote><ol><li><code>内部进程标识符</code>：标识各个进程，每个进程都有一个并且唯一的标识符，设置内部标识符主要是为了方便系统使用。</li><li><code>外部进程标识符</code>：它由创建者提供，可设置用户标识，以指示拥有该进程的用户。往往是由用户进程在访问该进程时使用。一般为了描述进程的家族关系，还应设置父进程标识及子进程标识。</li></ol></blockquote><ol><li><strong>处理机状态</strong>：由各种寄存器组成。包含许多信息都放在寄存器中，方便程序restart。</li></ol><blockquote><ol><li>通用寄存器、指令计数器、程序状态字PSW、用户栈指针等信息。</li></ol></blockquote><ol><li><strong>进程调度信息</strong></li></ol><blockquote><ol><li>进程状态：指明进程的当前状态，作为进程调度和对换时的依据。</li><li>进程优先级：用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机</li><li>进程调度所需的其它信息：与所采用的进程调度算法有关，如进程已等待CPU的时间总和、进程已执行的时间总和等。</li><li>事件：指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li></ol></blockquote><ol><li><strong>资源清单</strong></li></ol><blockquote><p>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</p></blockquote><h5 id="3-2-2-PCB-组织方式"><a href="#3-2-2-PCB-组织方式" class="headerlink" title="3.2.2 PCB 组织方式"></a>3.2.2 PCB 组织方式</h5><p>操作系统中有太多 PCB，如何管理是个问题，一般有如下方式。</p><figure class="image-box">                <img src="image-20220208105914468.png" alt="image-20220208105914468" title class>                <p>image-20220208105914468</p>            </figure><ol><li><strong>线性方式</strong>：</li></ol><blockquote><ol><li>将系统所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域</li><li>实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统</li></ol></blockquote><figure class="image-box">                <img src="image-20220208105928416.png" alt="image-20220208105928416" title class>                <p>image-20220208105928416</p>            </figure><p>索引方式</p><ol><li><strong>索引方式</strong>：</li></ol><blockquote><ol><li>将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</li></ol></blockquote><figure class="image-box">                <img src="image-20220208105942343.png" alt="image-20220208105942343" title class>                <p>image-20220208105942343</p>            </figure><ol><li><strong>链接方式</strong>：</li></ol><blockquote><ol><li>把同一状态的PCB链接成一个队列，形成就绪队列、阻塞队列、空白队列等。对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前。</li><li>因为进程创建、销毁、调度频繁，所以<strong>一般采用此模式</strong>。</li></ol></blockquote><h3 id="3-3-进程控制"><a href="#3-3-进程控制" class="headerlink" title="3.3 进程控制"></a>3.3 进程控制</h3><p>进程控制是进程管理最基本的功能，主要包括<code>创建新进程</code>，<code>终止已完成的进程</code>，<code>将发生异常的进程置于阻塞状态</code>，<code>将进程唤醒</code>等。</p><h5 id="3-3-1-进程创建"><a href="#3-3-1-进程创建" class="headerlink" title="3.3.1 进程创建"></a>3.3.1 进程创建</h5><p>父进程可创建子进程，父进程终止后子进程也会被终止。子进程可继承父进程所有资源，子进程终止需将自己所继承的资源归还父进程。接下来看下创建的大致流程。</p><ol><li>为新进程分配唯一进件标识号，然后创建一个空白PCB，需注意PCB数量是有限的，所以可能会创建失败。</li><li>尝试为新进程分配所需资源，如果资源不足进程会进入等待状态。</li><li>初始化PCB，有如下几个操作。</li></ol><blockquote><ol><li>标识信息：将系统分配的标识符和父进程标识符填入新PCB</li><li>处理机状态信息：使程序计数器指向程序入口地址，使栈指针指向栈顶</li><li>处理机控制信息：将进程设为就绪/静止状态，通常设为最低优先级</li></ol></blockquote><ol><li>如果进程调度队列能接纳新进程，就将进程插入到就绪队列，等待被调度运行。</li></ol><h5 id="3-3-2-进程终止"><a href="#3-3-2-进程终止" class="headerlink" title="3.3.2 进程终止"></a>3.3.2 进程终止</h5><p>进程终止情况一般分为正常结束、异常结束、外界干预三种。</p><ol><li>正常结束</li><li>异常结束</li></ol><blockquote><ol><li>越界错：访问的存储区越出该进程的区域</li><li>保护错：试图访问不允许访问的资源，或以不适当的方式访问（写只读）</li><li>非法指令：试图执行不存在的指令（可能是程序错误地转移到数据区，数据当成了指令）</li><li>特权指令出错：用户进程试图执行一条只允许OS执行的指令</li><li>运行超时：执行时间超过指定的最大值</li><li>等待超时：进程等待某件事超过指定的最大值</li><li>算数运算错：试图执行被禁止的运算（被0除）</li><li>I/O故障</li></ol></blockquote><ol><li>外界干预</li></ol><blockquote><ol><li>操作员或OS干预（死锁）</li><li>父进程请求，子进程完成父进程指定的任务时</li><li>父进程终止，所有子进程都应该结束</li></ol></blockquote><p><strong>终止过程</strong>：</p><ol><li>根据被终止进程的标识符，从PCB集合中检索出该PCB，读取进程状态</li><li>若处于执行状态则立即终止执行，将CPU资源分配给其他进程。</li><li>若进程有子孙进程则将其所有子孙进程终止。</li><li>全部资源还给父进程或操作系统。</li><li>该进程的PCB从所在队列/链表中移出。</li></ol><h5 id="3-3-3-进程阻塞"><a href="#3-3-3-进程阻塞" class="headerlink" title="3.3.3 进程阻塞"></a>3.3.3 进程阻塞</h5><p>意思是该进程执行半路被阻塞，必须由某个事件进程唤醒该进程。常见的就是IO读取操作。常见阻塞时机/事件如下：</p><ol><li>请求共享资源失败，系统无足够资源分配</li><li>等待某种操作完成</li><li>新数据尚未到达（相互合作的进程）</li><li>等待新任务</li></ol><p><strong>阻塞流程</strong>：</p><ol><li>找到要被阻塞进程标识号对应的 PCB。</li><li>将该进程由运行状态转换为阻塞状态。</li><li>将该 进程PCB 插入的阻塞队列中去。</li></ol><h5 id="3-3-4-进程唤醒"><a href="#3-3-4-进程唤醒" class="headerlink" title="3.3.4 进程唤醒"></a>3.3.4 进程唤醒</h5><p>唤醒 原语 wake up，一般和阻塞成对使用。唤醒过程如下：</p><ol><li>从阻塞队列找到所需PCB。</li><li>PCB从阻塞队列溢出，然后变为就绪状态。</li><li>从阻塞队列溢出该PCB然后插入到就绪状态队列等待被分配CPU资源。</li></ol><h3 id="3-4-进程调度"><a href="#3-4-进程调度" class="headerlink" title="3.4 进程调度"></a>3.4 进程调度</h3><p>进程数一般会大于CPU个数，进程状态切换主要由调度程序进行调度。一般情况下CPU调度时主要分为<code>抢占式调度</code>跟<code>非抢占式调度</code>。</p><ol><li><code>非抢占式</code>：让进程运行直到结束或阻塞的调度方式， 容易实现，适合专用系统。</li><li><code>抢占式</code>：每个进程获得时间片才可以被CPU调度运行， 可防止单一进程长时间独占CPU 系统开销大。</li></ol><h5 id="3-4-1-进程调度原则"><a href="#3-4-1-进程调度原则" class="headerlink" title="3.4.1 进程调度原则"></a>3.4.1 进程调度原则</h5><ol><li><strong>CPU 利用率</strong></li></ol><blockquote><ol><li>CPU利用率 = 忙碌时间 / 总时间。</li><li>调度程序应该尽量让 CPU 始终处于忙碌的状态，这可提高 CPU 的利用率。比如当发生IO读取时候，不要傻傻等待，去执行下别的进程。</li></ol></blockquote><ol><li><strong>系统吞吐量</strong></li></ol><blockquote><ol><li>系统吞吐量 = 总共完成多少个作业 / 总共花费时间。</li><li>长作业的进程会占用较长的 CPU 资源导致降低吞吐量，相反短作业的进程会提升系统吞吐量。</li></ol></blockquote><ol><li><strong>周转时间</strong></li></ol><blockquote><ol><li>周转时间 = 作业完成时间 - 作业提交时间。</li><li>平均周转时间 = 各作业周转时间和 / 作业数</li><li>带权周转时间 = 作业周转时间 / 作业实际运行时间</li><li>平均带权周转时间 = 各作业带权周转时间之和 / 作业数</li><li>尽可能使周转时间降低。</li></ol></blockquote><ol><li><strong>等待时间</strong></li></ol><blockquote><ol><li>指的是进程在等待队列中等待的时间，一般也需要尽可能短。</li><li><strong>响应时间</strong><br>响应时间 = 系统第一次响应时间 - 用户提交时间，在交互式系统中响应时间是衡量调度算法好坏的主要标准。</li></ol></blockquote><h5 id="3-4-2-调度算法"><a href="#3-4-2-调度算法" class="headerlink" title="3.4.2 调度算法"></a>3.4.2 调度算法</h5><p><strong>FCFS 算法</strong></p><ol><li>First Come First Severd 先来先服务算法，遵循先来后端原则，每次从就绪队列拿等待时间最久的，运行完毕后再拿下一个。</li><li>该模式对长作业有利，适用 CPU 繁忙型作业的系统，不适用 I/O 型作业，因为会导致进程CPU利用率很低。</li></ol><p><strong>SJF 算法</strong></p><ol><li>Shortest Job First 最短作业优先算法，该算法会优先选择运行所需时间最短的进程执行，可提高吞吐量。</li><li>跟FCFS正好相反，对长作业很不利。</li></ol><p><strong>SRTN 算法</strong></p><ol><li>Shortest Remaining Time Next 最短剩余时间优先算法，可以认为是SJF的抢占式版本，当一个新就绪的进程比当前运行进程具有更短完成时间时，系统抢占当前进程，选择新就绪的进程执行。</li><li>有最短的平均周转时间，但不公平，源源不断的短任务到来，可能使长的任务长时间得不到运行。</li></ol><p><strong>HRRN 算法</strong></p><ol><li>Highest Response Ratio Next 最高响应比优先算法，为了平衡前面俩而生，按照响应优先权从高到低依次执行。属于前面俩的折中权衡。</li><li>优先权 = (等待时间 + 要求服务时间) / 要求服务时间</li></ol><p><strong>RR 算法</strong></p><ol><li>Round Robin 时间片轮转算法，操作系统设定了个时间片Quantum，时间片导致每个进程只有在该时间片内才可以运行，这种方式导致每个进程都会均匀的获得执行权。</li><li>时间片一般20ms~50ms，如果太小会导致系统频繁进行上下文切换，太大又可能引起对短的交互请求的响应变差。</li></ol><p><strong>HPF 算法</strong></p><ol><li>Highest Priority First 最高优先级调度算法，从就绪队列中选择最高优先级的进程先执行。</li><li>优先级的设置有初始化固定死的那种，也有在代码运转过程中根据等待时间或性能动态调整 这两种思路。</li><li>缺点是可能导致低优先级的一直无法被执行。</li></ol><p><strong>MFQ 算法</strong></p><ol><li><p>Multilevel Feedback Queue 多级反馈队列调度算法 ，可以认为是 RR 算法 跟 HPF 算法 的综合体。</p></li><li><p>系统会同时存在多个就绪队列，每个队列优先级从高到低排列，同时优先级越高获得是时间片越短。</p></li><li><p>新进程会先加入到最高优先级队列，如果新进程优先级高于当前在执行的进程，会停止当前进程转而去执行新进程。新进程如果在时间片内没执行完毕需下移到次优先级队列。</p><p><img src="image-20220208110001762.png" alt="image-20220208110001762"><br>多级反馈队列调度算法</p></li></ol><h3 id="3-5-线程"><a href="#3-5-线程" class="headerlink" title="3.5 线程"></a>3.5 线程</h3><h5 id="3-5-1-线程定义"><a href="#3-5-1-线程定义" class="headerlink" title="3.5.1 线程定义"></a>3.5.1 线程定义</h5><p>早期操作系统是没有线程概念的，线程是后来加进来的。为啥会有线程呢？那是因为以前在多进程阶段，经常会涉及到进程之间如何通讯，如何共享数据的问题。并且进程关联到PCB的生命周期，管理起来开销较大。为了解决这个问题引入了线程。</p><p>线程是进程当中的一个执行流程。同一个进程内的多个线程之间可以共享进程的代码段、数据段、打开的文件等资源。同时每个线程又都有一套独立的寄存器和栈来确保线程的控制流是独立的。</p><p>进程有个<code>PCB</code>来管理，同理操作系统通过 <code>Thread Control Block</code>线程控制块来实现线程的管控。</p><h5 id="3-5-2-线程优缺点"><a href="#3-5-2-线程优缺点" class="headerlink" title="3.5.2 线程优缺点"></a>3.5.2 线程优缺点</h5><p><strong>优点</strong></p><ol><li>一个进程中可以同时存在1~N个线程，这些线程可以并发的执行。</li><li>各个线程之间可以共享地址空间和文件等资源。</li></ol><p><strong>缺点</strong></p><ol><li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。</li><li>多线程编程，让人头大的东西。</li><li>线程执行开销小，但不利于资源的隔离管理和保护，而进程正相反。</li></ol><h5 id="3-5-3-进程跟线程关联"><a href="#3-5-3-进程跟线程关联" class="headerlink" title="3.5.3 进程跟线程关联"></a>3.5.3 进程跟线程关联</h5><p><strong>进程</strong>：</p><ol><li>是系统进行资源分配和调度的一个独立单位.</li><li>是程序的一次执行，每个进程都有自己的地址空间、内存、数据栈及其他辅助记录运行轨迹的数据</li></ol><p><strong>线程</strong>：</p><ol><li>是进程的一个实体，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位</li><li>所有的线程运行在同一个进程中，共享相同的运行资源和环境</li><li>线程一般是并发执行的，使得实现了多任务的并行和数据共享。</li></ol><p><strong>进程线程区别</strong>：</p><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li><li>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li><li>CPU分配资源给进程，但真正在CPU上运行的是线程。</li><li>线程不能够独立执行，必须依存在进程中。</li></ol><p><strong>线程快在哪儿</strong>？</p><ol><li>线程创建的时有些资源不需要自己管理，直接从进程拿即可，线程管理寄存器跟栈的生命周期即可。</li><li>同进程内多线程共享数据，所以进程数据传输可以用zero copy技术，不需要经过内核了。</li><li>进程使用一个虚拟内存跟页表，然后多线程共用这些虚拟内存，如果同进程内两个线程进行上下文切换比进程提速很多。</li></ol><h5 id="3-5-4-线程实现"><a href="#3-5-4-线程实现" class="headerlink" title="3.5.4 线程实现"></a>3.5.4 线程实现</h5><p>在前面的内存管理中说到了内核态跟用户态。相对应的线程的创建也分为<code>用户态线程</code>跟<code>内核态线程</code>。</p><h6 id="3-5-4-1-用户态线程"><a href="#3-5-4-1-用户态线程" class="headerlink" title="3.5.4.1 用户态线程"></a>3.5.4.1 用户态线程</h6><p>在用户空间实现的线程，由用户态的线程库来完成线程的管理。操作系统按进程维度进行调度，<strong>当线程在用户态创建时应用程序在用户空间内要实现线程的创建、维护和调度。操作系统对线程的存在一无所知</strong>！操作系统只能看到进程看不到线程。所有的线程都是在用户空间实现。在操作系统看来，每一个进程只有一个线程。</p><figure class="image-box">                <img src="image-20220208110024780.png" alt="image-20220208110024780" title class>                <p>image-20220208110024780</p>            </figure><p>用户态线程</p><p><strong>好处</strong>：</p><ol><li>及时操作系统不支持线程模式也可以通过用户层库函数来支持线程模式，TCB 由用户级线程库函数来维护。</li><li>使用库函数模式实现线程可以避免用户态到内核态的切换。</li></ol><p><strong>坏处</strong>：</p><ol><li>CPU不知道线程存在，CPU的时间片切换是以进程为维度的，某个线程因为IO等操作导致线程阻塞，操作系统会阻塞整个进程，即使这个进程中其它线程还在工作。</li><li>用户态线程没法打断正在运行中的线程，除非线程主动交出CPU使用权。</li></ol><h6 id="3-5-4-2-内核态线程"><a href="#3-5-4-2-内核态线程" class="headerlink" title="3.5.4.2 内核态线程"></a>3.5.4.2 内核态线程</h6><p>在内核中实现的线程，是由内核管理的线程，线程对应的 TCB 在操作系统里，这样线程的创建、终止和管理都是由操作系统负责。内线程模式下一个用户线程对应一个内核线程。</p><figure class="image-box">                <img src="image-20220208110103377.png" alt="image-20220208110103377" title class>                <p>image-20220208110103377</p>            </figure><p>内核态线程</p><p><strong>注意</strong>：Linux中的JVM从1.2版以后是基于pthread实现的，<code>所以现在Java中线程的本质就是操作系统中的线程</code>。</p><p><strong>优点</strong>：</p><ol><li>一个进程中某个线程阻塞不会影响其他内核线程运行。</li><li>用户态模式一个时间片分给多个线程，内核态模式直接分配给线程的时间片增加。</li></ol><p><strong>缺点</strong>：</p><ol><li>内核级线程调度开销较大。调度内核线程的代价可能和调度进程差不多昂贵，代价要比用户级线程大很多。一个线程默认栈=1M，线程多了会导致内存消耗很大。</li><li>线程表是存放在操作系统固定的表格空间或者堆栈空间里，所以内核级线程的数量是有限的。</li></ol><h6 id="3-4-4-3-轻量级进程"><a href="#3-4-4-3-轻量级进程" class="headerlink" title="3.4.4.3 轻量级进程"></a>3.4.4.3 轻量级进程</h6><p>最初的进程定义都包含程序、资源及其执行三部分，其中程序通常指代码，资源在操作系统层面上通常包括内存资源、IO资源、信号处理等部分，而程序的执行通常理解为执行上下文，包括对CPU的占用，后来发展为线程。在线程概念出现以前，为了减小进程切换的开销，操作系统设计者逐渐修正进程的概念，逐渐允许将进程所占有的资源从其主体剥离出来，允许某些进程共享一部分资源，例如文件、信号，数据内存，甚至代码，这就发展出轻量进程的概念。</p><p>Light-weight process <strong>轻量级进程是内核支持的用户线程</strong>，它是基于内核线程的高级抽象，系统只有先支持内核线程才能有 LWP。一个进程可有1~N个LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持。</p><figure class="image-box">                <img src="image-20220208110121188.png" alt="image-20220208110121188" title class>                <p>image-20220208110121188</p>            </figure><p>LWP模式</p><p><strong>轻量级进程本质还是进程</strong>，只是跟普通进程相比LWP跟其他进程共享大部分逻辑地址空间跟系统资源，LWP轻量体现在它只有一个最小的执行上下文和调度程序所需的统计信息。他是进程的执行部分，只带有执行相关的信息。</p><p><strong>Linux特性</strong>：</p><ol><li>Linux中没有真正的线程，因为Linux并没有为线程准备特定的数据结构。在内核看来只有进程而没有线程，在调度时也是当做进程来调度。Linux所谓的线程其实是与其他进程共享资源的进程。但windows中确实有线程。</li><li>Linux中没有的线程，线程是由进程来模拟实现的。</li><li>所以在Linux中在CPU角度看，进程被称作轻量级进程LWP。</li></ol><h5 id="3-5-5-协程"><a href="#3-5-5-协程" class="headerlink" title="3.5.5 协程"></a>3.5.5 协程</h5><h6 id="3-5-5-1-协程定义"><a href="#3-5-5-1-协程定义" class="headerlink" title="3.5.5.1 协程定义"></a>3.5.5.1 协程定义</h6><p>大多数web服务跟互联网服务本质上大部分都是 IO 密集型服务，IO 密集型服务的瓶颈不在CPU处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。以前有两种解决方案：</p><ol><li><code>多进程</code>：存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。</li><li><code>多线程</code>：高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题。</li></ol><p>此时协程出现了，协程 Coroutines 是一种比线程更加轻量级的微线程。类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程。可以简单的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。</p><figure class="image-box">                <img src="image-20220208110132404.png" alt="image-20220208110132404" title class>                <p>image-20220208110132404</p>            </figure><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多，一般在Python、Go中会涉及到协程的知识，尤其是现在高性能的脚本Go。</p><h6 id="3-5-5-2-协程注意事项"><a href="#3-5-5-2-协程注意事项" class="headerlink" title="3.5.5.2 协程注意事项"></a>3.5.5.2 协程注意事项</h6><p>协程运行在线程之上，并且协程调用了一个阻塞IO操作，此时操作系统并不知道协程的存在，它只知道线程，因此在协程调用阻塞IO操作时，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度。</p><p>因此在协程中不能调用导致线程阻塞的操作，比如打印、读取文件、Socket接口等。<code>协程只有和异步IO结合</code>起来才能发挥最大的威力。并且<strong>协程只有在IO密集型的任务中才会发挥作用</strong>。</p><h3 id="3-6-进程通信"><a href="#3-6-进程通信" class="headerlink" title="3.6 进程通信"></a>3.6 进程通信</h3><p>进程的用户地址空间是相互独立的，不可以互相访问，但内核空间是进程都共享的，所以进程之间要通信必须通过内核。<strong>进程间通信主要通过管道、消息队列、共享内存、信号量、信号、Socket编程</strong>。</p><h5 id="3-6-1-管道"><a href="#3-6-1-管道" class="headerlink" title="3.6.1 管道"></a>3.6.1 管道</h5><p>管道主要分为匿名管道跟命名管道两种，可以实现数据的单向流动性。<strong>使用起来很简单，但是管道这种通信方式效率低，不适合进程间频繁地交换数据</strong>。</p><p><strong>匿名管道</strong>：</p><ol><li>日常Linux系统中的<code>|</code>就是匿名管道。指令的前一个输入是后一个指令的输出。</li></ol><p><strong>命名管道</strong>：</p><ol><li>一般通过<code>mkfifo SoWhatPipe</code>创建管道。通过<code>echo &quot;sw&quot; &gt; SoWhatPipe</code>跟<code>cat &lt; SoWhatPipe</code> 实现输入跟输出。</li></ol><p>匿名管道的实现依赖<code>int pipe(int fd[2])</code>函数，其中<code>fd[0]</code>是读取断描述符，<code>fd[1]</code>是管道写入端描述符。它的本质就是在内核中创建个属于内存的缓存，从一端输入无格式数据一端输出无格式数据，需注意管道传输大小是有限的。</p><figure class="image-box">                <img src="image-20220208110149376.png" alt="image-20220208110149376" title class>                <p>image-20220208110149376</p>            </figure><p>管道通信底层</p><p>匿名管道的通信范围是存在父子关系的进程。由于管道没有实体，也就是没有管道文件，不会涉及到文件系统。只能通过<code>fork</code>子进程来复制父进程 fd 文件描述符，父子进程通过共用特殊的管道文件实现跨进程通信，并且因为管道只能一端写入，另一端读出，所以通常父子进程遵从如下要求：</p><ol><li>父进程关闭读取的 fd[0]，只保留写入的 fd[1]。</li><li>子进程关闭写入的 fd[1]，只保留读取的 fd[0]。</li></ol><figure class="image-box">                <img src="image-20220208110206417.png" alt="image-20220208110206417" title class>                <p>image-20220208110206417</p>            </figure><p>shell管道通信</p><p>需注意Shell执行匿名管道 a | b其实是通过Shell父进程fork出了两个子进程来实现通信的，而ab之间是不存在父子进程关系的。而命名管道是可以直接在不想关进程间通信的，因为有管道文件。</p><h5 id="3-6-2-消息队列"><a href="#3-6-2-消息队列" class="headerlink" title="3.6.2 消息队列"></a>3.6.2 消息队列</h5><figure class="image-box">                <img src="image-20220208110230770.png" alt="image-20220208110230770" title class>                <p>image-20220208110230770</p>            </figure><p>消息队列</p><p>消息队列是保存在<strong>内核</strong>中的消息链表，<strong>会涉及到用户态跟内核态到来回切换</strong>，双方约定好消息体到数据结构，然后发送数据时将数据分成一个个独立的数据单元消息体，需注意消息队列及单个消息都有上限，日常我们到<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247490325&amp;idx=1&amp;sn=ab7cfedc7b8f2361cc1fab9418b314b8&amp;chksm=ebdefa2ddca9733b76cffbcba2d5f8c0c61bd36d5ebba20aaecb07148aa0fd7a5781e16ab03e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">RabbitMQ</a>、<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247488832&amp;idx=1&amp;sn=5999893d7fe773f54f7d097ac1c2074d&amp;chksm=ebdef478dca97d6e2433abdeecf600669ffbb1b68eb2b744e7ed72aac4cd5c4cabf19b0d8f19&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Redis </a>都涉及到消息队列。</p><h5 id="3-6-3-共享内存"><a href="#3-6-3-共享内存" class="headerlink" title="3.6.3 共享内存"></a>3.6.3 共享内存</h5><figure class="image-box">                <img src="image-20220208110245494.png" alt="image-20220208110245494" title class>                <p>image-20220208110245494</p>            </figure><p>共享空间</p><p>现代操作系统对内存管理采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和进程B虚拟地址是一样的，真正访问的也是不同的物理内存地址，该模式不涉及到用户态跟内核态来回切换，JVM 就是用的共享内存模式。并且并发编程也是个难点。</p><h5 id="3-6-4-信号量"><a href="#3-6-4-信号量" class="headerlink" title="3.6.4 信号量"></a>3.6.4 信号量</h5><p>既然共享内存容易造成数据紊乱，那为了简单的实现共享数据在任意时刻只能被一个进程访问，此时需要信号量。</p><p><strong>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</strong>。</p><p>信号量表示资源的数量，核心点在于原子性的控制一个数据的值，控制信号量的方式有<strong>PV两种原子操作</strong>：</p><ol><li>P 操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待。相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li><li>V 操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行。相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程。</li></ol><h5 id="3-6-5-信号"><a href="#3-6-5-信号" class="headerlink" title="3.6.5 信号"></a>3.6.5 信号</h5><p>对于异常状态下进程工作模式需要用到信号工作方式来通知进程。比如Linux系统为了响应各种事件提供了很多异常信号<code>kill -l</code>，<strong>信号是进程间通信机制中唯一的异步通信机制</strong>，可以在任何时候发送信号给某一进程。比如：</p><ol><li>kill -9 1412 ，表示给 PID 为 1412 的进程发送 SIGKILL 信号，用来立即结束该进程。</li><li>键盘 Ctrl+C 产生 SIGINT 信号，表示终止该进程。</li><li>键盘 Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束。</li></ol><p>有信号发生时，进程一般有三种方式响应信号：</p><ol><li>执行默认操作：Linux操作系统为众多信号配备了专门的处理操作。</li><li>捕捉信号：给捕捉到的信号配备专门的信号处理函数。</li><li>忽略信号：专门用来忽略某些信号，但 SIGKILL 和 SEGSTOP是无法被忽略的，为了能在任何时候结束或停止某个进程而存在。</li></ol><h5 id="3-6-6-Socket编程"><a href="#3-6-6-Socket编程" class="headerlink" title="3.6.6 Socket编程"></a>3.6.6 Socket编程</h5><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，<strong>那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocal)</span><br></pre></td></tr></table></figure><p>上面是socket编程的核心函数，可以指定IPV4或IPV6类型，TCP或UDP类型。比如<a href="http://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;mid=2247490719&amp;idx=1&amp;sn=9590fea26b75698ddb37b24ef34e0c8c&amp;chksm=ebdefda7dca974b16ac1e3ae78ff0222c4ad4bd181a70a233df8683cb3fb6199395e14bd65e6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"><strong>TCP</strong></a>协议通信的 socket 编程模型如下：</p><figure class="image-box">                <img src="image-20220208110306777.png" alt="image-20220208110306777" title class>                <p>image-20220208110306777</p>            </figure><p>Socket编程</p><ol><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符。</li><li>服务端调用<code>bind</code>，将绑定在 IP 地址和端口。</li><li>服务端调用 <code>listen</code>，进行监听。</li><li>服务端调用 <code>accept</code>，等待客户端连接。</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求。</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符。</li><li>客户端调用 <code>write</code> 写入数据，服务端调用 <code>read</code> 读取数据。</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了<code>EOF</code>，待处理完数据后，服务端调用 close，表示连接关闭。</li><li>服务端调用 <code>accept</code>时，连接成功会返回一个已完成连接的 <code>socket</code>，后续用来传输数据。服务端有俩<code>socket</code>，一个叫作监听 <code>socket</code>，一个叫作已完成连接 <code>socket</code>。</li><li>成功连接建立之后双方开始通过 read 和 write 函数来读写数据。</li></ol><figure class="image-box">                <img src="image-20220208110319666.png" alt="image-20220208110319666" title class>                <p>image-20220208110319666</p>            </figure><p>  UDP传输</p><p>UDP比较简单，属于类似广播性质的传输，不需要维护连接。但也需要 bind，每次通信时调用 sendto 和 recvfrom 都要传入目标主机的 IP 地址和端口。</p><h3 id="3-7-多线程编程"><a href="#3-7-多线程编程" class="headerlink" title="3.7 多线程编程"></a>3.7 多线程编程</h3><p>既然多进程开销过大，那平常我们经常使用到的就是多线程编程了。期间可能涉及到内存模型、JMM、Volatile、临界区等等。这些在<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1663052626025840644&amp;__biz=MzI4NjI1OTI4Nw==&amp;uin=&amp;key=&amp;devicetype=Windows+7+x64&amp;version=63010043&amp;lang=zh_CN&amp;ascene=7&amp;fontgear=2" target="_blank" rel="noopener">Java并发编程专栏</a>有讲。</p><h1 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h1><h3 id="4-1-VFS-虚拟文件系统"><a href="#4-1-VFS-虚拟文件系统" class="headerlink" title="4.1 VFS 虚拟文件系统"></a>4.1 VFS 虚拟文件系统</h3><p>  文件系统在操作系统中主要负责将文件数据信息存储到磁盘中，起到持久化文件的作用。文件系统的基本组成单元就是文件，文件组成方式不同就会形成不同的文件系统。</p><p>  文件系统有很多种而不同的文件系统应用到操作系统后需要提供统一的对外接口，此时用到了一个设计理念<code>没有什么是加一层解决不了的</code>，在用户层跟不同的文件系统之间加入一个虚拟文件系统层 <code>Virtual File System</code>。</p><p>  虚拟文件系统层<code>定义了一组所有文件系统都支持的数据结构和标准接口</code>，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p><p>  <img src="image-20220208110333436.png" alt="image-20220208110333436">虚拟文件系统</p><p>  日常的文件系统一般有如下三种：</p><p>   1 <code>磁盘文件系统</code>：就是我们常见的EXT 2/3/4系列。<br>   2 <code>内存文件系统</code>：数据没存储到磁盘，占用内存数据，比如<code>/sys</code>、<code>/proc</code>。进程中的一些数据映射到/proc中了。<br>   3 <code>网络文件系统</code>：常见的网盘挂载NFS等，通过访问其他主机数据实现。</p><h3 id="4-2-文件组成"><a href="#4-2-文件组成" class="headerlink" title="4.2 文件组成"></a>4.2 文件组成</h3><p>以Linux系统为例，在Linux系统中一切皆文件，Linux文件系统会为每个文件分配<code>索引节点 inode</code>跟<code>目录项directory entry</code>来记录文件内容跟目录层次结构。</p><h5 id="4-2-1-inode"><a href="#4-2-1-inode" class="headerlink" title="4.2.1 inode"></a>4.2.1 inode</h5><p>  要理解<code>inode</code>要从文件储存说起。文件存储在硬盘上，硬盘的最小存储单位叫做扇区。每个扇区储存512字节。操作系统读取硬盘的时候，不会一个个扇区的读取，这样效率太低，一般一次性连续读取8个扇区(4KB)来当做一块，这种由多个扇区组成的<strong>块</strong>，是文件存取的最小单位。</p><p>  文件数据都储存在块中，我们还必须找到一个地方储存文件的元信息，比如inode编号、文件大小、创建时间、修改时间、磁盘位置、访问权限等。几乎除了文件名以为的所有文件元数据信息都存储在一个叫叫索引节点inode的地方。可通过<code>stat 文件名</code>查看 inode 信息</p><p>  每个inode都有一个号码，操作系统用inode号码来识别不同的文件。Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件，用户可通过<code>ls -i</code>查看每个文件对应编号。对于系统来说文件名只是inode号码便于识别的别称或者绰号。特殊名字的文件不好删除时可以尝试用inode号删除，移动跟重命名不会导致文件inode变化，当用户尝试根据文件名打开文件时，实际上系统内部将这个过程分成三步：</p><ol><li>系统找到这个文件名对应的inode号码。</li><li>通过inode号码，获取inode信息，进行权限验证等操作。</li><li><p>根据inode信息，找到文件数据所在的block，读出数据。</p><p>需注意 inode也会消耗硬盘空间，硬盘格式化后会被分成<strong>超级块</strong>、<strong>索引节点区</strong>和<strong>数据块区</strong>三个区域：</p></li><li><p><code>超级块区</code>：用来存储文件系统的详细信息，比如块大小，块个数等信息。一般文件系统挂载后就会将数据信息同步到内存。</p></li><li><p><code>索引节点区</code>：用来存储索引节点 inode  table。每个inode一般为128字节或256字节，一般每1KB或2KB数据就需设置一个inode。一般为了加速查询会把索引数据缓存到内存。</p></li><li><p><code>数据块区</code>：真正存储磁盘数据的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -i # 查看每个硬盘分区的inode总数和已经使用的数量</span><br><span class="line">sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot; # 查看每个inode节点的大小</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-2-2-目录"><a href="#4-2-2-目录" class="headerlink" title="4.2.2 目录"></a>4.2.2 目录</h5><p>Unix/Linux系统中<strong>目录directory也是一种文件</strong>，打开目录实际上就是打开目录文件。目录文件内容就是一系列目录项的列，目录项的内容包含<strong>文件的名字、文件类型、索引节点指针以及与其他目录项的层级关系</strong>。</p><p>为避免频繁读取磁盘里的目录文件，内核会把已经读过的目录文件用<code>目录项</code>这个数据结构缓存在内存，方便用户下次读取目录信息，目录项可包含目录或文件，不要惊讶于可以保存目录，目录格式的目录项里面保存的是目录里面一项一项的文件信息。</p><h5 id="4-2-3-软连接跟硬链接"><a href="#4-2-3-软连接跟硬链接" class="headerlink" title="4.2.3 软连接跟硬链接"></a>4.2.3 软连接跟硬链接</h5><figure class="image-box">                <img src="image-20220208110345265.png" alt="image-20220208110345265" title class>                <p>image-20220208110345265</p>            </figure><p>软连接跟硬链接</p><p><strong>硬链接</strong>：老文件A被创建若干个硬链接B、C后。A、B、C三个文件的inode是相同的，所以不能跨文件系统。同时只有ABC全部删除，系统才会删除源文件。<br><strong>软链接</strong>：相当于基于老文件A新建了个文件B，该文件B有新的inode，不过文件B内容是老文件A的路径。所以软链接可以跨文件系统。当老文件A删除后，文件B仍然存在，不过找不到指定文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[sowhat@localhost ~]$ ln [选项] 源文件 目标文件</span><br><span class="line">选项：</span><br><span class="line">-s：建立软链接文件。如果不加 &quot;-s&quot; 选项，则建立硬链接文件；</span><br><span class="line">-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</span><br></pre></td></tr></table></figure><h3 id="4-3-文件存储"><a href="#4-3-文件存储" class="headerlink" title="4.3 文件存储"></a>4.3 文件存储</h3><p>说文件存储前需了解<strong>文件系统操作基本单位是数据块</strong>，而平常用户操作字节到数据块之间是需要转换的，当然这些文件系统都帮我们对接好了。接下来看文件系统是如何按照数据块， 文件在磁盘中存储时候主要分为<code>连续空间存储</code>跟<code>非连续空间存储</code></p><h5 id="4-3-1-连续空间存储"><a href="#4-3-1-连续空间存储" class="headerlink" title="4.3.1 连续空间存储"></a>4.3.1 连续空间存储</h5><ol><li><p><code>实现</code>：连续空间存储的意思就跟数组存储一样，找个连续的空间一次性把数据存储进去，<strong>文件头</strong>存储起始位置跟数据长度即可。</p></li><li><p><code>优势</code>：读写效率高，磁盘寻址一次即可。</p></li><li><p><code>劣势</code>：容易产生空间碎片，并且文件扩容不方便。</p><p><img src="image-20220208110358288.png" alt="image-20220208110358288"></p><p>连续存储</p></li></ol><h5 id="4-3-2-非连续空间存储之链表"><a href="#4-3-2-非连续空间存储之链表" class="headerlink" title="4.3.2 非连续空间存储之链表"></a>4.3.2 非连续空间存储之链表</h5><p><strong>隐式链表</strong></p><ol><li><code>实现</code>：文件头包含StartBlock、EndBlock。每个BLock有隐藏的next指针，跟单向链表一样。</li><li><code>缺点</code>：只能通过链式不断往下查找数据，不支持快速直接访问。</li></ol><figure class="image-box">                <img src="image-20220208110410511.png" alt="image-20220208110410511" title class>                <p>image-20220208110410511</p>            </figure><p><strong>显式链表</strong></p><ol><li><p><code>实现</code>：把每个Block中的next指针存储到内存<code>文件分配表</code>中，通过遍历数组方式实现拿到全部数据。</p></li><li><p><code>缺点</code>：前面说1KB就有个inode指针，如果磁盘数据很大那就需要很大的<strong>文件分配表</strong>来存储映射关系了，</p><p><img src="image-20220208110425596.png" alt="image-20220208110425596"><br>显示链表</p></li></ol><h5 id="4-3-3-非连续空间存储之索引"><a href="#4-3-3-非连续空间存储之索引" class="headerlink" title="4.3.3 非连续空间存储之索引"></a>4.3.3 非连续空间存储之索引</h5><ol><li><code>实现</code>：整个文件类型一本新华字典，真实的数据块在词典实际位置存储着，但文件所需数据块的索引位置会被汇总起来形成目录索引放在字典前头。</li><li><code>优势</code>：不会产生碎片，文件可动态扩容，并且支持顺序跟随机读写。</li><li><code>劣势</code>：可能一个小文件都要占用一个目录索引，文件过大导致索引指针一个容不下，可能还需要有<code>多级索引</code>或<code>索引+链表</code>模式。</li></ol><figure class="image-box">                <img src="image-20220208110436521.png" alt="image-20220208110436521" title class>                <p>image-20220208110436521</p>            </figure><p>  索引存储</p><p>这些存储方式各有利弊，所以操作系统才存储的时候一般是根据文件的大小进行动态的变化存储方式的，跟STL中的快排底层 = 快排 + 插入排序 + 堆排 一样的道理。</p><h5 id="4-3-4-空闲空间管理"><a href="#4-3-4-空闲空间管理" class="headerlink" title="4.3.4 空闲空间管理"></a>4.3.4 空闲空间管理</h5><p>为了避免用户存储数据时候遍历全部磁盘空间来寻找可以数据块，一般有如下几种记录方法。</p><ol><li><p><code>空闲表</code>：动态的维护一个空闲数据块列表，每行存储空闲块的开始位置跟空闲长度。适合少量有少量空闲数据块时。</p><p><img src="image-20220208110452631.png" alt="image-20220208110452631"><br>空闲表</p></li><li><p><code>空闲链表</code>：将空闲的数据库用next指针串联起来，缺点是不能随机访问。</p><p><img src="image-20220208110504160.png" alt="image-20220208110504160"><br>空闲链表</p></li><li><p><code>位图法</code>：利用Bit的 01 表示数据块可用跟不可用，简单方便，<strong>inode跟空闲数据库都用的此方法</strong>。</p><p><img src="image-20220208110514002.png" alt="image-20220208110514002"><br>位图法</p></li></ol><h1 id="5-输入输出管理"><a href="#5-输入输出管理" class="headerlink" title="5  输入输出管理"></a>5  输入输出管理</h1><h3 id="5-1-设备控制器跟驱动程序"><a href="#5-1-设备控制器跟驱动程序" class="headerlink" title="5.1 设备控制器跟驱动程序"></a>5.1 设备控制器跟驱动程序</h3><h5 id="5-1-1-设备控制器"><a href="#5-1-1-设备控制器" class="headerlink" title="5.1.1 设备控制器"></a>5.1.1 设备控制器</h5><figure class="image-box">                <img src="image-20220208110525266.png" alt="image-20220208110525266" title class>                <p>image-20220208110525266</p>            </figure><p>  设备控制器</p><p>操作系统为统一管理众多的设备并且屏蔽设备之间的差异，给每个设备都安装了个小CPU叫<strong>设备控制器</strong>。每个设备控制器都知道自己对应外设的功能跟用法，并且每个<strong>设备控制器</strong>都有独有的寄存器用来跟CPU通信。</p><ol><li>读设备寄存器值了解设备状态，是否可以接收新指令。</li><li>操作系统给设备寄存器写入一些指令可以实现发送数据、接收数据等等操作。</li></ol><p>控制器一般分为<strong>数据寄存器、命令寄存器跟状态寄存器</strong>，CPU 通过读、写设备控制器中的寄存器来便捷的控制设备：</p><ol><li><code>数据寄存器</code>：CPU 向 I/O 设备写入需要传输的数据，比如打印what，CPU 就要先发送一个w字符给到对应的 I/O 设备。</li><li><code>命令寄存器</code>：CPU 发送命令来告诉 I/O 设备要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。</li><li><code>状态寄存器</code>：用来告诉 CPU 现在已经在工作或工作已经完成，只有状态寄存标记成已完成，CPU 才能发送下一个字符和命令。</li></ol><p>同时输入输出设备可分为<code>块设备</code>跟<code>字符设备</code>。</p><ol><li><code>块设备</code>：用来把数据存储在固定大小的块中，每个块有自己的地址，硬盘、U盘等是常见的块设备。块设备一般数据传输较大为避免频繁IO，控制器中有个可读写等<strong>数据缓冲区</strong>。Linux操作系统为屏蔽不同块设备带来的差异引入了<strong>通用块层</strong>，<strong>通用块层</strong>是处于文件系统和磁盘驱动中间的一个块设备抽象层，主要提供如下俩功能：</li></ol><blockquote><ol><li>向上为文件系统和应用程序，提供访问块设备的标准接口，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面提供一个框架来管理这些设备的驱动程序。</li><li>通用层还会给文件系统和应用程序发来的 I/O进行<strong>调度</strong>，主要目的是为了提高磁盘读写的效率。</li></ol></blockquote><ol><li><code>字符设备</code>：以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。</li></ol><p>CPU一般通过<strong>IO端口</strong>跟<strong>内存映射IO</strong>来跟设备的控制寄存器和数据缓冲区进行通信</p><ol><li><code>IO端口</code>：每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 in/out 类似的指令。</li><li><code>内存映射IO</code>：将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。</li></ol><h5 id="5-1-2-驱动接口"><a href="#5-1-2-驱动接口" class="headerlink" title="5.1.2 驱动接口"></a>5.1.2 驱动接口</h5><figure class="image-box">                <img src="image-20220208110540638.png" alt="image-20220208110540638" title class>                <p>image-20220208110540638</p>            </figure><p>  驱动程序</p><p>设备控制器屏蔽了设备细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，它属于硬件。在操作系统图范畴内为了屏蔽设备控制器的差异，引入了<strong>设备驱动程序</strong>，<strong>不同设备到驱动程序会提供统一接口给操作系统来调用</strong>，这样操作系统内核会像调用本地代码一样使用设备驱动程序接口。</p><p>设备发出IO请求就是在<strong>设备驱动程序</strong>中来响应到，它会根据中断类型调用响应到中断处理程序进行处理。</p><figure class="image-box">                <img src="image-20220208110624410.png" alt="image-20220208110624410" title class>                <p>image-20220208110624410</p>            </figure><p>  中断请求流程</p><h3 id="5-2-IO-控制"><a href="#5-2-IO-控制" class="headerlink" title="5.2 IO 控制"></a>5.2 IO 控制</h3><p>CPU发送指令让那个设备控制器去读写数据，完毕后如何通知CPU呢？</p><h5 id="5-2-1-轮询模式"><a href="#5-2-1-轮询模式" class="headerlink" title="5.2.1 轮询模式"></a>5.2.1 轮询模式</h5><p>控制器中有个<strong>状态寄存器</strong>，CPU不断<strong>轮</strong>询查看寄存器状态，该模式会傻瓜式的一直占用CPU。</p><figure class="image-box">                <img src="image-20220208110635167.png" alt="image-20220208110635167" title class>                <p>image-20220208110635167</p>            </figure><p>  轮询模式</p><h5 id="5-2-2-IO-中断请求"><a href="#5-2-2-IO-中断请求" class="headerlink" title="5.2.2 IO 中断请求"></a>5.2.2 IO 中断请求</h5><figure class="image-box">                <img src="image-20220208110646262.png" alt="image-20220208110646262" title class>                <p>image-20220208110646262</p>            </figure><p>  中断模式</p><p>控制器有个中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU来处理中断请求。中断有两种，一种是<strong>软中断</strong>，比如代码调用 INT 指令触发。一种是<strong>硬件中断</strong>，硬件通过中断控制器触发的。但中断方式对于频繁读写磁盘数据的操作就不太友好了，会频繁打断CPU。</p><p>这里说下磁盘高速缓存 <strong>PageCache</strong>，它是用来缓存最近被CPU访问的数据到内存中，并且还具有预读功能，可能你读前16KB数据，已经把后16KB数据给你缓存好了。</p><blockquote><ol><li><strong>pagecache</strong> : 页缓存，当进程需读取磁盘文件时，linux先分配一些内存，将数据从磁盘读区到内存中，然后再将数据传给进程。当进程需写数据到磁盘时，linux先分配内存接收用户数据，然后再将数据从内存写到磁盘。同时pagecache由于大小受限，所以一般只缓存最近被访问的数据，数据不足时还需访问磁盘。</li></ol></blockquote><h5 id="5-2-3-DMA-模式"><a href="#5-2-3-DMA-模式" class="headerlink" title="5.2.3 DMA 模式"></a>5.2.3 DMA 模式</h5><p><code>Direct Memory Access</code> 直接内存访问，在硬件DMA控制器的支持下，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，让CPU 去处理别的事</strong>。</p><figure class="image-box">                <img src="image-20220208110700883.png" alt="image-20220208110700883" title class>                <p>image-20220208110700883</p>            </figure><p>  DMA模式</p><p>可以发现整个数据传输过程中CPU是不会直接参与数据搬运工作，由DMA来直接负责数据读取工作，现如今每个IO设备一般都自带DMA控制器。读数据时候仅仅在传送开始跟结束时需要CPU干预。</p><h5 id="5-2-4-Zero-Copy"><a href="#5-2-4-Zero-Copy" class="headerlink" title="5.2.4 Zero Copy"></a>5.2.4 Zero Copy</h5><p>Zero Copy 全程不会通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的，中间只需要经过2次上下文切换跟2次DMA数据拷贝，相比最原始读写方式至少速度翻倍。其实在Kafka中已经讲过Zero Copy了。</p><h6 id="5-2-4-1-老版本读写"><a href="#5-2-4-1-老版本读写" class="headerlink" title="5.2.4.1 老版本读写"></a>5.2.4.1 老版本读写</h6><p>老版本的简单读写操作中间不对数据做任何操作。期间会发生<strong>4次用户态跟内核态的切换。2次DMA数据拷贝，2次CPU数据拷贝</strong>。</p><figure class="image-box">                <img src="image-20220208110717472.png" alt="image-20220208110717472" title class>                <p>image-20220208110717472</p>            </figure><p>  老式读写</p><p>提速方法就是需减少用户态与内核态的上下文切换和内存拷贝的次数。数据传输时从内核的读缓冲区拷贝到用户的缓冲区，再从用户缓冲区拷贝到 socket 缓冲区的这个过程是没有必要的。接下来</p><p>接下来按照三个版本说下Zero Copy 发展史。</p><h6 id="5-2-4-2-mmap-跟-write"><a href="#5-2-4-2-mmap-跟-write" class="headerlink" title="5.2.4.2  mmap 跟 write"></a>5.2.4.2  mmap 跟 write</h6><figure class="image-box">                <img src="image-20220208110728516.png" alt="image-20220208110728516" title class>                <p>image-20220208110728516</p>            </figure><p>  mmap + write</p><p>思路就是用<strong>mmap</strong>替代read函数，mmap调用时会<strong>直接把内核缓冲区里的数据映射到用户空间</strong>，此时减少了一次数据拷贝，但仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><h6 id="5-2-4-3-sendfile"><a href="#5-2-4-3-sendfile" class="headerlink" title="5.2.4.3 sendfile"></a>5.2.4.3 sendfile</h6><p>Linux 内核版本 2.1版本提供了函数 <strong>sendfile()</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span><br><span class="line">out_fd : 目的文件描述符</span><br><span class="line">in_fd:源文件描述符</span><br><span class="line">offset:源文件内偏移量</span><br><span class="line">count:打算复制数据长度</span><br><span class="line">ssize_t:实际上复制数据的长度</span><br></pre></td></tr></table></figure><p>可以发现一个 sendfile = read + write，避免了2次用户态跟内核态来回切换，并且可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，这样就只有 2 次上下文切换，和 3 次数据拷贝。</p><figure class="image-box">                <img src="image-20220208110742002.png" alt="image-20220208110742002" title class>                <p>image-20220208110742002</p>            </figure><p> sendfile模式</p><h6 id="5-2-4-4-真正的零拷贝"><a href="#5-2-4-4-真正的零拷贝" class="headerlink" title="5.2.4.4 真正的零拷贝"></a>5.2.4.4 真正的零拷贝</h6><p>Linux 内核 2.4如果网卡支持SG-DMA 技术，可以减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure><p>SG-DMA 技术可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝。</p><figure class="image-box">                <img src="image-20220208110800158.png" alt="image-20220208110800158" title class>                <p>image-20220208110800158</p>            </figure><p>  ZeroCopy</p><h6 id="5-2-4-5-文件传输规则"><a href="#5-2-4-5-文件传输规则" class="headerlink" title="5.2.4.5 文件传输规则"></a>5.2.4.5 文件传输规则</h6><p>不要以为会了Zero Copy后，无论大小文件都用Zero Copy。实际工作中一般小文件采用Zero Copy技术，而大文件会用异步IO。至于为啥，且看如下分析：</p><p>前面说的数据从磁盘读到内核缓冲区就是读到PageCache中，PageCache具有缓存跟预读功能。但当传输超大文件时PageCache会不失效，因为大文件会快速占满PageCache区，但这些文件又只是一次访问，会造成其他热点小文件无法使用PageCache，所以索性不用PageCache，使用异步IO的了。至于异步IO是啥呢？下文在说。</p><h3 id="5-3-IO分层"><a href="#5-3-IO分层" class="headerlink" title="5.3 IO分层"></a>5.3 IO分层</h3><figure class="image-box">                <img src="image-20220208110811235.png" alt="image-20220208110811235" title class>                <p>image-20220208110811235</p>            </figure><p>  IO分层</p><p>Linux 存储系统的 I/O 由上到下可以分为<strong>文件系统层</strong>、<strong>通用块层</strong>、<strong>设备层</strong>。</p><ol><li>文件系统层向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。</li><li>通用块层包括块设备的 I/O 队列和 I/O 调度器，通过IO调度器处理IO请求。</li><li>设备层包括硬件设备、设备控制器和驱动程序，负责最终物理设备的 I/O 操作。</li></ol><p>Linux系统中的IO<strong>读取提速</strong>：</p><ol><li>为提高文件访问效率会使用页缓存、索引节点缓存、目录项缓存等多种缓存机制，目的是为了减少对块设备的直接调用。</li><li>为了提高块设备的访问效率， 会使用缓冲区，来缓存块设备的数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列| kafka中间件原理 &amp;&amp; 知识点</title>
      <link href="/2021/12/08/kafka-notes/"/>
      <url>/2021/12/08/kafka-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>首先了解一下使用分布式消息队列的优点，总结主要包括以下几个方面：</p><ul><li><p>解耦 tags: None</p><p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li><li><p>冗余</p><p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p></li><li><p>扩展性</p><p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p></li><li><p>灵活性 &amp; 峰值处理能力</p><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p></li><li><p>可恢复性</p><p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p></li><li><p>顺序保证</p><p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。［Kafka保证一个Partition内的消息的有序性；nsq不保证消息的顺序性］</p></li><li><p>缓冲</p><p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p></li><li><p>异步通信<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p></li></ul><p>不同的Message Queue各具特色，此处以nsq和kafka这两种平台为例，做简要介绍</p><h3 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h3><p>NSQ是基于Go语言开发的实时的分布式消息平台，具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。</p><p>四个重要组件：</p><ul><li>nsqd：一个负责接收、排队、转发消息到客户端的守护进程</li><li>nsqlookupd：管理拓扑信息并提供最终一致性的发现服务的守护进程</li><li>nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行各种各样的管理任务</li><li>utilities：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq</li></ul><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul><li>支持无 SPOF 的分布式拓扑</li><li>水平扩展(没有中间件，无缝地添加更多的节点到集群)</li><li>低延迟消息传递 (性能)</li><li>结合负载均衡和多播消息路由</li><li>擅长面向流(高吞吐量)和任务(低吞吐量)工作负载</li><li>主要是内存中(除了高水位线消息透明地保存在磁盘上)</li><li>运行时为消费者提供发现生产者的服务(nsqlookupd)</li><li>传输层安全性 (TLS)</li><li>数据格式不可知</li><li>较少依赖(容易部署)和健全的、有界、默认配置</li><li>简单 TCP 协议，可以支持任何语言的客户端库</li><li>HTTP 接口统计、管理行为和生产者(不需要客户端库发布)</li><li>集成了statsd来实现实时检测</li><li>健壮的集群管理界面 (nsqadmin)</li></ul><h4 id="担保："><a href="#担保：" class="headerlink" title="担保："></a>担保：</h4><ul><li>支持消息内存队列的大小设置，默认完全持久化（值为0），消息即可持久到磁盘也可以保存在内存中</li><li>保证消息至少传递一次,以确保消息可以最终成功发送</li><li>收到的消息是无序的, 实现了松散订购</li><li>发现服务nsqlookupd具有最终一致性,消息最终能够找到所有Topic生产者</li></ul><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>NSQ中的数据流模型是由stream和consumer组成。Topic是一种独特的stream，Channel是一个订阅了给定Topic的consumer逻辑分组。NSQ的数据流模型结构如下图所示：</p><figure class="image-box">                <img src="uigd95fik9.gif" alt="uigd95fik9" title class>                <p>uigd95fik9</p>            </figure><p>从上图可以看出，单个nsqd可以有多个Topic，每个Topic又可以有多个Channel。</p><p>Channel能够接收Topic所有消息的副本，从而实现了消息多播分发；</p><p>而Channel上的每个消息被分发给它的订阅者，从而实现负载均衡，所有这些就组成了一个可以表示各种简单和复杂拓扑结构的强大框架。</p><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h4><ul><li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。</li><li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。</li><li>同时支持离线数据处理和实时数据处理。</li><li>Scale out：支持在线水平扩展。</li></ul><h4 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h4><ul><li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li><li>Producer：负责发布消息到Kafka broker</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li></ul><h4 id="Kafka拓扑结构"><a href="#Kafka拓扑结构" class="headerlink" title="Kafka拓扑结构"></a>Kafka拓扑结构</h4><figure class="image-box">                <img src="1025005-20160924125839231-370630847.png" alt="kafka架构图" title class>                <p>kafka架构图</p>            </figure><p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p><h4 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h4><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。</p><h4 id="Producer消息路由"><a href="#Producer消息路由" class="headerlink" title="Producer消息路由"></a>Producer消息路由</h4><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。</p><p>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。</p><h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>（本节所有描述都是基于Consumer hight level API而非low level API）。</p><p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p><figure class="image-box">                <img src="70.png" alt="img" title class>                <p>img</p>            </figure><p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p><h3 id="NSQ-vs-Kafka"><a href="#NSQ-vs-Kafka" class="headerlink" title="NSQ vs Kafka"></a>NSQ vs Kafka</h3><table><thead><tr><th></th><th>NSQ</th><th>Kafka</th></tr></thead><tbody><tr><td>语言</td><td>Go</td><td>Scala</td></tr><tr><td>消息存储</td><td>内存&amp;&amp;磁盘</td><td>磁盘，文件方式</td></tr><tr><td>顺序保证</td><td>无序，松散订阅</td><td>保证有序</td></tr></tbody></table><p>至于在实际应用中，两种消息队列如何选择，要根据业务需求和消息队列的特性做出合理选择。以“问答”服务端为例，目前NSQ和Kafka两种消息队列都在使用中：</p><p>比如对用户行为进行统计的相关消息，我们采用nsq，主要是因为nsq消息主要保存在内存，它在处理消息上更快；并且统计用户行为的消息，只需要对消息事件记录即可，并不要求严格的顺序。</p><p>而对于提交类的事件，就需要保证严格的顺序性。比如用户提交一个答案，随后又立刻删除；由于后台和data相关业务方是根据发送的消息作相关处理，如果删除答案的消息先发送，后台和data相关业务方将会出现错误；对于此类需要严格保证消息顺序的事件，我们就采用kafka。</p><hr><h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><h2 id="KafkaServer"><a href="#KafkaServer" class="headerlink" title="KafkaServer"></a>KafkaServer</h2><p>使用消息队列的主要好处有：</p><ul><li>解耦</li><li>峰值处理能力、异步</li><li>持久化</li><li>顺序保证</li><li>扩展性</li></ul><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><strong>Broker：</strong></p><p>Kafka集群中的一台服务器。</p><p><strong>Topic：</strong></p><p>主题。消息的分类，是逻辑上的概念，实际以partition的形式存放在各Broker服务器上。</p><p><strong>Partition：</strong></p><ul><li>分区。是物理上的概念，组成Topic的单位。</li></ul><p><strong>Replica：</strong></p><p>副本。是具体的分区，比Partition更具体的物理概念，一个真实的目录，存放在一台Broker服务器上。在代码中又分为leader和follower。</p><p><strong>Producer：</strong></p><ul><li>生产者。负责发送消息到Broker。</li></ul><p><strong>Consumer：</strong></p><ul><li>消费者。负责订阅Topic并拉取消息。</li></ul><p><strong>CousumerGroup：</strong></p><p>消费者组。每条消息只被组内成员消费一次。</p><h3 id="1-2-逻辑架构"><a href="#1-2-逻辑架构" class="headerlink" title="1.2 逻辑架构"></a>1.2 逻辑架构</h3><figure class="image-box">                <img src="60af40353a110cbc9948067b4502a75d.png" alt="image" title class>                <p>image</p>            </figure><h3 id="1-3-物理架构"><a href="#1-3-物理架构" class="headerlink" title="1.3 物理架构"></a>1.3 物理架构</h3><h4 id="1-3-1-集群物理架构"><a href="#1-3-1-集群物理架构" class="headerlink" title="1.3.1 集群物理架构"></a>1.3.1 集群物理架构</h4><ul><li>*<figure class="image-box">                <img src="0993d208eeb5dfe12a9e6f132e9d0eef.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>如上图，本集群有：</p><ul><li>4台broker。broker_1 到 broker_4</li><li>2个topic。topic_A和topic_B</li><li>topic_A的分区数是4。topicA_0 到 topic_3</li><li>topic_A的副本因子是2。例如topicA_0这个分区，有两个副本，分别分布在broker_1和broker_3两台机器上。</li></ul><h4 id="1-3-2-一个副本目录结构"><a href="#1-3-2-一个副本目录结构" class="headerlink" title="1.3.2 一个副本目录结构"></a>1.3.2 一个副本目录结构</h4><p>上图中的topicA-0是一个partition，准确的说应该称之为一个副本，即Replica。它是broker_1服务器上的一个日志目录，其内部由多个segment文件组成。topicA-0目录结构：</p><ul><li>*<figure class="image-box">                <img src="15917459e5a10f3a6839bc535f0afbc6.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p><strong>*.log文件</strong>：日志文件</p><p><strong>*.index文件</strong>：稀疏索引文件</p><p><strong>*.timeindex文件</strong>：时间戳索引文件。根据时间戳快速定位消息所在位置。（Kafka API offsetsForTimes方法所使用）</p><p>index文件与log文件关系:</p><ul><li>*<figure class="image-box">                <img src="42a9581fb80035875abcaff0e6902542.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h3 id="1-4-代码架构"><a href="#1-4-代码架构" class="headerlink" title="1.4 代码架构"></a>1.4 代码架构</h3><h4 id="1-4-1-线程池"><a href="#1-4-1-线程池" class="headerlink" title="1.4.1 线程池"></a>1.4.1 线程池</h4><p>KafkaServer在启动时，初始化KafkaRequestHandlerPool线程池</p><p>KafkaRequestHandlerPool（线程池）由KafkaRequestHandler组成</p><p>KafkaRequestHandler调用KafkaApis处理request</p><p>下图：Kafka处理request的线程池</p><ul><li>*<figure class="image-box">                <img src="83fbd9155e52d987bb704a028f719772.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>kafkaServer接收的请求，包括来自客户端的请求和来自其他server的请求。客户端请求例如producer发送消息请求、consumer消费消息请求。其他broker请求例如副本同步日志请求。请求类型有21个枚举值。</p><p>所有的请求最终会收敛到Broker服务器上的KafkaApis.handle方法，如下图：</p><ul><li>*<figure class="image-box">                <img src="9fb206ff88bb93e7d92cf7dced0e540b.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h4 id="1-4-2-处理request的组件"><a href="#1-4-2-处理request的组件" class="headerlink" title="1.4.2 处理request的组件"></a>1.4.2 处理request的组件</h4><p>有3个重要组件处理上图21种请求，它们分别是：</p><ul><li><strong>ReplicaManager</strong><ul><li>把Produce日志写入磁盘</li><li>如果副本是follower，启动副本同步线程，发送fetch请求</li><li>如果副本是leader，处理来自副本的fetch请求</li></ul></li><li><strong>Coordinator</strong><ul><li>管理Consumer的balance</li></ul></li><li><strong>KafkaController</strong><ul><li>Broker 的上线、下线</li><li>新建 topic 或已有 topic 的扩容，topic 删除</li><li>处理replica的分配、迁移、leader 选举、leader 切换</li></ul></li></ul><p>下图：处理request请求</p><ul><li>*<figure class="image-box">                <img src="d85330c319388dddad5de8b90e743c9a.png" alt="image" title class>                <p>image</p>            </figure></li></ul><h2 id="2-可用性、可靠性保障"><a href="#2-可用性、可靠性保障" class="headerlink" title="2. 可用性、可靠性保障"></a>2. 可用性、可靠性保障</h2><h3 id="2-1-集群高可用性"><a href="#2-1-集群高可用性" class="headerlink" title="2.1 集群高可用性"></a>2.1 集群高可用性</h3><p>在应对单点故障时，kafka仍然能够对外提供服务，主要通过以下特性保证：</p><ul><li>分布式集群模式，多台服务器，分散单服务器压力。</li><li>一个topic拆分成多partition分区</li><li>一个partition建立n个副本，分为leader和follower，保持同步。leader一旦宕机从follower选举出新的leader提供读写日志服务。</li></ul><h3 id="2-2-消息可靠性与一致性"><a href="#2-2-消息可靠性与一致性" class="headerlink" title="2.2 消息可靠性与一致性"></a><strong>2.2 消息可靠性与一致性</strong></h3><p>面对故障时是否仍然保持最终一致。</p><ul><li>producer.ACKS = [ -1, 0, 1] 保证日志生产的准确性。</li><li>HW和LEO机制。保证日志同步的准确性。</li></ul><h4 id="2-2-1-producer-ACKs"><a href="#2-2-1-producer-ACKs" class="headerlink" title="2.2.1 producer.ACKs"></a>2.2.1 producer.ACKs</h4><p><strong>ACKs=1</strong></p><ul><li>producer发送日志，只要Leader写入成功，则返回producer成功</li></ul><p><strong>ACKs=0</strong></p><ul><li>producer发送日志，不需要等待leader返回成功</li><li>传输效率最高，可靠性最差</li></ul><p><strong>ACKs=-1</strong></p><ul><li>producer发送日志，Leader需要等待ISR中所有的Replica同步完成后，才返回给客户端成功</li><li>可靠性最高，效率最差。集群的瓶颈卡在了最差的那台机器</li></ul><h4 id="2-2-2-HW和LEO"><a href="#2-2-2-HW和LEO" class="headerlink" title="2.2.2 HW和LEO"></a>2.2.2 HW和LEO</h4><p><strong>LEO</strong></p><ul><li>LogEndOffset，日志末端偏移量</li><li>每个Replica最后一条log所在的位置</li></ul><p><strong>HW</strong></p><ul><li>HighWaterMark，高水位</li><li>HW = min( ISR.LEO )</li><li>已经被ISR完成同步的消息的位置</li><li>Consumer最多只能消费到HW所在的位置</li><li>对于内部Replica的同步消息请求，没有HW的限制</li></ul><p>如下图，HW与LEO位置示意：</p><figure class="image-box">                <img src="b9466c871eb1de0157d41377cd06d94a.png" alt="image" title class>                <p>image</p>            </figure><p><strong>HW与LEO更新过程：</strong></p><figure class="image-box">                <img src="d64eb94018321663dfe38c6ea278bbde.png" alt="image" title class>                <p>image</p>            </figure><p><strong>HW与LEO更新过程（详细）：</strong></p><p>HW与LEO存在于每一个副本，并不仅仅存在于leader。</p><p>leader中维护了两套LEO，一套是自己的，另一套是follower的。</p><p>假设目前消息队列为空，follower启动的同步消息线程，不会获取到任何消息，也不会更新HW和LEO</p><ul><li>*<figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/ec19a2cae1dc96baef8fe646f758b97a.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>此时，Producer给leader发送了一条日志</p><ol><li>leader的LEO + 1</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li></ol><ul><li>*<figure class="image-box">                <img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/219fab4d24791360c434d96ad75c71e8.png" alt="image" title class>                <p>image</p>            </figure></li></ul><p>follower发送fetch请求：</p><ul><li>*<figure class="image-box">                <img src="65578cc63bfff21a8529caed7fd904ff.png" alt="image" title class>                <p>image</p>            </figure></li></ul><ol><li>req的offset参数是0，表示从第0个消息开始fetch</li><li>leader更新remote LEO=0，这是因为follower request的offset是0</li><li>leader尝试更新HW，HW = min(LEO)，仍然是0</li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新LEO=1，更新HW仍然是0</li></ol><p>follower发送第二轮fetch请求:</p><figure class="image-box">                <img src="a730c7a7e7b6ea34fa9d3a71e1911f57.png" alt="image" title class>                <p>image</p>            </figure><ol><li>req的offset参数是1，表示请求同步第一个消息</li><li>leader更新remote LEO=1，因为follower request的offset是1</li><li>leader尝试更新HW，HW=min(LEO)，<strong>此时更新HW=1</strong></li><li>leader把数据和此时的leader HW返回给follower</li><li>follower接收到respsonse，更新HW，<strong>此时更新HW=1</strong></li></ol><p>至此，producer生产的消息已经保存到kafka的各个副本上了，Consumer已经可以消费到HW位置了。</p><p>一个消息从写入kafka到完成更新HW，需要follower发送两轮fetch请求。 第一轮fetch是follow告诉leader自己的leo, 以及更新offset以及leo. 第二轮fetch是告诉producer自己最新的leo用于leader更新hw.</p><h2 id="3-常见的选举、分配、Rebalance"><a href="#3-常见的选举、分配、Rebalance" class="headerlink" title="3. 常见的选举、分配、Rebalance"></a>3. 常见的选举、分配、Rebalance</h2><p>Kafka集群依赖Zookeeper，Zookeeper的数据模型是一棵树，kafka的组件把回调函数注册到zk树节点下，在节点发生变更时，zk通过回调通知kafka。</p><h3 id="3-1-Controller选举"><a href="#3-1-Controller选举" class="headerlink" title="3.1 Controller选举"></a>3.1 Controller选举</h3><p>KafkaController的选举过程比较简单，所有的broker启动时，抢占注册Zookeeper的/Controller节点，注册成功即成为Controller。伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def elect: Boolean = &#123;</span><br><span class="line">    leaderId = getControllerID   // 查询当前集群ControllerId</span><br><span class="line"></span><br><span class="line">    if(leaderId != -1) &#123;  // Controller早已存在了</span><br><span class="line">       return amILeader</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        zkCheckedEphemeral.create()  // 注册到zookeeper leader节点</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        case _: ZkNodeExistsException =&gt;   // leader被别人注册，抛异常</span><br><span class="line">        leaderId = getControllerID</span><br><span class="line">    &#125;</span><br><span class="line">    return amILeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Consumer启动触发Rebalance"><a href="#3-2-Consumer启动触发Rebalance" class="headerlink" title="3.2 Consumer启动触发Rebalance"></a>3.2 Consumer启动触发Rebalance</h3><p>由于Broker数量通常不会很多，所以Controller选举采用抢占注册的方式不会给zookeeper带来很大压力。</p><p>但是对于Consumer而言，一个大的Topic可能对应创建了数量庞大的Consumer，Kafka老版本也确实是这么实现的，这种情况下，存在两个问题：</p><ul><li>羊群效应：任何一个Consumer的增减都会触发所有Consumer的Rebalance</li><li>脑裂效应：每个Consumer分别单独通过Zookeeper判断哪些Consumer 宕机了，那么不同Consumer在同一时刻从Zookeeper看到的视角就可能不一样。这就会造成不正确的Reblance尝试。</li></ul><p>新版本的Kafka对此做了优化，使用了“协调员”这一角色，作为“权威”“指挥”Consumer Rebalance</p><p>新版本，Consumer启动过程如下：</p><figure class="image-box">                <img src="5849ad51359fe5c181c7c4673b8f6da8.png" alt="image" title class>                <p>image</p>            </figure><ol><li>Consumer启动，向任意一台broker发送请求，得到响应。响应内容为“协调员的地址”。</li><li>Consumer找到自己的Coordinator，<strong>持续</strong>发送心跳请求</li><li>Consumer判断心跳请求的响应的ErrorCode，如果没有异常则消费数据。如果有IllegalGeneration异常，说明Coordinator正在计算rebalance，统一给Consumer分配Partition。</li><li>Consumer给Coordinator发送JonGroup请求，得到响应，得知自己被分配了哪个Partition，连接那个partition进行消费。</li></ol><h3 id="3-3-Leader-Replica宕机触发Rebalance"><a href="#3-3-Leader-Replica宕机触发Rebalance" class="headerlink" title="3.3 Leader Replica宕机触发Rebalance"></a>3.3 Leader Replica宕机触发Rebalance</h3><figure class="image-box">                <img src="c981ddff865953bf37066940aa92cc28.png" alt="image" title class>                <p>image</p>            </figure><p>图：broker宕机触发replica选举</p><p>Replica分布在broker上，Replica leader掉线其实就是leader所在的broker的宕机，从宕机到集群恢复稳定态过程：</p><ol><li>Broker启动，在zookeeper的broker/ids路径注册临时节点</li><li>Controller启动，注册watcher函数，监听zookeeper上述路径的节点变化</li><li>Broker因为网络、断电、机器故障等原因宕机</li><li>zookeeper监听到broker节点掉线，触发controller注册的watcher，通过回调函数通知Controller</li><li>Controller决定一个set_p集合，包含宕机broker上的所有partition</li><li>对于上述的partition，Controller从/brokers/topics/[topic]/partitions/[partition]/state读取该 Partition 当前的 ISR</li><li>Controller从上述ISR中选出Leader。选举算法是quorum（法定人数）算法，通过数据冗余来保证数据一致性的投票算法。对于Kafka而言，选举人数就是ISR。</li><li>Controller将新的 Leader、ISR 和新的leader_epoch及controller_epoch写入/brokers/topics/[topic]/partitions/[partition]/state</li><li>向set_p相关的broker发送LeaderAndIsrRequest通知受影响的broker更新信息</li></ol><h3 id="3-4-topic分配到broker"><a href="#3-4-topic分配到broker" class="headerlink" title="3.4 topic分配到broker"></a>3.4 topic分配到broker</h3><ol><li>用户调用脚本创建topic，指定分区数和副本数</li><li>Controller接收CreateTopic请求，计算broker与partition的对应关系</li><li>Controller向Broker发送LeaderAndIsr请求，通知Broker有了新的Topic，各broker负责创建Partition</li></ol><p>副本分配算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* To achieve this goal for replica assignment without considering racks, we:</span><br><span class="line">* 1. Assign the first replica of each partition by round-robin, starting from a random position in the broker list.</span><br><span class="line">* 2. Assign the remaining replicas of each partition with an increasing shift.</span><br><span class="line">*</span><br><span class="line">* Here is an example of assigning</span><br><span class="line">* broker-0  broker-1  broker-2  broker-3  broker-4</span><br><span class="line">* p0        p1        p2        p3        p4       (1st replica)</span><br><span class="line">* p5        p6        p7        p8        p9       (1st replica)</span><br><span class="line">* p4        p0        p1        p2        p3       (2nd replica)</span><br><span class="line">* p8        p9        p5        p6        p7       (2nd replica)</span><br><span class="line">* p3        p4        p0        p1        p2       (3nd replica)</span><br><span class="line">* p7        p8        p9        p5        p6       (3nd replica)</span><br></pre></td></tr></table></figure><hr><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li><p>kafka使用tcp, io多路复用即信号驱动io, 生产者有同步和异步2种类型</p></li><li><p>选择由producer向broker push消息并由consumer从broker pull消息。</p></li><li><p>kafka和nsq对比：</p><ul><li>kafka是pull，有序，吞吐高；nsq消息是无序的，吞吐低，有requeue和defer功能，不持久化，不可回溯，pull，用内存，所以速度快。</li></ul></li><li><p>kafka数据可靠性和重复消费</p><ol><li>需要消费者操作幂等，来保证重复消费无影响</li><li>处理后提交commit，保证消息被消费到，事务保证</li><li>生产者生产消息失败时，报error。</li><li>如果要保证有序，让消息到1个partition就行了，partition内部消费是有序的</li></ol></li><li><p>kafka基于zk.</p></li><li><p>kafka是发布-订阅模型。</p></li><li><p>Zookeeper 主要为 Kafka 做了下面这些事情：</p><ol><li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li><strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li><li>……</li></ol></li><li><p>ISR:In-Sync Replicas 副本同步队列 AR:Assigned Replicas 所有副本</p><p>HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。</p><p>LEO:LogEndOffset 当前日志文件中下一条待写信息的offset</p><p>HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。</p><p>LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</p><p>LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li><a href="https://juejin.cn/post/6844903889003610119" target="_blank" rel="noopener">kafka面试题</a></li><li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/message-queue/Kafka常见面试题总结.md" target="_blank" rel="noopener">kafka面试题2</a></li><li><a href="http://trumandu.github.io/2019/04/13/Kafka面试题与答案全套整理/" target="_blank" rel="noopener">整理，答案不全的</a></li><li><a href="https://cloud.tencent.com/developer/article/1541215" target="_blank" rel="noopener">面试题3</a></li></ul><h2 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h2><ul><li><p>控制器是如何被选出来的？</p><ul><li><p>你一定很想知道，控制器是如何被选出来的呢？我们刚刚在前面说过，每台 Broker 都能充当控制器，那么，当集群启动后，Kafka 怎么确认控制器位于哪台 Broker 呢？</p><p>实际上，Broker 在启动时，会尝试去 ZooKeeper 中创建 /controller 节点。Kafka 当前选举控制器的规则是：第一个成功创建 /controller 节点的 Broker 会被指定为控制器。</p></li></ul></li><li><p>控制器是做什么的？</p><ul><li><p>1.主题管理（创建、删除、增加分区）</p><p>2.分区重分配</p><p>3.Preferred 领导者选举</p><p>4.集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）</p><p>5.数据服务</p></li></ul></li><li><p>保存的数据：</p></li><li><figure class="image-box">                <img src="20210523170815.png" alt="image-20210523170815843" title class>                <p>image-20210523170815843</p>            </figure></li></ul><h2 id="consumer管理offset"><a href="#consumer管理offset" class="headerlink" title="consumer管理offset"></a>consumer管理offset</h2><p><strong>kafka内部有个主题，__consumer_offset</strong></p><p>老版本 Consumer 的位移管理是依托于 Apache ZooKeeper 的，它会自动或手动地将位移数据提交到 ZooKeeper 中保存。当 Consumer 重启后，它能自动从 ZooKeeper 中读取位移数据，从而在上次消费截止的地方继续消费。这种设计使得 Kafka Broker 不需要保存位移数据，减少了 Broker 端需要持有的状态空间，因而有利于实现高伸缩性。</p><p>但是，ZooKeeper 其实并不适用于这种高频的写操作，因此，Kafka 社区自 0.8.2.x 版本开始，就在酝酿修改这种设计，并最终在新版本 Consumer 中正式推出了全新的位移管理机制，自然也包括这个新的位移主题。</p><p>新版本 Consumer 的位移管理机制其实也很简单，就是将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 <strong>consumer_offsets 中。可以这么说，</strong>consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。它要求这个提交过程不仅要实现高持久性，还要支持高频的写操作。显然，Kafka 的主题设计天然就满足这两个条件，因此，使用 Kafka 主题来保存位移这件事情，实际上就是一个水到渠成的想法了。</p><p>位移主题的 Key 中应该保存 3 部分内容：gourpId, topic, partitionId</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat架构原理解析到架构设计借鉴</title>
      <link href="/2021/12/06/tomcat-architecture/"/>
      <url>/2021/12/06/tomcat-architecture/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat-架构原理解析到架构设计借鉴"><a href="#Tomcat-架构原理解析到架构设计借鉴" class="headerlink" title="Tomcat 架构原理解析到架构设计借鉴"></a>Tomcat 架构原理解析到架构设计借鉴</h1><blockquote><p>Tomcat 发展这么多年，已经比较成熟稳定。在如今『追新求快』的时代，Tomcat 作为 Java Web 开发必备的工具似乎变成了『熟悉的陌生人』，难道说如今就没有必要深入学习它了么？学习它我们又有什么收获呢？</p></blockquote><p><strong>静下心来，细细品味经典的开源作品</strong> 。提升我们的「内功」，具体来说就是学习大牛们如何设计、架构一个中间件系统，并且让这些经验为我所用。</p><p>美好的事物往往是整洁而优雅的。但这并不等于简单，而是要将复杂的系统分解成一个个小模块，并且各个模块的职责划分也要清晰合理。</p><p>与此相反的是凌乱无序，比如你看到城中村一堆互相纠缠在一起的电线，可能会感到不适。维护的代码一个类几千行、一个方法好几百行。方法之间相互耦合糅杂在一起，你可能会说 what the f*k！</p><figure class="image-box">                <img src="1f3cb57ab959b4592513f10ba9cbd1ed.webp" alt="img" title class>                <p>img</p>            </figure><h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><h3 id="掌握-Tomcat-架构设计与原理提高内功"><a href="#掌握-Tomcat-架构设计与原理提高内功" class="headerlink" title="掌握 Tomcat 架构设计与原理提高内功"></a>掌握 Tomcat 架构设计与原理提高内功</h3><p><strong>宏观上看</strong></p><p>Tomcat 作为一个 「<code>Http</code> 服务器 + <code>Servlet</code> 容器」，对我们屏蔽了应用层协议和网络通信细节，给我们的是标准的 <code>Request</code> 和 <code>Response</code> 对象；对于具体的业务逻辑则作为变化点，交给我们来实现。我们使用了<code>SpringMVC</code> 之类的框架，可是却从来不需要考虑 <code>TCP</code> 连接、 <code>Http</code> 协议的数据处理与响应。就是因为 Tomcat 已经为我们做好了这些，我们只需要关注每个请求的具体业务逻辑。</p><p><strong>微观上看</strong></p><p><code>Tomcat</code> 内部也隔离了变化点与不变点，使用了组件化设计，目的就是为了实现「俄罗斯套娃式」的高度定制化（组合模式），而每个组件的生命周期管理又有一些共性的东西，则被提取出来成为接口和抽象类，让具体子类实现变化点，也就是模板方法设计模式。</p><p>当今流行的微服务也是这个思路，按照功能将单体应用拆成「微服务」，拆分过程要将共性提取出来，而这些共性就会成为核心的基础服务或者通用库。「中台」思想亦是如此。</p><p>设计模式往往就是封装变化的一把利器，合理的运用设计模式能让我们的代码与系统设计变得优雅且整洁。</p><p>这就是学习优秀开源软件能获得的「内功」，从不会过时，其中的设计思想与哲学才是根本之道。从中借鉴设计经验，合理运用设计模式封装变与不变，更能从它们的源码中汲取经验，提升自己的系统设计能力。</p><h3 id="宏观理解一个请求如何与-Spring-联系起来"><a href="#宏观理解一个请求如何与-Spring-联系起来" class="headerlink" title="宏观理解一个请求如何与 Spring 联系起来"></a>宏观理解一个请求如何与 Spring 联系起来</h3><p>在工作过程中，我们对 Java 语法已经很熟悉了，甚至「背」过一些设计模式，用过很多 Web 框架，但是很少有机会将他们用到实际项目中，让自己独立设计一个系统似乎也是根据需求一个个 Service 实现而已。脑子里似乎没有一张 Java Web 开发全景图，比如我并不知道浏览器的请求是怎么跟 Spring 中的代码联系起来的。</p><p>为了突破这个瓶颈，为何不站在巨人的肩膀上学习优秀的开源系统，看大牛们是如何思考这些问题。</p><p>学习 Tomcat 的原理，我发现 <code>Servlet</code> 技术是 Web 开发的原点，几乎所有的 Java Web 框架（比如 Spring）都是基于 <code>Servlet</code> 的封装，Spring 应用本身就是一个 <code>Servlet</code>（<code>DispatchSevlet</code>），而 Tomcat 和 Jetty 这样的 Web 容器，负责加载和运行 <code>Servlet</code>。如图所示：</p><figure class="image-box">                <img src="fb04017c2304f79fd043ed4a9e90190f.webp" alt="img" title class>                <p>img</p>            </figure><h3 id="提升自己的系统设计能力"><a href="#提升自己的系统设计能力" class="headerlink" title="提升自己的系统设计能力"></a>提升自己的系统设计能力</h3><p>学习 Tomcat ，我还发现用到不少 Java 高级技术，比如 Java 多线程并发编程、Socket 网络编程以及反射等。之前也只是了解这些技术，为了面试也背过一些题。但是总感觉「知道」与会用之间存在一道沟壑，通过对 Tomcat 源码学习，我学会了什么场景去使用这些技术。</p><p>还有就是系统设计能力，比如面向接口编程、组件化组合模式、骨架抽象类、一键式启停、对象池技术以及各种设计模式，比如模板方法、观察者模式、责任链模式等，之后我也开始模仿它们并把这些设计思想运用到实际的工作中。</p><h2 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h2><p>今天咱们就来一步一步分析 Tomcat 的设计思路，一方面我们可以学到 Tomcat 的总体架构，学会从宏观上怎么去设计一个复杂系统，怎么设计顶层模块，以及模块之间的关系；另一方面也为我们深入学习 Tomcat 的工作原理打下基础。</p><p>Tomcat 启动流程：<code>startup.sh -&gt; catalina.sh start -&gt;java -jar org.apache.catalina.startup.Bootstrap.main()</code></p><p>Tomcat 实现的 2 个核心功能：</p><ul><li>处理 <code>Socket</code> 连接，负责网络字节流与 <code>Request</code> 和 <code>Response</code> 对象的转化。</li><li>加载并管理 <code>Servlet</code> ，以及处理具体的 <code>Request</code> 请求。</li></ul><p><strong>所以 Tomcat 设计了两个核心组件连接器（Connector）和容器（Container）。连接器负责对外交流，容器负责内部 处理</strong></p><p><code>Tomcat</code>为了实现支持多种 <code>I/O</code> 模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。</p><figure class="image-box">                <img src="4e76498e3179b855b480be0924de5da5.webp" alt="img" title class>                <p>img</p>            </figure>Tomcat整体架构<br><br>- Server 对应的就是一个 Tomcat 实例。<br>- Service 默认只有一个，也就是一个 Tomcat 实例默认一个 Service。<br>- Connector：一个 Service 可能多个 连接器，接受不同连接协议。<br>- Container: 多个连接器对应一个容器，顶层容器其实就是 Engine。<br><br><strong>每个组件都有对应的生命周期，需要启动，同时还要启动自己内部的子组件，比如一个 Tomcat 实例包含一个 Service，一个 Service 包含多个连接器和一个容器。而一个容器包含多个 Host， Host 内部可能有多个 Contex t 容器，而一个 Context 也会包含多个 Servlet，所以 Tomcat 利用组合模式管理组件每个组件，对待过个也想对待单个组一样对待</strong>。整体上每个组件设计就像是「俄罗斯套娃」一样。<br><br>### 连接器<br><br>在开始讲连接器前，我先铺垫一下 <code>Tomcat</code>支持的多种 <code>I/O</code> 模型和应用层协议。<br><br><code>Tomcat</code>支持的 <code>I/O</code> 模型有：<br><br>- <code>NIO</code>：非阻塞 <code>I/O</code>，采用 <code>Java NIO</code> 类库实现。<br>- <code>NIO2</code>：异步<code>I/O</code>，采用 <code>JDK 7</code> 最新的 <code>NIO2</code> 类库实现。<br>- <code>APR</code>：采用 <code>Apache</code>可移植运行库实现，是 <code>C/C++</code> 编写的本地库。<br><br>Tomcat 支持的应用层协议有：<br><br>- <code>HTTP/1.1</code>：这是大部分 Web 应用采用的访问协议。<br>- <code>AJP</code>：用于和 Web 服务器集成（如 Apache）。<br>- <code>HTTP/2</code>：HTTP 2.0 大幅度的提升了 Web 性能。<br><br>所以一个容器可能对接多个连接器。连接器对 <code>Servlet</code> 容器屏蔽了网络协议与 <code>I/O</code> 模型的区别，无论是 <code>Http</code> 还是 <code>AJP</code>，在容器中获取到的都是一个标准的 <code>ServletRequest</code> 对象。<br><br>细化连接器的功能需求就是：<br><br>- 监听网络端口。<br>- 接受网络连接请求。<br>- 读取请求网络字节流。<br>- 根据具体应用层协议（<code>HTTP/AJP</code>）解析字节流，生成统一的 <code>Tomcat Request</code> 对象。<br>- 将 <code>Tomcat Request</code> 对象转成标准的 <code>ServletRequest</code>。<br>- 调用 <code>Servlet</code>容器，得到 <code>ServletResponse</code>。<br>- 将 <code>ServletResponse</code>转成 <code>Tomcat Response</code> 对象。<br>- 将 <code>Tomcat Response</code> 转成网络字节流。<br>- 将响应字节流写回给浏览器。<br><br>需求列清楚后，我们要考虑的下一个问题是，连接器应该有哪些子模块？优秀的模块化设计应该考虑<strong>高内聚、低耦合</strong>。<br><br>- <strong>高内聚</strong>是指相关度比较高的功能要尽可能集中，不要分散。<br>- <strong>低耦合</strong>是指两个相关的模块要尽可能减少依赖的部分和降低依赖的程度，不要让两个模块产生强依赖。<br><br>我们发现连接器需要完成 3 个<strong>高内聚</strong>的功能：<br><br>- 网络通信。<br>- 应用层协议解析。<br>- <code>Tomcat Request/Response</code> 与 <code>ServletRequest/ServletResponse</code> 的转化。<br><br>因此 Tomcat 的设计者设计了 3 个组件来实现这 3 个功能，分别是 <code>EndPoint、Processor 和 Adapter</code>。<br><br>网络通信的 I/O 模型是变化的, 应用层协议也是变化的，但是整体的处理逻辑是不变的，<code>EndPoint</code> 负责提供字节流给 <code>Processor</code>，<code>Processor</code>负责提供 <code>Tomcat Request</code> 对象给 <code>Adapter</code>，<code>Adapter</code>负责提供 <code>ServletRequest</code>对象给容器。<br><br><strong>封装变与不变</strong><br><br>因此 Tomcat 设计了一系列抽象基类来<strong>封装这些稳定的部分</strong>，抽象基类 <code>AbstractProtocol</code>实现了 <code>ProtocolHandler</code>接口。每一种应用层协议有自己的抽象基类，比如 <code>AbstractAjpProtocol</code>和 <code>AbstractHttp11Protocol</code>，具体协议的实现类扩展了协议层抽象基类。<br><br>这就是模板方法设计模式的运用。<br><br><figure class="image-box">                <img src="30457ee2c65903a81f033e32c5e60251.webp" alt="img" title class>                <p>img</p>            </figure>应用层协议抽象<br><br>总结下来，连接器的三个核心组件 <code>Endpoint</code>、<code>Processor</code>和 <code>Adapter</code>来分别做三件事情，其中 <code>Endpoint</code>和 <code>Processor</code>放在一起抽象成了 <code>ProtocolHandler</code>组件，它们的关系如下图所示。<br><br><figure class="image-box">                <img src="88f9b28eb4cef2749e180bc4517d470d.webp" alt="img" title class>                <p>img</p>            </figure>连接器<br><br>#### ProtocolHandler 组件<br><br>主要处理 <strong>网络连接</strong> 和 <strong>应用层协议</strong> ，包含了两个重要部件 EndPoint 和 Processor，两个组件组合形成 ProtocoHandler，下面我来详细介绍它们的工作原理。<br><br>##### EndPoint<br><br><code>EndPoint</code>是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 <code>EndPoint</code>是用来实现 <code>TCP/IP</code> 协议数据读写的，本质调用操作系统的 socket 接口。<br><br><code>EndPoint</code>是一个接口，对应的抽象实现类是 <code>AbstractEndpoint</code>，而 <code>AbstractEndpoint</code>的具体子类，比如在 <code>NioEndpoint</code>和 <code>Nio2Endpoint</code>中，有两个重要的子组件：<code>Acceptor</code>和 <code>SocketProcessor</code>。<br><br>其中 Acceptor 用于监听 Socket 连接请求。<code>SocketProcessor</code>用于处理 <code>Acceptor</code> 接收到的 <code>Socket</code>请求，它实现 <code>Runnable</code>接口，在 <code>Run</code>方法里调用应用层协议处理组件 <code>Processor</code> 进行处理。为了提高处理能力，<code>SocketProcessor</code>被提交到线程池来执行。<br><br>我们知道，对于 Java 的多路复用器的使用，无非是两步：<br><br>1. 创建一个 Seletor，在它身上注册各种感兴趣的事件，然后调用 select 方法，等待感兴趣的事情发生。<br>2. 感兴趣的事情发生了，比如可以读了，这时便创建一个新的线程从 Channel 中读数据。<br><br>在 Tomcat 中 <code>NioEndpoint</code> 则是 <code>AbstractEndpoint</code> 的具体实现，里面组件虽然很多，但是处理逻辑还是前面两步。它一共包含 <code>LimitLatch</code>、<code>Acceptor</code>、<code>Poller</code>、<code>SocketProcessor</code>和 <code>Executor</code> 共 5 个组件，分别分工合作实现整个 TCP/IP 协议的处理。<br><br>- LimitLatch 是连接控制器，它负责控制最大连接数，NIO 模式下默认是 10000，达到这个阈值后，连接请求被拒绝。<br>- <code>Acceptor</code>跑在一个单独的线程里，它在一个死循环里调用 <code>accept</code>方法来接收新连接，一旦有新的连接请求到来，<code>accept</code>方法返回一个 <code>Channel</code> 对象，接着把 <code>Channel</code>对象交给 Poller 去处理。<br>- <code>Poller</code> 的本质是一个 <code>Selector</code>，也跑在单独线程里。<code>Poller</code>在内部维护一个 <code>Channel</code>数组，它在一个死循环里不断检测 <code>Channel</code>的数据就绪状态，一旦有 <code>Channel</code>可读，就生成一个 <code>SocketProcessor</code>任务对象扔给 <code>Executor</code>去处理。<br>- SocketProcessor 实现了 Runnable 接口，其中 run 方法中的 <code>getHandler().process(socketWrapper, SocketEvent.CONNECT_FAIL);</code> 代码则是获取 handler 并执行处理 socketWrapper，最后通过 socket 获取合适应用层协议处理器，也就是调用 Http11Processor 组件来处理请求。Http11Processor 读取 Channel 的数据来生成 ServletRequest 对象，Http11Processor 并不是直接读取 Channel 的。这是因为 Tomcat 支持同步非阻塞 I/O 模型和异步 I/O 模型，在 Java API 中，相应的 Channel 类也是不一样的，比如有 AsynchronousSocketChannel 和 SocketChannel，为了对 Http11Processor 屏蔽这些差异，Tomcat 设计了一个包装类叫作 SocketWrapper，Http11Processor 只调用 SocketWrapper 的方法去读写数据。<br>- <code>Executor</code>就是线程池，负责运行 <code>SocketProcessor</code>任务类，<code>SocketProcessor</code> 的 <code>run</code>方法会调用 <code>Http11Processor</code> 来读取和解析请求数据。我们知道，<code>Http11Processor</code>是应用层协议的封装，它会调用容器获得响应，再把响应通过 <code>Channel</code>写出。<br><br>工作流程如下所示：<br><br><figure class="image-box">                <img src="3c0b315759fc82801d7ddc156969113e.webp" alt="img" title class>                <p>img</p>            </figure>NioEndPoint<br><br>##### Processor<br><br>Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。<br><br><figure class="image-box">                <img src="9bcbb1ffd832ab7098eb70981a0e368f.webp" alt="img" title class>                <p>img</p>            </figure><p><strong>从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 HttpProcessor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法，方法内部通过 以下代码将请求传递到容器中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calling the container</span></span><br><span class="line">connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</span><br></pre></td></tr></table></figure><h4 id="Adapter-组件"><a href="#Adapter-组件" class="headerlink" title="Adapter 组件"></a>Adapter 组件</h4><p>由于协议的不同，Tomcat 定义了自己的 <code>Request</code> 类来存放请求信息，这里其实体现了面向对象的思维。但是这个 Request 不是标准的 <code>ServletRequest</code> ，所以不能直接使用 Tomcat 定义 Request 作为参数直接容器。</p><p>Tomcat 设计者的解决方案是引入 <code>CoyoteAdapter</code>，这是适配器模式的经典运用，连接器调用 <code>CoyoteAdapter</code> 的 <code>Sevice</code> 方法，传入的是 <code>Tomcat Request</code> 对象，<code>CoyoteAdapter</code>负责将 <code>Tomcat Request</code> 转成 <code>ServletRequest</code>，再调用容器的 <code>Service</code>方法。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>连接器负责外部交流，容器负责内部处理。具体来说就是，连接器处理 Socket 通信和应用层协议的解析，得到 <code>Servlet</code>请求；而容器则负责处理 <code>Servlet</code>请求。</p><p>容器：顾名思义就是拿来装东西的， 所以 Tomcat 容器就是拿来装载 <code>Servlet</code>。</p><p>Tomcat 设计了 4 种容器，分别是 <code>Engine</code>、<code>Host</code>、<code>Context</code>和 <code>Wrapper</code>。<code>Server</code> 代表 Tomcat 实例。</p><p>要注意的是这 4 种容器不是平行关系，属于父子关系，如下图所示：</p><figure class="image-box">                <img src="4e5eb57d725c843208604aa7369cb4c2.webp" alt="img" title class>                <p>img</p>            </figure>容器<br><br>你可能会问，为啥要设计这么多层次的容器，这不是增加复杂度么？其实这背后的考虑是，<strong>Tomcat 通过一种分层的架构，使得 Servlet 容器具有很好的灵活性。因为这里正好符合一个 Host 多个 Context， 一个 Context 也包含多个 Servlet，而每个组件都需要统一生命周期管理，所以组合模式设计这些容器</strong><br><br><code>Wrapper</code> 表示一个 <code>Servlet</code> ，<code>Context</code> 表示一个 Web 应用程序，而一个 Web 程序可能有多个 <code>Servlet</code> ；<code>Host</code> 表示一个虚拟主机，或者说一个站点，一个 Tomcat 可以配置多个站点（Host）；一个站点（ Host） 可以部署多个 Web 应用；<code>Engine</code> 代表 引擎，用于管理多个站点（Host），一个 Service 只能有 一个 <code>Engine</code>。<br><br>可通过 Tomcat 配置文件加深对其层次关系理解。<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span> // 顶层组件，可包含多个 Service，代表一个 Tomcat 实例</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span>  // 顶层组件，包含一个 Engine ，多个连接器</span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span>  // 连接器</span><br><span class="line"></span><br><span class="line"> // 容器组件：一个 Engine 处理 Service 所有请求，包含多个 Host</span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">   // 容器组件：处理指定Host下的客户端请求， 可包含多个 Context</span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   // 容器组件：处理特定 Context Web应用的所有客户端请求</span><br><span class="line">   <span class="tag">&lt;<span class="name">Context</span>&gt;</span>Context&gt;</span><br><span class="line">      Host&gt;</span><br><span class="line">    Engine&gt;</span><br><span class="line">  Service&gt;</span><br><span class="line">Server&gt;</span><br></pre></td></tr></table></figure><p>如何管理这些容器？我们发现容器之间具有父子关系，形成一个树形结构，是不是想到了设计模式中的 <strong>组合模式</strong> 。</p><p>Tomcat 就是用组合模式来管理这些容器的。具体实现方法是，<strong>所有容器组件都实现了 <code>Container</code>接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</strong>。这里单容器对象指的是最底层的 <code>Wrapper</code>，组合容器对象指的是上面的 <code>Context</code>、<code>Host</code>或者 <code>Engine</code>。<code>Container</code> 接口定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Container extends Lifecycle &#123;</span><br><span class="line">    public void setName(String name);</span><br><span class="line">    public Container getParent();</span><br><span class="line">    public void setParent(Container container);</span><br><span class="line">    public void addChild(Container child);</span><br><span class="line">    public void removeChild(Container child);</span><br><span class="line">    public Container findChild(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到了<code>getParent</code>、<code>SetParent</code>、<code>addChild</code>和 <code>removeChild</code>等方法，这里正好验证了我们说的组合模式。我们还看到 <code>Container</code>接口拓展了 <code>Lifecycle</code> ，Tomcat 就是通过 <code>Lifecycle</code> 统一管理所有容器的组件的生命周期。通过组合模式管理所有容器，拓展 <code>Lifecycle</code> 实现对每个组件的生命周期管理 ，<code>Lifecycle</code> 主要包含的方法<code>init()、start()、stop() 和 destroy()</code>。</p><h4 id="请求定位-Servlet-的过程"><a href="#请求定位-Servlet-的过程" class="headerlink" title="请求定位 Servlet 的过程"></a>请求定位 Servlet 的过程</h4><p>一个请求是如何定位到让哪个 <code>Wrapper</code> 的 <code>Servlet</code> 处理的？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。</p><p><code>Mapper</code> 组件的功能就是将用户请求的 <code>URL</code> 定位到一个 <code>Servlet</code>，它的工作原理是：<code>Mapper</code>组件里保存了 Web 应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如 <code>Host</code>容器里配置的域名、<code>Context</code>容器里的 <code>Web</code>应用路径，以及 <code>Wrapper</code>容器里 <code>Servlet</code> 映射的路径，你可以想象这些配置信息就是一个多层次的 <code>Map</code>。</p><p>当一个请求到来时，<code>Mapper</code> 组件通过解析请求 URL 里的域名和路径，再到自己保存的 Map 里去查找，就能定位到一个 <code>Servlet</code>。请你注意，一个请求 URL 最后只会定位到一个 <code>Wrapper</code>容器，也就是一个 <code>Servlet</code>。</p><figure class="image-box">                <img src="c7c4351fa0f7cdfacb2d2dd1d531b863.webp" alt="img" title class>                <p>img</p>            </figure><p>假如有用户访问一个 URL，比如图中的<code>http://user.shopping.com:8080/order/buy</code>，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？</p><ol><li><strong>首先根据协议和端口号确定 Service 和 Engine</strong>。Tomcat 默认的 HTTP 连接器监听 8080 端口、默认的 AJP 连接器监听 8009 端口。上面例子中的 URL 访问的是 8080 端口，因此这个请求会被 HTTP 连接器接收，而一个连接器是属于一个 Service 组件的，这样 Service 组件就确定了。我们还知道一个 Service 组件里除了有多个连接器，还有一个容器组件，具体来说就是一个 Engine 容器，因此 Service 确定了也就意味着 Engine 也确定了。</li><li><strong>根据域名选定 Host。</strong> Service 和 Engine 确定后，Mapper 组件通过 URL 中的域名去查找相应的 Host 容器，比如例子中的 URL 访问的域名是<code>user.shopping.com</code>，因此 Mapper 会找到 Host2 这个容器。</li><li><strong>根据 URL 路径找到 Context 组件。</strong> Host 确定以后，Mapper 根据 URL 的路径来匹配相应的 Web 应用的路径，比如例子中访问的是 /order，因此找到了 Context4 这个 Context 容器。</li><li><strong>根据 URL 路径找到 Wrapper（Servlet）。</strong> Context 确定后，Mapper 再根据 web.xml 中配置的 Servlet 映射路径来找到具体的 Wrapper 和 Servlet。</li></ol><p>连接器中的 Adapter 会调用容器的 Service 方法来执行 Servlet，最先拿到请求的是 Engine 容器，Engine 容器对请求做一些处理后，会把请求传给自己子容器 Host 继续处理，依次类推，最后这个请求会传给 Wrapper 容器，Wrapper 会调用最终的 Servlet 来处理。那么这个调用过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。</p><p><code>Pipeline-Valve</code> 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理，Valve 表示一个处理点（也就是一个处理阀门），因此 <code>invoke</code>方法就是来处理请求的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>继续看 Pipeline 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addValve</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getBasic</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBasic</span><span class="params">(Valve valve)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Valve <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Pipeline</code>中有 <code>addValve</code>方法。Pipeline 中维护了 <code>Valve</code>链表，<code>Valve</code>可以插入到 <code>Pipeline</code>中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，<code>Valve</code>完成自己的处理后，调用 <code>getNext.invoke()</code> 来触发下一个 Valve 调用。</p><p>其实每个容器都有一个 Pipeline 对象，只要触发了这个 Pipeline 的第一个 Valve，这个容器里 <code>Pipeline</code>中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。</p><p>这是因为 <code>Pipeline</code>中还有个 <code>getBasic</code>方法。这个 <code>BasicValve</code>处于 <code>Valve</code>链表的末端，它是 <code>Pipeline</code>中必不可少的一个 <code>Valve</code>，负责调用下层容器的 Pipeline 里的第一个 Valve。</p><figure class="image-box">                <img src="ebb0f141d836202a2f7f9a174b40e584.webp" alt="img" title class>                <p>img</p>            </figure><p>整个过程分是通过连接器中的 <code>CoyoteAdapter</code> 触发，它会调用 Engine 的第一个 Valve：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="comment">// Calling the container</span></span><br><span class="line">    connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">        request, response);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 容器的最后一个 Valve 会创建一个 Filter 链，并调用 <code>doFilter()</code> 方法，最终会调到 <code>Servlet</code>的 <code>service</code>方法。</p><p>前面我们不是讲到了 <code>Filter</code>，似乎也有相似的功能，那 <code>Valve</code> 和 <code>Filter</code>有什么区别吗？它们的区别是：</p><ul><li><code>Valve</code>是 <code>Tomcat</code>的私有机制，与 Tomcat 的基础架构 <code>API</code>是紧耦合的。<code>Servlet API</code>是公有的标准，所有的 Web 容器包括 Jetty 都支持 Filter 机制。</li><li>另一个重要的区别是 <code>Valve</code>工作在 Web 容器级别，拦截所有应用的请求；而 <code>Servlet Filter</code> 工作在应用级别，只能拦截某个 <code>Web</code> 应用的所有请求。如果想做整个 <code>Web</code>容器的拦截器，必须通过 <code>Valve</code>来实现。</li></ul><h4 id="Lifecycle-生命周期"><a href="#Lifecycle-生命周期" class="headerlink" title="Lifecycle 生命周期"></a>Lifecycle 生命周期</h4><p>前面我们看到 <code>Container</code>容器 继承了 <code>Lifecycle</code> 生命周期。如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。也就是说，Tomcat 需要动态地管理这些组件的生命周期。</p><p>如何统一管理组件的创建、初始化、启动、停止和销毁？如何做到代码逻辑清晰？如何方便地添加或者删除组件？如何做到组件启动和停止不遗漏、不重复？</p><h5 id="一键式启停：LifeCycle-接口"><a href="#一键式启停：LifeCycle-接口" class="headerlink" title="一键式启停：LifeCycle 接口"></a>一键式启停：LifeCycle 接口</h5><p>设计就是要找到系统的变化点和不变点。这里的不变点就是每个组件都要经历创建、初始化、启动这几个过程，这些状态以及状态的转化是不变的。而变化点是每个具体组件的初始化方法，也就是启动方法是不一样的。</p><p>因此，Tomcat 把不变点抽象出来成为一个接口，这个接口跟生命周期有关，叫作 LifeCycle。LifeCycle 接口里定义这么几个方法：<code>init()、start()、stop() 和 destroy()</code>，每个具体的组件（也就是容器）去实现这些方法。</p><p>在父组件的 <code>init()</code> 方法里需要创建子组件并调用子组件的 <code>init()</code> 方法。同样，在父组件的 <code>start()</code>方法里也需要调用子组件的 <code>start()</code> 方法，因此调用者可以无差别的调用各组件的 <code>init()</code> 方法和 <code>start()</code> 方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是 Server 组件的 <code>init()</code>和<code>start()</code> 方法，整个 Tomcat 就被启动起来了。所以 Tomcat 采取组合模式管理容器，容器继承 LifeCycle 接口，这样就可以向针对单个对象一样一键管理各个容器的生命周期，整个 Tomcat 就启动起来。</p><h5 id="可扩展性：LifeCycle-事件"><a href="#可扩展性：LifeCycle-事件" class="headerlink" title="可扩展性：LifeCycle 事件"></a>可扩展性：LifeCycle 事件</h5><p>我们再来考虑另一个问题，那就是系统的可扩展性。因为各个组件<code>init()</code> 和 <code>start()</code> 方法的具体实现是复杂多变的，比如在 Host 容器的启动方法里需要扫描 webapps 目录下的 Web 应用，创建相应的 Context 容器，如果将来需要增加新的逻辑，直接修改<code>start()</code> 方法？这样会违反开闭原则，那如何解决这个问题呢？开闭原则说的是为了扩展系统的功能，你不能直接修改系统中已有的类，但是你可以定义新的类。</p><p><strong>组件的 <code>init()</code> 和 <code>start()</code> 调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除</strong>，这就是典型的<strong>观察者模式</strong>。</p><p>以下就是 <code>Lyfecycle</code> 接口的定义:</p><p><img src="6c0d1f851e590155176af9ad27f92a6f.webp" alt="img"><code>Lyfecycle</code></p><h5 id="重用性：LifeCycleBase-抽象基类"><a href="#重用性：LifeCycleBase-抽象基类" class="headerlink" title="重用性：LifeCycleBase 抽象基类"></a>重用性：LifeCycleBase 抽象基类</h5><p>再次看到抽象模板设计模式。</p><p>有了接口，我们就要用类去实现接口。一般来说实现类不止一个，不同的类在实现接口时往往会有一些相同的逻辑，如果让各个子类都去实现一遍，就会有重复代码。那子类如何重用这部分逻辑呢？其实就是定义一个基类来实现共同的逻辑，然后让各个子类去继承它，就达到了重用的目的。</p><p>Tomcat 定义一个基类 LifeCycleBase 来实现 LifeCycle 接口，把一些公共的逻辑放到基类中去，比如生命状态的转变与维护、生命事件的触发以及监听器的添加和删除等，而子类就负责实现自己的初始化、启动和停止等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public abstract class LifecycleBase implements Lifecycle&#123;</span><br><span class="line">    // 持有所有的观察者</span><br><span class="line">    private final List lifecycleListeners = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    /**</span><br><span class="line">     * 发布事件</span><br><span class="line">     *</span><br><span class="line">     * @param type  Event type</span><br><span class="line">     * @param data  Data associated with event.</span><br><span class="line">     */</span><br><span class="line">    protected void fireLifecycleEvent(String type, Object data) &#123;</span><br><span class="line">        LifecycleEvent event = new LifecycleEvent(this, type, data);</span><br><span class="line">        for (LifecycleListener listener : lifecycleListeners) &#123;</span><br><span class="line">            listener.lifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 模板方法定义整个启动流程，启动所有容器</span><br><span class="line">    @Override</span><br><span class="line">    public final synchronized void init() throws LifecycleException &#123;</span><br><span class="line">        //1. 状态检查</span><br><span class="line">        if (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">            invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //2. 触发 INITIALIZING 事件的监听器</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZING, null, false);</span><br><span class="line">            // 3. 调用具体子类的初始化方法</span><br><span class="line">            initInternal();</span><br><span class="line">            // 4. 触发 INITIALIZED 事件的监听器</span><br><span class="line">            setStateInternal(LifecycleState.INITIALIZED, null, false);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            setStateInternal(LifecycleState.FAILED, null, false);</span><br><span class="line">            throw new LifecycleException(</span><br><span class="line">                    sm.getString(&quot;lifecycleBase.initFail&quot;,toString()), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat 为了实现一键式启停以及优雅的生命周期管理，并考虑到了可扩展性和可重用性，将面向对象思想和设计模式发挥到了极致，<code>Containaer</code>接口维护了容器的父子关系，<code>Lifecycle</code> 组合模式实现组件的生命周期维护，生命周期每个组件有变与不变的点，运用模板方法模式。分别运用了<strong>组合模式、观察者模式、骨架抽象类和模板方法</strong>。</p><p>如果你需要维护一堆具有父子关系的实体，可以考虑使用组合模式。</p><p>观察者模式听起来 “高大上”，其实就是当一个事件发生后，需要执行一连串更新操作。实现了低耦合、非侵入式的通知与更新机制。</p><figure class="image-box">                <img src="844ce454077ebe51f60e86504dde3f8f.webp" alt="img" title class>                <p>img</p>            </figure><p><code>Container</code> 继承了 LifeCycle，StandardEngine、StandardHost、StandardContext 和 StandardWrapper 是相应容器组件的具体实现类，因为它们都是容器，所以继承了 ContainerBase 抽象基类，而 ContainerBase 实现了 Container 接口，也继承了 LifeCycleBase 类，它们的生命周期管理接口和功能接口是分开的，这也符合设计中<strong>接口分离的原则</strong>。</p><h3 id="Tomcat-为何打破双亲委派机制"><a href="#Tomcat-为何打破双亲委派机制" class="headerlink" title="Tomcat 为何打破双亲委派机制"></a>Tomcat 为何打破双亲委派机制</h3><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>我们知道 <code>JVM</code>的类加载器加载 Class 的时候基于双亲委派机制，也就是会将加载交给自己的父加载器加载，如果 父加载器为空则查找<code>Bootstrap</code> 是否加载过，当无法加载的时候才让自己加载。JDK 提供一个抽象类 <code>ClassLoader</code>，这个抽象类中定义了三个关键方法。对外使用<code>loadClass(String name) 用于子类重写打破双亲委派：loadClass(String name, boolean resolve)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 查找该 class 是否已经被加载过</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有加载过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 委托给父加载器去加载，递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器为空，查找 Bootstrap 是否加载过</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若果依然加载不到，则调用自己的 findClass 去加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">findClass</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 根据传入的类名 name，到在特定目录下去寻找类文件，把.class 文件读入内存</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 调用 defineClass 将字节数组转成 Class 对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(buf, off, len)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字节码数组解析成一个 Class 对象，用 native 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Class <span class="title">defineClass</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 中有 3 个类加载器，另外你也可以自定义类加载器，它们的关系如下图所示。</p><figure class="image-box">                <img src="bfaaa526706997606a0cb622dfc35396.webp" alt="img" title class>                <p>img</p>            </figure>类加载器<br><br>- <code>BootstrapClassLoader</code>是启动类加载器，由 C 语言实现，用来加载 <code>JVM</code>启动时所需要的核心类，比如<code>rt.jar</code>、<code>resources.jar</code>等。<br>- <code>ExtClassLoader</code>是扩展类加载器，用来加载<code>\jre\lib\ext</code>目录下 JAR 包。<br>- <code>AppClassLoader</code>是系统类加载器，用来加载 <code>classpath</code>下的类，应用程序默认用它来加载类。<br>- 自定义类加载器，用来加载自定义路径下的类。<br><br>这些类加载器的工作原理是一样的，区别是它们的加载路径不同，也就是说 <code>findClass</code>这个方法查找的路径不同。双亲委托机制是为了保证一个 Java 类在 JVM 中是唯一的，假如你不小心写了一个与 JRE 核心类同名的类，比如 <code>Object</code>类，双亲委托机制能保证加载的是 <code>JRE</code>里的那个 <code>Object</code>类，而不是你写的 <code>Object</code>类。这是因为 <code>AppClassLoader</code>在加载你的 Object 类时，会委托给 <code>ExtClassLoader</code>去加载，而 <code>ExtClassLoader</code>又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code>发现自己已经加载过了 <code>Object</code>类，会直接返回，不会去加载你写的 <code>Object</code>类。我们最多只能 获取到 <code>ExtClassLoader</code>这里注意下。<br><br>#### Tomcat 热加载<br><br>Tomcat 本质是通过一个后台线程做周期性的任务，定期检测类文件的变化，如果有变化就重新加载类。我们来看 <code>ContainerBackgroundProcessor</code>具体是如何实现的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBackgroundProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请注意这里传入的参数是 " 宿主类 " 的实例</span></span><br><span class="line">        processChildren(ContainerBase.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processChildren</span><span class="params">(Container container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 调用当前容器的 backgroundProcess 方法。</span></span><br><span class="line">            container.backgroundProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 遍历所有的子容器，递归调用 processChildren，</span></span><br><span class="line">            <span class="comment">// 这样当前容器的子孙都会被处理</span></span><br><span class="line">            Container[] children = container.findChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay，如果大于 0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。</span></span><br><span class="line">                <span class="keyword">if</span> (children[i].getBackgroundProcessorDelay() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    processChildren(children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Tomcat 的热加载就是在 Context 容器实现，主要是调用了 Context 容器的 reload 方法。抛开细节从宏观上看主要完成以下任务：</p><ol><li>停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。</li><li>停止和销毁 Context 容器关联的 Listener 和 Filter。</li><li>停止和销毁 Context 下的 Pipeline 和各种 Valve。</li><li>停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。</li><li>启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。</li></ol><p>在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。</p><h4 id="Tomcat-的类加载器"><a href="#Tomcat-的类加载器" class="headerlink" title="Tomcat 的类加载器"></a>Tomcat 的类加载器</h4><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 <code>ClassLoader</code>的两个方法：<code>findClass</code>和 <code>loadClass</code>。</p><h5 id="findClass-方法"><a href="#findClass-方法" class="headerlink" title="findClass 方法"></a>findClass 方法</h5><p><code>org.apache.catalina.loader.WebappClassLoaderBase#findClass</code>;为了方便理解和阅读，我去掉了一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Class clazz = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 先在 Web 应用目录下查找类</span></span><br><span class="line">            clazz = findClassInternal(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2. 如果在本地目录没有找到，交给父加载器去查找</span></span><br><span class="line">            clazz = <span class="keyword">super</span>.findClass(name);</span><br><span class="line">    &#125;  <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果父类也没找到，抛出 ClassNotFoundException</span></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先在 Web 应用本地目录下查找要加载的类。</li><li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器 <code>AppClassLoader</code>。</li><li>如何父加载器也没找到这个类，抛出 <code>ClassNotFound</code>异常。</li></ol><h5 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass 方法"></a>loadClass 方法</h5><p>再来看 Tomcat 类加载器的 <code>loadClass</code>方法的实现，同样我也去掉了一些细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, <span class="keyword">boolean</span> resolve)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先在本地 cache 查找该类是否已经加载过</span></span><br><span class="line">        clazz = findLoadedClass0(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从系统类加载器的 cache 中查找是否加载过</span></span><br><span class="line">        clazz = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resolve)</span><br><span class="line">                resolveClass(clazz);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 尝试用 ExtClassLoader 类加载器类加载，为什么？</span></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = javaseLoader.loadClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 尝试在本地目录搜索 class 并加载</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 尝试用系统类加载器 (也就是 AppClassLoader) 来加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (resolve)</span><br><span class="line">                        resolveClass(clazz);</span><br><span class="line">                    <span class="keyword">return</span> clazz;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 上述过程都加载失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有六个步骤：</p><ol><li>先在本地 Cache 查找该类是否已经加载过，也就是说 Tomcat 的类加载器是否已经加载过这个类。</li><li>如果 Tomcat 类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li><li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，这一步比较关键，目的 <strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>。因为 Tomcat 需要打破双亲委托机制，假如 Web 应用里自定义了一个叫 Object 的类，如果先加载这个 Object 类，就会覆盖 JRE 里面的那个 Object 类，这就是为什么 Tomcat 的类加载器会优先尝试用 <code>ExtClassLoader</code>去加载，因为 <code>ExtClassLoader</code>会委托给 <code>BootstrapClassLoader</code>去加载，<code>BootstrapClassLoader</code>发现自己已经加载了 Object 类，直接返回给 Tomcat 的类加载器，这样 Tomcat 的类加载器就不会去加载 Web 应用下的 Object 类了，也就避免了覆盖 JRE 核心类的问题。</li><li>如果 <code>ExtClassLoader</code>加载器加载失败，也就是说 <code>JRE</code>核心类中没有这类，那么就在本地 Web 应用目录下查找并加载。</li><li>如果本地目录下没有这个类，说明不是 Web 应用自己定义的类，那么由系统类加载器去加载。这里请你注意，Web 应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li><li>如果上述加载过程全部失败，抛出 <code>ClassNotFound</code>异常。</li></ol><h4 id="Tomcat-类加载器层次"><a href="#Tomcat-类加载器层次" class="headerlink" title="Tomcat 类加载器层次"></a>Tomcat 类加载器层次</h4><p>Tomcat 作为 <code>Servlet</code>容器，它负责加载我们的 <code>Servlet</code>类，此外它还负责加载 <code>Servlet</code>所依赖的 JAR 包。并且 <code>Tomcat</code>本身也是也是一个 Java 程序，因此它需要加载自己的类和依赖的 JAR 包。首先让我们思考这一下这几个问题：</p><ol><li>假如我们在 Tomcat 中运行了两个 Web 应用程序，两个 Web 应用中有同名的 <code>Servlet</code>，但是功能不同，Tomcat 需要同时加载和管理这两个同名的 <code>Servlet</code>类，保证它们不会冲突，因此 Web 应用之间的类需要隔离。</li><li>假如两个 Web 应用都依赖同一个第三方的 JAR 包，比如 <code>Spring</code>，那 <code>Spring</code>的 JAR 包被加载到内存后，<code>Tomcat</code>要保证这两个 Web 应用能够共享，也就是说 <code>Spring</code>的 JAR 包只被加载一次，否则随着依赖的第三方 JAR 包增多，<code>JVM</code>的内存会膨胀。</li><li>跟 JVM 一样，我们需要隔离 Tomcat 本身的类和 Web 应用的类。</li></ol><figure class="image-box">                <img src="bc3f88a879d635e79609c0f7e1ddb640.webp" alt="img" title class>                <p>img</p>            </figure><h5 id="1-WebAppClassLoader"><a href="#1-WebAppClassLoader" class="headerlink" title="1. WebAppClassLoader"></a>1. WebAppClassLoader</h5><p>Tomcat 的解决方案是自定义一个类加载器 <code>WebAppClassLoader</code>， 并且给每个 Web 应用创建一个类加载器实例。我们知道，Context 容器组件对应一个 Web 应用，因此，每个 <code>Context</code>容器负责创建和维护一个 <code>WebAppClassLoader</code>加载器实例。这背后的原理是，<strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间，每一个 Web 应用都有自己的类空间，Web 应用之间通过各自的类加载器互相隔离。</p><h5 id="2-SharedClassLoader"><a href="#2-SharedClassLoader" class="headerlink" title="2.SharedClassLoader"></a>2.SharedClassLoader</h5><p>本质需求是两个 Web 应用之间怎么共享库类,并且不能重复加载相同的类。在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗。</p><p>因此 Tomcat 的设计者又加了一个类加载器 <code>SharedClassLoader</code>，作为 <code>WebAppClassLoader</code>的父加载器，专门来加载 Web 应用之间共享的类。如果 <code>WebAppClassLoader</code>自己没有加载到某个类，就会委托父加载器 <code>SharedClassLoader</code>去加载这个类，<code>SharedClassLoader</code>会在指定目录下加载共享类，之后返回给 <code>WebAppClassLoader</code>，这样共享的问题就解决了。</p><h5 id="3-CatalinaClassloader"><a href="#3-CatalinaClassloader" class="headerlink" title="3. CatalinaClassloader"></a>3. CatalinaClassloader</h5><p>如何隔离 Tomcat 本身的类和 Web 应用的类？</p><p>要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，基于此 Tomcat 又设计一个类加载器 <code>CatalinaClassloader</code>，专门来加载 Tomcat 自身的类。</p><p>这样设计有个问题，那 Tomcat 和各 Web 应用之间需要共享一些类时该怎么办呢？</p><p>老办法，还是再增加一个 <code>CommonClassLoader</code>，作为 <code>CatalinaClassloader</code>和 <code>SharedClassLoader</code>的父加载器。<code>CommonClassLoader</code>能加载的类都可以被 <code>CatalinaClassLoader</code>和 <code>SharedClassLoader</code>使用</p><h2 id="整体架构设计解析收获总结"><a href="#整体架构设计解析收获总结" class="headerlink" title="整体架构设计解析收获总结"></a>整体架构设计解析收获总结</h2><p>通过前面对 Tomcat 整体架构的学习，知道了 Tomcat 有哪些核心组件，组件之间的关系。以及 Tomcat 是怎么处理一个 HTTP 请求的。下面我们通过一张简化的类图来回顾一下，从图上你可以看到各种组件的层次关系，图中的虚线表示一个请求在 Tomcat 中流转的过程。</p><figure class="image-box">                <img src="3eea333acf49278cb00d07818fa5d0f8.webp" alt="img" title class>                <p>img</p>            </figure><p>Tomcat 整体组件关系</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>Tomcat 的整体架构包含了两个核心组件连接器和容器。连接器负责对外交流，容器负责内部处理。连接器用 <code>ProtocolHandler</code>接口来封装通信协议和 <code>I/O</code>模型的差异，<code>ProtocolHandler</code>内部又分为 <code>EndPoint</code>和 <code>Processor</code>模块，<code>EndPoint</code>负责底层 <code>Socket</code>通信，<code>Proccesor</code>负责应用层协议解析。连接器通过适配器 <code>Adapter</code>调用容器。</p><p>对 Tomcat 整体架构的学习，我们可以得到一些设计复杂系统的基本思路。<strong>首先要分析需求，根据高内聚低耦合的原则确定子模块，然后找出子模块中的变化点和不变点，用接口和抽象基类去封装不变点，在抽象基类中定义模板方法，让子类自行实现抽象方法，也就是具体子类去实现变化点。</strong></p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><p>运用了<strong>组合模式 管理容器、通过 观察者模式 发布启动事件达到解耦、开闭原则。骨架抽象类和模板方法抽象变与不变，变化的交给子类实现，从而实现代码复用，以及灵活的拓展</strong>。使用责任链的方式处理请求，比如记录日志等。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Tomcat 的自定义类加载器 <code>WebAppClassLoader</code>为了隔离 Web 应用打破了双亲委托机制，它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载 Web 应用自己定义的类。<strong>防止 Web 应用自己的类覆盖 JRE 的核心类</strong>，使用 <strong>ExtClassLoader</strong> 去加载，这样即打破了双亲委派，又能安全加载。</p><h2 id="如何阅读源码持续学习"><a href="#如何阅读源码持续学习" class="headerlink" title="如何阅读源码持续学习"></a>如何阅读源码持续学习</h2><p><strong>学习是一个反人类的过程，是比较痛苦的</strong>。尤其学习我们常用的优秀技术框架本身比较庞大，设计比较复杂，在学习初期很容易遇到 “挫折感”，debug 跳来跳去陷入恐怖细节之中无法自拔，往往就会放弃。</p><p><strong>找到适合自己的学习方法非常重要，同样关键的是要保持学习的兴趣和动力，并且得到学习反馈效果</strong>。</p><p>学习优秀源码，我们收获的就是架构设计能力，遇到复杂需求我们学习到可以利用合理模式与组件抽象设计了可拓展性强的代码能力。</p><h3 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h3><p>比如我最初在学习 Spring 框架的时候，一开始就钻进某个模块啃起来。然而由于 Spring 太庞大，模块之间也有联系，根本不明白为啥要这么写，只觉得为啥设计这么 “绕”。</p><h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><ul><li>陷入细节，不看全局：<strong>我还没弄清楚森林长啥样，就盯着叶子看</strong> ，看不到全貌和整体设计思路。所以阅读源码学习的时候不要一开始就进入细节，而是宏观看待整体架构设计思想，模块之间的关系。</li><li>还没学会用就研究如何设计：首先基本上框架都运用了设计模式，我们最起码也要了解常用的设计模式，即使是“背”，也得了然于胸。在学习一门技术，我推荐先看官方文档，看看有哪些模块、整体设计思想。然后下载示例跑一遍，最后才是看源码。</li><li>看源码深究细节：到了看具体某个模块源码的时候也要下意识的不要去深入细节，重要的是学习设计思路，而不是具体一个方法实现逻辑。除非自己要基于源码做二次开发。</li></ul><h4 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h4><ul><li>定焦原则：抓主线（抓住一个核心流程去分析，不要漫无目的的到处阅读）。</li><li>宏观思维：从全局的视角去看待，上帝视角理出主要核心架构设计，先森林后树叶。切勿不要试图去搞明白每一行代码。</li><li>断点：合理运用调用栈（观察调用过程上下文）。</li></ul><h3 id="带着目标去学"><a href="#带着目标去学" class="headerlink" title="带着目标去学"></a>带着目标去学</h3><p>比如某些知识点是面试的热点，那学习目标就是彻底理解和掌握它，当被问到相关问题时，你的回答能够使得面试官对你刮目相看，有时候往往凭着某一个亮点就能影响最后的录用结果。</p><p>又或者接到一个稍微复杂的需求，<strong>学习从优秀源码中借鉴设计思路与优化技巧。</strong></p><p><strong>最后就是动手实践</strong>，将所学运用在工作项目中。只有动手实践才会让我们对技术有最直观的感受。有时候我们听别人讲经验和理论，感觉似乎懂了，但是过一段时间便又忘记了。</p><h2 id="实际场景运用"><a href="#实际场景运用" class="headerlink" title="实际场景运用"></a>实际场景运用</h2><p>简单的分析了 Tomcat 整体架构设计，从 【连接器】 到 【容器】，并且分别细说了一些组件的设计思想以及设计模式。接下来就是如何学以致用，借鉴优雅的设计运用到实际工作开发中。<strong>学习，从模仿开始。</strong></p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>在工作中，有这么一个需求，用户可以输入一些信息并可以选择查验该企业的 【工商信息】、【司法信息】、【中登情况】等如下如所示的一个或者多个模块，而且模块之间还有一些公共的东西是要各个模块复用。</p><p>这里就像一个请求，会被多个模块去处理。所以每个查询模块我们可以抽象为 <strong>处理阀门</strong>，使用一个 List 将这些 阀门保存起来，这样新增模块我们只需要新增一个<strong>阀门</strong>即可，实现了<strong>开闭原则</strong>，<strong>同时将一堆查验的代码解耦到不同的具体阀门中</strong>，使用抽象类提取 “<strong>不变的</strong>”功能。</p><figure class="image-box">                <img src="58f80e12c2dd2b9abd20c16b832fd4b4.webp" alt="img" title class>                <p>img</p>            </figure><p>具体示例代码如下所示：</p><p>首先抽象我们的处理阀门， <code>NetCheckDTO</code>是请求信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链模式：处理每个模块阀门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象基类，复用代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCheckValve</span> <span class="keyword">implements</span> <span class="title">Valve</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AnalysisReportLogDO <span class="title">getLatestHistoryData</span><span class="params">(NetCheckDTO netCheckDTO, NetCheckDataTypeEnum checkDataTypeEnum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取历史记录，省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取查验数据源配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getModuleSource</span><span class="params">(String querySource, ModuleEnum moduleEnum)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 省略代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体每个模块处理的业务逻辑，比如 【百度负面新闻】对应的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduNegativeValve</span> <span class="keyword">extends</span> <span class="title">AbstractCheckValve</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(NetCheckDTO netCheckDTO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是管理用户选择要查验的模块，我们通过 List 保存。用于触发所需要的查验模块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetCheckService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入所有的阀门</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map valveMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送查验请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> netCheckDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckRequest</span><span class="params">(NetCheckDTO netCheckDTO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于保存客户选择处理的模块阀门</span></span><br><span class="line">        List valves = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        CheckModuleConfigDTO checkModuleConfig = netCheckDTO.getCheckModuleConfig();</span><br><span class="line">        <span class="comment">// 将用户选择查验的模块添加到 阀门链条中</span></span><br><span class="line">        <span class="keyword">if</span> (checkModuleConfig.getBaiduNegative()) &#123;</span><br><span class="line">            valves.add(valveMap.get(<span class="string">"baiduNegativeValve"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码.......</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(valves)) &#123;</span><br><span class="line">            log.info(<span class="string">"网查查验模块为空，没有需要查验的任务"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发处理</span></span><br><span class="line">        valves.forEach(valve -&gt; valve.invoke(netCheckDTO));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>需求是这样的，可根据客户录入的财报 excel 数据或者企业名称执行财报分析。</p><p>对于非上市的则解析 excel -&gt; 校验数据是否合法-&gt;执行计算。</p><p>上市企业：判断名称是否存在 ，不存在则发送邮件并中止计算-&gt; 从数据库拉取财报数据，初始化查验日志、生成一条报告记录，触发计算-&gt; 根据失败与成功修改任务状态 。</p><figure class="image-box">                <img src="23cf73882200a0622108b396eb8710c3.webp" alt="img" title class>                <p>img</p>            </figure><p>重要的 ”变“ 与 ”不变“，</p><ul><li><strong>不变</strong>的是整个流程是<strong>初始化查验日志、初始化一条报告</strong>、<strong>前期校验数据</strong>（若是上市公司校验不通过还需要构建邮件数据并发送）、从不同来源拉取财报数据并且适配通用数据、然后触发计算，任务异常与成功都需要修改状态。</li><li><strong>变化</strong>的是上市与非上市校验规则不一样，获取财报数据方式不一样，两种方式的财报数据需要适配</li></ul><p>整个算法流程是固定的模板，但是需要将<strong>算法内部变化的部分</strong>具体实现延迟到不同子类实现，这正是模板方法模式的最佳场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnalysisTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交财报分析模板方法，定义骨架流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reportAnalysisRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FinancialAnalysisResultDTO <span class="title">doProcess</span><span class="params">(FinancialReportAnalysisRequest reportAnalysisRequest)</span> </span>&#123;</span><br><span class="line">        FinancialAnalysisResultDTO analysisDTO = <span class="keyword">new</span> FinancialAnalysisResultDTO();</span><br><span class="line">  <span class="comment">// 抽象方法：提交查验的合法校验</span></span><br><span class="line">        <span class="keyword">boolean</span> prepareValidate = prepareValidate(reportAnalysisRequest, analysisDTO);</span><br><span class="line">        log.info(<span class="string">"prepareValidate 校验结果 = &#123;&#125; "</span>, prepareValidate);</span><br><span class="line">        <span class="keyword">if</span> (!prepareValidate) &#123;</span><br><span class="line">   <span class="comment">// 抽象方法：构建通知邮件所需要的数据</span></span><br><span class="line">            buildEmailData(analysisDTO);</span><br><span class="line">            log.info(<span class="string">"构建邮件信息，data = &#123;&#125;"</span>, JSON.toJSONString(analysisDTO));</span><br><span class="line">            <span class="keyword">return</span> analysisDTO;</span><br><span class="line">        &#125;</span><br><span class="line">        String reportNo = FINANCIAL_REPORT_NO_PREFIX + reportAnalysisRequest.getUserId() + SerialNumGenerator.getFixLenthSerialNumber();</span><br><span class="line">        <span class="comment">// 生成分析日志</span></span><br><span class="line">        initFinancialAnalysisLog(reportAnalysisRequest, reportNo);</span><br><span class="line">  <span class="comment">// 生成分析记录</span></span><br><span class="line">        initAnalysisReport(reportAnalysisRequest, reportNo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法：拉取财报数据，不同子类实现</span></span><br><span class="line">            FinancialDataDTO financialData = pullFinancialData(reportAnalysisRequest);</span><br><span class="line">            log.info(<span class="string">"拉取财报数据完成, 准备执行计算"</span>);</span><br><span class="line">            <span class="comment">// 测算指标</span></span><br><span class="line">            financialCalcContext.calc(reportAnalysisRequest, financialData, reportNo);</span><br><span class="line">   <span class="comment">// 设置分析日志为成功</span></span><br><span class="line">            successCalc(reportNo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"财报计算子任务出现异常"</span>, e);</span><br><span class="line">   <span class="comment">// 设置分析日志失败</span></span><br><span class="line">            failCalc(reportNo);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> analysisDTO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后新建两个子类继承该模板，并实现抽象方法。这样就将上市与非上市两种类型的处理逻辑解耦，同时又复用了代码。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>需求是这样，要做一个万能识别银行流水的 excel 接口，假设标准流水包含【交易时间、收入、支出、交易余额、付款人账号、付款人名字、收款人名称、收款人账号】等字段。现在我们解析出来每个必要字段所在 excel 表头的下标。但是流水有多种情况：</p><ol><li>一种就是包含所有标准字段。</li><li>收入、支出下标是同一列，通过正负来区分收入与支出。</li><li>收入与支出是同一列，有一个交易类型的字段来区分。</li><li>特殊银行的特殊处理。</li></ol><p>也就是我们要<strong>根据解析对应的下标找到对应的处理逻辑算法</strong>，我们可能在一个方法里面写超多 <code>if else</code> 的代码，整个流水处理都偶合在一起，假如未来再来一种新的流水类型，还要继续改老代码。最后可能出现 “又臭又长，难以维护” 的代码复杂度。</p><p>这个时候我们可以用到<strong>策略模式</strong>，<strong>将不同模板的流水使用不同的处理器处理，根据模板找到对应的策略算法去处理</strong>。即使未来再加一种类型，我们只要新加一种处理器即可，高内聚低耦合，且可拓展。</p><figure class="image-box">                <img src="bc69c1f573168ded681da5bc39642a57.webp" alt="img" title class>                <p>img</p>            </figure><p>定义处理器接口，不同处理器去实现处理逻辑。将所有的处理器注入到 <code>BankFlowDataHandler</code> 的<code>data_processor_map</code>中，根据不同的场景取出对已经的处理器处理流水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理流水数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bankFlowTemplateDO 流水下标数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BankTransactionFlowDO <span class="title">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO, List row)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持处理该模板,不同类型的流水策略根据模板数据判断是否支持解析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理器的上下文</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankFlowDataContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将所有处理器注入到 map 中</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List processors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找对对应的处理器处理流水</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         DataProcessor processor = getProcessor(bankFlowTemplateDO);</span><br><span class="line">        <span class="keyword">for</span>(DataProcessor processor ：processors) &#123;</span><br><span class="line">           <span class="keyword">if</span> (processor.isSupport(bankFlowTemplateDO)) &#123;</span><br><span class="line">             <span class="comment">// row 就是一行流水数据</span></span><br><span class="line">           processor.doProcess(bankFlowTemplateDO, row);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义默认处理器，处理正常模板，新增模板只要新增处理器实现 <code>DataProcessor</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认处理器：正对规范流水模板</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"defaultDataProcessor"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataProcessor</span> <span class="keyword">implements</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BankTransactionFlowDO <span class="title">doProcess</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略处理逻辑细节</span></span><br><span class="line">        <span class="keyword">return</span> bankTransactionFlowDO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strategy</span><span class="params">(BankFlowTemplateDO bankFlowTemplateDO)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 省略判断是否支持解析该流水</span></span><br><span class="line">      <span class="keyword">boolean</span> isDefault = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> isDefault;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过策略模式，我们将不同处理逻辑分配到不同的处理类中，这样完全解耦，便于拓展。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 原理 </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转 | 数学 | 当前值除以10与上一个值比较，判断是否溢出（java）</title>
      <link href="/2021/12/01/reverse-integer/"/>
      <url>/2021/12/01/reverse-integer/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。<br>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。<br>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：<br>输入：x = 123<br>输出：321<br>示例 2：<br>输入：x = -123<br>输出：-321<br>示例 3：<br>输入：x = 120<br>输出：21<br>示例 4：<br>输入：x = 0<br>输出：0</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目不允许存储 64 位整数，不能用long类型；<br>想要使用最大最小的数值边界判断，你其实根本记不住；<br>最好的办法就是：在每次增大数字的时候，就要逆向计算一下，判断数值是否溢出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span> &amp;&amp; x&gt;-<span class="number">10</span>) <span class="keyword">return</span> x; <span class="comment">//个位数情况</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>, pev;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            pev=cur; <span class="comment">//保存上次的值</span></span><br><span class="line">            cur=cur*<span class="number">10</span>+x%<span class="number">10</span>;   <span class="comment">//旋转数字，不断从末尾插入新值，总值不断扩大</span></span><br><span class="line">            <span class="keyword">if</span>((cur-x%<span class="number">10</span>)/<span class="number">10</span>!=pev) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//当逆向计算发现不相同，说明数溢出，直接返回0</span></span><br><span class="line">            x/=<span class="number">10</span>;  <span class="comment">//删除个位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<br><code>if((cur-x%10)/10!=pev) return 0;</code><br>x%10是个位数，cur减去它后个位数是0，不减就是x%10。<br>无论减不减最后/10的结果都一样，因此直接换成<br><code>if(cur/10!=pev) return 0;</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">10</span> &amp;&amp; x&gt;-<span class="number">10</span>) <span class="keyword">return</span> x; <span class="comment">//个位数情况</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>, pev;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            pev=cur; <span class="comment">//保存上次的值</span></span><br><span class="line">            cur=cur*<span class="number">10</span>+x%<span class="number">10</span>;   <span class="comment">//旋转数字，不断从末尾插入新值，总值不断扩大</span></span><br><span class="line">            <span class="keyword">if</span>(cur/<span class="number">10</span>!=pev) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//当逆向计算发现不相同，说明数溢出，直接返回0</span></span><br><span class="line">            x/=<span class="number">10</span>;  <span class="comment">//删除个位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小覆盖子串 | 哈希表+队列+滑动窗口</title>
      <link href="/2021/11/15/minimum-window-substring/"/>
      <url>/2021/11/15/minimum-window-substring/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：<br>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>示例 2：<br>输入：s = “a”, t = “a”<br>输出：”a”<br>示例 3:<br>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p><p>提示：<br>1 &lt;= s.length, t.length &lt;= 105<br>s 和 t 由英文字母组成</p><p>进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>为了使用队列，减少对哈希表数组操作的遍历次数，设置了zoreNeed平衡点，定义了匹配字符在窗口中是否需要的平衡界限</li><li>左指针采用队列记录，实现左指针跳跃，相比左指针+1循环的方式减少了遍历次数<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">""</span> || t == <span class="string">""</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] tt = t.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> zoreNeed = ss.length; <span class="comment">//设置0平衡，定义了匹配字符在窗口中是否需要的平衡界限，作用是：使匹配字符的need最小无法达到0， 非匹配字符都是need=0，保证能区分开，来决定能否加入队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建hash表：匹配字符-&gt; zoreNeed + 实际需要数；非匹配字符 -&gt; 0</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">123</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: tt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(need[c]==<span class="number">0</span>) need[c]+=zoreNeed;</span><br><span class="line">            need[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//2. 匹配字符位置队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> needSum = tt.length,  ansStart=<span class="number">0</span>,  ansSize=Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//3. 窗口随着右指针end递增而增大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end= <span class="number">0</span>; end&lt;ss.length; end++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need[ss[end]]&gt;zoreNeed)&#123; <span class="comment">//4. 判断窗口是否需要当前字符,需要的话needSum-1</span></span><br><span class="line">                needSum--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(need[ss[end]]&gt;<span class="number">0</span>)&#123; <span class="comment">//5. 若是则匹配字符加入队列</span></span><br><span class="line">                queue.add(end);</span><br><span class="line">                need[ss[end]]--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//6. 窗口匹配成功</span></span><br><span class="line">            <span class="keyword">if</span>(needSum == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//6.1 从队列中不断取start，窗口随着左指针start递增而增大</span></span><br><span class="line">                start = queue.poll();  <span class="comment">//此时队列不可能为空，取队列第一个匹配字符（左指针指向第一次匹配字符位置 或 上一次成功匹配后将左指针指向下一个匹配字符位置）</span></span><br><span class="line">                <span class="keyword">while</span>(need[ss[start]]&lt;zoreNeed)&#123; <span class="comment">//缩小窗口，直到刚好匹配则结束</span></span><br><span class="line">                    need[ss[start]]++;</span><br><span class="line">                    start = queue.poll();  <span class="comment">//取出并删掉多余的匹配字符</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//6.2 取最小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(end-start&lt;ansSize)&#123;</span><br><span class="line">                    ansStart = start;</span><br><span class="line">                    ansSize = end-start;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//6.3 左指针右移，继续缩小窗口。 这里只先释放增加左指针指向匹配字符的需要数，真正右移是在等下一次匹配成功后，第一次调用 start = queue.poll();</span></span><br><span class="line">                need[ss[start]]++;</span><br><span class="line">                needSum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansSize == Integer.MAX_VALUE? <span class="string">""</span> :s.substring(ansStart, ansStart+ansSize+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 摩尔投票法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色分类LeetCode题 | 三指针，2指针循环去重写法改编</title>
      <link href="/2021/11/13/sort-colors/"/>
      <url>/2021/11/13/sort-colors/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p> 颜色分类<br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>示例 1：<br>输入：nums = [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：<br>输入：nums = [2,0,1]<br>输出：[0,1,2]<br>示例 3：<br>输入：nums = [0]<br>输出：[0]<br>示例 4：<br>输入：nums = [1]<br>输出：[1]</p><p>提示：<br>n == nums.length<br>1 &lt;= n &lt;= 300<br>nums[i] 为 0、1 或 2</p><p>进阶：<br>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p></blockquote><p><strong>思路</strong><br>根据快排的2指针循环去重写法，改编的3指针法</p><p><strong>代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>, r= nums.length-<span class="number">1</span>, m=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(m&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(m&lt;r &amp;&amp; nums[r]==<span class="number">2</span>)&#123;   <span class="comment">//右指针过滤2，找到待替换位置</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==<span class="number">0</span>)&#123;   <span class="comment">//左指针过滤0，找到待替换位置</span></span><br><span class="line">                l++;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(m&lt;r &amp;&amp; nums[m]==<span class="number">1</span>)&#123;   <span class="comment">//中指针过滤1，找到替换的位置</span></span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==<span class="number">0</span>)&#123;         </span><br><span class="line">                swap(nums, l ,m);   <span class="comment">// 左替换</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(nums, m ,r);    <span class="comment">//右替换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp =nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 三指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转链表 | 哈希表存储链表索引，定位查找链表环切断点</title>
      <link href="/2021/11/12/rotate-list/"/>
      <url>/2021/11/12/rotate-list/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">the leetcode link</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>计算链表长度，同时初始化哈希索引</li><li>取余去重</li><li>形成环，链尾指向链头</li><li>定位到翻转后的尾结点</li><li>断链</li><li>返回新链头<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哈希索引存储</span></span><br><span class="line">        Map&lt;Integer,ListNode&gt; map  = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算链表长度， 同时初始化哈希索引</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(len++, cur);</span><br><span class="line">            cur =cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//去重，转n*len+k次，等价于转k%len次，k%len=0等价与0次翻转</span></span><br><span class="line">        <span class="keyword">if</span>((k=(k%len))==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形成环</span></span><br><span class="line">        cur.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到翻转后的尾结点</span></span><br><span class="line">        ListNode newTail = map.get(len-k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开头尾</span></span><br><span class="line">        ListNode newHead = newTail.next;</span><br><span class="line">        newTail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打家劫舍 II | 动态规划 | 环看作两个队列 （JAVA）</title>
      <link href="/2021/11/10/house-robber-ii/"/>
      <url>/2021/11/10/house-robber-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>打家劫舍 II<br>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p></blockquote><blockquote><p>示例 1：<br>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2：<br>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 3：<br>输入：nums = [0]<br>输出：0</p><p>提示：<br>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 1000</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>环拆成两个队列，对每个队列动态规划求最优解（这里需掌握: 打家劫舍1），然后比较两者取最大值</p><h1 id="Q：环为什么能当成两个队列？"><a href="#Q：环为什么能当成两个队列？" class="headerlink" title="Q：环为什么能当成两个队列？"></a>Q：环为什么能当成两个队列？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A: 不妨列举出所有可能出现的最优偷取情况来验证</span><br><span class="line">偷：  1</span><br><span class="line">不偷：0</span><br><span class="line">有一队列：[x, x, x, x, x, x, x, x, x]  n个元素</span><br><span class="line">0 ~ n-1队列最优解所有可能情况</span><br><span class="line">情况1：   [1, 0, x, x, x, x, 0, 1] 0</span><br><span class="line">情况2：   [1, 0, x, x, x, x, 1, 0] 0</span><br><span class="line">情况3：   [0, 1, x, x, x, x, 0, 1] 0</span><br><span class="line">情况4：   [0, 1, x, x, x, x, 1, 0] 0</span><br><span class="line">1 ~ n  队列最优解所有可能情况</span><br><span class="line">情况1：    0 [1, 0, x, x, x, x, 0, 1]</span><br><span class="line">情况2：    0 [1, 0, x, x, x, x, 1, 0]</span><br><span class="line">情况3：    0 [0, 1, x, x, x, x, 0, 1]</span><br><span class="line">情况4：    0 [0, 1, x, x, x, x, 1, 0]</span><br><span class="line">对于 0~n 队列，自己的最优解可能情况与上述所有情况取差集，得到自己的剩下最优解可能情况</span><br><span class="line">剩下情况： [1, 0, x, x, x, x, x, 0, 1]</span><br><span class="line">假设是 0~n 环结构，会发现，只有“剩下情况”不成立，其他情况均成立。</span><br><span class="line">也就是说：</span><br><span class="line">0~n 环最优解所有可能情况 = （0 ~ n-1）队列最优解所有可能情况 + （1 ~ n） 队列最优解所有可能情况</span><br></pre></td></tr></table></figure><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,n-<span class="number">1</span>),rob(nums,<span class="number">1</span>, n));        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//动态规划 dp空间优化为first，second</span></span><br><span class="line">        <span class="keyword">int</span> first= nums[start];</span><br><span class="line">        <span class="keyword">int</span> second = Math.max(first, nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">2</span>; i&lt;end;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = second;</span><br><span class="line">           second = Math.max(second, first + nums[i]);</span><br><span class="line">           first = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> second;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 环 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组 | 二分法</title>
      <link href="/2021/11/05/search-in-rotated-sorted-array/"/>
      <url>/2021/11/05/search-in-rotated-sorted-array/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">the leetcode link</a></p><blockquote><p>搜索旋转排序数组<br>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：<br>输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br>示例 2：<br>输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br>示例 3：<br>输入：nums = [1], target = 0<br>输出：-1</p><p>提示：<br>1 &lt;= nums.length &lt;= 5000<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-10^4 &lt;= target &lt;= 10^4</p><p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二分查找法</p><p>Q:翻转数组的样子是怎么样的？<br><strong>A:部分有序。</strong><br>Q:划分中值后，有什么规律？<br><strong>A:一定有一侧是有序的。</strong><br>Q:有序侧和无序侧对查找有何影响？<br><strong>A:有序侧能通过between比较方式，O(1)时间判断target是否存在；<br>无序侧仅靠自身不能以O(1)时间判断存在，要借助有序侧判断。</strong><br>因此，我们先判断哪一侧是有序侧，再通过between比较方式判断target在不在有序侧，不在有序侧则说明是在无序侧，不断缩小范围，反复判断。<br><figure class="image-box">                <img src="https://pic.leetcode-cn.com/1640451129-ZRVuIB-binary.png" alt="binary.png" title class>                <p>binary.png</p>            </figure></p><p>left 最左下标；right 最右下标；mid中间值下标；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">翻转情况1：</span><br><span class="line">条件：nums[left]&lt;=nums[mid]</span><br><span class="line">    图中target可能出现情况依次是：</span><br><span class="line">    1. nums[left]&lt;= target &lt;= nums[mid]     （左侧绿点，有序侧）</span><br><span class="line">    2. target &gt;= nums[mid]                  （右侧1绿点）</span><br><span class="line">    3. target &lt;= nums[left]                 （右侧2绿点）</span><br><span class="line">2,3合并为 !(nums[left]&lt;= target &lt;= nums[mid])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">翻转情况2：</span><br><span class="line">条件：nums[left]&gt; nums[mid]</span><br><span class="line">    图中target可能出现情况依次是：</span><br><span class="line">    4. target &gt;= nums[right]                （左侧1绿点）</span><br><span class="line">    5. target &lt;= nums[mid]                  （左侧2绿点）</span><br><span class="line">    6. nums[mid]&lt;= target &lt;= nums[right]    （右侧绿点，有序侧）</span><br><span class="line">4,5合并为 !(nums[mid]&lt;= target &lt;= nums[right])</span><br></pre></td></tr></table></figure></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r =n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> m =(l+r)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target)&#123; <span class="comment">//中值等于马上返回</span></span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=nums[m])&#123;       <span class="comment">//翻转情况1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[l]==target)&#123; <span class="comment">//左值等于马上返回</span></span><br><span class="line">                    <span class="keyword">return</span> l;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[l]&lt;target &amp;&amp; target&lt;nums[m])&#123;</span><br><span class="line">                    r=m-<span class="number">1</span>; <span class="comment">//target情况1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l=m+<span class="number">1</span>; <span class="comment">//target情况2,3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;                      <span class="comment">//翻转情况2</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[r]==target)&#123; <span class="comment">//右值等于马上返回</span></span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(nums[m]&lt;target &amp;&amp; target&lt;nums[r])&#123;</span><br><span class="line">                    l=m+<span class="number">1</span>; <span class="comment">//target情况6</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r=m-<span class="number">1</span>; <span class="comment">//target情况4,5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础深复习，大杂烩整理笔记</title>
      <link href="/2021/11/03/java-interview/"/>
      <url>/2021/11/03/java-interview/</url>
      
        <content type="html"><![CDATA[<p><strong>首先感谢龙哥，向博主整理并提供资料，爱了~</strong></p><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><p>互联网的快速发展给了Oak机会 因为Oak的小巧 Sun公司首先推出了可以嵌入网页并且快速在网络上传输的Applet 非常适合网络传播</p><p>随后 各大公司竞相购买了Java使用许可证</p><p>申请注册商标时，发现Oak已经被人使用了，然后他们正在咖啡馆喝Java咖啡，灵机一动Oak语言改名为Java</p><p>Java吸收C++ 的很多优点 精简了很多东西（还摒弃了C++ 里难以理解的多继承、指针等概念） 当时被人称为 C++-</p><p>这一年的5月23日Java 1.0版本正式在SunWorld大会上发布 喊出了”Write Once，Run Anywhere”的口号 体现了其跨平台的特性</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>相信大家都具备基本的常识: 被final修饰的变量是不能够被改变的. 但是这里的”不能够被改变”对于不同的数据类型是有不同的含义的.</p><p>当final修饰的是一个基本数据类型数据时, 这个数据的值在初始化后将不能被改变; 当final修饰的是一个引用类型数据时, 也就是修饰一个对象时, 引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的.</p><h2 id="被final修饰的常量在编译阶段会被放入常量池中"><a href="#被final修饰的常量在编译阶段会被放入常量池中" class="headerlink" title="被final修饰的常量在编译阶段会被放入常量池中"></a>被final修饰的常量在编译阶段会被放入常量池中</h2><ul><li>final是用于定义常量的, 定义常量的好处是: 不需要重复地创建相同的变量. 而常量池是Java的一项重要技术, 由final修饰的变量会在编译阶段放入到调用类的常量池中.</li><li>请看下面这段演示代码. 这个示例是专门为了演示而设计的, 希望能方便大家理解这个知识点.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int n1 = 2019;          //普通变量</span><br><span class="line">    final int n2 = 2019;    //final修饰的变量</span><br><span class="line"></span><br><span class="line">    String s = &quot;20190522&quot;;  </span><br><span class="line">    String s1 = n1 + &quot;0522&quot;;//拼接字符串&quot;20190512&quot;</span><br><span class="line">    String s2 = n2 + &quot;0522&quot;;</span><br><span class="line"></span><br><span class="line">    System.out.println(s == s1);//false</span><br><span class="line">    System.out.println(s == s2);//true</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>首先要介绍一点: 整数-127-128是默认加载到常量池里的, 也就是说如果涉及到-127-128的整数操作, 默认在编译期就能确定整数的值. 所以这里我故意选用数字2019(大于128), 避免数字默认就存在常量池中.</p></blockquote><ul><li>上面的代码运作过程是这样的:</li><li>首先根据final修饰的常量会在编译期放到常量池的原则, n2会在编译期间放到常量池中.</li><li>然后s变量所对应的”20190522”字符串会放入到字符串常量池中, 并对外提供一个引用返回给s变量.</li><li>这时候拼接字符串s1, 由于n1对应的数据没有放入常量池中, 所以s1暂时无法拼接, 需要等程序加载运行时才能确定s1对应的值.</li><li>但在拼接s2的时候, 由于n2已经存在于常量池, 所以可以直接与”0522”拼接, 拼接出的结果是”20190522”. 这时系统会查看字符串常量池, 发现已经存在字符串20190522, 所以直接返回20190522的引用. 所以s2和s指向的是同一个引用, 这个引用指向的是字符串常量池中的20190522.</li></ul><ul><li>当程序执行时, n1变量才有具体的指向.</li><li>当拼接s1的时候, 会创建一个新的String类型对象, 也就是说字符串常量池中的20190522会对外提供一个新的引用.</li><li>所以当s1与s用”==”判断时, 由于对应的引用不同, 会返回false. 而s2和s指向同一个引用, 返回true.</li></ul><blockquote><p>总结: 这个例子想说明的是: 由于被final修饰的常量会在编译期进入常量池, 如果有涉及到该常量的操作, 很有可能在编译期就已经完成.</p></blockquote><pre><code>3. 探索: 为什么局部/匿名内部类在使用外部局部变量时, 只能使用被final修饰的变量?</code></pre><blockquote><p>提示: 在JDK1.8以后, 通过内部类访问外部局部变量时, 无需显式把外部局部变量声明为final. 不是说不需要声明为final了, 而是这件事情在编译期间系统帮我们做了. 但是我们还是有必要了解为什么要用final修饰外部局部变量.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Outter &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final int a = 10;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>在上面这段代码, 如果没有给外部局部变量a加上final关键字, 是无法通过编译的. 可以试着想想: 当main方法已经执行完后, main方法的栈帧将会弹出, 如果此时Thread对象的生命周期还没有结束, 还没有执行打印语句的话, 将无法访问到外部的a变量.</li><li>那么为什么加上final关键字就能正常编译呢? 我们通过查看反编译代码看看内部类是怎样调用外部成员变量的.</li><li>我们可以先通过javac编译得到.class文件(用IDE编译也可以), 然后在命令行输入<code>javap -c .class文件的绝对路径</code>, 就能查看.class文件的反编译代码.  以上的Outter类经过编译产生两个.class文件, 分别是<code>Outter.class和Outter$1.class</code>, 也就是说内部类会单独编译成一个.class文件. 下面给出<code>Outter$1.class</code>的反编译代码.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Outter.java&quot;</span><br><span class="line">final class forTest.Outter$1 extends java.lang.Thread &#123;</span><br><span class="line">  forTest.Outter$1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public void run();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: bipush        10</span><br><span class="line">       5: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>定位到<code>run()</code>方法反编译代码中的第3行:</li><li><code>3: bipush 10</code></li><li>我们看到a的值在内部类的<code>run()</code>方法执行过程中是以压栈的形式存储到本地变量表中的, 也就是说在内部类打印变量a的值时, 这个变量a不是外部的局部变量a, 因为如果是外部局部变量的话, 应该会使用<code>load</code>指令加载变量的值. 也就是说系统以拷贝的形式把外部局部变量a复制了一个副本到内部类中, 内部类有一个变量指向外部变量a所指向的值.</li></ul><ul><li>但研究到这里好像和final的关系还不是很大, 不加final似乎也可以拷贝一份变量副本, 只不过不能在编译期知道变量的值罢了. 这时该思考一个新问题了: 现在我们知道内部类的变量a和外部局部变量a是两个完全不同的变量, 那么如果在执行run()方法的过程中, 内部类中修改了a变量所指向的值, 就会产生数据不一致问题.</li><li>正因为我们的原意是内部类和外部类访问的是同一个a变量, 所以当在内部类中使用外部局部变量的时候应该用final修饰局部变量, 这样局部变量a的值就永远不会改变, 也避免了数据不一致问题的发生.</li></ul><h2 id="String-、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-、StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String 、StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?"></a>String 、StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?</h2><p>简单的来说：<code>String</code> 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以<code>String</code> 对象是不可变的。</p><p>而 <code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 <code>final</code> 关键字修饰，所以这两种对象都是可变的。</p><p><strong>线程安全性</strong></p><p>-=</p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</p><p><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。</p><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><ol><li><p>操作1111少量的数据: 适用 <code>String</code></p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></p><p><img src="20180411092328691.png" alt="img"></p></li></ol><h2 id="HashCode（）与-equals"><a href="#HashCode（）与-equals" class="headerlink" title="HashCode（）与 equals"></a>HashCode（）与 equals</h2><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p><p><strong>散列表存储</strong>的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p><p><strong>hashCode（）与 equals（）的相关规定</strong></p><ol><li>如果两个对象相等，则 hashcode 一定也是相同的;</li><li>两个对象相等,对两个对象分别调用 equals 方法都返回 true;</li><li>两个对象有相同的 hashcode 值，它们也不一定是相等的（不同的对象也可能产生相同的 hashcode，概率性问题）;</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h2 id="包装类Intege和Int的区别"><a href="#包装类Intege和Int的区别" class="headerlink" title="包装类Intege和Int的区别"></a>包装类Intege和Int的区别</h2><p><strong>二者的区别：</strong></p><p><strong>1. 声明方式不同：</strong></p><p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br> <strong>2. 存储方式及位置不同：</strong></p><p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br> <strong>3. 初始值不同：</strong></p><p>基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null；</p><p><strong>4. 使用方式不同：</strong></p><p>基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。</p><p><strong>5.函数传参</strong></p><p>有些函数传入参数需要object 类，这时可以传入包装类。</p><p>因为new生成的是两个对象，其内存地址不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">System.out.print(i == j);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>因为 Integer变量 指向的是 java 常量池 中的对象，<br>而 new Integer() 的变量指向 堆中 新建的对象，两者在<strong>内存中的地址</strong>不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>两个<code>Integer</code> 变量比较，如果两个变量的值在区间-128到127 之间，<strong>有缓存数组</strong>，则比较结果为true，如果两个变量的值  不在此区间，则比较结果为 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line">Integer j = <span class="number">100</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.print(i == j); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>因为包装类Integer 和 基本数据类型int 比较时，java会自动拆包装为int ，然后进行比较，实际上就变为两个int变量的比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>); <span class="comment">//自动拆箱为 int i=100; 此时，相当于两个int的比较</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">100</span>；</span><br><span class="line">System.out.print(i == j); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>二者的区别：</strong></p><p><strong>1. 声明方式不同：</strong></p><p>基本类型不使用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br> <strong>2. 存储方式及位置不同：</strong></p><p>基本类型是直接将变量值存储在栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br> <strong>3. 初始值不同：</strong></p><p>基本类型的初始   </p><p><strong>自动装箱和自动拆箱</strong></p><p>Integer number = 10; //自动装箱</p><p>int count = number; //自动拆箱</p><ul><li><strong>什么情况会触发自动装箱操作？</strong><br>当基本类型赋值给包装类型引用时，会触发自动装箱操作，调用包装类型的valueOf()方法。</li><li><strong>什么情况会触发自动拆箱操作？</strong><br>当包装类型参与运算时会触发自动拆箱操作，调用包装类型对应的***Value()方法，例如Integer类为intValue()。Why？因为运算是基本数据类型要做的事情。</li></ul><hr><p><strong>Integer 缓存数组相关</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//这里的low是-128，high是127</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="comment">// 这里说只要在-128~127这个返回，就会返回已经创建好的对象，这些对象就是存放在一个cache数组里面的。所以只要i是一样的，那么返回的对象也就是同一个。</span></span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 如果执行这一步，那么说明只能创建一个新的对象了，创建新对象，那么就表示所返回的地址肯定不一样啦！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>]; <span class="comment">//定于数组的大小</span></span><br><span class="line"><span class="keyword">int</span> j = low;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length ; k ++) <span class="comment">//每个数组存储了一个Integer对象，对象的values的范围就是-128~127</span></span><br><span class="line">    cache[k] = <span class="keyword">new</span> Integer(j ++);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是下列情况也会返回false，因为在cache范围内的，没有new的话，3是会直接指向创建好的对象（cache数组），</span></span><br><span class="line"><span class="comment">//而b  new了以后就是一个新对象。</span></span><br><span class="line">Integer a = <span class="number">3</span>;</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer();</span><br><span class="line">sout(a == b) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>机制:<strong>将类的各个组成部分封装成其他的对象。</strong></p><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</li></ul><p><strong>反射是框架设计的灵魂</strong></p><p>在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。</p><p><strong>spring反射实现:</strong></p><p>Spring 通过 XML 配置模式装载 Bean 的过程：</p><ol><li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li><li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li><li>使用反射机制，根据这个字符串获得某个类的Class实例</li><li>动态配置实例的属性</li></ol><p>Spring这样做的好处是：</p><ul><li>不用每一次都要在代码里面去new或者做其他的事情</li><li>以后要改的话直接改配置文件，代码维护起来就很方便了</li><li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现</li></ul><p>1、可以在程序运行中，操作这些对象。</p><p>2、可以解耦，提高程序的可扩展性。</p><h2 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a>对象创建的过程</h2><figure class="image-box">                <img src="image-20210317024116844.png" alt="image-20210317024116844" title class>                <p>image-20210317024116844</p>            </figure><p><strong>一、若该对象所属的类没有加载，则先执行类加载</strong></p><p><strong>二、创建对象</strong></p><p><strong>1、在堆区分配对象需要的内存</strong></p><p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p><p><strong>2、对所有实例变量赋默认值</strong></p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p><p><strong>3、执行实例初始化代码</strong></p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p><p><strong>4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</strong></p><p>需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问</p><p>补充：</p><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p><p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。</p><p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p><h2 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h2><p>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</p><p>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</p><p>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</p><p>short：16位，最<a href="http://lib.csdn.net/base/hadoop" target="_blank" rel="noopener">大数据</a>存储量是65536，数据范围是-32768~32767之间。</p><p>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</p><p>boolean：只有true和false两个取值。</p><p>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</p><p>char：16位，存储Unicode码，用单引号赋值。</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><strong>Collection：代表一组任意类型的对象，无下标、无序、不能重复。</strong></p><p><img src="1998506-20200830225616629-1434055405.png" alt="img"></p><p><strong>细节1：</strong></p><p>JDK1.7:ArrayList像饿汉式，直接创建一个初始容量为10的数组</p><p>JDK1.8:ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元 素时再创建一个始容量为10的数组</p><p><strong>细节2：</strong></p><p>ArrayList 源码中为何定义两个 Object 数组呢？EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 各有什么用处？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于默认大小的空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment"> * 我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时扩容多少。</span></span><br><span class="line"><span class="comment"> * MARK:无参构造函数 使用该数组初始化 与EMPTY_ELEMENTDATA的区别主要是区分作用，用来减少空数组的存在，优化内存使用 1.8后的优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这两个类常量EE和DEE都是表示空数组，只是名字不一样而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数为集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array. 这里</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下来看看add(E e)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当第一次调用add(E e)方法的时候，判读是不是无参构造函数创建的对象，如果是，</span></span><br><span class="line"><span class="comment">// 将DEFAULT_CAPACITY即10作为ArrayList的容量，此时minCapacity = 1</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他add方法如：add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)中都有ensureCapacityInternal(int minCapacity)方法，确保无参构成函数创建的实例al在添加第一个元素时，<em>最小的容量</em>是默认大小10。那有参构造函数创建的空实例al1、al2在通过add(E e)添加元素的时候是怎么样的呢？al1、al2容量增长是这样子的：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;6-&gt;9-&gt;13…，这样的增长是很慢的。具体扩容方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新容量为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：两个类常量都是表示空数组，为什么要用两个呢？在Java7中只有一个类常量表示空数组，就是EE。Java8中添加了DEE代替了EE。</p><p>在Java7中ArrayList的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                          initialCapacity);</span><br><span class="line">   <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   elementData = c.toArray();</span><br><span class="line">   size = elementData.length;</span><br><span class="line">   <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">   <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全就是DEE代替了EE。那EE干什么去了，看一下构造函数中EE安排在哪里了？都是在判断容量为空的情况下，赋值给elementData。Java7中如果容量是0的话，会创建一个空数组，赋值给elementData:<code>this.elementData = new Object[initialCapacity];</code>、<code>elementData = Arrays.copyOf(elementData, size, Object[].class);</code>。如果一个应用中有很多这样ArrayList空实例的话，就会有很多的空数组，无疑EE是为了优化性能，所有ArrayList空实例都指向同一个空数组。问题解决。</p><h2 id="ArraysList（基于动态数组实现）"><a href="#ArraysList（基于动态数组实现）" class="headerlink" title="ArraysList（基于动态数组实现）"></a><strong>ArraysList（基于动态数组实现）</strong></h2><blockquote><p>ArrayList的底层是基于一个动态数组实现的，LinkedList的底层是基于一个双向链表实现的，</p><p>ArrayList对象创建时有一个空参构造器还有一个给定数组容量的构造器，如果不规定数组容量，则默认是0。</p><p>当往数组里添加元素，数组容量将会变为10，数组元素数量超过了10，将会自动扩容，通过一个位运算将现在的容量右移一位再加上现在的容量，变成原数组的1.5倍，JDK1.7之前是1.5+1，然后创建一个新的数组，将原数组的复制进新数组，从而实现了动态扩容。</p><p>有一个细节是他的底层源码定义了两个空数组，一个是默认空数组，一个人创建对象时主动传0，也是空数组。</p><p>默认容量大小为10 （注意：集合中没有任何元素时，它的容量为0，添加一个元素以后，容量变成10，但数组size=1）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>扩容机制(每次扩容为原来的1.5倍)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//原来的数组大小加上 原来数组大小右移一位运算</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    <span class="comment">//将新数组复制</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用来存放元素的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure><p><strong>add()方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题四：ArrayList 的 add 操作如何优化？</strong></p><blockquote><p>扩容需要移动数据，非常影响性能。那么优化的重点就是尽量避免 ArrayList 内部进行内部扩容。对于add 操作，如果添加的元素个数已知，最好使用指定初始容量的构造方法创建 ArrayList 实例或者在添加元素之前执行ensureCapacity 方法确保有足够的容量来存放add 操作的元素。</p></blockquote><p><strong>为什么不取扩容固定容量呢？</strong><br>扩容的目的需要综合考虑这两种情况：</p><ol><li>扩容容量不能太小，防止频繁扩容，频繁申请内存空间 + 数组频繁复制</li><li>扩容容量不能太大，需要充分利用空间，避免浪费过多空间；</li></ol><p>而扩容固定容量，很难决定到底取多少值合适，取任何具体值都不太合适，因为所需数据量往往由数组的客户端在具体应用场景决定。</p><p>因为1.5 可以充分利用移位操作，减少浮点数或者运算时间和运算次数。</p><h2 id="LinkList（双向链表）"><a href="#LinkList（双向链表）" class="headerlink" title="LinkList（双向链表）"></a><strong>LinkList</strong>（双向链表）</h2><blockquote><p>LinkList是双向链表，链表的特点就是插入、删除操作时间复杂度为1，而查找的时间复制度为n。</p><p>增删速度相对于数组快，也不需要扩容操作，而查找、修改（需要先查找）速度相对慢一些。</p><p>LinkList也是非线程安全的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add()</strong></p><p>普通增加，就是在链表尾部添加数据。</p><p>可以看到源码，把 <strong>last</strong> 链表最后一个节点，先用 <strong>l</strong> 保存，然后 <strong>last</strong> 指向 <strong>newNode</strong> 新节点。</p><p>判断如果链表为空，那 <strong>first</strong> 头结点指向 <strong>newNode</strong>。</p><p>否则之前保存的最后一个节点 <strong>l</strong> 的 <strong>next</strong> 后指针指向 <strong>newNode</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeSet-有序不可重复"><a href="#TreeSet-有序不可重复" class="headerlink" title="TreeSet(有序不可重复)"></a>TreeSet(有序不可重复)</h2><p><strong>特点</strong></p><ul><li>基于排列顺序实现元素不重复</li><li>实现SortedSet接口，对集合元素自动排序</li><li>元素对象的类型必须实现<strong>Comparable接口</strong>，指定排序规则</li><li>通过<strong>CompareTo</strong>方法确定是否为重复元素</li></ul><p><strong>存储结构：红黑树</strong></p><p>创建集合 <code>TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;()</code></p><p>添加元素 <code>treeSet.add();</code></p><p>删除元素 <code>treeSet.remove();</code></p><p>遍历 1. 增强for 2. 迭代器</p><p>判断 <code>treeSet.contains();</code></p><p>补充：TreeSet集合的使用</p><p>Comparator 实现定制比较（比较器）</p><p>Comparable 可比较的</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>用于存储任意键值对（key - value）</p><p>键：无序、无下标、不允许重复（唯一）</p><p>值：无序、无下标、允许重复</p></blockquote><p><strong>Map的遍历</strong></p><p>得到一个Map的Key集合，装入Set集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 遍历</span></span><br><span class="line"><span class="comment">// 3.1 使用KeySet()</span></span><br><span class="line"><span class="comment">//Set&lt;String&gt; keyset = map.keySet(); // 所有Key的set集合</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keyset)&#123;</span><br><span class="line">  sout(key + <span class="string">"---"</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map.entrySet()遍历的效率更高，因为可以一次获取到键值对，而keySet拿到以后可以获取到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 使用entrySet()</span></span><br><span class="line"><span class="comment">//Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entries)&#123;</span><br><span class="line">  sout(entry.getKey() + <span class="string">"---"</span> + entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原码分析总结：</p><ol><li>HashMap刚创建时，table是null，节省空间，当添加第一个元素时，table容量调整为16</li><li>当元素个数大于阈值（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li><li>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64时，会调整成红黑树，目的是提高效率</li><li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li><li>jdk1.8 以前，链表时头插入，之后为尾插入</li></ol><h1 id="Hash大礼包"><a href="#Hash大礼包" class="headerlink" title="Hash大礼包"></a>Hash大礼包</h1><p><strong>源码分析总结：</strong></p><ol><li>HashMap刚创建时，table是null，节省空间，当添加第一个元素时，table容量调整为16</li><li>当元素个数大于阈值（16*0.75 = 12）时，会进行扩容，扩容后的大小为原来的两倍，目的是减少调整元素的个数</li><li><strong>jdk1.8 当每个链表长度 &gt;8 ，并且数组元素个数 ≥64时，会调整成红黑树，目的是提高效率</strong></li><li>jdk1.8 当链表长度 &lt;6 时 调整成链表</li><li>jdk1.8 以前，链表时头插入，之后为尾插入</li></ol><p><strong>负载因子</strong></p><p>Q：为什么负载因子是0.75？</p><blockquote><p>当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p></blockquote><p>jdk官方文档给出了一份计算结果：同一个哈希桶中哈希碰撞生成链表长度地概率。数据中哈希桶中有8个元素的概率低至0.000006%，所以0.75这个负载因子比较合适。</p><p><img src="v2-4e6b224503e39e90b9419946ba2f7166_720w.jpg" alt="img" style="zoom:67%;"></p><p><img src="v2-2936da1806372ffe26efa072de7da934_720w.jpg" alt="img" style="zoom:67%;"></p><h2 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h2><h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><p><img src="v2-f43eafe4e5d4d7616f885335fc185f3d_720w.jpg" alt="img" style="zoom:67%;"></p><h2 id="put方法流程"><a href="#put方法流程" class="headerlink" title="put方法流程"></a>put方法流程</h2><p>1.7：头插法</p><p>1.8：尾插法</p><p>Q：为什么1.8改成尾插法？因为1.8引入了红黑树，尾插法会遍历整个链表，顺带地知道当前链表长度，判断是否需要树化。</p><p><img src="v2-bb8ee0ee1c0cc51537ae5f8e02038102_720w.jpg" alt="img" style="zoom: 80%;"></p><p>多线程下HashMap put方法可能形成环形链表</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h2><blockquote><p>简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)</p></blockquote><p>Q：为什么要有红黑树？</p><p>红黑树的话是一个平衡搜索树，在大数据量下查找效率比单条的链表更高。链表需要遍历，红黑树采用的是二分查找的思想进行检索。</p><p><strong>特征：</strong></p><p>（1）每个节点只有两种颜色：红色和黑色。</p><p>（2）根节点是黑色的。</p><p>（3）每个叶子节点（NIL）都是黑色的空节点。</p><p>（4）从根节点到叶子节点，不会出现两个连续的红色节点。（<strong>红色的节点不能挨在一起</strong>）</p><p>（5）从任何一个节点出发，到叶子节点，这条路径上都有相同数目的黑色节点。</p><p><img src="image-20210327014042927.png" alt="image-20210327014042927" style="zoom:67%;"></p><p><strong>颜色变换规则</strong></p><p>旋转和变换规则：所有插入点默认为红色。</p><figure class="image-box">                <img src="image-20210328005814087.png" alt="image-20210328005814087" title class>                <p>image-20210328005814087</p>            </figure><p><strong>左旋规则</strong></p><figure class="image-box">                <img src="image-20210328005737527.png" alt="image-20210328005737527" title class>                <p>image-20210328005737527</p>            </figure><p><strong>右旋规则</strong></p><figure class="image-box">                <img src="image-20210328005635454.png" alt="image-20210328005635454" title class>                <p>image-20210328005635454</p>            </figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p> <strong>并发编程的三个重要特性</strong></p><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><p><strong>线程和进程的区别</strong></p><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p><strong>进程是一个可执行的程序，是系统资源分配的基本单位。</strong>线程是进程内部相对独立的可执行单元，是操作系统进行任务调度的基本单位。</p><p>java没有权限开启线程，通过本地方法调用c++，java无法直接操作硬件</p><p>并发（多线程操作同一个资源）</p><ul><li>CPU一核，模拟出来多个线程</li></ul><p>并行（多个线程可以同时执行）</p><ul><li><p>CPU多核，多个线程可以同时执行</p><p>一、进程的并行和并发</p><p><strong>并行:</strong> 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；（资源够用，比如三个线程，四核的CPU ）</p><p><strong>并发:</strong> 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路(单核CPU资源)同时只能过一个人，A走一段后，让给B，B用完继续给A ，交替使用，目的是提高效率。</p></li></ul><p>二、并行和并发的区别</p><p>   并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。</p><p>   并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个session。</p><hr><p><strong>创建线程的几种方法</strong></p><p>继承<strong>Thread类</strong>，重写run()方法，利用Thread.start()启动线程。</p><p>实现<strong>Runnable接口</strong>，重写run()方法，通过new Thread(Runnable a)创建线程，并调用start()方法启动线程。</p><p>通过<strong>callable</strong>和futuretask创建线程，实现callable接口，重写call方法，利用future对象包装callable实例，通过new Thread方法创建线程。</p><blockquote><p>和Runnable接口不一样，Callable接口提供了一个call()方法作为线程执行体，call()方法比run()方法功能要强大：call()方法可以有返回值，可以声明抛出异常。</p></blockquote><p>通过线程池创建线程。</p><hr><p><strong>多线程的优缺点</strong></p><p>优点：</p><ul><li>充分利用多核多cpu的资源，提高cpu的使用率，提高了程序的运行效率。</li></ul><p>缺点：</p><ul><li>线程数过多会影响性能，操作系统会在线程切换之间增加内存的开销。</li><li>存在线程同步和安全问题</li><li>可能产生死锁</li><li>增加了开发人员的技术难度</li></ul><hr><p><strong>线程有几种状态</strong></p><p>一共五种状态：分别是新建，就绪，运行，阻塞和死亡状态。详细见下图：</p><figure class="image-box">                <img src="d782ed346ccb4839bb148884b1745566~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li><strong>新建状态：</strong>当用new创建一个线程时，线程还没有开始运行，此时线程处于新建状态。处于新建状态的线程还没有开始运行。</li><li><strong>就绪状态：</strong>一个新建的线程并不会自动运行，要执行线程，要手动调用线程的start()方法，当start()方法返回后，线程就处于就绪状态，等待处理器的调度。</li><li><strong>运行状态：</strong>当线程获取了CPU的时间后，它才进入运行状态，真正的执行run()方法里的内容。</li><li><strong>阻塞状态：</strong>线程运行过程中，可能因为各种原因进入阻塞状态：比如调用sleep()进入休眠状态；调用一个在IO上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；等待获取锁被阻塞；线程在等待其他的触发条件。所谓的阻塞状态就是正在运行的线程没有运行结束，暂时让出CPU资源。</li><li><strong>死亡状态：</strong>有两个原因会导致线程死亡：run()方法正常结束；一个未捕获的异常终止了run()方法而导致线程猝死。</li></ul><hr><p><strong>经典题：一个线程OOM了，其他线程是否还能运行？</strong></p><p>答案是还能运行。虽然说堆是线程共享的区域，一个线程堆抛出OOM异常，你可能会觉得其他线程也会抛出OOM异常。但其实不然，<strong>当一个线程抛出OOM异常后，它所占据的内存会全部释放掉</strong>，从而不会影响其他线程的运行。 另外如果主线程异常了，子线程还能运行吗？这个问题也是可以运行的。线程不像进程，一个进程之间的线程之间是没有父子之分的，都是平级关系。即线程都是一样的，退出了一个不会影响另外一个。</p><p><strong>sleep和wait方法的区别？</strong></p><ul><li>wait只能在synchronized中调用，属于对象级别的方法，sleep不需要，属于Thread的方法</li><li>调用wait方法会释放锁，sleep不会释放锁</li><li>wait超时之后线程进入就绪状态，等待获取cpu继续执行。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p><blockquote><p>volatile作用是在并发编程中保证共享变量的可见性，同时防止这个JVM指令重排。每个线程在运行过程中都有自己的工作内存。因为JMM模型主要是是线程各自的工作内存和主内存。线程运行的时候会将主内存的变量读到工作内存，修改完毕后再写入主存。</p><p>volatile关键字修饰的变量值一经修改会立即写入主存，假设有AB两个线程，并且B线程操作volatile修饰的变量的时候，会导致A线程工作内存中的缓存volatile变量无效，A线程发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值，从而保证他的可见性。其中涉及到CPU总线嗅探机制和缓存一致性协议。工作内存和主存之间有一个总线，总线相当于工作内存和主存数据传输的主干道，当其中一个工作内存中的值被修改了并且写回内存以后，其他处理器会被通知，使得各自的缓存失效，线程就必须从主存中去读取最新的数据。</p><p>volatile第二个呢就是防止JVM指令重排，因为对程序的优化，JVM和CPU会对指令进行重新排序，但不会影响最后的结算结果，如果指令中有对volatile变量进行操作的指令，那么这条指令相当于一个内存屏障，在它之前的指令和在他之后的指令不允许交换位置，保证到达这条指令前，在他之前的指令已经全部完成。</p></blockquote><p>那么线程A在运行的时候，会将变量的值拷贝一份放在自己的工作内存当中。</p><p>那么当线程B更改了变量的值之后，但是还没来得及写入主存当中，线程B转去做其他事情了，那么线程A由于不知道线程B对变量的更改，因此还会一直循环下去。</p><p><strong>volatile的实现原理</strong></p><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内部的数据读到内部缓存后在进行操作，但操作完之后不知道什么时候会写入内存。</p><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条<strong>Lock前缀的指令</strong>，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p><p><strong>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏</strong>），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><hr><p><strong>指令重排</strong></p><p>Q：为什么产生指令重排？ CUP的乱序执行</p><p>编译器：不进行指令重排</p><p>运行期：DCL（懒汉式双重锁检验）+volatile</p><p><strong>内存屏障</strong></p><p><strong>happens-before</strong></p><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条<strong>Lock前缀的指令</strong>，将这个变量所在缓存行的数据写会到系统内存。</p><p><strong>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏</strong>），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p><figure class="image-box">                <img src="image-20210317010023428.png" alt="image-20210317010023428" title class>                <p>image-20210317010023428</p>            </figure><p>Java内存模型 (JMM)</p><p><img src="image-20210314184754409.png" alt="image-20210314184754409" style="zoom: 67%;"></p><p><strong>总线嗅探机制+缓存一致性协议</strong></p><figure class="image-box">                <img src="1472972-20200710225123177-483858511.png" alt="img" title class>                <p>img</p>            </figure><p>工作内存 = <strong>虚拟机栈</strong>    主内存 = 堆+ 方法区</p><p><img src="image-20210314185428706.png" alt="image-20210314185428706"></p><p>volatileの读：每一次都从<strong>主存</strong>中获取数据，然后写入<strong>虚拟机栈（工作内存）</strong> read-load</p><p>volatileの写：</p><p><img src="image-20210314190329333.png" alt="image-20210314190329333" style="zoom: 67%;"></p><p>线程和主存之间存在一条总线，加入关键字以后机会<strong>缓存一致性协议</strong>，监听共享变量。</p><p>DCL双重锁校验</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p> 并发编程的三个重要特性</p><ol><li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong> ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li></ol><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h3><p>对synchronized的理解?</p><blockquote><p>synchronized在jdk1.6属于Java中的重量级锁，同时也是一种互斥锁，重量级锁是因为需要依靠操作系统来实现互斥锁的，这导致大量上下文切换，消耗大量CPU，影响性能。在JDK1.6以后逐步地对sychronized进行了优化，加入了锁升级的机制，从而不用每次调用sychronized都直接上重量级锁。sychronized的实现依靠的每个对象头中的 mark word的所指向的monitor，monitor中从存储了关联对象的owner、waitSet和EntryList，当A线程竞争</p></blockquote><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有几个关键字段：</p><p><strong>_owner：</strong>指向持有ObjectMonitor对象的线程<br><strong>_WaitSet：</strong>存放处于wait状态的线程队列<br><strong>_EntryList：</strong>存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p><p><strong>Synchronized 的具体用法</strong></p><table><thead><tr><th>修饰位置</th><th>上锁对象</th></tr></thead><tbody><tr><td>普通方法/this关键字</td><td>该类的实例对象</td></tr><tr><td>同步代码块/.class</td><td>整个类对象</td></tr></tbody></table><ul><li><strong>Synchronized修饰普通方法时，锁对象默认为this,锁住的是该类的实例对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Synchronized修饰静态方法时，锁住的类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testStaticMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>同步代码块,this时，锁住的是类的实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>同步代码块，Demo.class,锁住的是类对象</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Demo<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Synchroinzed 锁的实现原理</strong>、</p><p>每个对象的对象头中有一个字段指向monitor对象，这个monitor是每个对象都有的。</p><p><img src="e691866125e34425820f025eb56b5c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="对象头" style="zoom:33%;"></p><p><strong>mark word</strong></p><p><img src="b75c46c4d41d40a89035a90eb6f2716d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" style="zoom: 33%;"></p><blockquote><p>biased_lock：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。<br><strong>age：</strong>4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为15的原因。<br><strong>identity_hashcode：</strong>25位的对象标识Hash码，采用延迟加载技术。调用<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。<br><strong>thread：</strong>持有偏向锁的线程ID。<br>epoch：偏向时间戳。<br>ptr_to_lock_record：指向栈中锁记录的指针。<br><strong>ptr_to_heavyweight_monitor：</strong>指向管程Monitor的指针。</p></blockquote><p>Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。 monitor 对象由 C++ 实现。其中有几个关键字段：</p><p><strong>_owner：</strong>指向持有ObjectMonitor对象的线程<br><strong>_WaitSet：</strong>存放处于wait状态的线程队列<br><strong>_EntryList：</strong>存放处于等待锁block状态的线程队列<br>_recursions：锁的重入次数<br>_count：用来记录该线程获取锁的次数</p><p><strong>JVM 对 synchronized 的处理</strong><br>上面了解了 monitor 的机制，那虚拟机是如何将 synchronized 和 monitor 关联起来的呢？分两种情况：<br>如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。<br>如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//反编译后的结果</span></span><br><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header = <span class="literal">NULL</span>;</span><br><span class="line">  _count = <span class="number">0</span>; <span class="comment">// 线程获取锁的次数</span></span><br><span class="line">  _waiters = <span class="number">0</span>,</span><br><span class="line">  _recursions = <span class="number">0</span>; <span class="comment">// 递归，锁的重入次数</span></span><br><span class="line">  _object = <span class="literal">NULL</span>;</span><br><span class="line">  _owner = <span class="literal">NULL</span>;   <span class="comment">// 持有monitor的线程</span></span><br><span class="line">  _WaitSet = <span class="literal">NULL</span>; <span class="comment">// 处于 wait 状态, 即等待monitor的线程，会被加入到 _WaitSet</span></span><br><span class="line">  _WaitSetLock = <span class="number">0</span> ; <span class="comment">// 自旋</span></span><br><span class="line">   _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   _succ = <span class="literal">NULL</span> ;</span><br><span class="line">   _cxq = <span class="literal">NULL</span> ;</span><br><span class="line">   FreeNext = <span class="literal">NULL</span> ;</span><br><span class="line">   _EntryList = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">   _SpinFreq = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>如图所示 [<figure class="image-box">                <img src="https://imgchr.com/i/y4j5pF" alt="y4j5pF.jpg](872e78995be24c90b4e8d8aafdf89360~tplv-k3u1fbpfcp-zoom-1.image)" title class>                <p>y4j5pF.jpg](872e78995be24c90b4e8d8aafdf89360~tplv-k3u1fbpfcp-zoom-1.image)</p>            </figure></strong></p><ol><li><strong>当Thread1、Thread2访问同步代码块时Thread1,Thread2会先进入ObjectMonitor的EntryList中等待；</strong></li><li><strong>接下来当Thread1获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，Thread1申请 Mutex 成功，则持 有该 Mutex，其它线程将无法获取到该 Mutex。ObjectMonitor的owner属性指向Thread1，EntryList中还剩Thread2在等待</strong></li><li><strong>如果Thread1调用了wait()方法，就会释放当前持有的 Mutex，Thread1进入WaitSet并释放锁，ObjectMonitor的owner属性等于null。</strong></li></ol><p><strong>如果Thread1执行完毕，也会释放所持有的Mutex。 4. Thread2获取到锁进入同步代码块，ObjectMonitor owner属性指向Thread2，任务执行完退出同步代码之前调用notifyAll， Thread1被唤醒，从WaitSet转到EntryList中等待锁，Thread2退出同步代码块，ObjectMonitor owner属性为null；</strong></p><p><strong>所以，Monitor依赖操作系统实现，存在用户态和内核态的切换，增加了性能开销。</strong></p><p><strong>说说 synchronized 关键字和 volatile 关键字的区别</strong></p><p><strong><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</strong></p><ul><li><strong>volatile 关键字是线程同步的轻量级实现，所以volatile 性能肯定比 synchronized 关键字要好。但是volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块。</strong></li><li><strong>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</strong></li><li><strong>volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h3><blockquote><p>    <strong>CAS属于乐观锁，乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</strong></p></blockquote><p><strong>原理：</strong></p><p><strong>CAS全称是Compare and Swap，即比较并交换，是通过原子指令来实现多线程的同步功能，将获取存储在内存地址的原值和指定的内存地址进行比较，只有当他们相等时，交换指定的预期值和内存中的值，这个操作是原子操作，若不相等，则重新获取存储在内存地址的原值。</strong></p><hr><p><strong>CAS的流程</strong></p><p>     <strong>CAS是一种无锁算法，有3个关键操作数，内存地址，旧的内存中预期值，要更新的新值，当内存值和旧的内存中预期值相等时，将内存中的值更新为新值。</strong></p><p><strong>首先看一看AtomicInteger当中常用的自增方法 incrementAndGet：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这段代码是一个无限循环，也就是CAS的自旋。循环体当中做了三件事：</span><br><span class="line"><span class="number">1</span>.获取当前值。</span><br><span class="line"><span class="number">2</span>.当前值+<span class="number">1</span>，计算出目标值。</span><br><span class="line"><span class="number">3</span>.进行CAS操作，如果成功则跳出循环，如果失败则重复上述步骤。</span><br></pre></td></tr></table></figure><p><strong>那CAS有什么缺陷吗？</strong></p><p><strong>我：CAS虽然高效的解决了原子问题，但是还是存在一些缺陷的，主要体现在三个方面：</strong><br> <strong>1、循环时间太长：如果自旋CAS长时间不成功，则会给CPU带来非常大的开销，在JUC中，有些地方就会限制CAS自旋的次数。</strong><br> <strong>2、只能保证一个共享变量原子操作：看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了。或者把多个变量整成一个变量也可以用CAS。</strong><br> <strong>3、ABA问题：CAS需要检查操作值有没有发生改变，如果没有发生改变则更新，但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题的解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A-&gt;B-&gt;A，变成1A-&gt;2B-&gt;3A。例如原子类中AtomicInteger会发生ABA问题，使用AtomicStampedReference可以解决ABA问题。</strong></p><p><strong>PS：总结1、长时间自旋不成功，会给CPU带来非常大的开销。</strong></p><p><strong>2、只能保证一个共享变量的原子操作，多个共享变量需要用到锁。</strong></p><p><strong>3、ABA问题：CAS对操作的值进行检查，检查它是否有被修改过。但有这么一种情况，它被别的县城改过了，但是又改回去了，此时依旧当前线程的期望值，但是实质上它被改动过了。这样就对当前线程造成了一种欺骗。用AtomicStampedReference可以解决ABA为题（即在变量上加上一个版本号）</strong></p><hr><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><blockquote><p><em>其实一句话总结：<strong>AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。</strong></em></p><p><strong><em>它包含了state变量、加锁线程、等待队列等并发中的核心组件。</em></strong></p></blockquote><p><strong>AQS 全称 AbstractQueuedSynchronizer。AQS 中有两个重要的成员：</strong><br><strong>成员变量 state。用于表示锁现在的状态，用 volatile 修饰，保证内存一致性。同时所用对 state 的操作都是使用 CAS 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。</strong><br><strong>还有一个双向链表，链表除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。</strong><br><strong>下面以 ReentrantLock 非公平锁的代码看看 AQS 的原理。</strong></p><p><strong>AbstractQueuedSynchronizer，抽象队列同步器</strong></p><p>如图：</p><p>ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。</p><figure class="image-box">                <img src="v2-d8386b404a820482d3080939e434d4a9_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>1、当线程1 CAS成功获取锁时</strong></p><figure class="image-box">                <img src="v2-f5d569e61d5aef81ab00f43c19586dd2_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>2、线程2来尝试获取锁 调用tryAcquire（CAS原理）（尝试将state=0变为1） 原理CAS  发现state并不等于0</strong></p><figure class="image-box">                <img src="v2-3985f7789b288baa2ac33091f2361d35_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>3、加锁失败，线程2进入等待队列</strong> 【队列是AQS内部的队列，专门存放获取锁失败的线程】</p><figure class="image-box">                <img src="v2-649ab6887475f84e6951469136b788e7_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！<strong>他释放锁的过程非常的简单</strong>，就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将“加锁线程”变量也设置为null！</p><p><strong>CLH队列</strong></p><p>QS通过内置的FIFO(first-in-first-out)同步队列来控制获取共享资源的线程。CLH队列是FIFO的双端双向队列，AQS的同步机制就是依靠这个CLH队列完成的。队列的每个节点，都有前驱节点指针和后继节点指针。</p><blockquote><p><strong>头结点并不在阻塞队列内！</strong></p></blockquote><figure class="image-box">                <img src="16f922162108de3b" alt="AQS-Node.jpg" title class>                <p>AQS-Node.jpg</p>            </figure><hr><h3 id="ReentrantLock-Lock锁"><a href="#ReentrantLock-Lock锁" class="headerlink" title="ReentrantLock Lock锁"></a>ReentrantLock <strong>Lock锁</strong></h3><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h3><p><strong>对象的组成</strong></p><p><strong><figure class="image-box">                <img src="e691866125e34425820f025eb56b5c4b~tplv-k3u1fbpfcp-zoom-1.image" alt="对象头" title class>                <p>对象头</p>            </figure></strong></p><p> <strong>实例变量</strong></p><p>  <strong>即实例数据。存放类的属性数据信息，包括父类的属性信息。</strong></p><p><strong>对其填充why?</strong></p><p> <strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。   如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></p><p><strong>对象头中数据（mark word 和 类型指针 组成）</strong></p><p><strong>mark word</strong></p><p> <strong>即标记字段。用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。   Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit</strong></p><p><strong><figure class="image-box">                <img src="b75c46c4d41d40a89035a90eb6f2716d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述" title class>                <p>在这里插入图片描述</p>            </figure></strong></p><p><strong>锁升级的过程</strong></p><blockquote><p><strong>synchronized锁有四种状态，无锁，偏向锁，轻量级锁，重量级锁</strong></p><p><strong>无锁，偏向锁，轻量级锁（CAS）都是在用户空间完成</strong></p><p><strong>重量级锁是需要向内核申请的</strong></p></blockquote><p><strong>当线程A启动后，获得了对象的锁，此时线程A的线程ID将保存到对象的对象头中，对象头中的偏向锁标志位变为1。此时如果第二个线程B想访问这个对象，线程A、B之间就存在一个竞争的关系，但是此时偏向锁是偏向于线程A的，即A是优先的，偏向锁将会升级为轻量级锁，以此来保证持有对象锁的的线程A运行。此时线程B将会进行CAS，CAS也叫做自旋锁，B会去检查对象的锁是否还是属于A的，如果是，那B将会继续自选，直到对象锁被释放，B马上就会获取对象的锁。但是假如长时间无法获取到对象的锁，CAS是会消耗CPU的性能的，尤其当许多个线程竞争同一个对象的锁时，CPU资源占用会大大提高，此时锁将会再次升级，对象锁将升级为重量级锁。此时，所有竞争的线程将进入阻塞队列，等待cup的调度。</strong></p><p><strong><figure class="image-box">                <img src="image-20210313015823511.png" alt="image-20210313015823511" title class>                <p>image-20210313015823511</p>            </figure></strong></p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title=".公平锁 VS 非公平锁"></a><strong>.公平锁 VS 非公平锁</strong></h3><blockquote><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p></blockquote><p><strong>公平锁：tryAcquire（）</strong>:</p><p>//假如tryacquire方法返回true表示为获取锁成功,&amp;&amp; 后面的表达式不会执行</p><p>//假如tryAcqyire方法返回false表示获取锁失败,进入等待队列并执行selfInterrupt() 中断当前线程</p><p><strong>hasQueuedPredecessors（）</strong>：判断队列中是否存在等待的线程</p><blockquote><p><code>hasQueuedPredecessors</code>就是<strong>判断锁是否公平的关键</strong>，如果在当前线程之前还有排队的线程就返回true，这时候当前线程就不会去竞争锁。从而保证了锁的公平性。</p></blockquote><figure class="image-box">                <img src="image-20210316020031393.png" alt="image-20210316020031393" title class>                <p>image-20210316020031393</p>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;<span class="comment">//这个方法是父类AQS的方法    acquire(1);&#125;public final void acquire(int arg) &#123;//上面有提过 tryAcquire 方法,尝试获取锁,需要子类实现    //当前类为FairSync 所以调用的 FairSync.tryAcquire 方法    //假如tryacquire方法返回true表示为获取锁成功,&amp;&amp; 后面的表达式不会执行    //假如tryAcqyire方法返回false表示获取锁失败,进入等待队列并执行selfInterrupt 中断当前线程    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();&#125;// java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire(int) 参数值为1protected final boolean tryAcquire(int acquires) &#123;//获取当前线程        final Thread current = Thread.currentThread();        //获取AQS.state的值,state 就是用来判断是否存在线程获取到锁        int c = getState();        //假如为0 表示 现在没有线程获取到锁        if (c == 0) &#123;        //hasQueuedPredecessors 方法 判断等待队列中是否存在 等待的线程 (因为是公平锁)            //compareAndSetState CAS 操作设置 state 的值            //setExclusiveOwnerThread 设置当前获取锁的线程为 当前线程           //所以  这个 if 中的表达式的意思 是:             //等待队列中没有线程在等待 并 CAS 操作成功 并且设置线程成功 则返回 true  表示获取锁成功            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        // 假如 state 的值不为 0 表示存在线程争取这个锁        //判断争取到锁的线程是否当前线程 (可重入锁)        else if (current == getExclusiveOwnerThread()) &#123;        // 假如是 累加 state的值,表示重入次数            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error("Maximum lock count exceeded");            setState(nextc);            return true;        &#125;        return false;    &#125;</span></span><br></pre></td></tr></table></figure><h3 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h3><p>可重入锁的字面意思是“可以重新进入的锁”，即<strong>允许同一个线程多次获取同一把锁</strong>。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是<strong>可重入锁</strong>（因为这个原因可重入锁也叫做<strong>递归锁</strong>）<strong>。</strong></p><p>Java里只要以Reentrant开头命名的锁都是可重入锁，而且<strong>JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。</strong></p><p>getExclusiveOwnerThread()：获取线程当前专属拥有者</p><p><strong>run和start()的区别：</strong></p><blockquote><p><strong>run 方法是执行任务的地方，它就是一个普通的方法，可以多次被调用，只调用 run 方法并不会启动一个线程。而 start 方法才会真正的启动线程，start 方法会调用到 native 底层方法，然后才会调用 run 方法执行任务。start 方法只能执行一次，执行多次会抛出异常。</strong></p></blockquote><p><strong>为什么要有锁升级这个过程呢？</strong></p><blockquote><p><strong>那为什么不直接上来就上<code>轻量级锁</code>或者<code>重量级锁</code>呢？</strong><br><strong>这是因为当线程执行到被锁住的代码块时，锁的获取是会消耗资源的。<code>轻量级锁</code>的实现原理是<code>CAS自旋</code>，就像while loop 一样，消耗CPU资源。<code>重量级锁</code>需要<code>操作系统</code>的<code>调度机制</code>接入，也会消耗资源。而大部分时候只有一个线程默默的干活，并不存在锁竞争，每次这个孤单的线程执行一块上了轻量级锁锁住的代码时需要过一遍CAS，执行一块重量级锁锁住的代码时需要等操作系统的发令，自己和自己竞争一下，这效率就有点低了。</strong><br><strong>当一个对象还没有上锁时，<code>偏向锁</code>会直接来往markword里贴上线程ID，表示锁住了，没有CAS自旋和操作系统调用这些耗时的锁竞争机制，提高了性能。 偏向锁假定了这对象还没锁，所以偏向锁又叫做<code>乐观锁</code>。</strong></p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h2><p><strong>什么叫死锁？</strong></p><p><strong>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象。若无外力作用，他们都将无法进行运行下去。</strong></p><p><strong>死锁产生的必要条件</strong></p><ul><li><strong>互斥条件：进程要求对所分配的资源在一段时间内只能由一个进程所拥有。</strong></li><li><strong>不可剥夺条件：资源在进程未使用完成之前，不能被其他进程夺走，除非是主动释放。</strong></li><li><strong>请求和保持条件：进程已经保持了至少一个资源，但是又申请新的资源，但是该资源已经被其他进程所拥有，这就陷入了死循环。</strong></li><li><strong>循环等待条件：总的来说，就是进程资源循环等待，A拥有资源1，B拥有资源2，同时A在没有释放资源1的情况下又去申请资源2，B在没有释放资源2的情况下又去申请资源1。</strong></li></ul><p><strong>如何避免死锁</strong></p><ul><li><strong>加锁顺序要合理：线程要按照一定的顺序加锁</strong></li><li><strong>加锁时限要适当：线程尝试获取锁的时候要加上一定时限，超时就要放弃锁请求，并释放自己占有的锁。不能无限等待。</strong></li><li><strong>死锁检测</strong></li></ul><p><strong>细节</strong></p><p>死锁排查</p><h2 id="ArrayBlockingQueue（阻塞队列）"><a href="#ArrayBlockingQueue（阻塞队列）" class="headerlink" title="ArrayBlockingQueue（阻塞队列）"></a><strong>ArrayBlockingQueue</strong>（阻塞队列）</h2><p><strong><figure class="image-box">                <img src="image-20210313044739282.png" alt="image-20210313044739282" title class>                <p>image-20210313044739282</p>            </figure></strong></p><p><img src="e5bdc645374f436fbccf86ffecd2e149~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p><strong>SynchronousQueue：同步队列</strong></p><p>不存储元素put元素以后必须take取出来，否则不能put进去元素。</p><p>任意时间只能一个线程操作。</p><h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>Semaphore又称信号量，是操作系统中的一个概念，在Java并发编程中，<strong>信号量控制的是线程并发的数量</strong>。</p><p>public Semaphore(int permits)<br> 其中参数permits就是允许同时运行的线程数目;</p><p>Semaphore是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。如果计数器值为0,线程进入休眠。当某个线程使用完共享资源后，释放信号量，并将信号量内部的计数器加1，之前进入休眠的线程将被唤醒并再次试图获得信号量。</p><p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即是获取Semaphore、共享资源使用完毕后释放Semaphore</p><p>主要有acquire()、release()这两个方法</p><p><strong>acquire()：</strong>当前线程调用该方法的目的是希望获取一个信号量资源。如果当前信号量个数大于0,则当前信号量的计数会减1，然后该方法直接返回。<strong>否则如果当前信号量个数等0，则当前线程会被放入AQS的阻塞队列</strong>。</p><p><strong>release()</strong>：<strong>该方法的作用是把当前Semaphore对象的信号量值增加1</strong>，如果当前有线程因为调用aquire方法被阻塞而被放入了AQS的阻塞 队列，则会根据公平策略选择一个信号量个数能被满足的线程进行激活， 激活的线程会尝试获取刚增加的信号量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量法 ：3线程交替打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建3个信号量</span></span><br><span class="line"><span class="comment">//semaphore1持有【1】个信号量</span></span><br><span class="line">Semaphore semaphore1 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//semaphore2持有【0】个信号量</span></span><br><span class="line">Semaphore semaphore2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//semaphore3持有【0】个信号量</span></span><br><span class="line">Semaphore semaphore3 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore1信号量-1</span></span><br><span class="line">            semaphore1.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore2信号量+1 release():该方法的作用是把当前Semaphore对象的信号量值增加1</span></span><br><span class="line">            semaphore2.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore2信号量-1</span></span><br><span class="line">            semaphore2.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore3信号量+1</span></span><br><span class="line">            semaphore3.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//semaphore3信号量-1</span></span><br><span class="line">            semaphore3.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//semaphore1信号量+1</span></span><br><span class="line">            semaphore1.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>为了避免系统频繁的创建和销毁线程，我们可以让创建的线程复用。我们可以使用一个线程池维护一些线程，当你需要使用线程的时候，可以从池子中随便拿一个空闲线程，当完成工作时，并不急着关闭线程，而是将这些线程退回到线程池中，方便下次使用。</p><p>简而言之，再使用线程池后，创建线程编程了从线程池中获得空闲线程，关闭线程变为想线程池归还线程。</p><h3 id="3大创建线程池的方法："><a href="#3大创建线程池的方法：" class="headerlink" title="3大创建线程池的方法："></a>3大创建线程池的方法：</h3><p>//可伸缩线程池<br>ExecutorService threadPool1 = Executors.newCachedThreadPool();<br>//单个线程池<br>ExecutorService threadPool2 = Executors.newSingleThreadExecutor();<br>//固定数量线程池  7个<br>ExecutorService threadPool3 = Executors.newFixedThreadPool(11);</p><p><img src="image-20210315024654123.png" alt="image-20210315024654123"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可伸缩线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="comment">//最小为0个，最大为2的31次方个，OOM风险</span></span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单个线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//固定数量线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上3个源码的本质</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程池大小</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//最大核心线程池大小  最多可同时处理的线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//超时释放时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//超时时长</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//阻塞队列  等待队列长度</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;<span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);<span class="comment">//线程工厂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大核心线程池如何确定？</p><p><strong>int maximumPoolSize,//最大核心线程池大小：</strong></p><p><strong>CPU 密集型任务(N+1)：</strong></p><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比x CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p><p><strong>I/O 密集型任务(2N)：</strong></p><p>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取CUP的核数System.out.println(Runtime.getRuntime().availableProcessors());//4</span></span><br></pre></td></tr></table></figure><h3 id="7大ThreadPoolExecutor常用参数"><a href="#7大ThreadPoolExecutor常用参数" class="headerlink" title="7大ThreadPoolExecutor常用参数"></a><strong>7大ThreadPoolExecutor常用参数</strong></h3><p><strong>1. corePoolSize ：核心线程线程数</strong></p><p>定义了最小可以同时运行的线程数量。</p><p><strong>2. maximumPoolSize ：最大线程数</strong></p><p>当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量会扩大到最大线程数。</p><p><strong>3. keepAliveTime ：等待时间</strong></p><p>当线程数大于核心线程数时，多余的空闲线程存活的最长时间。</p><p><strong>4. unit ：时间单位。</strong></p><p>keepAliveTime 参数的时间单位，包括 <code>TimeUnit.SECONDS</code>、<code>TimeUnit.MINUTES</code>、<code>TimeUnit.HOURS</code>、<code>TimeUnit.DAYS</code> 等等。</p><p><strong>5. workQueue ：任务队列</strong></p><p>任务队列，用来储存等待执行任务的队列。</p><p><strong>6. threadFactory ：线程工厂</strong></p><p>线程工厂，用来创建线程，一般默认即可。</p><p><strong>7. handler ：拒绝策略</strong></p><h3 id="4大拒绝策略"><a href="#4大拒绝策略" class="headerlink" title="4大拒绝策略"></a><strong>4大拒绝策略</strong></h3><p><strong>ThreadPoolExecutor.AbortPolicy：</strong> 抛出 <code>RejectedExecutionException</code>  来拒绝新任务的处理，是 Spring 中使用的默认拒绝策略。</p><p><strong>ThreadPoolExecutor.CallerRunsPolicy：</strong> 线程调用运行该任务的 <code>execute</code> 本身，也就是直接在调用 <code>execute</code> 方法的线程中运行 (<code>run</code>) 被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度，但可能造成延迟。若应用程序可以承受此延迟且不能丢弃任何一个任务请求，可以选择这个策略。</p><p><strong>ThreadPoolExecutor.DiscardPolicy：</strong> 不处理新任务，直接丢弃掉。</p><p><strong>ThreadPoolExecutor.DiscardOldestPolicy：</strong> 此策略将丢弃最早的未处理的任务请求</p><p><img src="image-20210317214636190.png" alt="image-20210317214636190"></p><h2 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h2><p>ThreadLocal是一个线程内部的数据存储类，可以在指定线程中存储数据，且只有在该指定线程中才可以获取存储数据。</p><ul><li>ThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组 table。</li><li><p>ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置。</p><p><strong>作用</strong></p></li><li><p>线程隔离：提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用。</p></li><li>传递数据：减少同一个线程内多个函数或组件之间一些公共变量传递的复杂度。</li></ul><p><strong>使用场景</strong></p><p><strong>某个数据是以线程为作用域且不同线程具有不同的 Lopper</strong></p><p>如果不采取 ThreadLocal，那么系统就必须提供一个全局的哈希表来 Handler 查找指定线程的 Lopper，这样一来就必须提供一个类似于 LooperManager 的类。</p><p><strong>复杂逻辑下的对象传递（如监听器的传递）</strong></p><p>有时一个线程中的任务过于复杂，可能表现为函数调用栈比较深以及代码入口的多样性，这时又要监听器能够贯穿整个线程的执行过程。</p><p>如果采用 ThreadLocal 可以让监听器作为线程内的全局对象而存在，在线程内部只要通过 get 方法就可以获取监听器。</p><p>如果不采取 ThreadLocal，就只能采用另外两种办法：</p><ul><li>讲监听器作为参数的形式在函数调用栈中传递：函数调用栈越深，越容易混乱。</li><li>将监听器作为静态变量供线程访问：不具有可扩展性，有几个线程在调用，就要提供几个静态监听器对象。</li></ul><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Boolean 类型的 ThreadLocal 对象</span></span><br><span class="line">ThreadLocal&lt;Boolean&gt; mBooleanThread = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class="line">mBooleanThread.set(<span class="keyword">true</span>);  <span class="comment">// 主线程中设置为 true</span></span><br><span class="line">mBooleanThread.get();      <span class="comment">// 主线程中获取为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread #1"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBooleanThread.set(<span class="keyword">false</span>);  <span class="comment">// 子线程1中设置为 false</span></span><br><span class="line">        mBooleanThread.get();       <span class="comment">// 子线程1中获取为 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"Thread #2"</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;             <span class="comment">// 子线程2中不去设置</span></span><br><span class="line">        mBooleanThread.get();       <span class="comment">// 子线程2中获取为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从 ThreadLocal 的 <code>set()</code> 和 <code>get()</code> 方法可以看出，他们所操作的对象都是当前线程的 localValues 对象和 table 数组，因此在不同线程中访问同一个 ThreadLocal 的 <code>set()</code> 和 <code>get()</code> 方法，它们对 ThreadLocal 所做的读写操作仅限于各自内部，这就是为什么 ThreadLocal 可以在多个线程找那个互不干扰的存储和修改数据。</p><hr><p> <strong>早期方案</strong></p><p>每个 ThreadLocal 都创建一个 ThreadLocalMap，用 Thread 作为 Map 的key，要存储的局部变量作为 Map 的 value。</p><figure class="image-box">                <img src="a4abc3c4e8ea435fbcf522511d461014~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><p><strong>JAVA 8 方案</strong></p><p>每个 Thread 维护一个 ThreadLocalMap，用 ThreadLocal 实例本身 Map 的 key，要存储的局部变量作为 Map 的 value。</p><ul><li>每个 Thread 线程内部都有一 个Map（ThreadLocalMap）</li><li>Map 里面存储 ThreadLocal 对象（ key）和线程的变量副本（value）</li><li>Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 map 获取和设置线程的变量值。</li><li>对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><figure class="image-box">                <img src="3f17325a42a1439d8eb008f8623794d1~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><p><strong>【优点】</strong></p><ul><li>每个Map所存储的元素数量变少了。</li><li>当Thread销毁时，ThreadLocalMap也被销毁，减少内存。</li></ul><p><strong>ThreadLocal 核心方法源码</strong></p><table><thead><tr><th><strong>方法声明</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>protected T initialValue()</td><td>返回当前线程局部变量的初始值</td></tr><tr><td>public void set(T value)</td><td>设置当前线程绑定的局部变量</td></tr><tr><td>public T get()</td><td>获取当前线程绑定的局部变量</td></tr><tr><td>public void remove()</td><td>移除当前线程绑定的局部变量</td></tr></tbody></table><p><strong>set 方法</strong></p><p>先获取当前线程的 ThreadLocalMap 变量，如果存在则设置值，不存在则创建并设置值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前线程绑定的局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取此线程对象所维护的ThreadLocalMap对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// map不为空，则设置或更新值</span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// map 为空，则为线程t创建一个ThreadLocalMap对象，并把value存放其中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程所维护的ThreadLocalMap对象</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为线程创建一个ThreadLocalMap对象，并赋予初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this是调用此方法的ThreadLocal对象</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>ThreadLocal 内存泄漏</strong></p><p><strong>当key是强引用</strong></p><p>ThreadLocalMap 中的 key 使用了强引用，会导致 threadLocal 和 value 出现内存泄漏。</p><figure class="image-box">                <img src="16a8dd89547242e08e21af965c6ea9c3~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li>假设在业务代码中使完 ThreadLocal，threadLocalRef被回收了。</li><li>由于 threadLocalMap 的 Entry 强引用了 threadLocal，造成 threadLocal 无法被回收。</li><li>在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，始终有引用链 threadRef -&gt; currentThread -&gt; threadLocalMap -&gt; entry，Entry就不会被回收，导致Entry内存泄漏（threadLocal 和 value 同时出现内存泄漏）。</li></ul><p><strong>当key是弱引用</strong></p><p>ThreadLocalMap 中的 key 使用了弱引用，会导致 value 出现内存泄漏。</p><figure class="image-box">                <img src="75c1d22fbcac4c8a829f8d66190b022a~tplv-k3u1fbpfcp-zoom-1.image" alt="img" title class>                <p>img</p>            </figure><ul><li>假设在业务代码中使完 ThreadLocal，threadLocalRef被回收了。</li><li>由于 ThreadLocalMap 只持有 ThreadLocal 的弱引用，没有任何强引用指向 threadlocal 实例，所以 threadlocal 就可以顺利被gc回收，此时 Entry 中的 key=null。</li><li>在没有手动删除这个 Entry 以及 CurrentThread 依然运行的前提下，也存在有强引用链 threadRef -&gt; currentThread -&gt; threadLocalMap -&gt; entry -&gt; value，value不会被回收，而这块 value 永远不会被访问到了，导致 value 内存泄漏。</li></ul><h3 id="3-2-3-导致内存泄漏的原因"><a href="#3-2-3-导致内存泄漏的原因" class="headerlink" title="3.2.3. 导致内存泄漏的原因"></a>3.2.3. 导致内存泄漏的原因</h3><ul><li>没有手动删除相应的Entry对象</li><li>当前线程依然在运行</li></ul><p><strong>【解决办法】</strong></p><ul><li>使用完 ThreadLocal，调用其 remove 方法删除对应的 Entry。</li><li>使用完 ThreadLocal，当前 Thread 也随之运行结束。（不好控制，线程池中的核心线程不会销毁）</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>静态代理：</strong></p><p>代理类和目标类都属于硬性编码，在编译器就确定下来了，不利于程序的扩展。同时，每一个代理类都只为一个目标类服务，时间长了下来总会产生过多的代理类。</p><p><strong>动态代理：</strong></p><p>可以根据不同目标类实现的接口，通过反射获取目标类的接口，然后获取接口中的方法，对方法进行统一的处理。</p><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h1><p><strong>实现跨平台的原理</strong></p><p><strong>Java是一门跨平台语言，所谓跨平台就是，Java源文件会被编译成为字节码文件，不管是Windows，Linux还是Mac，都有其适配的JVM，也就是字节码文件可以随意在这些JVM上去运行。</strong></p><p><strong>其他的语言，例如c语言和汇编，编译成为机器码之后，由于底层的机器语言支持不一样，编译后的机器语言文件是不可以跨操作系统运行的。而Java则是把兼容的工作，交给了JVM。不同的JVM负责去适配不同的操作系统。</strong></p><p>虚拟机内部的组成部分：堆，栈，方法区，本地方法栈，方法区，程序计数器</p><p><img src="image-20210628162346871.png" alt="image-20210628162346871"></p><p><img src="https://upload-images.jianshu.io/upload_images/16876298-ee51191fac8bd277.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img"></p><p><strong>Hotspot是基于栈的指令架构：</strong></p><p><strong>优点：1、设计和实现比较简单，适用于资源受限的系统。</strong></p><p><strong>JDK1.8之前：</strong></p><p><strong><figure class="image-box">                <img src="3e821b49984dd98980d20665ddfff290.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>JDK 1.8 ：</strong></p><p><strong><figure class="image-box">                <img src="d70dce6e7f061a82e78b3277888b5b72.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>线程私有的：</strong></p><ul><li><strong>程序计数器</strong></li><li><strong>虚拟机栈</strong></li><li><strong>本地方法栈</strong></li></ul><p><strong>线程共享的：</strong></p><ul><li><strong>堆</strong></li><li><strong>方法区</strong></li><li><strong>直接内存 (非运行时数据区的一部分)</strong></li></ul><p><strong><figure class="image-box">                <img src="image-20210227150521780.png" alt="image-20210227150521780" title class>                <p>image-20210227150521780</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210303010657779.png" alt="image-20210303010657779" title class>                <p>image-20210303010657779</p>            </figure></strong></p><h2 id="加载-过程√"><a href="#加载-过程√" class="headerlink" title="加载 过程√"></a><strong>加载 <a href="#类加载">过程</a>√</strong></h2><h2 id="类加载器的介绍"><a href="#类加载器的介绍" class="headerlink" title="类加载器的介绍"></a>类加载器的介绍</h2><p>之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，(验证，准备，解析)，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li>将class文件加载到内存</li><li>将静态数据结构转化成方法区中运行时的数据结构</li><li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li></ol><h4 id="2-1-2-连接"><a href="#2-1-2-连接" class="headerlink" title="2.1.2 连接"></a>2.1.2 连接</h4><ol><li>验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是一个赋值的操作，它会执行一个类构造器的()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</p><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li>BootStrap ClassLoader：rt.jar</li><li>Extention ClassLoader: 加载扩展的jar包</li><li>App ClassLoader：指定的classpath下面的jar包</li><li>Custom ClassLoader：自定义的类加载器</li></ol><p><strong><figure class="image-box">                <img src="image-20210217002723701.png" alt="image-20210217002723701" title class>                <p>image-20210217002723701</p>            </figure></strong></p><figure class="image-box">                <img src="image-20210701153004154.png" alt="image-20210701153004154" title class>                <p>image-20210701153004154</p>            </figure><p>简单来说就算先从下往上找，找到了就执行上面的，没找到就又从上往下找，找到了就执行下面的</p><p><strong>一些热点代码（反复高频执行的）会在虚拟机中缓存起来，使用时用JIT编译器编译</strong></p><p><strong>魔数</strong></p><blockquote><p><strong>每个class文件的前四个字节表示魔数，他的唯一作用是确定这个文件是否是一个能被虚拟机接受的class文件</strong></p><p><strong>前4个字节为魔数</strong></p><p><strong>紧接着魔数的4个字节后，第5个和第6个表示次版本号。第7、8表示主版本号。如下图</strong></p><p><strong>用16进制编辑器打开 可以看见前4个字节的16进制表示的是 0xCAFEBASE 表示魔数，0x00表示次版本号</strong></p><p><strong>0x32为主版本号 即为十进制的50 也就是说这个class文件可以被jdk1.6以上版本的虚拟机所执行。</strong></p></blockquote><p><strong><figure class="image-box">                <img src="20180528140355597" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>类加载的环节： <a name="类加载"></a></strong></p><blockquote><p><strong>类加载主要包括三个阶段，加载、链接、初始化。</strong></p><p><strong>第一个阶段是加载，通过一个类的全限定名获取此类的二进制字节流（流中实际保存的是字节码文件），通过这个字节流所代表的静态存储结构转化为<a href="#方法区">方法区</a>运行时数据结构，实际就是将这个字节码文件加载进内存里。然后在内存中（堆）生成一个该类的Class对象（反射），作为方法区这个类的数据访问入口。</strong></p><p><strong>在此阶段运行中，验证阶段就已开始，交叉进行。只有通过了验证阶段，字节流才会进入内存的方法区中进行存储。</strong></p><p><strong>第二个阶段是链接，分为验证、准备、解析三步。验证是验证class字节码文件包含的信息的正确性，保证对虚拟机不会产生危害。准备是为类变量分配空间并设置该变量的默认初始值。解析是将常量池的符号引用转换为直接引用。</strong></p><p><strong>第三个阶段是初始化，初始化阶段就是执行类构造器方法clinit，这个方法是编译器收集整个类中的<code>类变量</code>的赋值以及<code>静态代码块</code>而形成的，顺序按照源文件中类变量的复制顺序生成的，这个阶段开始，算是真正开始执行代码了。</strong></p></blockquote><p><strong><code>符号引用</code>：见上文中class文件中常量池的图片，我们可以知道常量池中有描述类，方法，字段等常量，这些常量通过一组符号（比如UTF8字符串）描述所引用的目标。虽然在验证阶段已经对此进行了验证，但是这些毕竟只是一些字符串，并不能拿来直接为虚拟机使用，并不指向任何真实的内存地址。</strong></p><p> <strong><code>直接引用</code>：直接引用则是指向这些目标的指针，偏移量或者句柄。</strong></p><p><strong>①加载：</strong></p><p><strong><figure class="image-box">                <img src="image-20210228211948061.png" alt="image-20210228211948061" title class>                <p>image-20210228211948061</p>            </figure></strong></p><p><strong>拓展：类初始化的时机</strong></p><p><strong>②链接：</strong></p><p><strong>Q：链接之验证？</strong></p><blockquote><p><strong>比如.class文件的魔数是否为cafebabe，前四个字节的一般都是固定的，用来让虚拟机识别是否为符合要求的文件，5，6位字节一般是次版本号，7，8位的话是主版本号，这三者信息代表着当前JVM版本是否可以运行，一般高版本的虚拟是向下兼容低版本的，除了这些验证还有元数据验证，字节码验证等。</strong></p></blockquote><p><strong>Q：链接之准备？</strong></p><blockquote><p><strong>准备是为static变量分配内存和初始化零值，这里的初始化是默认值。但是static final修饰的变量在编译期就分配了内存，这里会显式初始化。</strong></p></blockquote><p><strong>Q：符号引用和直接引用？</strong></p><blockquote><p><strong>符号引用就是用字符串符号表示的形式来引用，例如创建一个String s=”abc”的字符串s，输出的时候直接用s来代表这个String字符串，这就是符号引用。符号引用通常是设计字符串的——用文本形式来表示引用关系。</strong></p><p><strong>直接引用是是JVM所能直接使用的形式，这种引用可能是指针、也可能是用索引直接定位。</strong></p></blockquote><p><strong><figure class="image-box">                <img src="image-20210224212159865.png" alt="image-20210224212159865" title class>                <p>image-20210224212159865</p>            </figure></strong></p><p><strong>③初始化：</strong></p><p><strong>Q：初始化？</strong></p><p><strong>初始化就是执行类构造器clinit的过程，这个过程会收集类中所定义的所有类变量的复制动作，然后按照代码在源文件的顺序，为变量进行复制，这一步开始才真正开始执行java代码。</strong></p><p><strong><figure class="image-box">                <img src="image-20210224213335168.png" alt="image-20210224213335168" title class>                <p>image-20210224213335168</p>            </figure></strong></p><p><strong>对象创建环节：</strong></p><p><strong>对象头信息：运行时元数据（）、类型指针（指向方法区）</strong></p><p><strong><figure class="image-box">                <img src="image-20210305010045281.png" alt="image-20210305010045281" title class>                <p>image-20210305010045281</p>            </figure></strong></p><p><strong>加载器种类：</strong></p><ol start="2"><li><strong>启动类加载器Bootstrap ClassLoader</strong></li><li><strong>扩展类加载器Extension ClassLoader</strong></li><li><strong>应用程序类加载器Application ClassLoader</strong></li></ol><p><strong>加载指的是将类的class文件（字节码文件）读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</strong></p><p>  <strong>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</strong></p><p>  <strong>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</strong></p><ul><li><strong>从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。</strong></li><li><strong>从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。</strong></li><li><strong>通过网络加载class文件。</strong></li><li><strong>把一个Java源文件动态编译，并执行加载。</strong></li></ul><p><strong><figure class="image-box">                <img src="1458123-20191224224841067-1374425461.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227131317516.png" alt="image-20210227131317516" title class>                <p>image-20210227131317516</p>            </figure></strong></p><h2 id="JVM内存分配方式√"><a href="#JVM内存分配方式√" class="headerlink" title="JVM内存分配方式√"></a><strong>JVM内存分配方式√</strong></h2><p><strong>Q：JVM的内存分配？</strong></p><blockquote><p><strong>JVM的内存分配分为两种情况，一种是如果内存是绝对规整的，如堆内存的新生区常使用复制算法来进行GC，这种情况就使用指针碰撞的方法进行分配，指针记录了上一次内存分配结束的地址，那么进行下次内存分配的时候，则只需要在这个指针后进行分配就可以了。第二种情况是内存不规整的，例如在老年代，每次GC后都可能产生内存碎片，这种情况就使用空闲列表，找到一块足够大的空间进行分配。</strong></p></blockquote><p><strong>在内存分配绝对规则的情况下，会用指针记录上一次内存分配结束的地址。在进行下次的内存分配时，会从内存指针所在的位置往后进行分配。</strong></p><p><strong>指针碰撞：假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边。中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲空间那边挪动一段与对象大小相等的距离。这种方式则属于指针碰撞。</strong></p><p><strong>空闲列表：如果堆中的内存并不是规整的，已使用的内存和空闲内存相互交错，显然无法使用指针碰撞。虚拟机就必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新记录表上的数据。这种方式属于空闲列表。</strong></p><p><strong>具体选择哪种分配方式由Java堆决定，而Java堆是否规整，则有GC收集器决定。因此使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞。而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用的空闲列表。</strong></p><h2 id="双亲委派机制：安全√"><a href="#双亲委派机制：安全√" class="headerlink" title="双亲委派机制：安全√"></a><strong>双亲委派机制：安全√</strong></h2><blockquote><p><strong>双亲委派机制，是类加载机制的一个工作模型，他其实没有一个双的概念，我认为这是译者的不专业所产生的错误译词，我一个称为上溯委派机制，类加载器收到请求以后，会检查这个类是否已经加载过。<code>会向自己的父类加载器进行委托</code>，如果当前加载器还有父类加载器，递归这个操作，一直委托到最上层的根加载器，委托到最上层以后会检查当前类加载器是否能加载，如果不能加载则向下委派，直到可以加载或者抛出classNotFound异常。双亲委派机制的作用就是为了防止核心的api被篡改，如果假如我在自己的项目下创建一个跟已存在的java.lang包下已存在取的类同样的名字，然后运行运行起来就会报SecurityException。</strong></p></blockquote><p>总结为， 向上检索，向下操作。</p><p>1.除了bootstrap classloader其他所有的类加载器都有父类加载器</p><p>2.一个类加载器在接受到一个类加载请求时，它首先不会自己去尝试加载，而是会先把这个加载请求委派给它的父类加载器去先请求加载，每个层次的类加载器都会如此去做，所以最后的类加载请求都会委派到顶层类加载器bootstrap classloader，只有在父类加载器反馈无法加载该请求时，子类加载器才会自己去加载。</p><p>戏称：啃老机制</p><p><strong>细节：</strong></p><p><strong>双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器的实现方式。大部分的类加载器都遵循这个模型，但双亲委派模型也可以被破坏，破坏并不是不好，而是在有足够意义和理由的情况下，突破已有的规则进行创建，实现特定的功能。</strong></p><p><strong>三种破坏双亲委派模型的方式</strong></p><ul><li><strong>重写 loadClass() 方法</strong></li><li><strong>逆向使用类加载器，引入线程上下文类加载器</strong></li><li><strong>追求程序的动态性：代码热替换、模块热部署等技术</strong></li></ul><p><strong>作用：</strong></p><p><strong>1、避免类的重复加载</strong></p><p><strong>2、保护程序安全，防止核心api被随意篡改，如自定义类java.lang.String</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader;classLoader.getParent(); <span class="comment">// jre\lib\ext文件夹classLoader.getParent().getParent(); // rt.jar RunTime包</span></span><br></pre></td></tr></table></figure><p><strong>委派方向：先寻找应用程序类加载器（Application ClassLoader）—&gt;扩展类加载器（Extension ClassLoader）—&gt;启动类加载器（Bootstrap ClassLoader）</strong></p><p>为什么是双亲委派模式 而不叫单亲委派模式呢？</p><p>这就是名称问题而已，不管是继承自一个类还是实现多个接口，本质都要用到invoke指令。双亲单亲仅仅是个名称而已。</p><p>双亲委派的原文是”parents delegate”。parents在英文中是“父母”、“双亲”的意思，常用翻译是“父母”,但也有“上溯，母体，祖先”这一类的意思，这里其实表达的是“父母这一辈”的人的意思。实际上这个模型中，只是表达“父母这一辈”的class loader而已，并不是说真的有一个父亲的class loader和一个母亲class loader。本人观点是叫做上溯委派机制。</p><p><strong>机制：</strong></p><ol><li><strong>类加载器收到请求</strong></li><li><strong>将这个请求委托给父类加载器去完成，一直向上委托，直到启动类加载器</strong></li><li><strong>启动类加载器检查是否能够加载当前这个类，能加载就使用当前加载器，否则抛出异常</strong></li><li><strong>重复步骤3</strong></li></ol><p><strong>PS：若输出当前类加载器值为NULL，则该加载器不存在或调用不到（比如用C++、C语言写的就调用不到）</strong></p><p><strong><figure class="image-box">                <img src="image-20210227144108510.png" alt="image-20210227144108510" title class>                <p>image-20210227144108510</p>            </figure></strong></p><h1 id="拓展：-双亲委派机制的BUG"><a href="#拓展：-双亲委派机制的BUG" class="headerlink" title="拓展： 双亲委派机制的BUG"></a>拓展： 双亲委派机制的BUG</h1><p><a href="https://zhuanlan.zhihu.com/p/345534653" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/345534653</a></p><h5 id="1-工作流程"><a href="#1-工作流程" class="headerlink" title="1 工作流程"></a>1 工作流程</h5><ul><li><p>当一个类加载器收到一个类加载请求 在 JDK9 后，会首先搜索它的内建加载器定义的所有“具名模块”：</p></li><li><ul><li>如果找到合适的模块定义，将会使用该加载器来加载</li><li>如果未找到，则会将该请求委派给父级加载器去加载</li></ul></li></ul><ul><li>因此所有的类加载请求最终都应该被传入到启动类加载器(Bootstrap ClassLoader)中，只有当父级加载器反馈无法完成这个列的加载请求时（它的搜索范围内不存在这个类），子级加载器才尝试加载。</li></ul><p>在类路径下找到的类将成为这些加载器的无名模块。</p><p><strong>这里的父子关系是组合而不是继承</strong>。</p><ul><li>双亲委派模型示意图</li></ul><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-cebbc2df3aeb45700e1fbcfac72d37bc_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h5 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h5><ul><li>避免重复加载 父类已经加载了，子类就不需要再次加载。 eg，object 类。它存放在 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器加载，因此 object 类在程序的各种加载环境中都是同一个类。</li><li>更安全 解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心 API，会带来安全隐患。</li></ul><h5 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // 首先先检查该类已经被加载过了</span><br><span class="line">           Class c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;//该类没有加载过，交给父类加载</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;//交给父类加载</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;//父类不存在，则交给启动类加载器加载</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                  //父类加载器抛出异常，无法完成类加载请求</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;//</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   //父类加载器无法完成类加载请求时，调用自身的findClass方法来完成类加载</span><br><span class="line">                   c = findClass(name);</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-类加载的方式"><a href="#3-3-类加载的方式" class="headerlink" title="3.3 类加载的方式"></a>3.3 类加载的方式</h5><ol><li>通过命令行启动应用时由JVM初始化加载含有main()方法的主类。</li><li>通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</li><li>通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</li></ol><h2 id="拓展：破坏双亲委派模型"><a href="#拓展：破坏双亲委派模型" class="headerlink" title="拓展：破坏双亲委派模型"></a>拓展：破坏双亲委派模型</h2><p>双亲模型有个问题：父加载器无法向下识别子加载器加载的资源。</p><ul><li>如下证明 JDBC 是启动类加载器加载，但 mysql 驱动是应用类加载器。而 JDBC 运行时又需要去访问子类加载器加载的驱动，就破坏了该模型。</li></ul><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-ebe7177191430f24e606c80ff0e24bde_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>JDK 自己为解决该问题，引入线程上下问类加载器，可以通过Thread的setContextClassLoader()进行设置</p><ul><li>当为启动类加载器时，使用当前实际加载驱动类的类加载器</li></ul><figure class="image-box">                <img src="https://pic1.zhimg.com/80/v2-d1d03fa21efba80b0e90eab73648b298_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h2><p>比如OSGI的模块化热部署，它的类加载器就不再是严格按照双亲委派模型，很多 可能就在平级的类加载器中执行了。</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ol><li>ClassLoader通过一个类全限定名来获取二进制流，如果我们需通过自定义类加载其来加载一个Jar包的时候,难道要自己遍历jar中的类,然后依次通过ClassLoader进行加载吗?或者说我们怎么来加载一个jar包呢? 对于动态加载jar而言，JVM默认会使用第一次加载该jar中指定类的类加载器作为默认的ClassLoader。</li></ol><p>假设我们现在存在名为sbbic的jar包，该包中存在ClassA和ClassB类(ClassA中没有引用ClassB)。 现在我们通过自定义的ClassLoaderA来加载在ClassA这个类，此时ClassLoaderA就成为sbbic.jar中其他类的默认类加载器。即ClassB默认也会通过ClassLoaderA去加载。</p><ol><li>如果一个类引用的其他的类,那么这个其他的类由谁来加载?</li></ol><p>如果ClassA中引用了ClassB呢? 当类加载器在加载ClassA的时候，发现引用了ClassB，此时类加载如果检测到ClassB还没有被加载，则先回去加载。当ClassB加载完成后，继续回来加载ClassA。即类会通过自身对应的来加载其加载其他引用的类。</p><ol><li>既然类可以由不同的加载器加载,那么如何确定两个类如何是同一个类?</li></ol><p>JVM规定：对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在java虚拟机中的唯一性。即在jvm中判断两个类是否是同一个类取决于类加载和类本身，也就是同一个类加载器加载的同一份Class文件生成的Class对象才是相同的，类加载器不同，那么这两个类一定不相同。</p><h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h1><p><strong>沙箱基本组件:</strong></p><ol><li><strong>字节码校验器（确保代码遵循java语言规范。这样可以帮助java程序实现内存保护，但并不是所有类文件都能经过字节码校验，比如核心类（比如String）。）</strong></li><li><strong>存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</strong></li><li><strong>安全管理器：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</strong></li><li><strong>安全软件包：</strong></li></ol><figure class="image-box">                <img src="image-20210701181806141.png" alt="image-20210701181806141" title class>                <p>image-20210701181806141</p>            </figure><h2 id="堆-amp-逃逸分析-√"><a href="#堆-amp-逃逸分析-√" class="headerlink" title="堆&amp;逃逸分析 √"></a><strong>堆&amp;<a href="#逃逸分析">逃逸分析</a> √</strong></h2><blockquote><p><strong>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。堆空间划分为新生代1/3，老年代2/3，新生代又分为伊甸园区，同时也是主要GC区域。</strong></p></blockquote><blockquote><p><strong>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p></blockquote><p><strong>锁消除</strong></p><p><strong>细节</strong></p><p><strong><figure class="image-box">                <img src="image-20210304212603211.png" alt="image-20210304212603211" title class>                <p>image-20210304212603211</p>            </figure></strong></p><h2 id="1-2-Java-虚拟机栈（以栈帧为单位）√"><a href="#1-2-Java-虚拟机栈（以栈帧为单位）√" class="headerlink" title="1.2 Java 虚拟机栈（以栈帧为单位）√"></a><strong>1.2 Java 虚拟机栈（以栈帧为单位）√</strong></h2><blockquote><p> <strong>局部变量表的基本存储单元是变量槽slot，主要存放当前栈帧的方法参数和局部变量和部分返回结果等等，方法被调用的时候，JVM会给变量槽分配一个索引，通过这个索引就可以访问对应的局部变量值，同时局部变量的变量槽可以复用，当一个变量使用后被销毁，即可以让下一个变量使用被销毁变量的变量槽。</strong></p><p> <strong>操作数栈主要对变量值进行运算，运算完成后会将结果压入栈，jvm执行引擎虚拟机时基于栈的执行引擎，这个栈指的就是操作数栈。</strong></p><p> <strong>动态链接就是将class文件一部分符号引用在运行期间转化为直接引用，另外一部分是在类加载的第一阶段由符号引用转化为直接引用，叫做静态解析。</strong> (找到代码)</p><p> <strong>方法出口：最后就是方法返回地址，正常返回时，这个就是将当前栈帧的结果返回到当前方法的调用者，调用者的PC寄存器就时返回地址。如果是异常返回且没有被处理，则返回结果中时没有值的。</strong></p><p> 不会有垃圾回收。</p></blockquote><figure class="image-box">                <img src="image-20210628165938450.png" alt="image-20210628165938450" title class>                <p>image-20210628165938450</p>            </figure><p><strong>Java 虚拟机栈也线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong></p><figure class="image-box">                <img src="image-20210628170802813.png" alt="image-20210628170802813" title class>                <p>image-20210628170802813</p>            </figure><p>java 反汇编命令</p><p>javap  -c  Math.class</p><figure class="image-box">                <img src="image-20210628165426208.png" alt="image-20210628165426208" title class>                <p>image-20210628165426208</p>            </figure><p><strong>JAVA栈的模型</strong></p><blockquote><p><strong>Java 虚拟机栈是由一个个栈帧组成，</strong></p><p><strong>栈帧：局部变量表、操作数栈、动态链接、方法出口信息。</strong></p><p><strong>idea VM参数：Xss256K 设置虚拟机栈的大小为256K</strong></p></blockquote><h1 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h1><p>【方法索引，输入输出，本地变量，Class File:引用，父帧，子帧】</p><p>正在执行的方法在栈顶</p><p>StackOverflowError 错误</p><h3 id="栈帧-局部变量表"><a href="#栈帧-局部变量表" class="headerlink" title="栈帧-局部变量表"></a><strong>栈帧-局部变量表</strong></h3><p><strong>在编译期就分配了空间</strong></p><p><strong>问：栈帧中的局部变量表有什么作用？</strong></p><blockquote><p><strong>局部变量表的基本存储单元称为是slot(变量槽)，主要存放着当前栈帧的用于存储方法参数和局部变量，部分结果的返回值等等，当方法被调用的时候，JVM会为每个变量槽分配一个索引，通过这个索引访问索引对应的局部变量值。当方法被调用的时候，会按照局部变量的的产生顺序写到局部变量表上的slot槽上。</strong></p></blockquote><p><strong>局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）、主要影响着栈帧的大小。</strong></p><h3 id="栈帧-动态链接"><a href="#栈帧-动态链接" class="headerlink" title="栈帧-动态链接"></a><strong>栈帧-动态链接</strong></h3><p><strong>Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会<code>在类加载阶段或第一次使用时转化为直接引用</code>，这种转化称为静态解析。另一部分将在每一次<code>运行期间转化为直接引用</code>，这部分称为动态连接</strong></p><p><strong><figure class="image-box">                <img src="image-20210302211215497.png" alt="image-20210302211215497" title class>                <p>image-20210302211215497</p>            </figure></strong></p><p><strong>常量池：作用就是为了提供一些符号和常量，便于指令的识别</strong></p><p><strong>早期绑定：在编译时就能确定下来。比如：java当中的方法只有final，static，private和构造方法是前期绑定</strong></p><p><strong>晚期绑定：在编译期无法确定下来。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。</strong></p><p><strong><figure class="image-box">                <img src="image-20210302225908600.png" alt="image-20210302225908600" title class>                <p>image-20210302225908600</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227183359462.png" alt="image-20210227183359462" title class>                <p>image-20210227183359462</p>            </figure></strong></p><p><strong>栈顶缓存技术</strong></p><h3 id="栈帧-操作数栈"><a href="#栈帧-操作数栈" class="headerlink" title="栈帧-操作数栈"></a><strong>栈帧-操作数栈</strong></h3><blockquote><p><strong>操作数栈会根据字节码指令对变量的值进行压栈然后运算，运算完毕后变量就弹出栈，然后将结果再压入操作数栈，<code>Java</code>虚拟机的解释执行引擎被称为基于栈的执行引擎 ，其中所指的栈就是指－操作数栈。</strong></p></blockquote><p><strong>操作数栈实现方式是数组，在编译完成以后就确定了深度</strong></p><p><strong>细节1</strong></p><p><strong>slot重复利用：一些在变量在方法执行期间被销毁，但是变量槽依旧存在，会被一些变量重新利用起来。</strong></p><p><strong>细节2：</strong></p><p><strong>栈帧中性能调优关系最密切的是局部变量表。可以作为垃圾回收的根节点。涉及到垃圾回收算法指<a href="#标记">可达性分析</a></strong></p><p><strong><figure class="image-box">                <img src="image-20210228165257622.png" alt="image-20210228165257622" title class>                <p>image-20210228165257622</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210228165045672.png" alt="image-20210228165045672" title class>                <p>image-20210228165045672</p>            </figure></strong></p><p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p><ul><li><strong><code>StackOverFlowError</code>： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</strong></li><li><strong><code>OutOfMemoryError</code>： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</strong></li></ul><p><strong>扩展：那么方法/函数如何调用？</strong></p><p><strong>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</strong></p><p><strong>Java 方法有两种返回方式：</strong></p><ol><li><strong>return 语句。</strong></li><li><strong>抛出异常。</strong></li></ol><p><strong>不管哪种返回方式都会导致栈帧被弹出。</strong></p><h3 id="栈帧-方法返回地址"><a href="#栈帧-方法返回地址" class="headerlink" title="栈帧-方法返回地址"></a><strong>栈帧-方法返回地址</strong></h3><p><strong>方法返回地址有两种情况，</strong></p><p><strong>正常返回：当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口(<code>Normal Method Invocation Completion</code>)，一般来说，调用者的<code>PC</code>计数器可以作为返回地址。</strong></p><p><strong>异常返回：当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口(<code>Abrupt Method Invocation Completion</code>)，返回地址要通过异常处理器表来确定。</strong></p><p><img src="image-20210628170246978.png" alt="image-20210628170246978"></p><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a><strong>1.3 本地方法栈</strong></h2><p><strong>和虚拟机栈所发挥的作用非常相似。</strong></p><p><strong>区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</strong></p><p><strong>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</strong></p><p><strong>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</strong></p><h3 id="Native关键字（加分项）"><a href="#Native关键字（加分项）" class="headerlink" title="Native关键字（加分项）"></a><strong>Native关键字</strong>（加分项）</h3><ol><li><strong>native是调用底层C语言编写的库</strong></li><li><strong>会进入本地方法栈（有一个Java栈、本地方法栈）并调用本地接口JNI</strong></li><li><strong>JNI的作用：扩展Java的使用，融合不同的变成语言为Java所用。（C、C++，Java诞生的时候C、C++横行，Java必须融入这种语言生态环境中）</strong></li></ol><p>它在内存区域中，开辟一块标记区域：native method stack ，登记native 方法</p><p>在最终执行的时候，加载本地方法库中的方法通过JNI</p><h2 id="程序计数器（PC寄存器）"><a href="#程序计数器（PC寄存器）" class="headerlink" title="程序计数器（PC寄存器）"></a><strong>程序计数器（PC寄存器）</strong></h2><blockquote><p><strong>Q：程序计数器？</strong></p><p><strong>A：程序计数器中存储着指向下一条字节码指令的地址，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令，同时多线程情况下，CPU需要不停的切换线程，程序计数器可以记录当前线程执行到的位置，当CPU切换回来当前线程时，可以知道当前线程执行到哪儿了。同时呢，程序计数器是唯一不会发生内存溢出的地方，因为它之改变值，而不会随着程序的运行需要更大的空间。</strong></p><p><strong>Q：当线程切换到native上的时候，程序计数器是怎样的？</strong></p><p><strong>线程切换以后，由于方法是native修饰，那说明是底层的c/c++来写的方法，这种情况下就直接使用当前OS的PC寄存器和CPU，相当于用当前操作系统的CPU和PC寄存器来运行这个native方法。</strong></p></blockquote><blockquote><p><strong>1、为什么要使用PC寄存器存储当前线程的执行地址呢？（使用PC寄存器存储字节码指令地址有什么用呢？）</strong></p><p><strong>因为CUP需要不停地切换各个线程，这时候切换回来以后，就得知道从哪开始继续执行。</strong></p></blockquote><p><strong>每一个线程都有一个程序计数器，是线程私有的，指向方法区的字节码，在执行引擎读取下一条指令。</strong></p><p><strong>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p><p><strong>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li><strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</strong></li><li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li></ol><p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><p><strong>JVM的PC寄存器是对物理PC寄存器的一种抽象模拟</strong></p><p><strong><code>程序计数器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令</code></strong></p><p><strong><figure class="image-box">                <img src="image-20210227152516914.png" alt="image-20210227152516914" title class>                <p>image-20210227152516914</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210227162230226.png" alt="image-20210227162230226" title class>                <p>image-20210227162230226</p>            </figure></strong></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区<a name="方法区"></a></strong></h2><p><strong>Q：方法区主要存放？</strong></p><blockquote><p><strong>主要存储存储类的信息、字面量信息、运行时常量池、方法数据、方法代码、JIT代码缓存等。</strong></p></blockquote><p>方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单地说，所有定义的方法的信息都 保存在该区域，此区域属于共享区间。</p><p>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是，实例变量存在堆内存中，和方法无关。</p><p>static，final，Class模板，常量池；</p><p><strong>Q：方法区在jdk 1.7以及之前的实现是永久代，1.8以后变成了元空间。</strong></p><p><strong>why？</strong></p><blockquote><p><strong>因为永久代是一个内存固定的区域，会发生oom错误，但是变成元空间以后，内存就是物理内存，通俗的讲，你的机器磁盘有多大，元空间就有多大，大大降低了oom发生。永久代使用的并不是物理内存，所以更容易发生OOM</strong></p></blockquote><p><strong>运行时常量池</strong></p><p><strong>在常量池中，可以看到都是用#1 #2 #3这些临时符号来表示。当运行某个程序时候，JVM会把所有的字节码文件加入到内存当中，在经过链接、验证后，将#1 #2 #3这些符号全部转换成内存中的实际地址，放入到运行时常量池运行。运行时常量池是放在方法区中的，全局只有一份，是一个被所有的class共享的区域。</strong></p><p><strong>字符串常量池：</strong></p><p>　　<strong>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<string>。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容</string></strong></p><p><strong>-XX:MetaSpaceSize=100m -XX:MaxMetaspaceSize=100m</strong></p><p><strong>1.8的元空间大小默认值为21M，最大值为-1，即没有限制。</strong></p><p><strong>默认值为GC触发的水位线，一旦触发到，FULL GC将被触发并卸载没用的类（类对应的加载器不在存活），然后这个水位线将会被重置，如果GC后空间依然不足，则将适当地提高值，反之则降低值。</strong></p><p><strong>方法区GC：</strong></p><p><strong><figure class="image-box">                <img src="image-20210305001251584.png" alt="image-20210305001251584" title class>                <p>image-20210305001251584</p>            </figure></strong></p><p><strong>方法区是被所有线程共享，所有定义的方法都存在该区域，此区域属于共享区间。</strong></p><p><strong><figure class="image-box">                <img src="1111824-20190418173802066-4603036.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210303145007956.png" alt="image-20210303145007956" title class>                <p>image-20210303145007956</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183716879.png" alt="image-20210304183716879" title class>                <p>image-20210304183716879</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183744672.png" alt="image-20210304183744672" title class>                <p>image-20210304183744672</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183812607.png" alt="image-20210304183812607" title class>                <p>image-20210304183812607</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304183425558.png" alt="image-20210304183425558" title class>                <p>image-20210304183425558</p>            </figure></strong></p><blockquote></blockquote><h2 id="常量池、运行时常量池、字符串常量池"><a href="#常量池、运行时常量池、字符串常量池" class="headerlink" title="常量池、运行时常量池、字符串常量池"></a><strong>常量池、运行时常量池、字符串常量池</strong></h2><p><strong>常量池中储存的数据类型包括数量值、字符串值、类引用、字段引用、方法引用。</strong></p><p><strong><figure class="image-box">                <img src="5d58f2e0fc2f47ac9d9e2e2797e7a47c~tplv-k3u1fbpfcp-watermark.image" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304034638632.png" alt="image-20210304034638632" title class>                <p>image-20210304034638632</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210304034152726.png" alt="image-20210304034152726" title class>                <p>image-20210304034152726</p>            </figure></strong></p><p><strong>字符串常量池：</strong></p><p>　　<strong>HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<string>。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容</string></strong></p><hr><p><strong>jdk 1.7后，移除了方法区间，运行时常量池和字符串常量池都在堆中。</strong></p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><strong>对象头</strong></h2><p><strong><figure class="image-box">                <img src="image-20210311223140615.png" alt="image-20210311223140615" title class>                <p>image-20210311223140615</p>            </figure></strong></p><h2 id="访问对象的方式"><a href="#访问对象的方式" class="headerlink" title="访问对象的方式"></a><strong>访问对象的方式</strong></h2><p><strong>句柄访问</strong></p><p><strong>栈帧中的本地变量表中的reference类型记录指针指向堆中句柄池的，句柄中又有到对象示例数据的指针（堆）和对象类型数据的指针（方法区）</strong></p><p><strong>缺点：需要在堆里开辟一个句柄池空间，并且需要经过三次寻址。在占用空间的同时效率也不高。</strong></p><p><strong><figure class="image-box">                <img src="image-20210307002846067.png" alt="image-20210307002846067" title class>                <p>image-20210307002846067</p>            </figure></strong></p><p><strong>直接指针（hotspot采用）：</strong></p><p><strong>Java栈中直接reference的指针</strong></p><p><strong><figure class="image-box">                <img src="image-20210307003002082.png" alt="image-20210307003002082" title class>                <p>image-20210307003002082</p>            </figure></strong></p><h1 id="JVM垃圾回收（GC）"><a href="#JVM垃圾回收（GC）" class="headerlink" title="JVM垃圾回收（GC）"></a><strong>JVM垃圾回收（GC）</strong></h1><blockquote><p><strong>JVM垃圾回收主要发生在新生代，因为新生代的对象存活率低，运行时会产生很多死亡的对象，需要JVM进行垃圾回收。</strong></p></blockquote><h2 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a><strong>垃圾收集有哪些算法，各自的特点？</strong></h2><p><strong>-XX:MaxTenuringThreshold：晋升到老年代临界值设定。</strong></p><p><strong>-XX:PretenureSizeThreshold 即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对 Serial 及 ParNew 两款收集器有效。</strong></p><p><strong>如果在 Survivor 区中相同年龄（设年龄为 age ）的对象的所有大小之和超过 Survivor 空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</strong></p><p><strong>复制算法：</strong></p><blockquote><p><strong>复制算法主要针对堆中的新生代，因为新生代是有产生的对象98%都无法存活，复制算法正是应用在这种对象村落率比较低的区域，该算法会把每次幸存的对象从Eden区和From区复制到To区，此时To区会变成From区，因为在每次GC使用复制算法的时候哦From区和To区会交换位置，To区始终是空的，同时这样造成了一个To区空间的浪费，但是优点就是对象是规整的，没有内存的碎片。</strong></p></blockquote><p><strong>在一次GC中，将伊甸园区幸存下来的对象和幸存From区的对象复制到幸存To区。</strong></p><p><strong>好处：没有内存的碎片，所有的对象都复制到了幸存From区</strong></p><p><strong>坏处：总有一个幸存To区是空的，存在空间浪费。</strong></p><p><strong>复制算法最佳适用场景：对象存活率较低情况下使用，因为极端情况下（假设对象100%存活），成本太高。即一般在新生区使用</strong></p><p>​                                    <strong>GC前                                                                                GC后</strong></p><p><strong><figure class="image-box">                <img src="image-20210223211344746.png" alt="image-20210223211344746" title class>                <p>image-20210223211344746</p>            </figure></strong></p><p><strong>标记清除算法：</strong></p><blockquote><p><strong>标记清除算法，扫描所有对象，对需要回收的对象进行标记，被标记的对象将在GC的过程中被清除，这是最基础的垃圾收集算法，但是容易产生内存的碎片，对有些需要连续内存空间的对象不友好，所以这种算法效率也比较低。</strong></p></blockquote><p><strong>第一次-扫描：扫描所有对象，对需要回收的对象进行标记</strong></p><p><strong>第二次-清除：清除在第一次扫描中被标记的对象</strong></p><p><strong><figure class="image-box">                <img src="image-20210223212338753.png" alt="image-20210223212338753" title class>                <p>image-20210223212338753</p>            </figure></strong></p><p><strong>优点：不需要额外的空间。</strong></p><p><strong>缺点：标记和清除即两次扫描，时间成本较高。对象四处散落，产生内存碎片。</strong></p><p><strong>标记压缩清除算法：</strong></p><p><strong>在标记清除算法的基础上，加多一步整理，对存活的对象向内存的一端进行移动，整理出连续的内存的空间，</strong></p><p><strong><figure class="image-box">                <img src="image-20210223212828566.png" alt="image-20210223212828566" title class>                <p>image-20210223212828566</p>            </figure></strong></p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a><strong>空间分配担保</strong></h2><blockquote><p><strong>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果大于，则此次Minor GC是安全的。</strong></p><p><strong>如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</strong></p></blockquote><p><strong>3.为什么要进行空间担保？</strong></p><p><strong>是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</strong></p><h2 id="堆-JVM优化"><a href="#堆-JVM优化" class="headerlink" title="堆/JVM优化"></a><strong>堆/JVM优化</strong></h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析<a name="逃逸分析"></a></strong></h3><blockquote><p><strong>如果这个对象的作用域仅仅是方法内，不会被其他方法进行调用修改的话，就判断这个对象没有逃逸出去，虚拟机就可能将他直接在栈上分配，因为在栈上分配的话就不存在GC，对象随着方法运行结束被弹出栈而销毁，提高程序的运行性能。同时，也表明了能使用局部变量就尽量不要在方法内定义。</strong></p></blockquote><p><strong>细节</strong></p><p><strong>逃逸分析并不成熟</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000344240.png" alt="image-20210305000344240" title class>                <p>image-20210305000344240</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210305000413629.png" alt="image-20210305000413629" title class>                <p>image-20210305000413629</p>            </figure></strong></p><p><strong>同步省略（锁消除）</strong></p><p><strong>经过逃逸分析以后，如果作用域是在方法内的话，会省略掉同步操作。</strong></p><p><strong>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</strong></p><p><strong>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000150535.png" alt="image-20210305000150535" title class>                <p>image-20210305000150535</p>            </figure></strong></p><p><strong>标量替换</strong></p><p><strong>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</strong></p><p><strong><figure class="image-box">                <img src="image-20210305000143737.png" alt="image-20210305000143737" title class>                <p>image-20210305000143737</p>            </figure></strong></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h2><p><strong>我所了解的垃圾回收器有serial和parNew这两种</strong></p><p><strong>Serial / Serial Old 收集器：</strong></p><p><strong>单线程收集器，只使用一个 CPU 和一个收集线程，垃圾回收时暂停其他所有的工作线程，直到收集结束。</strong></p><p><strong>新生代采用复制算法，老年代采用标记整理算法。</strong></p><p><strong>ParNew 收集器：</strong></p><p><strong>Serial 的多线程版本，能与 CMS 收集器配置工作，所以是许多运行在 Server 模式下的首选新生代收集器。</strong></p><p><strong>在垃圾收集器的上下文中，先明确两个概念：</strong></p><blockquote><p><strong>并行：多条垃圾线程并行工作，用户线程仍然处于等待状态</strong></p><p><strong>并发：用户线程和垃圾回收线程同时执行（不一定并行，可能会交替执行）</strong></p></blockquote><p><strong>G1 收集器：</strong></p><p><strong>Garbge-First 面向服务端应用，具有并发并行、分代收集、空间整合、可预测停顿等特点。</strong></p><p><strong>使用 G1 时，Java 堆的内存分为多个大小相等的独立区域，虽然保留新生代和老年代的概念，但不再是物理隔离。G1 跟踪各个 Region 里垃圾堆积的价值，在后台维护一个优先列表，优先回收价值最大的 Region。</strong></p><p><strong>G1 的运作大致分为初始标记、并发标记、最终标记和筛选回收。</strong></p><p><strong>CMS 收集器：</strong></p><p><strong>Concurrnt Mark Sweep 以获取最短收回停顿时间为目标，使用标记清除算法。收集过程分为 4 部：初始标记、并发标记、重新标记和并发清理。初始标记和重新标记耗时很少，并发标记和并发清理两部耗时较长，但都可以与用户线程一起并发执行。</strong></p><p><strong>CMS 收集器有 3 个明显缺点：</strong></p><ol><li><strong>对 CPU 资源敏感，并发阶段占用一部分 CPU 资源导致应用程序变慢。</strong></li><li><strong>无法收集浮动垃圾，即并发清理阶段由于程序还在运行产生的垃圾，可能导致另一次 Full GC。</strong></li><li><strong>标记清除算法导致收集结束后存在大量空间碎片，可配置 Full GC 执行多少次时伴随一次空间压缩。</strong></li></ol><h2 id="如何判断对象是否死亡-两种方法"><a href="#如何判断对象是否死亡-两种方法" class="headerlink" title="如何判断对象是否死亡?(两种方法)"></a><strong>如何判断对象是否死亡?(两种方法)</strong></h2><p><strong>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</strong></p><p><strong>引用计数法：</strong></p><p><strong>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</strong></p><p><strong>问题：这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是【它很难解决对象之间相互循环引用的问题】。</strong></p><p><strong>可达性分析算法：<a name="标记"></a></strong></p><p>　 <strong>通过一系列称为GC Roots的根对象作为起始节点集，根据引用关系向下搜索，搜索走过的路径叫做引用链，如果某个对象到GC Roots节点集没有任何的引用链也被称为不可达，则证明这个对象不可能再被使用。</strong></p><p>　<strong>可作为GC Roots根节点的：</strong></p><ul><li><strong>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</strong></li><li><strong>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</strong></li><li><strong>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用</strong></li><li><strong>在本地方法栈中JNI（即通常所说的Native方法）引用的对象</strong></li><li><strong>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</strong></li><li><strong>所有被同步锁（synchronized关键字）持有的对象</strong></li><li><strong>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></li><li><strong>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合</strong></li></ul><p><strong>引用</strong></p><p><strong>强引用 ： 是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong></p><p><strong>软引用：是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用</strong></p><p><strong>弱引用 ：也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用</strong></p><p><strong>虚引用：也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</strong></p><p><strong><figure class="image-box">                <img src="227c2ddb38278e2c42a40def9484aa44.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>方法区垃圾回收</strong></p><ul><li><strong>方法区的回收主要包括废弃常量和无用的类。</strong></li><li><strong>废弃常量和堆中的对象类似，当发生垃圾回收时，如果常量池中的常量不存在任何引用，必要情况下回被清理。</strong></li><li><strong>判断一个类无用的条件很苛刻，需要所有实例都已经被回收、加载该类的 ClassLoader 已经被回收，并且该类对应的 java.lang.Class 对象没有在任何地方被引用，无法通过反射访问该类的方法，满足以上条件的无用类才能被回收。</strong></li></ul><p>1.</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a><strong>树</strong></h2><p><strong>前序遍历：对于当前节点，先输出该节点，然后输出他的左孩子，最后输出他的右孩子（中左右）。</strong></p><p><strong>中序遍历：对于当前结点，先输出它的左孩子，然后输出该结点，最后输出它的右孩子（左中右）。</strong></p><p><strong>后续遍历：对于当前结点，先输出它的左孩子，然后输出它的右孩子，最后输出该结点（左右中）。</strong></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><strong>栈</strong></h2><p><strong><figure class="image-box">                <img src="image-20210221225916916.png" alt="image-20210221225916916" title class>                <p>image-20210221225916916</p>            </figure></strong></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a><strong>排序算法</strong></h1><p><img src="1655bd71cc1bbbf5" alt="img"></p><p><strong>冒泡排序：</strong></p><p>冒泡排序，每次冒泡都比较相邻两个数的大小，大小关系不对，则交换。如下图，第一躺冒泡下来，最大的值都会被排到正确的位置，也有可能有其他数字处于正确位置。所以一趟下来至少有一个最大的处于正确位置（如下图的9）。</p><p><img src="166aa856d3308e96" alt="img" style="zoom: 80%;"></p><p><strong>选择排序</strong></p><p>选择排序如下图，每次都找出剩余中最小的值，将该最小值放到正确位置</p><figure class="image-box">                <img src="166adfaa33b75103" alt="img" title class>                <p>img</p>            </figure><h1 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a><strong>ArrayList和LinkedList</strong></h1><blockquote><p><strong>ArrayList的底层是基于一个动态数组实现的，LinkedList的底层是基于一个双向链表实现的，</strong></p><p><strong>ArrayList对象创建时有一个空参构造器还有一个给定数组容量的构造器，如果不规定数组容量，则默认是0。</strong></p><p><strong>当往数组里添加元素，数组容量将会变为10，数组元素数量超过了10，将会自动扩容，通过一个位运算将现在的容量右移一位再加上现在的容量，变成原数组的1.5倍，JDK1.7之前是1.5+1，然后创建一个新的数组，将原数组的复制进新数组，从而实现了动态扩容。</strong></p><p><strong>有一个细节是他的底层源码定义了两个空数组，一个是默认空数组，一个人创建对象时主动传0，也是空数组。</strong></p></blockquote><p>-</p><p><strong>区别</strong></p><ol><li><strong>底层原理：Arraylist底层是基于动态数组的，而LinkedList底层是基于双向链表的。</strong></li><li><strong>ArrayList必须是连续内存的，而LinkedList不要求是连续内存。</strong></li><li><p><strong>优缺点：ArrayList查询快，增删慢；LinkedList增删块，查慢。</strong></p></li><li><p><strong>ArrayList必须是连续内存的，而LinkedList不要求是连续内存。<br>ArrayList查询快，增删慢；Linked增删快，查慢。</strong></p></li></ol><p><strong>也就是arraylist底层是动态数组，所以查询时直接通过访问下标，查效率高，而增加和删除某一个位置后，后方元素都得向前移动一位。</strong><br><strong>当然最坏情况就是删除第一个元素，而后面的第2到第n个元素都得往前移动一位，所以增删慢。</strong></p><p><strong>例：当数组元素数已满时调用了add方法向尾部添加一个元素，则此时会进行扩容，arraylist会 Arrays.copyOf 复制一个更大的数组 1.5倍，而原数组会被抛弃，被GC回收。</strong></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><p> <strong>@Autowired</strong></p><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p><p><strong>@Component,@Repository,@Service, @Controller</strong></p><p>我们一般使用 @Autowired 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,可以采用以下注解实现：</p><p>1、@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。<br> 2、@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。<br> 3、@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。<br> 4、@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面</p><p><strong>@Configuration</strong></p><p>一般用来声明配置类，可以使用 @Component注解替代，不过使用Configuration注解声明配置类更加语义化。</p><p>读取配置信息：</p><p><strong>@value(常用)</strong></p><p>使用 @Value(“${property}”) 读取比较简单的配置信息：</p><p><strong>@ConfigurationProperties(常用)</strong></p><p>通过@ConfigurationProperties读取配置信息并与 bean 绑定。</p><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><p>SpringBoot自动装配原理主要涉及到@SpringBootApplication这个注释，而这个注释又可拆分为@EnableAutoConfiguration和@ComponentScan，@EnableAutoConfiguration由@AutoConfigurationPackage（作用是扫描启动类目录下所有包，加载启动类目录下所有的类），还有一个@Import(AutoConfigurationImportSelector.class)将会加载jar包META-INF下spring.factories中带有autoconfiguration尾缀的自动配置类</p><p><img src="image-20210318185345974.png" alt="image-20210318185345974"></p><p><strong>先来分析@AutoConfigurationPackage</strong></p><p>观察其内部实现，内部是采用了@Import，来给容器导入一个Registrar组件</p><figure class="image-box">                <img src="v2-f4fc91431709815748f4743160bf626a_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>所以，我们继续往下跟踪，来看Registrar内部是什么情况？</p><figure class="image-box">                <img src="v2-a93f83f34cd21c13701ad55ea8b7212e_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>我们可以跟踪源码看看这段是什么信息</p><figure class="image-box">                <img src="v2-260515784d191c4e149a0b8e87151025_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>结论：</strong></p><p>通过源码跟踪，我们知道，程序运行到这里，会去加载启动类所在包下面的所有类</p><p>这就是为什么，默认情况下，我们要求定义的类，比如controller，service必须在启动类的同级目录或子级目录的原因</p><p><strong>再来分析@Import(AutoConfigurationImportSelector.class)</strong></p><p>这个的关键是来看AutoConfigurationImportSelector.class内部的细节</p><p>在这个类的内部，有一个关键的方法，我们可以调试来看看结果</p><figure class="image-box">                <img src="v2-37063c2b7b7e2666841eaef6ca79b4b0_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>发现默认加载了好多的自动配置类，这些自动配置类，会自动给我们加载每个场景所需的所有组件，并配置好这些组件，这样就省去了很多的配置</p><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="keyword">new</span> AutoConfigurationEntry();</span><br><span class="line"></span><br><span class="line"><span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&lt;1&gt;.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&lt;2&gt;.</span></span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//&lt;3&gt;.</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">//&lt;4&gt;.</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>第 1 步</strong>:</p><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><p><strong>第 2 步</strong> ：</p><p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p><p><strong>第 3 步</strong></p><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p><p><img src="58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p><p><img src="94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 <strong>Spring Boot Starter</strong> 下的<strong><code>META-INF/spring.factories</code></strong>都会被读取到。</p><p><strong>第 4 步</strong> ：</p><p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p><p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p><figure class="image-box">                <img src="267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image" alt="img" title class>                <p>img</p>            </figure><p>因为，这一步有经历了一遍筛选，<strong><code>@ConditionalOnXXX</code></strong> 中的所有条件都满足，该类才会生效。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span></span><br><span class="line"><span class="comment">// 存在才会加载</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; RabbitTemplate<span class="class">.<span class="keyword">class</span>, <span class="title">Channel</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RabbitProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(<span class="title">RabbitAnnotationDrivenConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RabbitAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试官：你说下什么是spring？</strong></p><p><strong>我：spring是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。我们一般说的spring框架指的是Spring Framework，它是很多模块的集合，使用这些模块可以很方便的协助我们开发。这些模块是：核心容器、数据访问/集成、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container中的Core组件是Spring所有组件的核心，Beans组件和Context组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</strong></p><p><strong>面试官：使用Spring框架有什么好处呢？</strong></p><p><strong>我：框架能更让我们高效的编程以及更方便的维护我们的系统。</strong></p><ol><li><strong>轻量：Spring是轻量的，相对其他框架来说。</strong></li><li><strong>控制反转：Spring通过控制反转实现了松散耦合，对象给出他们的依赖，而不是创建或查找依赖的对象们。</strong></li><li><strong>面向切面编程（AOP）：Spring支持面向切面编程，并且把业务逻辑和系统服务分开。</strong></li><li><strong>容器：Spring包含并管理应用中对象的生命周期和配置。</strong></li><li><strong>MVC框架：Spring的WEB框架是个精心设计的框架，是WEB框架的一个很好的替代品。</strong></li><li><strong>事务管理：Spring提供一个持续的事务管理接口，提供声明式事务和编程式事务。</strong></li><li><strong>异常处理:Spring提供方便的API把具体技术相关的异常转化为一致的unchecked异常。</strong></li></ol><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><p><strong>Bean的自动装配：</strong></p><figure class="image-box">                <img src="image-20210321205512991.png" alt="image-20210321205512991" title class>                <p>image-20210321205512991</p>            </figure><p>1、通过ComponentScanner<strong>扫描全部@Component及其派生注解标识的类</strong>，此路径主要用于自编程代码，取代原先springboot1.* xml标记时代bean.xml内手动组装的Bean内容，体现自动装配中的“自动”，<strong>其本质就是通过Scanner扫描@Component</strong>。</p><p>2、<strong>通过ImportSelector从spring.factories文件中获取自动配置类</strong>，此路径用于解耦三方件之间的依赖，也就是我们代码从pom里引入其他模块是为什么也能够自动装配上里面的Bean。如果我们的程序写完也作外用，那么spring.factories这里面的key-value一定要仔细认真的核对。该文件里同时定义了各种上下文初始化器和事件监听器，非常重要。源码里位置放在\src\main\resources\META-INF\spring.factories</p><p>填满beanDefinitionMap后Bean定义集合获取完毕。</p><p>Bean的作用域：</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a><strong>Bean的生命周期</strong></h3><blockquote><p><strong>Bean的生命周期包括Bean的创建、存活、销毁的过程，创建就是实例化的过程，存活包括属性赋值和初始化，所以又说Bean的生命周期为：实例化、属性赋值、初始化和销毁，而这个过程单例和多例有所不同：</strong></p></blockquote><p><strong>【1】单例Bean</strong></p><ul><li><strong>实例化：容器启动的时候实例化对象</strong></li><li><strong>存活：只要容器还在，Bean对象就一直存活（和容器共存亡）</strong></li><li><strong>销毁：容器关闭的时候就销毁</strong></li></ul><p><strong>【2】多例Bean</strong></p><ul><li><strong>实例化：获取对象的时候实例化对象</strong></li><li><strong>存活：对象只要在使用过程中就一直存活</strong></li><li><strong>销毁：当对象长时间不用且没有其他对象引用时，由Java垃圾回收器回收</strong></li></ul><p>  <strong>解释Spring框架中bean的生命周期。</strong></p><ul><li>Spring容器 从XML 文件中读取bean的定义，并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>如果bean实现了BeanNameAware 接口，Spring 传递bean 的ID 到 setBeanName方法。</li><li>如果Bean 实现了 BeanFactoryAware 接口， Spring传递beanfactory 给setBeanFactory 方法。</li><li>如果有任何与bean相关联的BeanPostProcessors，Spring会在postProcesserBeforeInitialization()方法内调用它们。</li><li>如果bean实现IntializingBean了，调用它的afterPropertySet方法，如果bean声明了初始化方法，调用此初始化方法。</li><li>如果有BeanPostProcessors 和bean 关联，这些bean的postProcessAfterInitialization() 方法将被调用。</li><li>如果bean实现了 DisposableBean，它将调用destroy()方法。</li></ul><p><strong>四种常见的 Spring Bean 的作用域：</strong></p><p><strong>singleton :</strong> bean在每个Spring ioc 容器中只有一个实例。</p><p><strong>prototype</strong>：一个bean的定义可以有多个实例。</p><p><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p><strong>session</strong>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><p><strong>global-session</strong>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</p><blockquote><h1 id="描述一下bean的生命周期"><a href="#描述一下bean的生命周期" class="headerlink" title="描述一下bean的生命周期"></a>描述一下bean的生命周期</h1><p>背图:记住图中的流程</p><figure class="image-box">                <img src="image-20210905114954780.png" alt="image-20210905114954780" title class>                <p>image-20210905114954780</p>            </figure><blockquote><p><code>在表述的时候不要只说图片中有的关键点，要学会扩展描述</code></p></blockquote><blockquote><p><code>设置对象这步骤 可以衍生出循环依赖的问题</code></p></blockquote><p>1.实例化Bean，反射的方式生成对象</p><p>2.填充bena的属性：populateBean(), 循环依赖的问题(三级缓存)</p><p>3.调用aware接口相关的方法：invokeAwareMethod(完成BeanName可以获取容器bean的名称，BeanFactory获取当前bean factory这也可以调用容器的服务，BeanClassLoader对象的属性设置)</p><p>4.调用     </p><p>5.调用initmethod方法:invokeInitmethod(),判断是否实现了InitializingBean接口，如果有，调用afterPropertiesSet方法，</p><p>6.调用BeanPostProcessor的后置处理方法：spring的aop就是在此处实现的，AbstractAutoProxyCreator</p><p>​        注册Destuction相关的回调接口</p><p>7.获取到完整的对象，可以通过getBean的方式来进行对象的获取</p><p>8.销毁流程 ①判断是否实现了DispoableBean接口②调用destroyMethod方法</p></blockquote><blockquote><h1 id="Bean-Factory与FactoryBean有什么区别？"><a href="#Bean-Factory与FactoryBean有什么区别？" class="headerlink" title="Bean Factory与FactoryBean有什么区别？"></a>Bean Factory与FactoryBean有什么区别？</h1><p>相同点：都是用来创建bean对象的，是接口</p><p>不同点：BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了，如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactoryBean接口了它的方法</p><pre><code>isSingleton：是否是单例对象getObjectType：获取返回对象的类型getObject：自定义创建对象的过程(new,反射,动态代理)</code></pre></blockquote><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h2><p>从哪里开始聊， aop 是ioc的一个拓展功能，先有ioc，再有aop。是ioc整个流程新增的功能点 ：BeanPostProcessor</p><p>总：aop概念，应用场景，动态代理</p><p><strong>Aop（面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的扩展性和可维护性。这里聚个日志处理的栗子：</strong></p><p>分：bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现</p><p>​        1.代理对象的创建过程（advice，切面，切点）</p><p>​         2.<strong>通过jdk或者cglib的方式来生成代理对象 </strong>  （拓展点）</p><p>​        3.在执行方法调用的时候，会调用到生成的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的intercept方法，从此方法开始执行</p><p>​        4.根据之前定义好的通知来生成拦截器链</p><p>​        5.从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个CglibMethodInvocation的对象，找的时候是从-1的位置依次开始查找并且执行的。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a><strong>JDK动态代理</strong></h3><p>运用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法，同时代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理了</p><p><strong>基本概念</strong></p><p>首先，我们知道Spring AOP的底层实现有两种方式：一种是JDK动态代理，另一种是CGLib的方式。</p><p>自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。</p><p>JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</p><p>JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。</p><p>CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p><p><strong>JDK 和 CGLib动态代理区别</strong></p><p><strong>1、JDK动态代理具体实现原理：</strong></p><ul><li>通过实现InvocationHandlet接口创建自己的调用处理器；</li><li>通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；</li><li>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；</li></ul><p>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。</p><p><strong>2、CGLib动态代理：</strong></p><p>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代 理的类，重写父类的方法，实现AOP面向切面编程呢。</p><p>ASM 建议不聊</p><p><strong>3、两者对比：</strong></p><ul><li>JDK动态代理是面向接口的。</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。</li></ul><p><strong>4、使用注意：</strong></p><ul><li>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</li><li>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</li></ul><p>实现InvocationHandler接口，并且实现接口中的invoke方法。仔细看<strong>invoke</strong>方法，就是在该方法中加入<strong>切面逻辑</strong>的。目标类方法的执行是由<strong>mehod.invoke(target,args)</strong>这条语句完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.java.base.springaop;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Object target;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> MyInvocationHandler(Object target) &#123;</span><br><span class="line"> <span class="keyword">super</span>();</span><br><span class="line"> <span class="keyword">this</span>.target = target;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"> <span class="comment">// 程序执行前加入逻辑，MethodBeforeAdviceInterceptor</span></span><br><span class="line"> System.out.println(<span class="string">"before-----------------------------"</span>);</span><br><span class="line"> <span class="comment">// 程序执行</span></span><br><span class="line"> Object result = method.invoke(target, args);</span><br><span class="line"> <span class="comment">// 程序执行后加入逻辑，MethodAfterAdviceInterceptor</span></span><br><span class="line"> System.out.println(<span class="string">"after------------------------------"</span>);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中增强的目标对象是由Proxy.newProxyInstance(aService.getClass().getClassLoader(),aService.getClass().getInterfaces(), handler);来生成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     Service aService = <span class="keyword">new</span> ServiceImpl();</span><br><span class="line">     MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(aService);</span><br><span class="line">     <span class="comment">// Proxy为InvocationHandler实现类动态创建一个符合某一接口的代理实例</span></span><br><span class="line">     Service aServiceProxy = (Service) Proxy.newProxyInstance(aService</span><br><span class="line">     .getClass().getClassLoader(), aService.getClass()</span><br><span class="line">     .getInterfaces(), handler);</span><br><span class="line">     <span class="comment">// 由动态生成的代理对象来aServiceProxy 代理执行程序，其中aServiceProxy 符合Service接口</span></span><br><span class="line">     aServiceProxy.add();</span><br><span class="line">     System.out.println();</span><br><span class="line">     aServiceProxy.update();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h3><p>静态代理和 JDK 代理模式都要求目标对象实现一个接口，但有时候目标对象只是一个单独的对象，并没有实现任何接口，这个时候就可以使用目标对象子类来实现代理，这就是 cglib 代理。</p><ul><li><strong>cglib(Code Generation Library)是一个基于ASM(开源工具包)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。</strong>cglib 通过继承方式实现代理。它广泛的被许多AOP的框架使用，比如我们的 Spring AOP。</li><li>cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类。</li><li>cglib 代理也被叫做子类代理，它是在内存中构建一个子类对象从而实现目标对象功能扩展。</li></ul><p>至于CGLIB底层是如何动态的生成一个目标类的子类，它是使用动态字节码技术，我们知道我们编写的Java对象都是先编译为<code>.class</code>文件，然后由类加载器加载到内存中变为一个Java对象的，动态字节码技术就是通过转换字节码生成新的类来实现改变一个类的内部逻辑的。至于更基础的部分，我也没有深入的研究，有兴趣的可以自己研究一下。</p><figure class="image-box">                <img src="v2-f541ebdf0b2f894a6884166cb8a3dbd3_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>Coding</strong></p><p>添加 cglib 依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>1、不需要接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInternet</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectTo</span><span class="params">(String serverHost)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Connecting to "</span>+ serverHost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、代理工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib 代理开始，可以添加逻辑"</span>);</span><br><span class="line">        Object obj = method.invoke(target,objects);</span><br><span class="line">        System.out.println(<span class="string">"cglib 代理结束"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//工具类，类似于JDK动态代理的Proxy类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        RealInternet target = <span class="keyword">new</span> RealInternet();</span><br><span class="line">        <span class="comment">//获取代理对象,并且将目标对象传递给代理对象</span></span><br><span class="line">        RealInternet internet = (RealInternet) <span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line">        internet.connectTo(<span class="string">"so.cn"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cglib 代理开始，可以添加逻辑</span><br><span class="line">Connecting to so.cn</span><br><span class="line">cglib 代理结束</span><br></pre></td></tr></table></figure><h3 id="强大的AspectJ"><a href="#强大的AspectJ" class="headerlink" title="强大的AspectJ"></a>强大的AspectJ</h3><p><strong>SpringBoot AspectJ实现AOP:<a href="https://juejin.cn/post/6844904129240760327" target="_blank" rel="noopener">https://juejin.cn/post/6844904129240760327</a></strong></p><ul><li><strong>AspectJ的织入方式及其原理概要</strong></li></ul><p>经过前面的简单介绍，我们已初步掌握了AspectJ的一些语法和概念，但这样仍然是不够的，我们仍需要了解AspectJ应用到java代码的过程（这个过程称为织入），对于织入这个概念，可以简单理解为aspect(切面)应用到目标函数(类)的过程。</p><p>对于这个过程，一般分为动态织入和静态织入，动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如<strong>Java JDK的动态代理(Proxy，底层通过反射实现)</strong>或者<strong>CGLIB的动态代理(底层通过继承实现)</strong>，Spring AOP采用的就是基于运行时增强的代理技术，这点后面会分析，这里主要重点分析一下静态织入，<strong>ApectJ采用的就是静态织入</strong>的方式。ApectJ主要采用的是编译期织入，在这个期间使用AspectJ的acj编译器(类似javac)把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。</p><p><img src="v2-a4f70efe3e2bb0b438ea89a3ae927011_720w.png" alt="img"></p><p>关于ajc编译器，是一种能够识别aspect语法的编译器，它是采用java语言编写的，由于javac并不能识别aspect语法，便有了ajc编译器，注意ajc编译器也可编译java文件。</p><p>这里简单说明一下切点的定义语法：关键字为pointcut，定义切点，后面跟着函数名称，最后编写匹配表达式，此时函数一般使用call()或者execution()进行匹配，这里我们统一使用call()</p><blockquote><p>pointcut 函数名 : 匹配表达式</p></blockquote><p><strong>将注解设置为切点。</strong>将切点织入切面后使用环绕通知增强已经被注解标注的方法，此时就可以获得所有的注解操作，然后将日志记录入库，就可以简单实现用户的日志操作监控，当前提是在AOP中获得用户名，常见的shiro框架就有getSubject的方法获得用户名，当然根据不同的读者使用的技术不同进行获取，知识追寻者这边为了简单实现功能就没有使用一堆繁琐的方法去实现一个用户登陆认证系统；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author lsc</span><br><span class="line"> * &lt;p&gt;日志aop切面 &lt;/p&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAsp &#123;</span><br><span class="line"></span><br><span class="line">    /* *</span><br><span class="line">     * @Author lsc</span><br><span class="line">     * &lt;p&gt; 设置切点&lt;/p&gt;</span><br><span class="line">     * @Param []</span><br><span class="line">     * @Return void</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;@annotation(com.zszxz.annotation.MonitorLog)&quot;)</span><br><span class="line">    public void logPointCut() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 环绕通知</span><br><span class="line">    @Around(&quot;logPointCut()&quot;)</span><br><span class="line">    public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line">        // 开始时间</span><br><span class="line">        LocalDateTime beginTime = LocalDateTime.now();</span><br><span class="line">        // 执行方法</span><br><span class="line">        Object result = point.proceed();</span><br><span class="line">        // 结束时间</span><br><span class="line">        LocalDateTime endTime = LocalDateTime.now();</span><br><span class="line">        Duration duration = Duration.between(beginTime, endTime);</span><br><span class="line">        // 操作时长</span><br><span class="line">        long seconds = duration.getSeconds();</span><br><span class="line">        // 保存日志</span><br><span class="line">        saveLog(point,seconds);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void  saveLog(ProceedingJoinPoint point, long seconds)&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        // 获得注解</span><br><span class="line">        MonitorLog monitorLog = method.getAnnotation(MonitorLog.class);</span><br><span class="line">        if (monitorLog!=null)&#123;</span><br><span class="line">            // 获得操作类型</span><br><span class="line">            LogEnum operateType = monitorLog.operateType();</span><br><span class="line">            // 获得操作内容</span><br><span class="line">            String value = monitorLog.value();</span><br><span class="line">            System.out.printf(&quot;获得操作类型: %s , 获得操作内容: %s &quot;,operateType.getCode(),value);</span><br><span class="line"></span><br><span class="line">            //请求的参数</span><br><span class="line">            Object[] args = point.getArgs();</span><br><span class="line">            try&#123;</span><br><span class="line">                List&lt;Object&gt; objects = Arrays.asList(args);</span><br><span class="line">                System.out.println(objects);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态切换数据源案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源，切面处理类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将注释设置为切点@Pointcut("@annotation(com.tcl.platform.manager.origin.datasource.annotation.DataSource) " +"|| @within(com.tcl.platform.manager.origin.datasource.annotation.DataSource)")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"dataSourcePointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Class targetClass = point.getTarget().getClass();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line"></span><br><span class="line">        DataSource targetDataSource = (DataSource)targetClass.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        DataSource methodDataSource = method.getAnnotation(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(targetDataSource != <span class="keyword">null</span> || methodDataSource != <span class="keyword">null</span>)&#123;</span><br><span class="line">            String value;</span><br><span class="line">            <span class="keyword">if</span>(methodDataSource != <span class="keyword">null</span>)&#123;</span><br><span class="line">                value = methodDataSource.value();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                value = targetDataSource.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DynamicContextHolder.push(value);</span><br><span class="line">            logger.debug(<span class="string">"set datasource is &#123;&#125;"</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DynamicContextHolder.poll();</span><br><span class="line">            logger.debug(<span class="string">"clean datasource"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC⭐⭐⭐"><a href="#IOC⭐⭐⭐" class="headerlink" title="IOC⭐⭐⭐"></a><strong>IOC</strong>⭐⭐⭐</h2><figure class="image-box">                <img src="image-20210319234416409.png" alt="image-20210319234416409" title class>                <p>image-20210319234416409</p>            </figure><p>配置好XML文件，通过实体类的Set方法进行注入。</p><blockquote><h1 id="1-谈谈Spring-IOC得理解，原理与实现"><a href="#1-谈谈Spring-IOC得理解，原理与实现" class="headerlink" title="1. 谈谈Spring IOC得理解，原理与实现"></a>1. 谈谈Spring IOC得理解，原理与实现</h1><p><strong>总</strong>：</p><p><strong>控制反转</strong>：理论思想，原来的对象是由使用者来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理</p><p><strong>DI</strong>：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，populateBean完成属性值的注入</p><p><strong>容器</strong>：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjeacts存放完整的bean对象，整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理的(bean的生命周期)</p><p><strong>分</strong>：</p><p>1.一般聊ioc容器的时候涉及到容器的创建过程(<strong> <code>beanFactory</code>,<code>DefaultListableBeanFactory</code> </strong>),向bean工厂中设置一些参数(BeanPostProcessor,Aeare接口的子类)等等属性</p><p>2.加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition(xml或者注解的解析过程)</p><p>3.beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSupport，ConfigurationClassPostProcessor</p><p>4.BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p><p>5.通过反射的方式讲BeanDefinition对象实例化成具体的bean对象</p><p>6.<strong>bean对象的初始化过程(填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-mehtod方法，BeanPostProcessor的后置处理方法)</strong></p><p>7.生成完整的bean对象，通过getBean方法可以直接获取</p><p>8.销毁过程</p><p>面试官， 这是我对IOC的整体理解，包含了一些详细的整体过程，您有什么想要提问的？（作为结束语）</p><figure class="image-box">                <img src="image-20210905114954780.png" alt="image-20210905114954780" title class>                <p>image-20210905114954780</p>            </figure></blockquote><blockquote><h1 id="2-谈一下spring-IOC的底层实现"><a href="#2-谈一下spring-IOC的底层实现" class="headerlink" title="2. 谈一下spring IOC的底层实现"></a>2. 谈一下spring IOC的底层实现</h1><p>底层实现：工作原理，过程，数据结构，流程，设计模式，设计思想</p><p>你对他的理解和你了解过的实现过程</p><p><code>反射，工厂，设计模式，关键的几个方法</code>(不会的别说)</p><p>createBeanFactory , getBean ,doGetBean , createBean , doCreateBean,createBeanInstance(getDeclaredConstructor(),newinstance),populateBean</p><p>1.先通过createBeanFactory 创建一个Bean工厂(DefaultListableBeanFactory)</p><p>2.开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找，找不到的话，</p><p>3.通过createBean，doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造器(getDeclaredConstructor(),newinstance)</p><p>4.进行对象的属性填充populateBean</p><p>5.进行其他的初始化操作(initializingBean)</p></blockquote><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a><strong>依赖注入</strong></h3><p><strong>18. 什么是Spring的依赖注入？</strong></p><p>依赖注入，是IOC的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC容器）负责把他们组装起来。</p><h5 id="Spring是如何解决循环依赖的问题的？⭐"><a href="#Spring是如何解决循环依赖的问题的？⭐" class="headerlink" title="Spring是如何解决循环依赖的问题的？⭐"></a>Spring是如何解决循环依赖的问题的？⭐</h5><blockquote><p>三级缓存，提前暴露对象，aop</p><p><strong>总</strong>：什么是循环依赖问题，A依赖B，B依赖C，C依赖A</p><p><strong>分</strong>：先说明bean得创建过程：实例化，初始化（填充属性）</p><p>1.先创建A对象，实例化A对象，此时A对象中的b属性为空</p><p>2.从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题(不通)，找不到直接创建B对象</p><p>3.实例化B对象，此时B对象中的a属性为空，填充属性a</p><p>4.从容器中查找A对象，找不到，直接创建</p><p>此时形成了闭环，如果仔细琢磨的话，会发现A对象，是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，<br>能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于<strong>提前暴露了某个不完整对象的引用</strong>，所以解决问题的<strong> 核心在于实例化和初始化</strong>分开操作，这也是解决循环依赖问题的关键，</p><p>当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几种状态: 完成实例化但未完成初始化，完整状态，<br>因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方式来查找的。++一级缓存中放的是完整对象，二级缓存中放的是非完整对象 ++</p><p>为什么需要三级缓存？<br>三级缓存的value类型是ObjectFactory，是一个<strong> 函数式接口</strong> ，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。</p><p>如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要</p><p>普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象<strong>覆盖</strong>掉之前的普通对象，<br>在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，<br>因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()</p><p>因此，所有的bean对象在创建的时候要优先放到三级缓存中，<br>在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p></blockquote><p>细节： 缓存的放置时间和删除时间</p><p>三级缓存：createBeanInstance 之后： addSingletonFactory</p><p>二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候。同时删除三级缓存getInsingleton</p><p>一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存：addSingleton</p><p><strong>19. 有哪些不同类型的IOC（依赖注入）方式？</strong></p><ul><li><strong>构造器依赖注入：</strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>Setter方法注入：</strong>Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li></ul><p><strong>20. 哪种依赖注入方式你建议使用，构造器注入，还是 Setter方法注入？</strong></p><p>你两种依赖方式都可以使用，构造器注入和Setter方法注入。最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><p><strong>@Qualifier</strong></p><p>根据上面@Autowired的第三种情况，需要更改变量名来对应注入，这样就对程序不是很灵活，于是有了@Qualifier这个注解。@Qualifier的作用是在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用（但是在给方法参数注入时可以单独使用），因此@Qualifier注解很受限制，因此用的不是很多。<strong>@Qualifier常常组合@Autowired一起使用，用来指明具体名字的自动装配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//如果单纯一个@Autowired 注解则表示找类型为IAccuntDao的，如果有两个类型为IAccuntDao的，则接着匹配类型为IAccuntDao而且名字为accountDao的【缺点：要改变量名指定】</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"accountDao2"</span>) <span class="comment">//加上这个注解直接找类型为IAccuntDao而且名字为accountDao2的</span></span><br><span class="line"><span class="keyword">private</span> IAccuntDao accountDao;</span><br><span class="line"></span><br><span class="line">所以这段代码注解的意思就是直接找类型为IAccuntDao而且名字为accountDao的组件</span><br></pre></td></tr></table></figure><ul><li><strong>面试官：你第二点提到了spring的控制反转，能解释下吗？</strong></li><li><strong>我：首先来解释下控制反转。控制反转(Inversion Of Control，缩写为IOC)是一个重要的面向对象编程的法则来削减程序的耦合问题，也是spring框架的核心。应用控制反转，对象在被创建的时候，由一个调控系统内的所有对象的外界实体，将其所依赖的对象的引用，传递给它。也可以说，依赖被注入到对象中。所以，控制反转是关于一个对象如何获取他所依赖的对象的引用，这个责任的反转。另外，控制反转一般分为两种类型，依赖注入（Dependency Injection，简称DI）和依赖查找(Dependency Lookup)。依赖注入应用比较广泛。</strong><br><strong>还有几个常见的问题:</strong></li></ul><ol><li><strong>谁依赖谁-当然是应用程序依赖于IOC容器。</strong></li><li><strong>为什么需要依赖-应用程序需要IOC容器来提供对象需要的外部资源。</strong></li><li><strong>谁注入谁-很明显是IOC容器注入应用程序某个对象，应用程序依赖的对象</strong></li><li><strong>注入了什么-就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）</strong></li></ol><hr><p><strong>面试官：那IOC与new对象有什么区别吗</strong></p><p><strong>我：这就是正转与反转的区别。传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转。而反转则是容器来帮助我们创建并注入依赖对象。</strong></p><hr><p><strong>面试官：好的，那IOC有什么优缺点吗？</strong></p><p><strong>我：优点：很明显，实现了组件之间的解耦，提高程序的灵活性和可维护性。缺点：对象生成因为是反射编程，在效率上有些损耗。但相对于IOC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。</strong></p><hr><p><strong>面试官：spring管理这么多对象，肯定需要一个容器吧。你能说下对IOC容器的理解吗？</strong></p><p><strong>我：首先来解释下容器：在每个框架中都有个容器的概念，所谓的容器就是将常用的服务封装起来，然后用户只需要遵循一定的规则就可以达到统一、灵活、安全、方便和快速的目的。</strong></p><p><strong>我：然后IOC容器是具有依赖注入功能的容器，负责实例化、定位、配置应用程序中的对象以及建立这些对象间的依赖。</strong></p><h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a><strong>Spring事务隔离级别</strong></h3><p>采用默认的</p><p><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>    使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</p><p><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p><p><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p><p><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><hr><h3 id="事务传播机制（策略）"><a href="#事务传播机制（策略）" class="headerlink" title="事务传播机制（策略）"></a><strong>事务传播机制（策略）</strong></h3><p><strong>1、支持当前事务的情况:</strong></p><p><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong>TransactionDefinition.PROPAGATION_SUPPORTS:</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。b</p><p><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong><br> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p><p><strong>2、不支持当前事务的情况：</strong></p><p><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong><br> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p><p><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED:</strong><br> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p><strong>TransactionDefinition.PROPAGATION_NEVER：</strong><br> 以非事务方式运行，如果当前存在事务，则抛出异常。</p><p><strong>3、嵌套情况：</strong></p><p><strong>TransactionDefinition.PROPAGATION_NESTED：</strong><br> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</p><p>不论使用<code>REQUIRES_NEW</code>或是<code>NESTED</code>，在调用B的invoke时如果发生异常，都能正确完成业务逻辑</p><ul><li><code>REQUIRES_NEW</code>执行到B时，A事物被挂起，B会新开了一个事务进行执行，B发生异常后，B中的修改都会回滚，然后外部事物继续执行</li><li><code>NESTED</code>执行到B时，会创建一个<code>savePoint</code>，如果B中执行失败，会将数据回滚到这个<code>savePoint</code></li></ul><p>重点来了，如果B处正常执行，就会产生区别了</p><ul><li><code>REQUIRES_NEW</code>如果B正常执行，则B中的数据在A提交之前已经完成提交，其他线程已经可见其修改，这就意味着可能有脏数据的产生；同时，如果接下来A的其他逻辑发生了异常，A回滚，但是B已经完成提交，不会回滚了。当然，如果A接下来的逻辑没有相关要求，那就无所谓了</li><li><code>NESTED</code>如果B正常执行，此时B中的修改并不会立即提交，而是在A提交时一并提交，如果A下面的逻辑中发生异常，A回滚时，B中的修改也会回滚，就可以避免上述情况的发生</li></ul><p>某一个事务嵌套另外一个事务的时候怎么办？</p><blockquote><h3 id="A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？"><a href="#A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？" class="headerlink" title="A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？"></a>A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</h3></blockquote><hr><p><strong>总</strong>：事务的传播特性指的是不同方法的嵌套调用过程中，事务该如何进行处理，是同一个事务还是不同的事务，当出现异常的时候会回滚还是提交，两个方法之间相互影响，在日常工作中，使用比较多的是required，Requireds_new</p><p><strong>分</strong>：1.先说事务的不同分类，可以分为三类，支持当前事务，不支持当前事务，嵌套事务</p><p>​        2.如果外层方法是required，内层方法是：required，requireds_new,nested</p><p>​        3.如果外层方法是requireds_new，内层方法是：required，requireds_new,nested</p><p>​        4.如果外层方法是nested，内层方法是：required，requireds_new,nested</p><p>核心处理逻辑非常简单：</p><p>1.判断内外方法是否是同一事务：</p><p>​        是：异常统一在外层方法处理</p><p>​        不是：内层方法有可能影响到外层方法，但是外层方法是不会影响内层方法的</p><p>​        （大致可以这么理解，但是有个别情况不同，nested）</p><hr><h3 id="事务超时属性"><a href="#事务超时属性" class="headerlink" title="事务超时属性"></a><strong>事务超时属性</strong></h3><p>  所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p><hr><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a><strong>事务只读属性</strong></h3><p>  事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。</p><hr><h3 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a><strong>回滚规则</strong></h3><p>  这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><blockquote><h1 id="Spring的事务是如何回滚的？"><a href="#Spring的事务是如何回滚的？" class="headerlink" title="Spring的事务是如何回滚的？"></a>Spring的事务是如何回滚的？</h1><p>spring的事务管理是如何实现的？</p><p>总：spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知实现的，而是通过一个<strong>TransactionInterceptor</strong>来实现的，然后<strong>调用invoke</strong>来实现具体的逻辑</p><p>分：1.先做准备工作，解析各个方法上事务相关的属性，根据具体的属性来判断是否开始新事务</p><p>​        2.当需要开启的时候，获取数据库连接，关闭自动提交功能，开启事务</p><p>​        3.执行具体的sql逻辑操作</p><p>​        4.在操作过程中，如果执行失败了，那么会通过<u>completeTransactionAfterThrowing</u>看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是要先获取链接对象，通过<code>连接对象</code>来回滚。</p><p>​        5.如果执行过程中，没有任何意外情况的发生，那么通过c<u>ommitTransactionAfterReturning</u>来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实现的，实现的时候也要获取链接，通过链接对象来提交</p><p>​        6.当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo</p><p>如果想要聊的更加细致的话，需要知道TransactionInfo，TransactionsStatus</p></blockquote><h1 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a><strong>Mysql数据库</strong></h1><h2 id="sql语句解析顺序"><a href="#sql语句解析顺序" class="headerlink" title="sql语句解析顺序"></a><strong>sql语句解析顺序</strong></h2><p><strong><figure class="image-box">                <img src="image-20210305162751070.png" alt="image-20210305162751070" title class>                <p>image-20210305162751070</p>            </figure></strong></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h2><p><strong>Q：如何解决幻读？</strong></p><blockquote><p><strong>幻读是因为在事务进行期间，有其他事务向当前表插入数据</strong></p></blockquote><p><strong>ACID原则：</strong></p><p><strong>原子性Atomicity：要么都成功，要么都失败。</strong></p><p><strong>一致性Consistency：前后数据的完整性要保持一致。</strong></p><p><strong>隔离性Isolation：多个用户并发访问的时候，数据库为每个用户都开启事务，不能被其他事务所干扰。</strong></p><p><strong>持久性Durability：事务提交后不可逆转。</strong></p><p><strong>事务的四种隔离级别</strong></p><p><strong>Read Unconnitted 读未提交：</strong></p><blockquote><p> <strong>所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。</strong></p></blockquote><p><strong>Read Connitted读已提交：</strong></p><blockquote><p><strong>这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。它满足了隔离的简单定义: 一个事务只能看见已经提交事务所做的改变。这种隔高级别也支持所谓的不可重复读</strong></p><p><strong>(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的commit,所以同一select可能返回不同结果。</strong></p></blockquote><p><strong>Repeatable Read可重复读：</strong></p><blockquote><p><strong>这是MySQL的默认事务隔离级别，它确保同- -事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上,这会导致另一个棘手的问题:幻读(Phantom Read)。简单的说，幻读指当用户读取某-范围的数据行时， 另- -个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影”行。InnoDB和Falcon存 储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)机制解决了该问题。</strong></p></blockquote><p><strong>Serializable 串行化：</strong></p><blockquote><p><strong>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突,从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</strong></p></blockquote><p><strong>事务并发产生的问题</strong></p><p><strong>脏读：A事务读取了B事务未提交的数据，但是B如果执行回滚，则A读取的为脏数据</strong></p><p><strong>不可重复读：A事务读取了数据，B事务对该数据进行了修改并提交，A再次读取时</strong></p><p><strong>幻读：A事务两次查询的数据行数不一样，可能是由于B事务插入了新数据。</strong></p><blockquote><h1 id="ACID是靠什么保证的？"><a href="#ACID是靠什么保证的？" class="headerlink" title="ACID是靠什么保证的？"></a>ACID是靠什么保证的？</h1><p>原子性由undolog日志来保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</p><p>一致性是由其他三大特性保证，程序代码要保证业务上的一致性</p><p>隔离性是由MVCC来保证</p><p>持久性由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失</p></blockquote><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a><strong>数据库引擎</strong></h2><p><strong>MyISAM 和InnoDB区别：</strong></p><ol><li><strong>MyISAM是非事务安全的，而InnoDB是事务安全的</strong></li><li><strong>MyISAM锁的粒度是表级的，而InnoDB支持行级锁</strong></li><li><strong>MyISAM支持全文类型索引，而InnoDB不支持全文索引</strong></li><li><strong>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</strong></li><li><strong>MyISAM表保存成文件形式，跨平台使用更加方便</strong></li></ol><p><strong>应用场景：</strong></p><p><strong>1、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果再应用中执行大量select操作，应该选择MyISAM</strong></p><p><strong>2、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，应该选择InnoDB</strong></p><p><strong><figure class="image-box">                <img src="image-20210305145252564.png" alt="image-20210305145252564" title class>                <p>image-20210305145252564</p>            </figure></strong></p><h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a><strong>锁</strong></h2><p><strong>show open tables:查看当前库所有表的锁使用情况。</strong></p><p><strong><figure class="image-box">                <img src="image-20210308021228997.png" alt="image-20210308021228997" title class>                <p>image-20210308021228997</p>            </figure></strong></p><p><strong>show status like ‘Table%’: 表的锁定情况。</strong></p><p><strong><figure class="image-box">                <img src="image-20210308021217218.png" alt="image-20210308021217218" title class>                <p>image-20210308021217218</p>            </figure></strong></p><p><strong>锁分类</strong></p><p><strong>从操作粒度分</strong></p><p><strong>表锁：锁定表</strong></p><p><strong>行锁：锁定指定表中的行</strong></p><p><strong>从操作类型分</strong></p><p><strong>读锁（共享锁）：</strong></p><p><strong>写锁（排他锁）：</strong></p><p><strong><figure class="image-box">                <img src="image-20210308020426981.png" alt="image-20210308020426981" title class>                <p>image-20210308020426981</p>            </figure></strong></p><p><strong>锁升级</strong></p><p><strong>当sql语句中索引失效时，行锁将会升级为表锁。</strong></p><p><strong>间隙锁</strong></p><p><strong>sql语句是作用于范围时，若1 2 3【4为间隙】  5，间隙将被锁定。</strong></p><p><strong>锁优化建议！！！！！！！！！！</strong></p><p><strong><figure class="image-box">                <img src="image-20210308030836304.png" alt="image-20210308030836304" title class>                <p>image-20210308030836304</p>            </figure></strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><p><strong>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是有序的数据结构。</strong></p><figure class="image-box">                <img src="image-20210901175227062.png" alt="image-20210901175227062" title class>                <p>image-20210901175227062</p>            </figure><p><strong>聚簇索引：叶子节点存放的是整行的数据。</strong></p><blockquote><p><strong>如果表设置了主键，则主键就是聚簇索引</strong></p><p><strong>如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引</strong>  </p><p><strong>以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引</strong></p></blockquote><p><strong>非聚簇索引（普通索引）：</strong></p><blockquote><p><strong>普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。</strong></p></blockquote><p><strong>回表：</strong></p><blockquote><p><strong>如果查询条件为普通索引 （非聚簇索引）where 后的条件不是索引，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。</strong></p><p><strong>需要扫描两次索引B+树， 。</strong></p></blockquote><p><strong>索引覆盖：</strong></p><blockquote><p><strong>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</strong></p></blockquote><blockquote><p><strong>常见的方法是：将被查询的字段，建立到联合索引里去。</strong></p><p><strong>1、如实现：select id,age fro m user where age = 10;</strong></p><p><strong>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引</strong></p></blockquote><p><strong><figure class="image-box">                <img src="1702e72ac250a40f" alt="MySQL 的覆盖索引与回表" title class>                <p>MySQL 的覆盖索引与回表</p>            </figure></strong></p><p><strong>索引失效条件</strong></p><ul><li><strong>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></li><li><strong>存储引擎不能使用索引范围条件右边的列</strong></li><li><strong>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</strong></li><li><strong>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</strong></li><li><strong>is null,is not null也无法使用索引</strong></li><li><strong>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操</strong></li></ul><p><strong>二叉排序树</strong></p><p><strong>在介绍B树之前，先来看另一棵神奇的树——二叉排序树（Binary Sort Tree），首先它是一棵树，“二叉”这个描述已经很明显了，就是树上的一根树枝开两个叉，于是递归下来就是二叉树了（下图所示），而这棵树上的节点是已经排好序的，具体的排序规则如下：</strong></p><ul><li><strong>若左子树不空，则左子树上所有节点的值均小于它的根节点的值</strong></li><li><strong>若右子树不空，则右字数上所有节点的值均大于它的根节点的值</strong></li><li><strong>它的左、右子树也分别为二叉排序数（递归定义）</strong></li><li><strong><figure class="image-box">                <img src="758447-20180126164904240-511277096.png" alt="img" title class>                <p>img</p>            </figure></strong></li></ul><p><strong>B树</strong></p><p><strong>B树的特点可以总结为如下：</strong></p><ol><li><strong>关键字集合分布在整颗树中。</strong></li><li><strong>任何一个关键字出现且只出现在一个节点中。</strong></li><li><strong>搜索有可能在非叶子节点结束。</strong></li><li><strong>其搜索性能等价于在关键字集合内做一次二分查找。</strong></li><li><strong>B树在插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。</strong></li></ol><p><strong><figure class="image-box">                <img src="758447-20180126165126756-1850778539.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>B+树</strong></p><p><strong>作为B树的加强版，B+树与B树的差异在于</strong></p><ul><li><strong>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。</strong></li><li><strong>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</strong></li><li><strong>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</strong></li></ul><p><strong><figure class="image-box">                <img src="758447-20180126171338850-1455023219.png" alt="img" title class>                <p>img</p>            </figure></strong></p><p><strong>1、B+树的层级更少：相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</strong></p><p><strong>2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</strong></p><p><strong>3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</strong></p><p><strong>4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</strong></p><p><strong>B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</strong></p><p><strong>B+树多高?</strong></p><p>这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。</p><p><strong>InnoDB的默认一页大小是【16k】</strong>，一页即<strong>叶子节点</strong>的存储空间。</p><p>上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。</p><p>那么现在我们需要计算出非叶子节点能存放多少指针，其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，<strong>而指针大小在InnoDB源码中设置为6字节</strong>，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。</p><p>根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170<em>1170</em>16=21902400条这样的记录。所以在InnoDB中B+树高度一般为1-3层，这就能满足千万级的数据存储。在查找数据时，一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查到数据。</p><h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a><strong>最左前缀法则</strong></h2><h2 id="数据库优化（重要重要！）"><a href="#数据库优化（重要重要！）" class="headerlink" title="数据库优化（重要重要！）"></a><strong>数据库优化（重要重要！）</strong></h2><p><strong>定位低效原因方式</strong></p><p>·</p><h3 id="定位低效率的SQL查询语句"><a href="#定位低效率的SQL查询语句" class="headerlink" title="定位低效率的SQL查询语句"></a><strong>定位低效率的SQL查询语句</strong></h3><p><strong>explain分析执行计划</strong></p><p><strong><figure class="image-box">                <img src="image-20210307171257288.png" alt="image-20210307171257288" title class>                <p>image-20210307171257288</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307173624838.png" alt="image-20210307173624838" title class>                <p>image-20210307173624838</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307181719755.png" alt="image-20210307181719755" title class>                <p>image-20210307181719755</p>            </figure></strong></p><p><strong>show profile：显示对应Query ID在每个阶段的耗时情况</strong></p><h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a><strong>优化手段</strong></h3><p><strong>联合索引：</strong></p><p><strong>为什么要使用联合索引？</strong></p><blockquote><ul><li><strong>减少开销。建一个联合索引 <code>(col1,col2,col3)</code>，实际相当于建了 <code>(col1)</code>，<code>(col1,col2)</code>，<code>(col1,col2,col3)</code> 三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！</strong></li><li><strong>覆盖索引。对联合索引 <code>(col1,col2,col3)</code>，如果有如下的 SQL：<code>select col1,col2,col3 from test where col1=1 and col2=2;</code>。那么 MySQL 可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机 IO 操作。减少 IO 操作，特别的随机 IO 其实是 DBA 主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</strong></li><li><strong>效率高。索引列越多，通过索引筛选出的数据越少。有 1000W 条数据的表，有如下 SQL：<code>select from table where col1=1 and col2=2 and col3=3</code>，假设假设每个条件可以筛选出 10% 的数据，如果只有单值索引，那么通过该索引能筛选出 1000W10%=100w 条数据，然后再回表从 100w 条数据中找到符合 col2=2 and col3=3 的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出 1000w <em> 10% </em> 10% * 10% =1w，效率提升可想而知！</strong></li></ul></blockquote><p><strong>批量插入数据</strong></p><p><strong>索引维护列数据有序导入效率比无序数据效率高。</strong></p><blockquote><p><strong>插入数据时需要维护索引树，有序数据的索引树创建的更快。</strong></p></blockquote><p><strong>关闭唯一性校验</strong></p><blockquote><p><strong>当插入时，Mysql会对主键进行唯一性校验，关闭唯一性校验以后，插入数据时不需要唯一性校验主键，效率提高。</strong></p></blockquote><p><strong>手动提交事务</strong></p><p><strong>聚合函数（常用）</strong></p><p><strong><figure class="image-box">                <img src="image-20210308031636317.png" alt="image-20210308031636317" title class>                <p>image-20210308031636317</p>            </figure></strong></p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h3><p><strong><figure class="image-box">                <img src="image-20210309052439562.png" alt="image-20210309052439562" title class>                <p>image-20210309052439562</p>            </figure></strong></p><h3 id="应用优化"><a href="#应用优化" class="headerlink" title="应用优化"></a><strong>应用优化</strong></h3><p><strong><figure class="image-box">                <img src="image-20210309061028463.png" alt="image-20210309061028463" title class>                <p>image-20210309061028463</p>            </figure></strong></p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h2><p><strong>慢查询日志</strong></p><p><strong>show proceslist：查看实时的SQL语句执行情况</strong></p><p><strong><figure class="image-box">                <img src="image-20210307171113409.png" alt="image-20210307171113409" title class>                <p>image-20210307171113409</p>            </figure></strong></p><p><strong><figure class="image-box">                <img src="image-20210307171134186.png" alt="image-20210307171134186" title class>                <p>image-20210307171134186</p>            </figure></strong></p><p><strong>binlog、undolog</strong></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h1><p><strong>为了保证事务的持久性</strong>，mysql的InnoDB采用了WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。<br> 具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。<br> InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><figure class="image-box">                <img src="webp.webp" alt="img" title class>                <p>img</p>            </figure><p> write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示redo log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。<br> <strong>为什么会有两份日志呢？</strong>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><h2 id="DDL、DML、DCL、TCL"><a href="#DDL、DML、DCL、TCL" class="headerlink" title="DDL、DML、DCL、TCL"></a>DDL、DML、DCL、TCL</h2><p>DDL（Data Definition Languages）语句：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME。增删改表的结构</p><p>DML（Data Manipulation Language）语句：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE,包括通用性的增删改查。增删改表的数据</p><p>DCL（Data Control Language）语句：即数据控制语句，用于授权/撤销数据库及其字段的权限（DCL is short name of Data Control Language which includes commands such as GRANT and mostly concerned with rights, permissions and other controls of the database system.）。常用的语句关键字有：GRANT,REVOKE。</p><p>TCL（Transaction Control Language）语句：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION。</p><h2 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h2><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a><strong>主从复制的原理</strong></h2><p>首先放一张Mysql主从复制的原理图，总的来说Mysql的主从复制原理还是比较好理解的，原理非常的简单。</p><p><img src="v2-12f36a0aa2ea88020809173182e54e73_b.jpg" alt="img" style="zoom:67%;"></p><p>Mysql的主从复制中主要有三个线程：<code>master（binlog dump thread）、slave（I/O thread 、SQL thread）</code>，Master一条线程和Slave中的两条线程。</p><p><code>master（binlog dump thread）</code>主要负责Master库中有数据更新的时候，会按照<code>binlog</code>格式，将更新的事件类型写入到主库的<code>binlog</code>文件中。</p><p>并且，Master会创建<code>log dump</code>线程通知Slave主库中存在数据更新，这就是为什么主库的binlog日志一定要开启的原因。</p><p><code>I/O thread</code>线程在Slave中创建，该线程用于请求Master，Master会返回binlog的名称以及当前数据更新的位置、binlog文件位置的副本。</p><p>然后，将<code>binlog</code>保存在 <strong>「relay log（中继日志）」</strong> 中，中继日志也是记录数据更新的信息。</p><p>SQL线程也是在Slave中创建的，当Slave检测到中继日志有更新，就会将更新的内容同步到Slave数据库中，这样就保证了主从的数据的同步。</p><p>以上就是主从复制的过程，当然，主从复制的过程有不同的策略方式进行数据的同步，主要包含以下几种：</p><ol><li><strong>「同步策略」</strong>：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。</li><li><strong>「半同步策略」</strong>：Master至少会等待一个Slave回应后提交。</li><li><strong>「异步策略」</strong>：Master不用等待Slave回应就可以提交。</li><li><strong>「延迟策略」</strong>：Slave要落后于Master指定的时间。</li></ol><h1 id="MVVC"><a href="#MVVC" class="headerlink" title="MVVC"></a>MVVC</h1><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h1><p><strong>八大数据类型：</strong></p><ul><li><strong>string：最基本的数据类型，二进制安全的字符串，最大512M</strong></li><li><strong>list：按照添加顺序保持顺序的 字符串列表</strong></li><li><strong>set：无序的字符串集合，不存在重复的元素</strong></li><li><strong>sorted set：已排序的字符串集合</strong></li><li><strong>hash：key/value对的一种集合</strong></li></ul><p><strong>string（字符串）</strong></p><p><strong>二进制安全</strong></p><p><strong>可以包含任何数据，比如jpg图片或者序列化对象</strong></p><p><strong>Hash（字典）</strong></p><p><strong>键值对集合，即编程语言中的map类型</strong></p><p><strong>适合存储对象，并且可以像数据库中的update一个属性一样只修改某一项属性值</strong></p><p><strong>存储、读取、修改用户属性</strong></p><p><strong>List（列表）</strong></p><p><strong>链表（双向链表）</strong></p><p><strong>增删快，提供了操作某一元素的api</strong></p><p><strong>最新消息排行；消息队列</strong></p><p><strong>set（无重复集合）</strong></p><p><strong>hash表实现，元素不重复</strong></p><p><strong>添加、删除、查找的复杂度都是O(1)，提供了求交集、并集、差集的操作</strong></p><p><strong>共同好友；利用唯一性，统计访问网站的所有Ip</strong></p><p><strong>Zset（自动排序无重复集合）</strong></p><p><strong>ZSet可以实现有序性操作，从而实现排行榜等功能；（以访问量为分数进行排列）</strong></p><hr><hr><p><strong>Redis的优势</strong></p><ul><li><strong>速度快。因为数据存储于内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</strong></li><li><strong>支持丰富的数据类型，支持string，list，set，sorted set，hash</strong></li><li><strong>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</strong></li><li><strong>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</strong></li></ul><p><strong>Redis为什么这么快？</strong></p><p><strong>第一：Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)。第二：数据结构简单，对数据操作也简单。第三：采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。第四：使用多路复用IO模型，非阻塞IO。</strong></p><hr><h2 id="缓存产生的问题"><a href="#缓存产生的问题" class="headerlink" title="缓存产生的问题"></a><strong>缓存产生的问题</strong></h2><p><strong>缓存穿透：</strong></p><blockquote><p><strong>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</strong></p></blockquote><p><strong>如何避免？</strong></p><ol><li><strong>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</strong></li><li><strong>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</strong></li></ol><hr><p><strong>缓存雪崩</strong></p><blockquote><p><strong>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力，导致系统崩溃。</strong></p><p><strong>目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</strong></p></blockquote><p><strong>如何避免？</strong></p><ol><li><strong>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</strong></li><li><strong>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期 3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</strong></li></ol><hr><h2 id="Redis内存回收机制"><a href="#Redis内存回收机制" class="headerlink" title="Redis内存回收机制"></a><strong>Redis内存回收机制</strong></h2><p><strong>Redis的内存回收主要围绕以下两个方面：</strong></p><ol><li><strong><a href="#1">Redis过期策略</a>：删除过期时间的key值</strong></li><li><strong><a href="#2">Redis淘汰策略</a>：内存使用到达maxmemory上限时触发内存淘汰数据</strong></li></ol><p><strong>Redis过期策略<a name="1"></a></strong></p><p><strong>Redis过期策略通常有以下三种：</strong></p><ol><li><strong>定时过期 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</strong></li><li><strong>惰性过期 只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</strong></li><li><strong>定期过期 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</strong></li></ol><p><strong>【Redis中同时使用了惰性过期和定期过期两种过期策略。】</strong></p><p><strong>Q:Redis key的过期时间和永久有效分别怎么设置？</strong></p><blockquote><p><strong><code>EXPIRE</code>和<code>PERSIST</code>命令。</strong></p></blockquote><hr><p><strong>Redis有哪几种数据淘汰策略<a name="2"></a></strong></p><p><strong>在Redis中，允许用户设置最大使用内存大小<code>server.maxmemory</code>，当Redis内存数据集大小上升到一定大小的时候，就会执行数据淘汰策略</strong></p><ul><li><strong>volatile-lru：从已设置过期的数据集中挑选最近最少使用的淘汰</strong></li><li><strong>volatile-ttl：从已设置过期的数据集中挑选将要过期的数据淘汰</strong></li><li><strong>volatile-random：从已设置过期的数据集中任意挑选数据淘汰</strong></li><li><strong>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</strong></li><li><strong>allkeys-random：从数据集中任意挑选数据淘汰</strong></li><li><strong>noenviction：禁止淘汰数据</strong></li></ul><h2 id="02-redis是单线程还是多线程"><a href="#02-redis是单线程还是多线程" class="headerlink" title="02.redis是单线程还是多线程"></a>02.redis是单线程还是多线程</h2><p>1, 无论什么版本,工作线程就是一个</p><p>2, 6.x高版本出现了IO多线程</p><p>3,使用上来说,没有变化</p><hr><p>4, [去学一下系统IO课],你要真正的理解面向IO模型编程的时候,有内核的事,从内核把数据搬运到程序里这是第一步,然后,搬运回来的数据做的计算是第二步,netty</p><p>5,单线程,满足redis的串行原子,只不过IO多线程后,把输入/输出放到更多的线程里去并行,好处如下: 1,执行时间短,更快; 2,更好的压榨系统及硬件的资源(网卡能够高效的使用);</p><p>*,客户端被读取的顺序不能被保障<br>哪个顺序是可以被保障的: 在一个连接里,socket里</p><p>6.x以前</p><figure class="image-box">                <img src="image-20210309122215735.png" alt="6.x以前" title class>                <p>6.x以前</p>            </figure>缓存不严谨,尽量去分片<br><br><br><br><br><br> 6.x以后<br><br><figure class="image-box">                <img src="image-20210309123037436.png" alt="6.x以后" title class>                <p>6.x以后</p>            </figure><h1 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h1><h1 id="redis的分布式布隆过滤器"><a href="#redis的分布式布隆过滤器" class="headerlink" title="redis的分布式布隆过滤器"></a>redis的分布式布隆过滤器</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>老顾先来举个常会问到的面试题：现有<strong>50亿个电话号码，现有10万个电话号码</strong>，如何要<strong>快速准确的判断这些电话号码是否已经存在？</strong></p><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-f078b9444162b88f79ea8cf98063ab5e_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上面的问题可以细化一下，也就是50亿个电话号码在数据库中，现在要<strong>快速、准确</strong>的判断提供的10万个电话号码是否存在。</p><p>我们小伙伴们是否脑子中会有以下方案：</p><figure class="image-box">                <img src="v2-be68dbd9576a4d485574703f606e786b_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>实际项目中也会遇到类似的问题，如垃圾邮件过滤、网络爬虫重复url检测等，<strong>本质就是判断数据存不存在一个大的集合中。</strong></p><p>那如何去解决呢？这就是我们今天老顾要介绍的布隆过滤器方案，我们继续往下看。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是<strong>一种类似set的数据结构</strong>，只是不太准确，当判断元素<strong>是否存在时返回结果存在但真实不一定存在</strong>；当<strong>返回不存在时肯定是不存在</strong>，所以判断去重时有一定的误判概率。</p><blockquote><p>当然，误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判。</p></blockquote><p><strong>特点：高效地插入和查询，占用空间少，返回的结果是不确定性的。</strong></p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>这个是由柏顿.布隆在1970年提出，<strong>用很小的空间，解决上述的类似问题。</strong></p><p>实现原理就是我们需要一个<strong>很长的二进制数组（也叫向量）</strong>；在添加数据时，使用<strong>多个hash函数对key进行hash运算得到一个索引值（即二进制数组的索引值）</strong></p><figure class="image-box">                <img src="v2-984115177dfcb0ec6c61d78360bc6c3b_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上图中，下面是很长的二进制数组，第二层就是多个hash函数，再上面就是数据。</p><figure class="image-box">                <img src="v2-43a8efe34ad3a8e72d182ed2b645af61_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>上图中，每个数据经过多个hash函数计算，得到索引值，并把<strong>二进制数组对应的索引值那边设置为1，我们发现经过三次hash</strong>，<strong>就会在三个索引的地方设置为1，也就是代表此数据存在。</strong></p><h2 id="布隆过滤器误差"><a href="#布隆过滤器误差" class="headerlink" title="布隆过滤器误差"></a>布隆过滤器误差</h2><p><strong>空间占用</strong></p><p>布隆过滤器的空间占用有一个简单的计算公式，但推导比较繁琐。布隆过滤器有两个参数，<strong>预计元素数量n</strong>，错误率f，公式得到两个输出，<strong>位数组长度L（即存储空间大小bit）</strong>，hash函数的最佳数量k。</p><p>k = 0.7*(1/n)<br>f = 0.6185^(L/n)</p><figure class="image-box">                <img src="v2-d0db1392f878a2898eec29647f6ce17d_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>实际元素超出时</strong></p><figure class="image-box">                <img src="https://pic3.zhimg.com/80/v2-2920bb0c45ccd76f6d1bca22ae9463e2_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><p>以上小伙伴们只要知道会存在误差就行了，不需要强求是怎么计算的。</p><h2 id="Redis布隆过滤器的基本使用"><a href="#Redis布隆过滤器的基本使用" class="headerlink" title="Redis布隆过滤器的基本使用"></a>Redis布隆过滤器的基本使用</h2><p>在Redis中，布隆过滤器有两个基本命令，分别是：</p><ul><li><strong>bf.add</strong>：<strong>添加元素到布隆过滤器中</strong>，类似于集合的<strong>sadd</strong>命令，不过<strong>bf.add</strong>命令只能一次添加一个元素，如果想一次添加多个元素，可以使用<strong>bf.madd</strong>命令。</li><li><strong>bf.exists</strong>：<strong>判断某个元素是否在过滤器中</strong>，类似于集合的<strong>sismember</strong>命令，不过<strong>bf.exists</strong>命令只能一次查询一个元素，如果想一次查询多个元素，可以使用<strong>bf.mexists</strong>命令。</li></ul><figure class="image-box">                <img src="v2-592b76212a0848532ad61843440bbbe7_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="布隆过滤器的高级使用"><a href="#布隆过滤器的高级使用" class="headerlink" title="布隆过滤器的高级使用"></a>布隆过滤器的高级使用</h2><p>上面的例子中使用的布隆过滤器<strong>只是默认参数的布隆过滤器</strong>，它在我们第一次使用 bf.add 命令时自动创建的。Redis还提供了<strong>自定义参数的布隆过滤器</strong>，想要尽量减少布隆过滤器的误判，就要设置合理的参数。</p><p>在使用 <strong>bf.add</strong> 命令添加元素之前，<strong>使用bf.reserve</strong> <strong>命令创建一个自定义的布隆过滤器</strong>。<strong>bf.reserve</strong>命令有三个参数，分别是：</p><ul><li><strong>key</strong>：键</li><li><strong>error_rate</strong>：期望错误率，期望错误率越低，需要的空间就越大。</li><li><strong>capacity</strong>：初始容量，当实际元素的数量超过这个初始化容量时，误判率上升。</li></ul><p>比如：</p><figure class="image-box">                <img src="v2-4e8ffdee45bb0ca9a570c617ea83a3ed_1440w.jpg" alt="img" title class>                <p>img</p>            </figure><blockquote><p>如果对应的key已经存在时，在执行bf.reserve命令就会报错。如果不使用bf.reserve命令创建，而是使用Redis自动创建的布隆过滤器，默认的error_rate是 0.01，capacity是 100。</p></blockquote><p>布隆过滤器的<strong>error_rate</strong> 越小，需要的存储空间就越大，对于不需要过于精确的场景，<strong>error_rate</strong>设置稍大一点也可以。布隆过滤器的<strong>capacity</strong>设置的过大，会浪费存储空间，设置的过小，就会影响准确率，所以在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出设置值很多。总之，<strong>error_rate</strong>和<strong>capacity</strong>都需要设置一个合适的数值。</p><h2 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h2><p><strong>解决缓存穿透的问题</strong></p><p>一般情况下，<strong>先查询缓存是否有该条数据，缓存中没有时，再查询数据库。</strong>当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。缓存穿透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。</p><p>可以使用布隆过滤器解决缓存穿透的问题，<strong>把已存在数据的key存在布隆过滤器中。当有新的请求时，先到布隆过滤器中查询是否存在，如果不存在该条数据直接返回</strong>；如果存在该条数据再查询缓存查询数据库。</p><p><strong>黑名单校验</strong></p><p>发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。<strong>把所有黑名单都放在布隆过滤器中，再收到邮件时，判断邮件地址是否在布隆过滤器中即可。</strong></p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP四层模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层（Application）</td><td>应用层</td><td>HTTP、TFTP, FTP, NFS, WAIS、SMTP</td></tr><tr><td>表示层（Presentation）</td><td>Telnet, Rlogin, SNMP, Gopher</td><td></td></tr><tr><td>会话层（Session）</td><td>SMTP, DNS</td><td></td></tr><tr><td>传输层（Transport）</td><td>传输层</td><td>TCP, UDP</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP, ICMP, ARP, RARP, AKP, UUCP</td></tr><tr><td>数据链路层（Data Link）</td><td>数据链路层</td><td>FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td></tr><tr><td>物理层（Physical）</td><td>IEEE 802.1A, IEEE 802.2到IEEE 802.11</td></tr></tbody></table><h2 id="在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a><strong>在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</strong></h2><p><strong>总体来说分为以下几个过程:</strong></p><ol><li><strong>DNS解析</strong></li><li><strong>TCP连接</strong></li><li><strong>发送HTTP请求</strong></li><li><strong>服务器处理请求并返回HTTP报文</strong></li><li><strong>浏览器解析渲染页面</strong></li><li><strong>连接结束</strong></li></ol><p><strong>具体可以参考下面这篇文章：</strong></p><p><strong>假设输入的URL是包含域名的，那肯定会涉及到DNS解析。当然，如果URL仅仅是IP，那就不会涉及到DNS的。域名的出现是为了方便记忆，因为域名比IP好记。我们这里假设URL包含域名。</strong></p><p><strong>解析的步骤大致如下图：</strong></p><p><strong><figure class="image-box">                <img src="1249-20181201164228952-1248762918.png" alt="img" title class>                <p>img</p>            </figure></strong></p><hr><p><strong>首先，在本地域名服务器中根据域名查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求。</strong></p><p><strong>如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器（TLD）发送一个请求，依次类推下去。</strong></p><p><strong>直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。</strong></p><h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a><strong>TCP/IP协议</strong></h2><p> <img src="image-20210404234920439.png" alt="image-20210404234920439" style="zoom: 80%;"></p><p>​    </p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h3><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a><strong>三次握手</strong></h3><table><thead><tr><th></th><th><strong>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</strong></th></tr></thead><tbody><tr><td></td><td><strong>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</strong></td></tr><tr><td></td><td><strong>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</strong></td></tr></tbody></table><p><strong>TCP三次握手的Socket过程</strong></p><hr><p><strong><figure class="image-box">                <img src="clip_image001-1605197589861-1613496648112.png" alt="640?wx_fmt=png" title class>                <p>640?wx_fmt=png</p>            </figure></strong></p><hr><ul><li><p><strong>服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待；</strong></p></li><li><p><strong>客户端Socket对象调用connect()向服务器发送了一个SYN并阻塞；</strong></p></li><li><p><strong>服务器完成了第一次握手，即发送SYN和ACK应答；</strong></p></li><li><p><strong>客户端收到服务端发送的应答之后，从connect()返回，再发送一个ACK给服务器；</strong></p></li><li><p><strong>服务器Socket对象接收客户端第三次握手ACK确认，此时服务端从accept()返回，建立连接。</strong></p></li></ul><hr><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h3><table><thead><tr><th></th><th><strong>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</strong></th></tr></thead><tbody><tr><td></td><td><strong>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</strong></td></tr><tr><td></td><td><strong>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</strong></td></tr><tr><td></td><td><strong>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</strong></td></tr></tbody></table><hr><ol><li>第一次挥手，客户端设置seq和 ACK ,向服务器发送一个 FIN(终结)报文段。此时，客户端进入 FIN_WAIT_1状态，表示客户端没有数据要发送给服务端了。</li><li>第二次挥手，服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。</li><li>第三次挥手，服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</li><li>第四次挥手，客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，<strong>客户端等待2MSL（指一个片段在网络中最大的存活时间）</strong>后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。四次挥手</li></ol><p><strong>四次挥手释放连接时，等待2MSL的意义？</strong></p><blockquote><p><strong>MSL</strong>是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间<code>等待计时器</code>。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p><strong>为什么要三次握手</strong></p><ul><li><strong>三次握⼿的⽬的是建⽴可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，⽽三次握⼿最主     要的⽬的就是双⽅确认⾃⼰与对⽅的发送与接收是正常的。</strong></li><li><strong>第⼀次握⼿：Client     什么都不能确认；Server 确认了对⽅发送正常，⾃⼰接收正常</strong></li><li><strong>第⼆次握⼿：Client     确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：对⽅发送 正常，⾃⼰接收正常</strong></li><li><strong>第三次握⼿：Client     确认了：⾃⼰发送、接收正常，对⽅发送、接收正常；Server 确认了：⾃⼰发 送、接收正常，对⽅发送、接收正常</strong></li><li><strong>所以三次握⼿就能确认双发收发功能都正常，缺⼀不可。</strong></li></ul><hr><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h2><p><strong>UDP通讯协议的特点</strong></p><hr><ul><li><strong>将数据封装为数据包。面向无连接。</strong></li><li><strong>每个数据包大小限制在64K。</strong></li><li><strong>因为无连接，所以不可靠。</strong></li><li><strong>因为不需要建立连接，所以速度快。</strong></li><li><strong>UDP通讯是不分服务端和客服端的，只分发送端和接收端。</strong></li><li><strong>在UDP协议中，有一个IP地址称作为广播地址，广播地址就是主机号为255的地址。给广播地址发送消息时，在同一个网络段的机器都可以接收到信息。</strong></li><li><strong>UDP是一个不可靠（数据包可能会丢失）的协议。如一下情况：</strong></li></ul><h2 id="TCP拥塞避免算法"><a href="#TCP拥塞避免算法" class="headerlink" title="TCP拥塞避免算法"></a><strong>TCP拥塞避免算法</strong></h2><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a><strong>慢开始算法</strong></h3><p>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。</p><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p><p><img src="v2-54715533f093170d50f1ff1be39006e9_720w.jpg" alt="img"></p><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a><strong>拥塞避免算法</strong></h3><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p><img src="17384f11ea6ed5fc" alt="img" style="zoom:67%;"></p><p>拥塞避免</p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a><strong>拥塞发生</strong></h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p><blockquote><p>发生超时重传的拥塞发生算法</p></blockquote><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，sshresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code></li></ul><p><img src="17384f11ff07e074" alt="img" style="zoom: 50%;"></p><p><strong>拥塞发送 —— 超时重传</strong></p><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><p><strong>重传机制</strong></p><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p><img src="17384f114569c301" alt="img" style="zoom:50%;"></p><p>正常的数据传输</p><p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p><p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><p>接下来说说常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a><strong>超时重传</strong></h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><img src="17384f1143f3adb1" alt="img" style="zoom: 50%;"></p><p><strong>RTT</strong></p><p><code>RTT</code> 就是<strong>数据从网络一端传送到另一端所需的时间</strong>，也就是包的往返时间。</p><p>超时重传时间是以 <code>RTO</code> （Retransmission Timeout 超时重传时间）表示。</p><p>假设在重传的情况下，超时时间 <code>RTO</code> 「较长或较短」时，会发生什么事情呢？</p><p><img src="17384f115f970fd0" alt="img" style="zoom: 67%;"></p><p>超时时间较长与较短</p><p>上图中有两种超时时间不同的情况：</p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>精确的测量超时时间 <code>RTO</code> 的值是非常重要的，这可让我们的重传机制更高效。</p><p>根据上述的两种情况，我们可以得知，<strong>超时重传时间 RTO 的值应该略大于报文往返  RTT 的值</strong>。</p><p><img src="17384f1163667495" alt="img" style="zoom:50%;"></p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><strong>快速重传</strong></h3><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p><p><img src="17384f116656218a" alt="img" style="zoom:67%;"></p><p>快速重传机制</p><p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，接收到收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）</li><li>重传丢失的数据包</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1</li><li>如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法</li></ul><p><img src="17384f12005eb183" alt="img" style="zoom: 50%;"></p><p>快速重传和快速恢复</p><p>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><strong>滑动窗口</strong></h2><blockquote><p>“ 引入窗口概念的原因<br>”</p></blockquote><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p><p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p><p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p><p><img src="v2-d388476be4c044b1f0c055ad1b61d543_720w.jpg" alt="img" style="zoom:67%;"></p><p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="v2-719ef8746c5e323e13f7e28ca8709b81_720w.jpg" alt="img" style="zoom:67%;"></p><p>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><blockquote><p>“ 窗口大小由哪一方决定？<br>”</p></blockquote><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p><p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><blockquote><p>“ 发送方的滑动窗口<br>”</p></blockquote><p>我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：</p><figure class="image-box">                <img src="v2-dab1fd117460ca012080fdb52a99f847_720w.jpg" alt="img" title class>                <p>img</p>            </figure><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节</li><li>#2 是已发送但未收到 ACK确认的数据：32~45 字节</li><li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节</li><li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</li></ul><p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p><figure class="image-box">                <img src="v2-d486cc3872e9873ab2a646cd6908f739_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p>在下图，当收到之前发送的数据 <code>32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code>52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code>52~56</code> 这 5 个字节的数据了。</p><figure class="image-box">                <img src="v2-609be3306d058eafc9a45c89adb21840_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a><strong>HTTP状态码</strong></h2><p><strong><figure class="image-box">                <img src="be714471b75a4e901581ffb719981796.jpg" alt="状态码" title class>                <p>状态码</p>            </figure></strong></p><p><strong>常见状态码</strong>：</p><ul><li>200 OK - 客户端请求成功</li><li>206 部分成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>302 - 临时跳转</li><li>400 Bad Request - 客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</li><li>404 - 请求资源不存在，可能是输入了错误的URL</li><li>500 - 服务器内部发生了不可预期的错误</li><li>503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</li></ul><p>转发和重定向的区别</p><p> 转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址 栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p><p> 重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动 跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><p><strong>HTTP特点</strong></p><ol><li>http协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><p><strong>HTTP的缺点：</strong></p><ol><li>通信使用明文（不加密），内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报文的完整性，所以有可能已遭篡改。</li></ol><blockquote><p><strong>HTTP持久连接</strong><br>如果有大量的连接，每次在连接，关闭都要经历三次握手，四次挥手，这显然会造成性能低下。因此。Http 有一种叫做 长连接（keepalive connections） 的机制。它可以在传输数据后仍保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而无需再次握手。</p></blockquote><figure class="image-box">                <img src="v2-e051b1ebaa5217a4e902a754523650d0_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>HTTPS</strong></p><p>​</p><p><img src="v2-a994fbf3094d737814fe01c2b919477b_720w.jpg" alt="img"></p><p><img src="v2-169338067adce8c5da0aeca08a04db1c_720w.jpg" alt="img"></p><p><strong>服务端证书通过CA机构签名认证的过程如下</strong></p><figure class="image-box">                <img src="v2-f6dc4107ba6149196895eb55ad210333_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p><strong>对称加密</strong></p><blockquote><p>简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。</p></blockquote><figure class="image-box">                <img src="v2-1252526c263ee50c47b7b49bd1c2ef44_720w.jpg" alt="img" title class>                <p>img</p>            </figure><p><strong>用对称加密可行吗？</strong></p><p><strong>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</strong></p><p>然而最大的问题就是<strong>这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。</p><p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行了！这么做显然不现实。<br>怎么办？所以我们就需要<strong><code>非对称加密</code></strong> 。</p><p><strong>什么是非对称加密？</strong></p><p>简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p><figure class="image-box">                <img src="v2-1589bbfab027eb9f52da03c02a837fd4_720w.jpg" alt="img" title class>                <p>img</p>            </figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步?何为阻塞与非阻塞?二者的区别在哪里?阻塞在何处?为什么会有多种IO模型，分别用来解决问题?常用的框架采用的是何种I/O模型?各种IO模型的优劣势在哪里，适用于何种应用场景?</p><p>简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。</p><h2 id="I-O-的定义"><a href="#I-O-的定义" class="headerlink" title="I/O 的定义"></a>I/O 的定义</h2><p>I/O 的全称是Input/Output。虽常谈及I/O，但想必你也一时不能给出一个完整的定义。搜索了谷歌，发现也尽是些冗长的论述。要想理清I/O这个概念，我们需要从不同的视角去理解它。</p><p><strong>计算机视角</strong></p><p>冯•诺伊曼计算机的基本思想中有提到计算机硬件组成应为五大部分：控制器，运算器，存储器，输入和输出。其中输入是指将数据输入到计算机的设备，比如键盘鼠标;输出是指从计算机中获取数据的设备，比如显示器;以及既是输入又是输出设备，硬盘，网卡等。</p><p>用户通过操作系统才能完成对计算机的操作。计算机启动时，第一个启动的程序是操作系统的内核，它将负责计算机的资源管理和进程的调度。换句话说：操作系统负责从输入设备读取数据并将数据写入到输出设备。</p><p>所以I/O之于计算机，有两层意思：</p><ol><li>I/O设备</li><li>对I/O设备的数据读写</li></ol><p>对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为磁盘I/O，网络I/O(一次网络的请求响应，网卡)等。</p><p><strong>程序视角</strong></p><p>应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程API等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。</p><p>因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为内核空间(内核对应进程所在内存空间)和用户空间，进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。</p><p>但操作系统向外提供API，其由各种类型的系统调用(System Call)组成，以提供安全的访问控制。所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的系统调用(system call)进行间接访问。</p><p>所以I/O之于应用程序来说，强调的通过向内核发起系统调用完成对I/O的间接访问。换句话说应用程序发起的一次IO操作实际包含两个阶段：</p><ol><li>IO调用阶段：应用程序进程向内核发起系统调用</li><li>IO执行阶段：内核执行IO操作并返回</li></ol><p>准备数据阶段：内核等待I/O设备准备好数据</p><p>拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</p><p>怎么理解准备数据阶段呢?对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区;对于读请求：等待系统调用的完整请求数据;(若请求数据不存在于内核缓冲区)则将外围设备的数据读入到内核缓冲区。</p><p><img src="v2-0fe981d52109a6eec954a4f19813ecb7_1440w.jpg" alt="img"></p><p>而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题阻塞IO与非阻塞IO。</p><h2 id="IO-模型之阻塞I-O-BIO"><a href="#IO-模型之阻塞I-O-BIO" class="headerlink" title="IO 模型之阻塞I/O(BIO)"></a>IO 模型之阻塞I/O(BIO)</h2><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。阻塞IO简称BIO，Blocking IO。其处理流程如下图所示：</p><p><img src="v2-0f788eddca6f6fe20841bf8544e2ec62_1440w.jpg" alt="  "></p><p>从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间用户调用线程选择阻塞等待数据返回。</p><p>因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是阻塞二字。</p><h2 id="IO-模型之非阻塞I-O-NIO"><a href="#IO-模型之非阻塞I-O-NIO" class="headerlink" title="IO 模型之非阻塞I/O(NIO)"></a>IO 模型之非阻塞I/O(NIO)</h2><p>那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：</p><p><strong>内核select轮询套接字</strong></p><p><img src="v2-707bb073ca8a4bbdbba9ccd0a5e58645_1440w.jpg" alt="img"></p><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。</p><p><strong>缺陷：</strong></p><p>然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那NIO问题的本质就是频繁轮询导致的无效系统调用。</p><ol><li>空循环，无意义循环</li><li>JAVA–JVM–OS</li></ol><h2 id="IO模型之IO多路复用"><a href="#IO模型之IO多路复用" class="headerlink" title="IO模型之IO多路复用"></a>IO模型之IO多路复用</h2><p>解决NIO的思路就是降解无效的系统调用，如何降解呢?我们一起来看看以下几种IO多路复用的解决思路。</p><p>IO多路复用模型，就是通过一种新的系统调用，一个进程可以监视多个文件描述符(如socket)，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核kernel能够通知程序进行相应的IO系统调用。</p><p>目前支持IO多路复用的系统调用，有 select，epoll等等。select系统调用，是目前几乎在所有的操作系统上都有支持，具有良好跨平台特性。epoll是在linux 2.6内核中提出的，是select系统调用的linux增强版本。而Java NIO库中的 <strong>selector</strong> 底层就是IO多用复用技术。</p><p><strong>IO多路复用之select/poll</strong></p><p>Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态，当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。其IO流程如下所示：</p><p><img src="v2-80a46760bcf7751b65c52c174513fec9_1440w.jpg" alt="img"></p><p>但是，select有一个限制，就是存在连接数限制，针对于此，又提出了poll。其与select相比，主要是解决了连接限制。</p><p>select/epoll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：</p><p>用户空间和内核空间之间，大量的数据拷贝</p><p>内核循环遍历IO状态，浪费CPU时间</p><p>换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：内核存在无效的循环遍历。</p><p><strong>IO多路复用之epoll</strong></p><p>针对select/pool引入的问题，我们把解决问题的思路转回到内核上，如何减少内核重复无效的循环遍历呢?变主动为被动，基于事件驱动来实现。其流程图如下所示：</p><p><img src="v2-cd3810718115195b6b0948ec30bf33e0_1440w.jpg" alt="img"></p><p>epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。</p><p><img src="v2-989c77a28bae71276916fc4ec20638b1_1440w.jpg" alt="img"></p><p>epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：数据准备阶段都还是被阻塞的。所以这是一个可以继续优化的点。</p><p>“多路”是指：服务器端同时监听多个“端口”的情况。每个端口都要监听多个客户端的连接。<br>服务器端的非多路复用效果</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzQyMA==,size_16,color_FFFFFF,t_70.png" alt="img" title class>                <p>img</p>            </figure><p>服务器端的多路复用效果</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ3MzQyMA==,size_16,color_FFFFFF,t_70.png" alt="img" title class>                <p>img</p>            </figure><p>选择器Selector<br>Selector被称为：选择器，也被称为：多路复用器，它可以注册到很多个Channel上，监听各个 Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个 Channel，就可以处理大量网络连接了。 有了Selector，我们就可以利用一个线程来处理所有的Channels。线程之间的切换对操作系统来说代价 是很高的，并且每个线程也会占用一定的系统资源。所以，对系统来说使用的线程越少越好。</p><h2 id="IO-模型之信号驱动IO-SIGIO"><a href="#IO-模型之信号驱动IO-SIGIO" class="headerlink" title="IO 模型之信号驱动IO(SIGIO)"></a>IO 模型之信号驱动IO(SIGIO)</h2><p>信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信的号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。</p><p><img src="v2-ea392e66039a354515f63863c5f36e25_1440w.jpg" alt="img"></p><p>乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的。</p><p>综上，你会发现，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。那如果能将IO执行的第二阶段变成非阻塞，那就完美了。</p><h2 id="IO-模型之异步IO-AIO"><a href="#IO-模型之异步IO-AIO" class="headerlink" title="IO 模型之异步IO(AIO)"></a>IO 模型之异步IO(AIO)</h2><p>异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程IO操作执行完毕(与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕)。其流程如下：</p><p><img src="v2-230080fe14c7d68630a96bbbf36aca99_1440w.jpg" alt="img"></p><p>所以，之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO。</p><p><img src="v2-3984144fcdb6a880a6512bcf2b29396d_1440w.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理完这些IO模型后，之前一直处于懵懂状态的阻塞，非阻塞，同步异步IO，终于算是有个概念了。同时也纠正了自己一直以来的误解，所以一路走来，愈发觉得返璞归真的重要性，只有如此，才能在快速更迭的技术演进中，以不变应万变。</p><p>回顾 BIO，NIO，多路复用器</p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#1__4" target="_blank" rel="noopener">1. 计组知识</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#2_BIO_10" target="_blank" rel="noopener">2. BIO</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#3_NIO_49" target="_blank" rel="noopener">3. NIO</a></p><p><a href="https://blog.csdn.net/cjl836735455/article/details/106695636?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-6.highlightwordscore#4__112" target="_blank" rel="noopener">4. 多路复用器</a></p><blockquote><p><strong>回顾一下BIO，NIO，多路复用器</strong></p><p>————————————————————————————————————</p><figure class="image-box">                <img src="20200612204735300.png" alt="img" title class>                <p>img</p>            </figure></blockquote><h1 id="1-计组知识"><a href="#1-计组知识" class="headerlink" title="1. 计组知识"></a>1. 计组知识</h1><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70" alt="img" title class>                <p>img</p>            </figure><p><strong>cpu</strong></p><p>首先计算机的组成肯定有<strong>cpu</strong>，他是核心的处理器，然后有内存，你的所有程序都需要加载到内存中，才能和cpu进行交互，比如Java就是通过ClassLoader将字节码.class文件加载到内存中再执行的。</p><p><strong>计算机内核</strong></p><p>他也是一个程序，属于操作系统的核心程序，<strong>是基于硬件的第一层软件扩充，提供操作系统的最基本的功能</strong>，我们在操作系统上启动的程序最终都要调用cpu执行操作，而为了系统安全和效率，不能让机器上的程序自己去直接随意操作底层硬件，必须都通过内核来完成对系统底层硬件的使用调度，简称<strong>系统调用</strong>。内核在内存中有独立安全的地址空间，使用保护模式和用户空间隔离开来，保护和统一管理系统调用。</p><p><strong>中断</strong></p><p>假如我们只有一颗cpu，则同时只能运行一个程序(application)，但是由于程序间切换很快，感觉起来就像多个程序属于并行状态，而何时停止当前程序，去调用其它程序，就依靠着<strong>中断</strong>，中断有外部中断，例如电子电路中的<strong>晶振</strong>带来的时钟中断，也有内部中断，例如<strong>程序回调中断</strong>。附上一个比较详细的中断说明链接，这里不再阐述：<a href="https://blog.csdn.net/jadeshu/article/details/100176917" target="_blank" rel="noopener">CPU中断</a></p><h1 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2. BIO"></a>2. BIO</h1><p><strong><em>\</em>BIO (blocking I/O)： 同步阻塞I/O模型**</strong></p><p>我们主要来看一下Java代码中BIO的实现(底层实现是依靠内核提供的<strong>阻塞IO系统调用</strong>)，上代码(这些都是在<strong>Java IO</strong>包中的，基于<strong>ServerSocket</strong>和<strong>Socket</strong>)</p><figure class="image-box">                <img src="20200612215259479.png" alt="img" title class>                <p>img</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">*// 这里是服务端的程序实现，主线程接收客户端连接，将每一个客户端连接放入clone的一个子线程中(这里的clone是底层的系统调用)*</span><br><span class="line"></span><br><span class="line">*// 绑定端口7777并监听 bind→listen*</span><br><span class="line"></span><br><span class="line">ServerSocket serverSocket = new ServerSocket(7777);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;服务端启动...&quot;);</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">*// serverSocket.accept()方法是阻塞等待客户端连接，*</span><br><span class="line"></span><br><span class="line">*// 没有客户端连接就一直等待，直到有客户端接入*</span><br><span class="line"></span><br><span class="line">*// 有接入后返回接入的客户端socket*</span><br><span class="line"></span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;客户端连接...&quot;);</span><br><span class="line"></span><br><span class="line">*// 客户端接入之后需要将其连接放入到一个线程中去处理后续的数据读取操作，*</span><br><span class="line"></span><br><span class="line">*// 因为读取操作也是一个阻塞的等待状态，客户端可能一会给你发消息，一会不发，*</span><br><span class="line"></span><br><span class="line">*// 如果不开启子线程，则此时服务器就只能阻塞等待客户端发信息，无法接入其他客户端*</span><br><span class="line"></span><br><span class="line">*// 相当于这个一个服务器只能接入一个客户端，这显然是不符合常理的*</span><br><span class="line"></span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">*// 获取客户端输入流*</span><br><span class="line"></span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">*// is.read() 也是阻塞方法，子线程在此等待客户端输入...*</span><br><span class="line"></span><br><span class="line">​      int clientData = is.read(b);</span><br><span class="line"></span><br><span class="line">*// ...*</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>我们说BIO是<strong>同步阻塞I/O模型</strong>，这里同步的意思就是指，客户发来的IO信息，需要我自己线程去同步读取，客户端发送一点我接收一点，两端数据是同步的。</p><p>在这里边有<strong>两个阻塞</strong>，第一个是服务端等待客户端接入的阻塞，另一个是子线程中等待客户端发送消息的阻塞。上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B1%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>图中**</strong>recv<strong>**是指读取信息的系统调用</strong>，你可以把他理解为Java中的InputStream .read()，以上就是Java最古老的基于<strong>BIO</strong>的<strong>每线程每连接</strong>，而这里BIO的问题主要是两个：</p><p><strong>第一</strong>，创建线程是要分配给每个线程对应独立的内存空间的，很占资源，而且如果这个连接不做任何事情会造成不必要的开销。</p><p><strong>第二</strong>，多个线程cpu在执行时会给每个线程分配时间去调度执行他们，如果线程很多，则cpu会有很多时间都浪费在了线程之间调度切换，切换也不是很简单的操作，其中包含了当前线程挂起，线程的执行场景保留和下一个线程的执行状态恢复等操作。所以引出了我们的新IO模型，<strong>NIO</strong> ↓</p><h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h1><p><strong><em>\</em>NIO (non-blocking I/O)： 同步非阻塞I/O模型**</strong></p><figure class="image-box">                <img src="20200613082503702.png" alt="img" title class>                <p>img</p>            </figure><p>NIO默认是指操作系统提供的NIO，而在Java中，NIO也可以叫做<strong>new IO</strong>，因为是全新的IO包，新的一套体系，是<strong>NIO包</strong>下的内容，基于<strong>ServerSocketChannel</strong>和<strong>SocketChannel</strong>，虽然底层也还是依靠新的非阻塞的系统调用。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B2%5D" alt="img" title class>                <p>img</p>            </figure><p>NIO是随着内核系统调用发展的产物，其非阻塞的方法也是依靠内核提供的，如图为Linux的内核实现的非阻塞IO方法参数</p><figure class="image-box">                <img src="2020061308333075.png" alt="img" title class>                <p>img</p>            </figure><p>图上是<strong>服务端</strong>的非阻塞参数<strong>SOCK_NONBLOCK</strong>，同时也可以通过<strong>fcntl(2)**</strong>这个系统调用来设置<strong>**客户端</strong>非阻塞。(如BIO中说明的两个阻塞分别有对应的两个解决)</p><p>我们还是来看Java中对NIO的实现，上代码(服务端代码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">*// 创建serverSocketChannel，监听8888端口，类似于BIO中的ServerSocket*</span><br><span class="line"></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open()；</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(8888));</span><br><span class="line"></span><br><span class="line">*// 重点：设置为非阻塞参数 → 内核提供的NIO*</span><br><span class="line"></span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*// 创建一个放置客户端连接的集合*</span><br><span class="line"></span><br><span class="line">LinkedList&lt;SocketChannel&gt; clients = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">*// 循环是在一个主线程中，期间没有开启任何其他子线程*</span><br><span class="line"></span><br><span class="line">*// 循环中有两大步，第一步接收客户端连接，第二步遍历客户端查看是否有数据需要接收*</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">  *// ① ******接收客户端连接*******</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *// 接收客户端连接，一秒去接一次(也可以不设定)，非阻塞，一直会有返回值*</span><br><span class="line"></span><br><span class="line">  Thread.currentThread().sleep(1000);</span><br><span class="line"></span><br><span class="line">  SocketChannel client = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *// 那接收的结果就是两种情况，接到和没接到*</span><br><span class="line"></span><br><span class="line">  *// 内核系统调用时没接收到返回-1，Java中为null*</span><br><span class="line"></span><br><span class="line">  if (channel == null)&#123;</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;服务端监听中...暂无接入...&quot;);</span><br><span class="line"></span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;客户端接入...&quot;);</span><br><span class="line"></span><br><span class="line">​    *// 设置客户端非阻塞，比方说*</span><br><span class="line"></span><br><span class="line">​    *// 客户端有数据发来就接受到了，没有就返回-1，也是非阻塞的*</span><br><span class="line"></span><br><span class="line">​    client.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;客户端端口：&quot; + client.socket().getPort());</span><br><span class="line"></span><br><span class="line">​    clients.add(client);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *// ② ******遍历客户端集合查看是否有数据需要接收*******</span><br><span class="line"></span><br><span class="line">  ByteBuffer buffer = ByteBuffer.allocateDirect(4096);</span><br><span class="line"></span><br><span class="line">  for (SocketChannel c : clients) &#123;</span><br><span class="line"></span><br><span class="line">​    *// 此时读取不会阻塞，返回 &gt;0，0，-1*</span><br><span class="line"></span><br><span class="line">​    int num = c.read(buffer);</span><br><span class="line"></span><br><span class="line">​    if (num &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">​      buffer.flip();</span><br><span class="line"></span><br><span class="line">​      byte[] bytes = new byte[buffer.limit()];</span><br><span class="line"></span><br><span class="line">​      buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​      String message = new String(bytes);</span><br><span class="line"></span><br><span class="line">​      System.out.println(c.socket().getPort() + &quot;: &quot; + message);</span><br><span class="line"></span><br><span class="line">​      buffer.clear();</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里NIO一个线程就干了<strong>接受客户端连接</strong>和<strong>读取客户端数据</strong>的工作，解决了BIO中的<strong>线程内存浪费</strong>和<strong>cpu调度消耗</strong>的问题。NIO的优势就是解决了客户端连接多线程的问题，那么NIO有哪些弊端呢，<strong>C10K问题(client 有10K个)</strong>，假如你有一万个客户端连接，每次你去读取客户端数据都要向内核进行recv(读数据)的系统调用，但是假如此时此刻发来数据的客户端只有一个，那剩下9999次的调用都将会是无效的，没有意义的浪费资源，上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B3%5D" alt="img" title class>                <p>img</p>            </figure><p>那如何解决C10K问题呢，C10K的主要问题在于for循环调用了一万次系统调用，如果我们可以降低循环的次数，减少对应的系统调用，那性能将大大提升，好比说我们在一万次的循环之前，访问<strong>某一个系统调用</strong>，将一万个客户端连接描述传递给内核，让他给我们返回到底有几个客户端发来了数据，在这之后我们就可以只遍历内核返回回来的真正有数据传达了的客户端，假如有三个客户端传来了数据，加上我们循环之前访问内核的<strong>某一个系统调用</strong>，总共有只四次系统调用，而只循环了三次，是不是大大提高了效率。</p><p>我们可以将这一万个客户端理解为一万个数据通路，这多个数据通路都同时使用了<strong>某一个系统调用</strong>完成了数据传输状态的确认，我们将这个过程称之为<strong>多路复用</strong>，使用到的<strong>某一个系统调用</strong>称之为<strong>多路复用器</strong>。</p><p>可以把多路复用器理解为是基于NIO模型来使用的。</p><h1 id="4-多路复用器"><a href="#4-多路复用器" class="headerlink" title="4. 多路复用器"></a>4. 多路复用器</h1><p><strong><em>\</em>多路复用器： select，poll，epoll**</strong></p><p>多路复用器也是随着内核系统调用发展的产物，是内核为我们提供的可以管理多个数据通路的系统调用方法。上边三个版本多路复用器大致又可以分为两类：</p><p><strong>一类：select，poll</strong></p><p><strong>二类：epoll</strong></p><p>先来聊一下<strong>一类</strong>，select和poll，以select为例，看一下linux内核提供的系统调用，调用方法名就是select，这里是C语言实现的。</p><figure class="image-box">                <img src="2020061310565648.png" alt="img" title class>                <p>img</p>            </figure><p>首先，select是同步I/O多路复用器。(multiplexing：多路复用)</p><figure class="image-box">                <img src="20200613103518120.png" alt="img" title class>                <p>img</p>            </figure><p>再来看系统调用提供的方法，其中int类型的参数nfds就表示的是<strong>文件描述符</strong>的个数，这里具体表示的就是多少个客户端连接需要询问内核(C10K)，后边三个参数是三个文件描述符的集合，可读集合，可写集合和异常集合，最后参数是请求时间超时的限制，为什么使用文件描述符呢，因为Linux中一切皆文件，而什么是文件描述符？这里的使用可以暂时理解为你每个客户端的连接信息，这里补上一个比较详细的文件描述符说明链接，这里不再阐述：<a href="https://blog.csdn.net/wan13141/article/details/89433379" target="_blank" rel="noopener">Linux文件描述符到底是什么？</a></p><p>关于select的系统调用是有如下描述：<strong>允许一个程序监视多个文件描述符。</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B4%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>直到一个或多个文件描述符达到一个准备好的状态。</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B5%5D" alt="img" title class>                <p>img</p>            </figure><p>这里select多路复用器的作用就是替代了之前循环遍历客户端的过程，用户端时间复杂度从一万减少到了一，但是其实在将一万个文件描述符传递给内核后，内核还是要遍历，不过内核内部的自行遍历相比于用户循环一万次做系统调用，要快的多(因为用户态到内核态有保护模式，系统调用执行间还有好长的一段路要走)。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B6%5D" alt="img" title class>                <p>img</p>            </figure><p>这里需要明确的一点是，<strong>多路复用器返回的只是对应客户端的状态</strong>，多路复用器不会帮你去读数据，读取数据的工作都是在代码中实现的，都在自己的线程中(比如上边图中最后都调用了recv)，无论是BIO还是NIO。</p><p>这里再补充一下 <strong>IO模型的**</strong>同步<strong><strong>与</strong></strong>异步**：</p><p>如果是程序自己读取IO(类似于上边的代码获取客户端输入流，系统调用recv)，那么这个IO类型，无论是BIO，还是NIO(使用和不使用多路复用器)，他们都是<strong>同步的IO模型</strong>。只不过BIO是同步阻塞，NIO是同步<strong>非</strong>阻塞，而多路复用器只是NIO的帮手，不属于IO模型。</p><p>那<strong>异步IO模型</strong>呢，windows中有IOCP实现，Linux也有Proactor模式，做法都是在内核中启动线程(不是在程序中启动线程)，内核线程把数据拷贝到程序的内存空间中去，当内核线程完成IO操作之后，发送一个通知，告知程序操作已完成，此时程序就可以直接进行获取，程序不用自己开线程去调读取方法(recv)来读取数据，这就叫做异步IO模型。如图(kernel就是内核)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B7%5D" alt="img" title class>                <p>img</p>            </figure><p>这里简单的提一下，就是NIO 2.0引入了新的异步通道的概念，就是图中的AIO。</p><p>附上一个Linux异步IO模型的详细说明，这里不再阐述：</p><p><a href="https://www.cnblogs.com/schips/p/12575933.html" target="_blank" rel="noopener">Linux 网络编程的5种IO模型：异步IO模型</a></p><p>这里差不多了解完了多路复用器select，再提一下多路复用器poll，select和poll是一类的，区别在于select有一个源代码的1024限制(不同版本代码可能限制数不一样)，一个select最多同时监视1024个文件描述符(可以理解为一个select同时最多管理1024个客户端连接)，而poll是没有显示的限制的，是随着操作系统底层配置来实现限制的。</p><p>那么一类的多路复用器select和poll有哪些问题呢，也可以总结为两个</p><p><strong>第一个</strong>：每次会重复传递文件描述符，每次系统调用都传一万个过去，循环多了，资源空间上也很浪费</p><p><strong>第二个</strong>：多路复用器select和poll都要全量遍历文件描述符，有没有什么方法可以减少遍历次数呢？或者说可不可以不用再主动遍历文件描述符了呢(无论是程序遍历还是内核遍历)？</p><p>EPOLL可以解决，这也是为什么现在用的比较多的同步IO模型的多路复用器是epoll，那么如何解决上边两个问题呢，</p><p><strong>第一个</strong>：让内核开辟一块内存空间，来保留文件描述符，不用重复传递了</p><p><strong>第二个</strong>：属于计组的知识，使用中断，callback回调等来实现被动获取文件描述符的状态，不再主动遍历所有文件描述符(连接信息)。</p><p>上图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B8%5D" alt="img" title class>                <p>img</p>            </figure><p>下来我们主要说一下二类多路复用器：EPOLL</p><p>在讲原理之前这里先对NIO内容进行一个小补充：</p><p>Java Nio主要由三个核心部分组成：</p><p><strong>1.通道 Channel</strong></p><p>所有的io的Nio都是从一个channel开始的，Channel有点类似于流，但是和流不同的是，channel是可以双向读写的，<strong>可以把一个channel理解为一个客户端连接</strong>，Channel主要分两大类：</p><p>SelectableChannel：网络IO读写</p><p><strong>ServerSocketChannel</strong>和<strong>SocketChannel</strong>都是SelectableChannel的子类</p><p>FileChannel：本地文件IO读写</p><p><strong>2.缓冲区 Buffer</strong></p><p>在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。（<strong>用于读入和读出channel的数据</strong>）</p><p>缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。</p><p>具体的缓存区有这些：ByteBuffer、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。</p><p><strong>3.多路复用器 Selector</strong></p><p>Selector是Java NIO 编程的基础。</p><p>Java中的Selector类位于NIO包下，名字叫Selector，是一个多路复用器的统称，可以理解为适配器模式，<strong>Selector类代码运行不同的服务器上可以是不同的多路复用器实现</strong>，主要看底层服务器内核是如何提供系统调用的，可以是select，可以是poll，也可以是epoll，还可以是unix系统下实现的kqueue等等等等。</p><p>最后上个图</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B9%5D" alt="img" title class>                <p>img</p>            </figure><hr><p><strong>现在我们看一下epoll解决一类多路复用器两个问题的原理：</strong></p><p>（最后会有代码的演示）</p><p><strong>第一个问题解决方案</strong>：让内核开辟一块内存空间，来保留文件描述符，不用重复传递了</p><p><strong>原理</strong>：在客户端接入时，将对应的文件描述符写入到内核开辟的内存空间保存，其实内核开辟的内存空间有两个部分，A部分用来存放全部已经连接的客户端文件描述符，B部分存放有了对应读取状态的客户端文件描述符。我们的程序现在不用循环遍历客户端连接了，只需要从B部分获取对应的客户端就可以了，内核负责监视A部分的客户端，当有输入到达时，就将客户端文件描述符从A部分拷贝到B部分，再由程序轮询获得。此时就是通过内核牺牲部分内存空间来换取时间。</p><p><strong>select和poll的多路复用器，在多cpu的时候无法发挥出多核的优势</strong>，因为内存没有开辟内存空间，每次需要程序进行系统调用，等待cpu返回结果，因为cpu处理和程序获得结果这两个顺序是不能颠倒的，所以别的cpu也帮不上忙，但是在epoll的情况下，因为内核内存空间的存在，可以让cpu1去接受客户端信息，做A部分拷贝到B部分的工作，而cpu2去运行程序，并且轮询(轮流循环询问)内存空间B部分的状态，这样就可以充分发挥多核的优势。</p><p><strong>下来看一下这个操作的系统调用级实现(Linux)：</strong></p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B10%5D" alt="img" title class>                <p>img</p>            </figure><p>分别有三个系统调用方法：</p><p><strong>epoll_create</strong> → epoll创建</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B11%5D" alt="img" title class>                <p>img</p>            </figure><figure class="image-box">                <img src="20200613160434656.png" alt="img" title class>                <p>img</p>            </figure><p>epoll_create方法返回了一个文件描述符，这个文件描述符会在后续的epoll_ctl中作为参数传递过去并且使用。</p><p><strong>epoll_ctl</strong> → epoll控制</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B12%5D" alt="img" title class>                <p>img</p>            </figure><p>这里第一个参数epfd就是刚才返回的文件描述符，第二个参数op是option的意思，有如下几个表示值，【添加，修改还有删除】<figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B13%5D" alt="img" title class>                <p>img</p>            </figure></p><p>如果op是add，那么添加什么呢，就是添加第三个参数fd，也是一个文件描述符，就是我们的客户端连接的文件描述符，最后一个参数是event集合，表示监听哪些事件，比如客户端的读事件，写事件。</p><p><strong>epoll_wait</strong> → epoll等待</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B14%5D" alt="img" title class>                <p>img</p>            </figure><p>这里第一个参数还是epfd，后边是对应的事件(指针)，以及最大事件数和响应过期时间。事件指针是为了更快的访问到对应的事件。</p><p><strong>下来用这三个系统调用来说明如何实现第一个问题的解决：</strong></p><p>首先在你的服务端程序启动时，调用且只调用一次<strong>epoll_create</strong>，使得内核创建内存空间，方法返回一个文件描述符epfd，假如等于7，这个文件描述符就是<strong>内核开辟内存空间的描述</strong>，包含地址啊，大小啊，等等，为什么内存空间也是由文件描述符来描述，因为Linux一切皆文件嘛</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B15%5D" alt="img" title class>                <p>img</p>            </figure><p>有了fd7之后，表明内核已经开辟了一块内存空间了，我们程序在启动后，会绑定并监听一个端口，返回我们<strong>程序的第一个文件描述符</strong>，也就是程序服务端(server)的文件描述符，假如是3，接下来就是把次文件描述符拷贝到内核开辟的内存空间中去，这里还是用上边的代称，就是拷贝到内核内存的A部分去，此时调用的方法是<strong>epoll_ctl</strong>，op参数为add，监听服务端的accept事件↓</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B16%5D" alt="img" title class>                <p>img</p>            </figure><p>这里内核空间fd7其实使用<strong>红黑树</strong>来存放这些添加进来的文件描述符的，使得对文件描述符的获取和使用更加便捷效率。</p><figure class="image-box">                <img src="20200613164358546.png" alt="img" title class>                <p>img</p>            </figure><p>此时已经拷贝完毕，内核负责监听拷贝到A部分的文件描述符的事件，假如此时又客户端接入，则将fd3从A部分拷贝到B部分，当我程序随时想要获取状态时，只需要调用<strong>epoll_wait</strong>即可，就是之前提到的轮询，程序会时不时的过来查看一下最新的状态，有变化的话就读取对应信息到程序内存中去执行，epoll_wait的意思就可以理解为等待内核监听事件直到有事件发生。epoll_wait是阻塞的方法，但是可以设置一个timeout时间，超过时间则直接返回-1。最优情况下epoll_wait可以到达O(1)的复杂度，一次获取多个连接信息。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B17%5D" alt="img" title class>                <p>img</p>            </figure><p>再下来无非是服务端fd3接收到客户端，假如是fd8，再次调用epoll_ctl来add到A部分，内核再监听对应的可读事件，有读事件发生了，再拷贝到B部分，等待程序调用epoll_wait来获取。这一部分的解决方法大概就是这样。</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B18%5D" alt="img" title class>                <p>img</p>            </figure><p><strong>总结一下，epoll其实相比于select和poll，就是多了epoll_create和epoll_ctl方法，这两个方法分别以在【内核中开辟空间】并【操作文件描述符】。</strong></p><p><strong>第二个问题解决方案</strong>：属于计组的知识，使用中断，callback回调等来实现被动获取文件描述符的状态，不再主动遍历所有文件描述符(连接信息)。</p><p><strong>原理</strong>：简单说明一下，内核在开辟的A部分内存空间里，监听了所有文件描述符对应的事件，何时把A部分的文件描述符拷贝到B部分，上边已经说过了，是对应监听的事件发生的时候，比如读事件，那为什么文件描述符对应监听的事件发生时，会接着发生A，B部分的拷贝事件呢，这两者明显没有直接的关联关系，结果就是，内核使用回调机制，比如callback事件回调，在读事件发生之后回调了拷贝事件完成了这一操作。</p><hr><p><strong>最后看一下多路复用器在Java中的封装：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">*// 服务端代码依旧是绑定端口和监听端口，设置非阻塞*</span><br><span class="line"></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(new InetSocketAddress(8888));</span><br><span class="line"></span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*// 多路复用器：select poll epoll都有可能，优先选择epoll，可以通过传参 -D修改*</span><br><span class="line"></span><br><span class="line">*// 在epoll的模型下 open() -&gt; epoll_create -&gt; fd7 让内核开辟内存空间*</span><br><span class="line"></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">*// 为服务端register(注册) selector*</span><br><span class="line"></span><br><span class="line">*// select,poll -&gt; 在jvm里开辟一个数组，把fd3放进去(进程空间)*</span><br><span class="line"></span><br><span class="line">*// epoll -&gt; epoll_ctl(fd7,add,fd3,EPOLLIN) 把fd3放到内核内存空间A部分(内核空间)*</span><br><span class="line"></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;服务端开始工作：&quot;);</span><br><span class="line"></span><br><span class="line">*// 下来开始执行*</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line"></span><br><span class="line">  *// 查看多路复用器中当前监视了多少了文件描述符*</span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; keys = selector.Keys();</span><br><span class="line"></span><br><span class="line">  System.out.println(keys.size() + &quot; size&quot;);</span><br><span class="line"></span><br><span class="line">  *//创建消息处理器*</span><br><span class="line"></span><br><span class="line">ServerHandlerBs handler = new ServerHandlerImpl(1024);</span><br><span class="line"></span><br><span class="line">  *// select()方法就是调用多路复用器(select，poll 或者 epoll)*</span><br><span class="line"></span><br><span class="line">  *// 语义就是去查询一下那些IO可以读写了*</span><br><span class="line"></span><br><span class="line">  *// select，poll -&gt; 调用内核的 select(fd3)，poll(fd3)*</span><br><span class="line"></span><br><span class="line">  *// epoll -&gt; 调用内核的 epoll_wait()*</span><br><span class="line"></span><br><span class="line">  *// 超时时间500毫秒 -&gt; selector.wakeup() 返回0*</span><br><span class="line"></span><br><span class="line">  while(selector.select(timeout: 500) &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">​    *// selectedKeys()方法返回有状态的fd集合*</span><br><span class="line"></span><br><span class="line">​    Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">​    *// 这里遍历的就是有真正IO需求的连接*</span><br><span class="line"></span><br><span class="line">​    while (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">*// 连接请求*</span><br><span class="line"></span><br><span class="line">if (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">   *// select，poll -&gt; 在jvm里开辟的数组中存储新客户端*</span><br><span class="line"></span><br><span class="line">   *// epoll -&gt; epoll_ctl(...add...) 新客户端注册到内核内存空间*</span><br><span class="line"></span><br><span class="line">handler.handleAccept(key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*// 读请求*</span><br><span class="line"></span><br><span class="line">if (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(handler.handleRead(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*// 处理完后移除当前使用的key，不移除下次循环会重复处理*</span><br><span class="line"></span><br><span class="line">keyIterator.remove();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/***</span><br><span class="line"></span><br><span class="line">** description:对selectionKey事件的处理接口*</span><br><span class="line"></span><br><span class="line">**/*</span><br><span class="line"></span><br><span class="line">interface ServerHandlerBs &#123;</span><br><span class="line"></span><br><span class="line">void handleAccept(SelectionKey selectionKey) throws IOException;</span><br><span class="line"></span><br><span class="line">String handleRead(SelectionKey selectionKey) throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*/***</span><br><span class="line"></span><br><span class="line">** description:用来处理有需求的连接*</span><br><span class="line"></span><br><span class="line">**/*</span><br><span class="line"></span><br><span class="line">public class ServerHandlerImpl implements ServerHandlerBs &#123;</span><br><span class="line"></span><br><span class="line">private int bufferSize = 1024;</span><br><span class="line"></span><br><span class="line">private String localCharset = &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(int bufferSize) &#123;</span><br><span class="line"></span><br><span class="line">this(bufferSize, null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(String localCharset) &#123;</span><br><span class="line"></span><br><span class="line">this(-1, localCharset);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ServerHandlerImpl(int bufferSize, String localCharset) &#123;</span><br><span class="line"></span><br><span class="line">this.bufferSize = bufferSize &gt; 0 ? bufferSize : this.bufferSize;</span><br><span class="line"></span><br><span class="line">this.localCharset = localCharset == null ? this.localCharset : localCharset;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  *// 当连接是客户接入的时候*</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public void handleAccept(SelectionKey selectionKey) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">*//获取channel*</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line"></span><br><span class="line">*//非阻塞*</span><br><span class="line"></span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">*//注册selector*</span><br><span class="line"></span><br><span class="line">socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;建立请求......&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  *// 当连接是客户发送数据的时候*</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public String handleRead(SelectionKey selectionKey) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();</span><br><span class="line"></span><br><span class="line">String receivedStr = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if (socketChannel.read(buffer) == -1) &#123;</span><br><span class="line"></span><br><span class="line">*//没读到内容关闭*</span><br><span class="line"></span><br><span class="line">socketChannel.shutdownOutput();</span><br><span class="line"></span><br><span class="line">socketChannel.shutdownInput();</span><br><span class="line"></span><br><span class="line">socketChannel.close();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;连接断开......&quot;);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">*//将channel改为读取状态*</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">*//按照编码读取数据*</span><br><span class="line"></span><br><span class="line">receivedStr = Charset.forName(localCharset).newDecoder().decode(buffer).toString();</span><br><span class="line"></span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line">*//返回数据给客户端*</span><br><span class="line"></span><br><span class="line">buffer = buffer.put((&quot;received string : &quot; + receivedStr).getBytes(localCharset));</span><br><span class="line"></span><br><span class="line">*//读取模式*</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">*//注册selector 继续读取数据*</span><br><span class="line"></span><br><span class="line">socketChannel.register(selectionKey.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufferSize));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return receivedStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码是参照此博客的，我懒得写了，基本只是加了点关于底层系统调用的注释：</p><p><a href="https://blog.csdn.net/qq_36666651/article/details/80955398" target="_blank" rel="noopener">java Nio 使用 NioSocket 客户端与服务端交互实现</a></p><p>最后附上一张图，是在Linux中验证epoll调用顺序的(注意一下左边写的监听的是3，右边是4，没有本质上的区别)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B19%5D" alt="img" title class>                <p>img</p>            </figure>————————————————————————<br><br>最后再补充一下，类似于netty的实现：<br><br>上边代码是单线程的，代码中的Selector既要负责建立连接，又要负责确认客户端状态，还是假如现在有十万个连接都有数据不断在发送过来，那么每次epoll_wait的时间就会变长，两个epoll_wait的间隔就越来越大，这意味着什么，意味着程序每次响应会<strong>一次处理大量并发</strong>，会导致用户端感觉程序反应很慢，用户体验降低，原理就是在你执行第一个epoll_wait之后，所有的连接再进来就得等第一个epoll_wait处理完才能再接入，然后在第二次epoll_wait的时候再由程序处理，所以解决方案很简单，可以建立多个Selector复用器，在多个线程中，将数据量分开，符合了负载均衡的理念，提升处理的响应速度。<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B20%5D" alt="img" title class>                <p>img</p>            </figure><p>多线程多Selector：</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B21%5D" alt="img" title class>                <p>img</p>            </figure><p>可以让多个多路复用器去做不同的事情，比如Selector1是大管家，负责找到需要接入客户端并分发出去，Selector2和Selector3接受Selector1的任务来真正的处理客户端接入，这样就使用了两个多路复用器在不同的线程中处理了客户端接入，速度肯定比单个线程单个多路复用器快。(多核操作系统这三个线程就可以跑在不同的核心上，并行效率更高)</p><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B22%5D" alt="img" title class>                <p>img</p>            </figure>线程的构造方法如下，Selector1分发任务的多路复用器使用第一种，selectors就是处理任务的子多路复用器有多少，剩下Selector2和Selector3使用第二种，单纯负责任务完成。线程内部都包含任务队列queue。<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B23%5D" alt="img" title class>                <p>img</p>            </figure><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B24%5D" alt="img" title class>                <p>img</p>            </figure>下来开始执行，只有第一个线程中所在的多路复用器Selector1被注册到了server上了可以获取监听状态，在接受到客户端之后走acceptHandler方法<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B25%5D)acceptHandler方法中就包含了任务的分配，分配给Selector2和Selector3，一人一个这样分配(给对应线程的queue中分配" alt="img" title class>                <p>img</p>            </figure>，下来看一下Selector2和Selector3的任务实现<br><br><figure class="image-box">                <img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqbDgzNjczNTQ1NQ==,size_16,color_FFFFFF,t_70%20%5B26%5D" alt="img" title class>                <p>img</p>            </figure><h1 id="牛客面经总结"><a href="#牛客面经总结" class="headerlink" title="牛客面经总结"></a><strong>牛客面经总结</strong></h1><h2 id="new一个对象的所有过程"><a href="#new一个对象的所有过程" class="headerlink" title="new一个对象的所有过程"></a><strong>new一个对象的所有过程</strong></h2><h2 id="spring⭐⭐⭐"><a href="#spring⭐⭐⭐" class="headerlink" title="spring⭐⭐⭐"></a><strong>spring⭐⭐⭐</strong></h2><p><strong>AOP</strong></p><p><strong>IOC</strong></p><h1 id="Spring中用到的设计模式"><a href="#Spring中用到的设计模式" class="headerlink" title="Spring中用到的设计模式"></a>Spring中用到的设计模式</h1><p>  准备几个则够了</p><p><strong>单例模式：bean默认都是单例的</strong></p><p><strong>原型模式：指定作用域为prototype</strong></p><p><strong>工厂模式：BeanFactory</strong></p><p>模板模式：postProcessBeanFactory，onRefresh，initPropertyValue</p><p>策略模式：XmlBeanDefinitionReader，PropertiesBeanDefinitionReader</p><p>观察者模式：listener，event，multicast</p><p>适配器模式：Adapter （AOP）</p><p>装饰者模式：BeanWrapper</p><p><strong>责任链模式：使用aop的时候会生成一个拦截器</strong></p><p><strong>代理模式：动态代理 </strong></p><p><strong>委托者模式：delegate</strong></p><p>proxy与delegete语义（也即使用场景）的区别：<br>     proxy :译为代理， 被代理方（B）与代理方（A）的接口完全一致。 主要使用场景（语义）应该是：为简化编程（或无法操作B），不直接把请求交给被代理方（B），而把请求交给代码方（A），由代理方与被代理方进行通信，以完成请求。<br>     delegete : 译为委托，主要语义是：一件事情（或一个请求）对象本身不知道怎样处理，对象把请求交给其它对象来做。</p><p>门面模式又称为外观模式，实际开发中，屏蔽了子模块内部的实现细节，只是将客户端需要的接口提供给客户。</p><p>如： spring ApplicationContext;<br>它实现了Factory、ResourceLoader等接口，并通过引用这些接口的实例，对外统一提供：加载配置、解析资源、创建Bean、提供环境、启动流程等功能；</p><p>客户代码只需要操作context就可以获取spring的提供的功能，而无需关心内部的细节；</p><h2 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a><strong>springboot自动装配原理</strong></h2><h2 id="hashcode-和equals⭐⭐⭐"><a href="#hashcode-和equals⭐⭐⭐" class="headerlink" title="hashcode 和equals⭐⭐⭐"></a><strong>hashcode 和equals⭐⭐⭐</strong></h2><h2 id="HashMap和TreeMap区别-⭐⭐"><a href="#HashMap和TreeMap区别-⭐⭐" class="headerlink" title="HashMap和TreeMap区别 ⭐⭐"></a><strong>HashMap和TreeMap区别 ⭐⭐</strong></h2><h2 id="HashMap如何遍历，TreeMap如何排序的"><a href="#HashMap如何遍历，TreeMap如何排序的" class="headerlink" title="HashMap如何遍历，TreeMap如何排序的"></a><strong>HashMap如何遍历，TreeMap如何排序的</strong></h2><h2 id="hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐"><a href="#hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐" class="headerlink" title="hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐"></a><strong>hashmap为什么用红黑树，为什么不用其他的树，为什么扩容是2倍，是否线程安全⭐</strong></h2><h2 id="MVCC详细说说"><a href="#MVCC详细说说" class="headerlink" title="MVCC详细说说"></a><strong>MVCC详细说说</strong></h2><h2 id="springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析"><a href="#springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析" class="headerlink" title="springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析"></a><strong>springMVC你知道的注解，前端如果有个奇怪的时间字符串，如果解析</strong></h2><h2 id="如何确定垃圾"><a href="#如何确定垃圾" class="headerlink" title="如何确定垃圾"></a><strong>如何确定垃圾</strong></h2><h2 id="类加载器种类，双亲委派和打破"><a href="#类加载器种类，双亲委派和打破" class="headerlink" title="类加载器种类，双亲委派和打破"></a><strong>类加载器种类，双亲委派和打破</strong></h2><h2 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a><strong>TCP如何实现可靠传输</strong></h2><h2 id="如何实现UDP可靠传输"><a href="#如何实现UDP可靠传输" class="headerlink" title="如何实现UDP可靠传输"></a><strong>如何实现UDP可靠传输</strong></h2><h2 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a><strong>TCP和UDP的使用场景</strong></h2><h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><strong>cookie和session的区别</strong></h2><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 复习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学创业的结束随笔</title>
      <link href="/2021/11/03/chuangye-end/"/>
      <url>/2021/11/03/chuangye-end/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 如果让博主盘点自己的大学生涯，说实话挺单调的，就是 – <code>All In 创业</code></p></blockquote><p>博主，只不过是一个有两年创业经历的互联网年轻人。读的是双非重本的学校，在校期间开家小型软件公司，开展经营活动数次，这就是博主过往大学的基本情况。提到校园创业者，按我理解，是要分两种，一种为了参加创业比赛赢奖而在台上进行创业路演的学生，一种是为了挣钱在校期间有真实创办运作公司经历的学生。博主属于后者，业务活跃地点<strong>Base广州&amp;广州湾</strong>。博主参与的都是要求落地的商业案例，与多个公司合作，更多追求的是项目的健壮性与快速迭代，没有其他科技园团队成员那样，做创新型或包装型项目打比赛，正是博主的团队没有花心思在参赛上，即使自己技能足够也没去争取拿奖。之前在经历添彩这方面看得过于淡泊，没去好好渡金。不过博主私心里还是个想被认可的人，目前在马不停蹄地学习新东西和沉淀自己。</p><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><p>编程是我的爱好，很高兴选了计算机科学与技术专业，进入了科班行列。<br>刚入大学时，博主马上搜罗学校的科技团队，看中了当时院内评分最好的科技团队，名字叫网维创业工作室。了解后发现，工作室的创始人是一家千人体量公司CEO，十多年间，给工作室投资和合作机会，提供校园外界的资源和项目，扶持学生创业。目前工作室已创立了十多家互联网企业，当时博主蛮渴望成为其中一员。</p><p>博主的大一是创业准备阶段，从成功考核进入学校科技园网维创业团队开始，与同届伙伴携手，做创业准备。作为技术骨干，博主去学习网页软件开发，掌握了java写后端的技能；</p><p>大二则是一边学习一边接业务，找机会拓展渠道；</p><p>到大三才创办公司，有了公司资质，便有了广泛的客户群，有了各种签约订单，工作忙得没有了生活，疫情期间日均工作13小时；</p><p>大四达成网维团队初始设定的创业目标–可持续性经营， 也是承接了团队的十几年创业传统。</p><p>在一番折腾后，博主于刚毕业的六月末决定直接退出股权离开公司，退出了创业赛道。</p><p>博主在大学走了一条不同寻常稍坎坷的路，路上挑战重重，但感受到每一步是渐进式，人在不断成长。过程细讲怕涉及太多个人信息，总体有得有失吧。</p><h3 id="创业动机"><a href="#创业动机" class="headerlink" title="创业动机"></a>创业动机</h3><ol><li>当初就是对互联网方面有想法、有兴趣、也觉得自己有实力且合适就选择创业了，没有想得很复杂，分析很细致。</li><li>想过让自己创作的产品能在市场上得到认可反馈，有一个亲手打造的成就感满满的长线产品，自己顺势往复合式人才方向发展。</li><li>选择大学创业，是因为年轻有试错的资本，追梦也是年轻人的权利，大学是适合去积累创业经验的时间点，失败也无畏，真到上岁数很怕失去了这份激情。</li><li>现实有资源支撑，具备可行性，博主选择创业，能够得到机遇、人脉、客户、资金，还有创业前辈成熟的商业模式，加上一同上道的创业伙伴，博主具备足够的执行力，顺势而为了。</li><li>并非创业不可，博主做事也会权衡，考研，找工作，考公，创业在大一的时候都想过，这是个选赛道问题，早选择则不迷茫。机缘巧合接触了多位创业者，了解其人生轨迹后，博主内心挺愿意创业。</li></ol><h3 id="离开原因"><a href="#离开原因" class="headerlink" title="离开原因"></a>离开原因</h3><blockquote><p>根本原因是个人达到瓶颈上限，在公司里对个人发展失去信心。<br>博主主要负责项目技术，也参与团队管理，还会与客户对接，前期分析需求协助产品设计，后期对开发成品做验收测试，全流程打怪属于是。<br>什么都做，意味着什么都不精通。创业期间，博主的时间被繁杂重复的劳动工作占据，自己苦了自己，却发现一切都距离个人目标越来越遥远，得不到自身的价值追求。</p></blockquote><blockquote><p>博主想开了，博主的创业其实是在通过简单重复的方式赚取利润，旧的业务如此，不断探索的新业务也是如此，若是不精进自己，不赋能自身，就一眼看到尽头。<br>博主已经决定要成为专一的技术人员，要摆脱现状，跳出小公司氛围，离开自己的公司，裸辞去挤出时间精力去研究学习沉淀，势必把深层代码逻辑了解通透，学好算法与数据结构，深入操作系统与虚拟机，熟悉网络，数据库和分布式，跑好技术赛道。<br>不留恋过往，在设定目标后，参与到云上自习室，通过衡水模式的坚持+努力，最后希望找一个符合双方利益、有共同价值观的企业。11月了，博主还在坚持~</p></blockquote><h3 id="离开后感悟"><a href="#离开后感悟" class="headerlink" title="离开后感悟"></a>离开后感悟</h3><blockquote><p>总觉得，人生一定给自己一个plan B。博主也是个憨憨，当时决定创业后，主动舍弃了很多有用的机会，说不后悔是假的。首当其冲是错过校招机会，结合身边进入大厂的同学来看，<br>博主加入了科技园团队，若是不选择创业，按自己的学习情况，有希望进入一个不错的厂，可惜博主没有走好这一步棋。事到如今，过往就让他随风而去，走好当下才有更好的未来，博主也不放弃，有机会也去争取。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列|（转） 分布式最终一致性方案 &amp;&amp; 重复消费、消息堆积、消息丢失、顺序消息</title>
      <link href="/2021/01/06/mq-eventual-consistency/"/>
      <url>/2021/01/06/mq-eventual-consistency/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务——消息最终一致性方案-转"><a href="#分布式事务——消息最终一致性方案-转" class="headerlink" title="分布式事务——消息最终一致性方案(转)"></a><a href="https://www.cnblogs.com/myseries/p/10819804.html" target="_blank" rel="noopener">分布式事务——消息最终一致性方案(转)</a></h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　随着分布式服务架构的流行与普及，原来在单体应用中执行的多个逻辑操作，现在被拆分成了多个服务之间的远程调用。虽然服务化为我们的系统带来了水平伸缩的能力，然而随之而来挑战就是分布式事务问题，多个服务之间使用自己单独维护的数据库，它们彼此之间不在同一个事务中，假如A执行成功了，B执行却失败了，而A的事务此时已经提交，无法回滚，那么最终就会导致两边数据不一致性的问题；尽管很早之前就有基于两阶段提交的XA分布式事务，但是这类方案因为需要资源的全局锁定，导致性能极差；因此后面就逐渐衍生出了消息最终一致性、TCC等<code>柔性事务</code>的分布式事务方案，本文主要分析的是<strong>基于消息的最终一致性方案</strong>。</p><h3 id="普通消息的处理流程"><a href="#普通消息的处理流程" class="headerlink" title="普通消息的处理流程"></a>普通消息的处理流程</h3><figure class="image-box">                <img src="1684370-5a225e6eb5c076ca.png" alt="img" title class>                <p>img</p>            </figure><p>普通消息处理流程.png</p><ol><li>消息生成者发送消息</li><li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li><li>返回ACK给消费者</li><li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li><li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li><li>MQ删除消息</li></ol><h4 id="普通消息处理存在的一致性问题"><a href="#普通消息处理存在的一致性问题" class="headerlink" title="普通消息处理存在的一致性问题"></a>普通消息处理存在的一致性问题</h4><p>我们以订单创建为例，订单系统先创建订单(本地事务)，再发送消息给下游处理；如果订单创建成功，然而消息没有发送出去，那么下游所有系统都无法感知到这个事件，会出现脏数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订单处理(业务操作)</span></span><br><span class="line">    orderService.process();</span><br><span class="line">    <span class="comment">// 发送订单处理成功消息(发送消息)</span></span><br><span class="line">    sendBizMsg ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果先发送订单消息，再创建订单；那么就有可能消息发送成功，但是在订单创建的时候却失败了，此时下游系统却认为这个订单已经创建，也会出现脏数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 发送订单处理成功消息(发送消息)</span></span><br><span class="line">    sendBizMsg ();</span><br><span class="line">    <span class="comment">// 订单处理(业务操作)</span></span><br><span class="line">    orderService.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个错误的想法"><a href="#一个错误的想法" class="headerlink" title="一个错误的想法"></a>一个错误的想法</h4><p>此时可能有同学会想，我们可否将消息发送和业务处理放在同一个本地事务中来进行处理，如果业务消息发送失败，那么本地事务就回滚，这样是不是就能解决消息发送的一致性问题呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactionnal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 订单处理(业务操作)</span></span><br><span class="line">        orderService.process();</span><br><span class="line">        <span class="comment">// 发送订单处理成功消息(发送消息)</span></span><br><span class="line">        sendBizMsg ();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">         事务回滚;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息发送的异常情况分析"><a href="#消息发送的异常情况分析" class="headerlink" title="消息发送的异常情况分析"></a>消息发送的异常情况分析</h4><table><thead><tr><th>可能的情况</th><th>一致性</th></tr></thead><tbody><tr><td>订单处理成功，然后突然宕机，事务未提交，消息没有发送出去</td><td>一致</td></tr><tr><td>订单处理成功，由于网络原因或者MQ宕机，消息没有发送出去，事务回滚</td><td>一致</td></tr><tr><td>订单处理成功，消息发送成功，但是MQ由于其他原因，导致消息存储失败，事务回滚</td><td>一致</td></tr><tr><td><strong>订单处理成功，消息存储成功，但是MQ处理超时，从而ACK确认失败，导致发送方本地事务回滚</strong></td><td>不一致</td></tr></tbody></table><p>　　从上面的情况分析，我们可以看到，使用普通的处理方式，无论如何，都无法保证业务处理与消息发送两边的一致性，其根本的原因就在于：<strong>远程调用，结果最终可能为成功、失败、超时；而对于超时的情况，处理方最终的结果可能是成功，也可能是失败，调用方是无法知晓的。</strong> 笔者就曾经在项目中出现类似的情况，调用方先在本地写数据，然后发起RPC服务调用，但是处理方由于DB数据量比较大，导致处理超时，调用方在出现超时异常后，直接回滚本地事务，从而导致调用方这边没数据，而处理方那边数据却已经写入了，最终导致两边业务数据的不一致。为了保证两边数据的一致性，我们只能从其他地方寻找新的突破口。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>　　由于传统的处理方式无法解决<code>消息生成者本地事务处理成功</code>与<code>消息发送成功</code>两者的一致性问题，因此事务消息就诞生了，<strong>它实现了消息生成者本地事务与消息发送的原子性，保证了消息生成者本地事务处理成功与消息发送成功的<code>最终一致性</code>问题。</strong></p><h3 id="事务消息处理的流程"><a href="#事务消息处理的流程" class="headerlink" title="事务消息处理的流程"></a>事务消息处理的流程</h3><figure class="image-box">                <img src="1684370-f84835acfdd0507e.png" alt="img" title class>                <p>img</p>            </figure><p>事务消息处理流程.png</p><ol><li>事务消息与普通消息的区别就在于消息生产环节，生产者首先预发送一条消息到MQ(这也被称为发送half消息)</li><li>MQ接受到消息后，先进行持久化，则存储中会新增一条状态为<code>待发送</code>的消息</li><li>然后返回ACK给消息生产者，此时MQ不会触发消息推送事件</li><li>生产者预发送消息成功后，执行本地事务</li><li>执行本地事务，执行完成后，发送执行结果给MQ</li><li>MQ会根据结果删除或者更新消息状态为<code>可发送</code></li><li>如果消息状态更新为<code>可发送</code>，则MQ会push消息给消费者，后面消息的消费和普通消息是一样的</li></ol><p><strong>注意点</strong>：由于MQ通常都会保证消息能够投递成功，因此，如果业务没有及时返回ACK结果，那么就有可能造成MQ的重复消息投递问题。<strong>因此，对于消息最终一致性的方案，消息的消费者必须要对消息的消费支持幂等，不能造成同一条消息的重复消费的情况。</strong></p><h4 id="事务消息异常情况分析"><a href="#事务消息异常情况分析" class="headerlink" title="事务消息异常情况分析"></a>事务消息异常情况分析</h4><table><thead><tr><th>异常情况</th><th>一致性</th><th>处理异常方法</th></tr></thead><tbody><tr><td>消息未存储，业务操作未执行</td><td>一致</td><td>无</td></tr><tr><td>存储<code>待发送</code>消息成功，但是ACK失败，导致业务未执行(可能是MQ处理超时、网络抖动等原因)</td><td>不一致</td><td>MQ确认业务操作结果，处理消息(删除消息)</td></tr><tr><td>存储<code>待发送</code>消息成功，ACK成功，业务执行(可能成功也可能失败)，但是MQ没有收到生产者业务处理的最终结果</td><td>不一致</td><td>MQ确认业务操作结果，处理消息(根据就业务处理结果，更新消息状态，如果业务执行成功，则投递消息，失败则删除消息)</td></tr><tr><td>业务处理成功，并且发送结果给MQ，但是MQ更新消息失败，导致消息状态依旧为<code>待发送</code></td><td>不一致</td><td>同上</td></tr></tbody></table><h3 id="支持事务消息的MQ"><a href="#支持事务消息的MQ" class="headerlink" title="支持事务消息的MQ"></a>支持事务消息的MQ</h3><p>　　现在目前较为主流的MQ，比如ActiveMQ、RabbitMQ、Kafka、RocketMQ等，只有RocketMQ支持事务消息。据笔者了解，早年阿里对MQ增加事务消息也是因为支付宝那边因为业务上的需求而产生的。因此，如果我们希望强依赖一个MQ的事务消息来做到消息最终一致性的话，在目前的情况下，技术选型上只能去选择RocketMQ来解决。上面我们也分析了事务消息所存在的异常情况，即MQ存储了<code>待发送</code>的消息，但是MQ无法感知到上游处理的最终结果。对于RocketMQ而言，它的解决方案非常的简单，就是其内部实现会有一个定时任务，去轮训状态为<code>待发送</code>的消息，然后给producer发送check请求，而producer必须实现一个check监听器，监听器的内容通常就是去检查与之对应的本地事务是否成功(一般就是查询DB)，如果成功了，则MQ会将消息设置为<code>可发送</code>，否则就删除消息。</p><h3 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h3><ol><li><p>问：如果预发送消息失败，是不是业务就不执行了？</p><p>答：是的，对于基于消息最终一致性的方案，一般都会强依赖这步，如果这个步骤无法得到保证，那么最终也 就不可能做到最终一致性了。</p></li><li><p>问：为什么要增加一个消息<code>预发送</code>机制，增加两次发布出去消息的重试机制，为什么不在业务成功之后，发送失败的话使用一次重试机制？</p><p>答：如果业务执行成功，再去发消息，此时如果还没来得及发消息，业务系统就已经宕机了，系统重启后，根本没有记录之前是否发送过消息，这样就会导致业务执行成功，消息最终没发出去的情况。</p></li><li><p>如果consumer消费失败，是否需要producer做回滚呢？</p><p>答：这里的事务消息，producer不会因为consumer消费失败而做回滚，采用事务消息的应用，其所追求的是<strong>高可用</strong>和<strong>最终一致性</strong>，消息消费失败的话，MQ自己会负责重推消息，直到消费成功。因此，事务消息是针对生产端而言的，而消费端，消费端的一致性是通过MQ的重试机制来完成的。</p></li><li><p>如果consumer端因为<strong>业务异常</strong>而导致回滚，那么岂不是两边最终无法保证一致性?</p><p>答：基于消息的最终一致性方案必须保证消费端在<strong>业务上的操作没障碍</strong>，它只允许系统异常的失败，不允许业务上的失败，比如在你业务上抛出个NPE之类的问题，导致你消费端执行事务失败，那就很难做到一致了。</p></li></ol><p>由于并非所有的MQ都支持事务消息，假如我们不选择RocketMQ来作为系统的MQ，是否能够做到消息的最终一致性呢？答案是可以的。</p><h3 id="基于本地消息的最终一致性"><a href="#基于本地消息的最终一致性" class="headerlink" title="基于本地消息的最终一致性"></a>基于本地消息的最终一致性</h3><p> <img src="1684370-c5a20749a59fc1a8.png" alt="img"><br>基于本地消息最终一致性.png</p><p><code>基于本地消息的最终一致性</code>方案的<strong>最核心做法就是在执行业务操作的时候，记录一条消息数据到DB，并且消息数据的记录与业务数据的记录必须在同一个事务内完成，这是该方案的前提核心保障</strong>。在记录完成后消息数据后，后面我们就可以通过一个定时任务到DB中去轮训状态为<code>待发送</code>的消息，然后将消息投递给MQ。这个过程中可能存在消息投递失败的可能，此时就依靠<code>重试机制</code>来保证，直到成功收到MQ的ACK确认之后，再将消息状态更新或者消息清除；而后面消息的消费失败的话，则依赖MQ本身的重试来完成，其最后做到两边系统数据的最终一致性。<code>基于本地消息服务</code>的方案虽然可以做到消息的最终一致性，但是它有一个比较严重的弊端，每个业务系统在使用该方案时，都需要在对应的业务库创建一张消息表来存储消息。针对这个问题，我们可以将该功能单独提取出来，做成一个消息服务来统一处理，因而就衍生出了我们下面将要讨论的方案。</p><h3 id="独立消息服务的最终一致性"><a href="#独立消息服务的最终一致性" class="headerlink" title="独立消息服务的最终一致性"></a>独立消息服务的最终一致性</h3><figure class="image-box">                <img src="1684370-d36234ba75d83a95.png" alt="img" title class>                <p>img</p>            </figure><p>独立消息服务最终一致性.png</p><p><code>独立消息服务最终一致性</code>与<code>本地消息服务最终一致性</code>最大的差异就在于将消息的存储单独地做成了一个RPC的服务，这个过程其实就是模拟了事务消息的消息预发送过程，如果预发送消息失败，那么生产者业务就不会去执行，因此对于生产者的业务而言，它是强依赖于该消息服务的。不过好在独立消息服务支持水平扩容，因此只要部署多台，做成HA的集群模式，就能够保证其可靠性。在消息服务中，还有一个单独地定时任务，它会定期轮训长时间处于<code>待发送</code>状态的消息，通过一个<strong>check补偿机制</strong>来确认该消息对应的业务是否成功，如果对应的业务处理成功，则将消息修改为<code>可发送</code>，然后将其投递给MQ；如果业务处理失败，则将对应的消息更新或者删除即可。因此在使用该方案时，消息生产者必须同时实现一个check服务，来供消息服务做消息的确认。对于消息的消费，该方案与上面的处理是一样，都是通过MQ自身的重发机制来保证消息被消费。</p><p>转自：</p><p><a href="https://www.jianshu.com/p/04bad986a4a2" target="_blank" rel="noopener">分布式事务——消息最终一致性方案 - 简书 (jianshu.com)</a></p><hr><p>面试官杠上消息队列？重复消费、消息堆积、消息丢失、顺序消息…</p><p>什么，这么多问题啊！别慌，现在就来找找解决方案。</p><p><strong>注 意</strong></p><p> <strong>文末有：互联网大厂面试题、架构师项目实战视频等福利</strong></p><h3 id="一、-重复消费"><a href="#一、-重复消费" class="headerlink" title="一、 重复消费"></a><strong>一、 重复消费</strong></h3><p>现在消息队列一般都能保证at least once的，也就是消息至少一次投递。在这种情况为什么会出现重复消费的问题呢？通常都是由于网络原因造成的，原因如下：通常消息被成功消费后消费者都会发送一个成功标志给MQ，MQ收到这个标志就表示消息已经成功消费了，就不会再发送给其他消费者了。但是如果因为网络这个标志没有送到MQ就丢失了，MQ就认为这个消息没有被成功消费，就会再次发送给其他消费者消费，就造成重复了。</p><p>这时我们看这个问题就变成了我们怎么保证消费端的幂等性。</p><p>幂等性 是指一个操作其执行任意多次所产生的影响均与一次执行的影响相同，大白话就是你同样的参数调用我这个接口，调用多少次结果都相同。</p><p>怎么保证消息队列消费的幂等性</p><p>其实还是得结合业务来思考，我这里给出几个解决方案：</p><p><strong>1. 分布式锁</strong>。生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p><p><strong>2.唯一键防重</strong>。基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p><p><strong>3.先查后写。</strong>要写数据库前，先根据主键查一下，如果这数据都有了，你就别插入了，update一下好了。</p><p><strong>4. 关闭重试机制</strong>。如果把重试机制关掉的话不显示，虽然解决了重复消费的问题，但是可能会造成丢失消息，不建议这么做。</p><p>不同的业务可以选择不同的方案，如果服务的并发量不高，可以考虑唯一键防重或者先查后写的方案；如果并发量较高，追求性能，沐子推荐采用分布式锁实现幂等性（本公司目前采用的方案）</p><h3 id="二、-消息堆积"><a href="#二、-消息堆积" class="headerlink" title="二、 消息堆积"></a><strong>二、 消息堆积</strong></h3><p><strong>1. 消息堆积的产生原因</strong></p><p>消息堆积的原因主要在于两方面，其一为消费的太慢或消费方出现异常，其二为生产方生产的太快，总的来说就是消息的速度赶不上生产的速度，生产和消费速度不匹配造成的。</p><p><strong>2. 消息堆积的解决方案</strong></p><p>1）生产端：一般当生产端发生积压（Broker正常的情况下）就要查看你的业务逻辑是否有异常的耗时步骤导致的，是否需要改并行化操作等。</p><p>Broker端：当Broker端发生积压我们首先要查看，消息队列内存使用情况，如果有分区的的话还得看每个分区积压的消息数量差异。当每个分区的消息积压数据量相对均匀的话，我们大致可以认为是流量激增。需要在消费端做优化，或者同时需要增加Broker节点（相当于存储扩容），如果分区加压消息数量差异很大的话（有的队列满了，有的队列可能还是空闲状态），我们这时候就要检查我们的路由转发规则是否合理。</p><p>2） 增加消费者，多部署几台消费者机器（横向扩展），提升消费者的消费能力。</p><p>3）此种情况可以将这些消费不成功的消息转发到其它队列里去(类似死信队列)，后面再慢慢分析死信队列里的消息处理问题。</p><p>\4) mq 中的消息过期失效了。可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。</p><p>总之，上面说到消息积压的问题，我们需要查看是否有无限重发的消息或者有进入死锁的程序等等，当确定是流量激增的话，我们需要评估是否需要增加资源还是通过限流的方式解决，当短时间大量消息需要处理时，在资源允许的情况下，我们可以新启一批消费者与消息队列，将原来的消费者中的消息直接作为生产者转发到临时应急队列中，这样大概率的能够快速解决消息积压。与其事后处理不如我们在设计之初就要把积压考虑进来，对于数据量非常大，但是实时性要求不高的场景，可以设计出批量消息发送，当队列积累到一定阀值再做批量消费消费，这里需要注意的就是重复消费带来的影响，设计不好就是一场灾难。</p><h3 id="三、-消息丢失"><a href="#三、-消息丢失" class="headerlink" title="三、 消息丢失"></a><strong>三、 消息丢失</strong></h3><p>一般来讲消息丢失的途径有三个：生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据。</p><p><strong>1. 生产者弄丢数据</strong></p><p>a、丢失的原因：因为网络传输的不稳定性，当生产者在向MQ发送消息的过程中，MQ没有成功接收到消息，但是生产者却以为MQ成功接收到了消息，不会再次重复发送该消息，从而导致消息的丢失。</p><p> b、解决办法：有两个解决办法，第一个方法：向broker发送消息时，如果由于网络抖动等原因导致消息发送失败，可以设置失败重试次数让消息重发。</p><p>第二个方法：</p><p>事务机制和confirm机制，最常用的是confirm机制；</p><p>事务机制和</p><p> confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm</p><p>机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 MQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p><strong>2. MQ弄丢数据</strong></p><p>a、丢失的原因：MQ接收到生产者发送过来的消息，是存在内存中的，如果没有被消费完，此时MQ宕机了，那么再次启动的时候，原来内存中的那些消息都丢失了。</p><p>b、解决办法：开启MQ的持久化。结合上面的说到的confirm机制，只有当消息成功持久化磁盘之后，才会回调生产者的接口返回ack消息，否则都算失败，生产者会重新发送。存入磁盘的消息不会丢失，就算MQ挂掉了，重启之后，他会读取磁盘中的消息，不会导致消息的丢失。</p><p>注意，哪怕是你给 MQ 开启了持久化机制，也有一种可能，就是这个消息写到了MQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时MQ挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，MQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。</p><p><strong>3. 消费者弄丢数据</strong></p><p>a、丢失的原因：如果MQ成功的把消息发送给了消费者，那么MQ的ack机制会自动的返回成功，表明发送消息成功，下次就不会发送这个消息。但如果就在此时，消费者还没处理完该消息，然后宕机了，那么这个消息就丢失了。</p><p>b、解决的办法：1）简单来说，就是必须关闭 MQ 的自动提交，把自动提交改为手动提交，也就是说当我消费成功后才会进行提交。</p><figure class="image-box">                <img src="image-20220221020121786.png" alt="image-20220221020121786" title class>                <p>image-20220221020121786</p>            </figure><p>2）消费者端已经正常接收到消息但是在执行后续消息处理时发生了异常，最终返回处理失败。重试-进行重新消费问题，如果一直这样重复消费都持续失败到一定次数，可以投递到 DLQ 死信队列，应用可以监控死信队列来做人工干预。</p><h3 id="四、-顺序消费"><a href="#四、-顺序消费" class="headerlink" title="四、 顺序消费"></a><strong>四、 顺序消费</strong></h3><p>比如一个电商的下单操作，下单后先减库存然后生成订单，这个操作就需要顺序执行的。队列本身是有顺序的，但是为什么还要保证顺序消费呢，主要是因为生产环境服务实例一般都是集群，当消费者是多个实例时，队列中的消息会分发到所有实例进行消费（同一个消息只能发给一个消费者实例），这样就不能保证消息顺序的消费，因为你不能确保哪台机器执行消费端业务代码的速度快。</p><p>保证每次只有单个消费实例消费</p><p>所以对于需要保证顺序消费的业务，我们可以只部署一个消费者实例，然后设置MQ 每次只推送一个消息，再开启手动 ack 即可。这样MQ 每次只会从队列推送一个消息过来，处理完成之后我们 ack 回应，再消费下一个，就能确保消息顺序性。</p><p>这样MQ 每次只会从队列推送一个消息过来，处理完成之后我们 ack 回应，再消费下一个，就能确保消息顺序性。</p><p>但是这样的操作也会降低消费者的性能，一个消费者消费消息时，其他消费者会阻塞，所以很多场景下可能并不会采用这样的方案。</p><p>所以一般会根据场景，制定一定的策略来解决消费顺序问题。</p><p>多线程并发抢占出现消费乱序问题</p><p>当MQ采用简单队列模式的时候,如果消费者采用多线程的方式来加速消息的处理,此时也会出现消息乱序的问题。</p><p>多线程并发抢占出现消费乱序问题，将消息ID进行hash计算，将相同值放入同一个内存队列，让指定线程执行，即可解决顺序消费问题。</p><p><strong>在多个分区中保证消息顺序和消息处理效率</strong></p><p>首先使用多个分区，消息可以被发送端发送至多个分区，保证消息发送的效率。然后在消费端在拉消息时使用ConutdownLunch来记录一组有序消息的个数。如果达到个数，说明已拉取到完整的一组有序消息。然后在消费端根据消息序号进行排序，消费端将排好序的消息发到内存队列(可以搞多个)，一个内存队列开启一个线程顺序处理消息。即可最大程度上既保证顺序又保证效率！</p><figure class="image-box">                <img src="image-20220221020157000.png" alt="image-20220221020157000" title class>                <p>image-20220221020157000</p>            </figure><p>RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，支持顺序消息，所以如果有这种场景或者要使用MQ，小编建议你直接使用RocketMQ即可。</p><p>我们说了一些处理与分析问题的方法，这里有一个最重要的点就是我们需要有一套实用的监控发现工具或者方式，在问题第一时间发现才是王道，不然我们上面所说的都空谈，当问题发现的时候损失已经无法挽回。所以我们要在设计系统之初需要要为监控系统或者程序提供完备或者必须的日志，接口，数据等，这要才是一个合理的设计。当没有监控系统的情况下我们必须自己设计一套简单分析接口。</p><p>作者：首席架构师专栏<br>链接：<a href="https://www.jianshu.com/p/5db930b2071b" target="_blank" rel="noopener">https://www.jianshu.com/p/5db930b2071b</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 高可用 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> 技术 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会计学| 复式记账法</title>
      <link href="/2020/02/01/debit-creditbookkeeping/"/>
      <url>/2020/02/01/debit-creditbookkeeping/</url>
      
        <content type="html"><![CDATA[<p>借贷记账法</p><p>泛金融类企业的账务或者财务系统常常使用“借贷”记账法，又称<strong>复式记账法</strong>。</p><p>看一下财务系统的一条分录信息：</p><blockquote><p>借（D）：xx账号 1000元</p><p>贷（C）：xx账号 1000元</p></blockquote><p>什么是贷？什么是借？千万别被字面意思误导，忘记什么“贷”就是减少，“借”是“增加”等的错误印象。</p><p>在学习复式记账法，会计学的几个基础需要先弄明白。</p><h2 id="第一点：“借”、“贷”-只是一个符号"><a href="#第一点：“借”、“贷”-只是一个符号" class="headerlink" title="第一点：“借”、“贷” 只是一个符号"></a>第一点：“借”、“贷” 只是一个符号</h2><p>“借”“贷”二字，由于借贷记账法是从国外引入的，所以他们讲的“借”“贷”和我们日常所说的借贷（你以为的借款啊借钱呢 贷款啊）有比较大的差距，这一点特别会给我们理解借贷记账法增加一道障碍。</p><p>实际上，“借贷记账法”里的“借贷”与借钱、贷款没有半毛钱关系，它们仅仅是<strong>用来记账的符号而已</strong>。</p><p>“借”这一符号记为D（Debit）或D；</p><p>“贷”这一符号记为C（Credit）或C。</p><p>所以在这里，我们关键的一点是有一个心智：<strong>借（Debit）贷（Credit）二字理解成记录方向的符号就行，如同 左/右，买/卖，上/下，东/西等一类相反的符号。</strong>程序员可理解为<strong>布尔类型</strong>。</p><h2 id="第二点：两个会计基础公式"><a href="#第二点：两个会计基础公式" class="headerlink" title="第二点：两个会计基础公式"></a>第二点：两个会计基础公式</h2><p>前置内容《财务系统入门“三张表”》</p><blockquote><p>以一个包子铺的例子来进行串联三张表。</p><p>小明同学以前是后厂村路F4的一家做过账务清算系统的程序员，年底不幸被优化，但是也不能闲着呢，毕竟需要每个月还一万多的房贷呢，怎么办？</p><p>于是，他想在后厂村路开个包子铺赚钱。</p><p>说干就干，也是做过账务清算系统的，记账自然不能忘，从开始投资就要把帐记录好，看看自己究竟能挣多少钱，做生意嘛，挣钱才是最关键的，不能免俗，赚钱才是最终的目的。</p><p>为了记录赚多少钱这个事，引入了第一个重要公式：</p><p><strong>利润 = 收入 - 成本。</strong></p><p>举例来讲，包子铺一个月收入两万，成本是一万，那么小学生也能算清楚了，利润是1万。</p><p>这个记录收入、成本、利润的东西，换个高大上的名词，就是我包子铺这家企业的“利润表”。</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>回过头来讲，包子不可能直接new出来呢，需要找店铺付租金，购置面粉，还得找人，这一切的东西都需要实打实的现金投入呢，想想自己N+1的赔偿金也是不够呢。</p><p>粗略的算下来，至少30万，赔偿金只有20万，这差的10万怎么办呢？想起来在后厂村工作收到的“XX银行”、“XX”有钱花，为了自己的包子铺开起来，借一笔吧，利润好的话很快就能还上了。</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>该记账了，为了赚取利润，比如投入资源也就是钱，这也资源是产生收入的基础和来源，将它换个高大上的名字就是包子铺的资产了。</p><p><strong>资产的意思，就是包子铺用来产生收入的资源总和</strong>。按照来源，可以划分成自己的，和别人的。或者简单来讲，一部分是自己所有的，剩下的是借来的。</p><p>记录一下这个资产过程：</p><p><strong>资源总和 = 自己的 + 借来的。</strong></p><p>包子铺总投入30万 = 自己20万+ 借10万。</p><p>在财务上，换了一些装逼的名字：</p><p>自己的 = <strong>所有者权益</strong></p><p>别人的 = 一个债务或者负债；于是有：</p><p><strong>资产 = 所有者权益 + 负债</strong></p><p>这个公式耳熟能详的，这就是财务系统重要的<strong>资产负债表</strong>。</p><p>如下图，总结一下资产负债表的推导过程：</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>到了包子铺的日常经营中，有一些特例，小明不知道这笔钱该怎么记录，放在利润表不合适，放在资产负债表感觉也不对劲，一直困挠着小明，到底是什么事呢？</p><p>第一件事：由于在后厂村路，程序员同行颇多，熟人自然是避免不了的，比如小王，每天都会光顾小明的包子铺，可是从来不给钱，一个月下来，欠了300多，可是架不住时间长了，一年下来也是3000元，这笔钱小明该怎么记录呢？收入？但是钱没收到自己的手里呢。</p><p>有一天遇到了原公司的会计小丽，小明问小丽该怎么处理小王的这笔钱，小丽这么回答的：“这笔钱小王有义务未来偿还，你对他有追偿权，这笔算是包子铺的收入只是暂时未到账，需要一个中间账户来记录，过渡一下，等小王还了 就划掉”。</p><p>小明于是新建了一个中间账户，记录着像小王这种吃包子不给钱的情况，这笔钱叫做应收款项，等小王年底年终奖发了就还给我 应收款项就没了。</p><p>第一件事刚解决，第二件事又来了。</p><p>既然是新兴的程序员卖包子，当然就要与众不同了，为次小明花了10万元进口了一个AI机器人帮自己包包子，10万啊，不是小数目，一下子公司的现金就见底了，当然得上帐了，这笔钱又该怎么算呢？投资资产？还是今年的成本？不过这个机器人可以用很多年的，如果算成本也应该平均一下呢。</p><p>小明又拿免费的包子请教了一下会计同学小丽，小丽又给他上了一课：</p><blockquote><p>按照经济和商业的本质来处理每笔商业交易，和按照现金在收银台里流进流出，在很多时候是有差异的，有时差异需要长达十年才能弥补，有时永远也不能消除。前者在会计上叫暂时性差异，而后者叫永久性差异，它们的存在，对公司的利润表，纳税等，都会有广泛深入的影响。</p><p>为了处理现金流入流出和利润表及资产负债表表达的经济本质之间的差异，于是就出现了单独的一张报表：<strong>现金流量表</strong>。它的含义很简单，就是<strong>把企业的每笔交易，按照现金流入流出的角度记录下来。</strong></p></blockquote><p>得了，小明又get一个点，现金流量表。</p><p>这样，小王同学这种赊账行为，以及自己投资未来的钱都找到了记录地方。</p><p>复盘一下，小明的现金流量表的产生过程：</p><figure class="image-box">                <img src="640.webp" alt="图片" title class>                <p>图片</p>            </figure><p>总结：</p><p>利润表来表达该记账主体到底赚钱不赚钱或者赚多少的问题；</p><p>资产负债表记录的是为了实现赚钱的目的，能用到的资源以及它的来源（这个很重要，后面讲贷借记账大法的时候专门会提到这个）;</p><p>现金流表是一些特殊情况或者说是对前两者的一个补充。</p></blockquote><p>其中，有三条会计等式</p><p><strong>资产 = 负债 + 所有者权益</strong>，这是最基本的会计等式，通常被称为第一会计等式。</p><p><strong>利润 = 收入 - 费用</strong>，被称为第二会计等式。</p><p><strong>资产 = 负债 + 所有者权益 + 利润</strong>，这是将第一会计等式和第二会计等式相结合的第三会计等式，是利润分配前的会计等式。</p><p>将第二等式和第三等式连接起来，就形成了我们一般记账时最常用的等式：</p><p><strong>资产 + 费用 = 负债 + 所有者权益 + 收入</strong></p><p>以上公式的元素称为会计的五要素。</p><h2 id="第三点，账户分类"><a href="#第三点，账户分类" class="headerlink" title="第三点，账户分类"></a>第三点，账户分类</h2><p>为什么要讲会计的五大要素呢，为了后面我们的账户进行分类，大概我们的账户类别是围绕着这五个要素展开的。</p><blockquote><p><strong>资产</strong></p><p>是企业过去的交易或者事项形成的、由企业拥有或者控制、预期会给企业<strong>带来</strong>利润的资源</p><p>要点包括：</p><ol><li>资产必须是显示的资产</li><li>企业对于资产必须拥有所有权。从经济实质来看，企业以融资租赁方式租入的固定资产虽然在法律层面上不具有其所有权，但是由于占有时间长，也可以被看做是企业的资产</li><li>资产预期要给企业带来收益</li></ol><p>资产的确认条件：</p><ul><li>与该资源有关的经济利益很有可能<strong>流入</strong>企业</li><li>该资源的成本或者价值能够被可靠地计量</li></ul><p>资产的分类：</p><ul><li>流动资产，预计在一个正常经营周期内变现、出售或耗用，或者以交易为目的持有，或者预期在一年内变现的资产<ul><li>货币资产</li><li>交易性金融资产</li><li>应收或者预付款项</li><li>存货</li></ul></li><li>非流动资产，流动资产以外的资产<ul><li>可供出售金融资产</li><li>持有至到期投资</li><li>长期股权投资</li><li>投资性房地产</li><li>固定资产</li><li>无形资产</li><li>其他资产</li></ul></li></ul><p><strong>负债</strong></p><p>是指企业过去的交易或者事项形成的，预期会导致经济利益<strong>流出</strong>企业的现时义务</p><p>负债的确认条件：</p><ol><li>与该义务有关的经济利益很有可能流出企业</li><li>未来流出的经济利益的金额能够可靠地量化</li></ol><p>负债的分类：</p><ul><li>流动负债<ul><li>短期借款</li><li>应付票据</li><li>应付账款</li><li>预收账款</li><li>应付职工薪酬</li><li>应交税费</li><li>应付股利</li><li>应付利息</li><li>其他应付款项</li></ul></li><li>非流动负债<ul><li>长期借款</li><li>应付债权</li><li>长期应付款</li></ul></li></ul><p><strong>所有者权益</strong></p><p>企业资产扣除负债后由所有者享有的剩余权益。公司的所有者权益又称为股东权益。由于资产减去负债后的余额为<strong>净资产</strong>，所以所有者权益也就是所有者对于企业净资产的所有权</p><ul><li>所有者权益表明了企业的产权关系。但是，所有者权益并不与企业任何具体的资产项目发生对应关系</li><li>所有者权益与负债共同构成企业全部资产的来源，但是两者有着本质的区别<ul><li>所有者参与企业的经营管理，债权人无权参与</li><li>所有者根据资额比例以股利或者利润的刑事参与企业利润分配，债权人不参与利润分配，知识按规定得到偿付并获得利息收入</li><li>一般除按照法律程序减资外，一般不能提前撤回投资。而债权一般有规定的偿还期限</li><li>企业进行清算时，资产在支付了破产、清算费用后优先用于偿还负债，如果有剩余资产，才能进行所有权再分配</li></ul></li></ul><p>所有者权益的确认条件：</p><p>所有者权益的确认、计量主要取决于资产、负债、收入、费用等其他会计要素的确认和计量</p><p>所有者权益的来源包括：</p><ul><li>所有者投入的资本，既包括构成企业注册资本或者股本部分的金额，也包括超过注册资本或者股本部分的金额，即资本溢价或者股本溢价。</li><li>直接计入所有者权益的利得和损失，不计入档期损益、会导致所有者权益发生变动的、与所有者投入或者向所有者分配利润无关的利得或者损失。</li><li>留存收益。盈余公积和未分配利润的统称。</li></ul><p>所有者权益的具体表现为：</p><ol><li>实收资本</li><li>资本公积，包含资本溢价或者股本溢价、其他资本公积</li><li>盈余公积</li><li>未分配利润</li></ol><p><strong>收入</strong></p><p>企业在日常活动中形成的、会导致所有者权益增加的、与所有者投入资本无关的经济利益的总流入</p><p>收入的增加极可能表现为<strong>资产的增加</strong>，如增加银行存款、应收账款等；也可能表现为<strong>负债的减少</strong>，如减少预收账款；也可能表现为两者的结合</p><p>收入的确认条件：</p><ol><li>与收入相关的经济利益应当很有可能流入企业</li><li>经济利益流入企业的结果会导致资产的增加或者负债的减少</li><li>经济利益的流入额能够可靠计量</li></ol><p>收入的分类：</p><p>按照经营业务，分为主营业务收入和其他业务收入</p><p>按照性质不同，分为销售商品；提供劳务；让渡资产使用权</p><p><strong>费用</strong></p><p>企业在日常活动中发生的、会导致所有者权益减少的、与所有者分配利润无关的经济利益的总流出</p><p>费用既可以表现为<strong>资产的减少</strong>，如减少银行存款、应收账款等；也可能表现为<strong>负债的增加</strong>，如增加预收账款；也可能表现为两者的结合</p><p>费用的确认条件：</p><ol><li>与费用相关的经济利益应当很可能流出企业</li><li>经济利益流出企业的结果会导致资产的减少或者负债的增加</li><li>经济利益的流出额能够可靠计量</li></ol><p>费用的分类</p><p>费用包括生产费用和期间费用</p><p>生产费用指与企业日常生产经营活动有关的费用。直接材料、直接人工和制造费用。期间费用指企业本期发生的、不能直接或者间接归入产品生产成本，而应当直接计入当期损益的各项费用，包括管理费用，销售费用和财物费用</p><p><strong>利润</strong></p><p>企业在一定会计期间的经营成果，是评价企业管理层业绩的指标之一</p><p>利润 = 收入 - 费用</p><p>利润反映收入减去费用、直接计入当期利润的利得减去损失后的<strong>净值</strong></p></blockquote><p>有个规则：</p><p><strong>资产 + 费用 = 负债 + 所有者权益 + 收入</strong>，如果账户属于公式左边的我们成为资产类账户，相应的，右边的称为负债类。</p><p>一个账户是资产还是负债时，是看你的屁股坐在哪里，它是相对于一个记账主体的基础上的。</p><p>比如对于小明去某银行存了一笔钱，这笔钱对于银行这个主体来说，是客户放在银行的存款，但对银行实际上是银行的<code>负债</code>，相反，如果小明向银行借了一遍钱，银行发放给客户的贷款实际上是<code>资产</code>。</p><p><img src="v2-d2da03dc925b5c484da9a06031a4f3e4_720w.jpg" alt="img"></p><p>上面这段话多看几遍，彻底的理解它。</p><h2 id="最核心：借贷记账三步流程"><a href="#最核心：借贷记账三步流程" class="headerlink" title="最核心：借贷记账三步流程"></a>最核心：借贷记账三步流程</h2><h3 id="第一步：明确记账主体"><a href="#第一步：明确记账主体" class="headerlink" title="第一步：明确记账主体"></a>第一步：明确记账主体</h3><p>类比在讨论任何问题的时候我们先确定好边界，借贷记帐法目的是为了记账，记流水，但最关键的是我们要为谁记账。</p><p>比如“小明通过招商银行向支付宝充值了100元”这个情况，我们怎么记账？我们首先要做的就是要明确，是为小明记账，还是为招商银行还是支付宝记账，不同的记账主体记账内容肯定是不同的。</p><h3 id="第二步：明确账户属性"><a href="#第二步：明确账户属性" class="headerlink" title="第二步：明确账户属性"></a>第二步：明确账户属性</h3><p>这点在前面强调了，我们明确了记账主体后，需要明确记账主体下的账号类别，是“资产类”还是“负债类”，因为根据账户属性不同，记账方式也不同，后面举例来讲。</p><h3 id="第三步：按照会计理论进行加减。"><a href="#第三步：按照会计理论进行加减。" class="headerlink" title="第三步：按照会计理论进行加减。"></a>第三步：按照会计理论进行加减。</h3><p>资金像流水一样，是运动的，记账就是为了记录这种运用的过程，无非就是某个账户加，某些账户减，但是每个行业都有自己的术语，要不怎么体现出入门门槛呢，会计也不例外，加减多俗，我们换个高大上的名词“借”和“贷”。</p><p>从会计账本的格式来看，会计账户分成左右两个部分，一个部分表示记录增加，一个部分表示记录减少，账户左边的部分叫做借方，账户右边的部分叫做贷方。</p><p>如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-10cc0b3ee99435f1998ef57e18de2201_720w.jpg" alt="img"></p><p><strong>借贷记账法的结构</strong></p><p>账户的左方为借方，右方为贷方。</p><p>所有账户的借方和贷方按相反的方向记录增加数和减少数，即一方登记增加额，另一方就登记减少额。</p><p><strong>借贷记账法的记账规则</strong></p><p>有借必有贷，借贷必相等</p><p>同借同贷则相加，互异借贷则相减。</p><ul><li><p>资产 、费用:   增加用“借”表示，减少用“贷”表示；</p></li><li><p>负债 、所有者权益、收入:  增加用“贷”表示，减少用“借”表示。</p></li></ul><p><strong>会计分录</strong></p><p>简称分录，是对没想经济业务列出应借、应贷的账目民称以及其金额的一种记录</p><p>会计分录由应借应贷方向、互相对应的科目及其金额三个要素构成</p><p>会计分录的书写格式为：</p><ol><li>先借后贷，借方在前，贷方在后</li><li>贷方的文字和数字都要比借方后退两格书写</li><li>一借多贷或一贷多借和多贷多借的情况下，借方和贷方的文字要对齐，金额也要对齐</li></ol><p><strong><em>不能将没有互相联系的简单分录合并相加成多贷多借的会计分录，否则无法反应账户的对应关系</em></strong></p><p><strong>借贷记账法下的试算平衡</strong></p><ol><li>发生额试算平衡<ul><li>全部账户本期借方发生额 = 全部账户本期贷方发生额</li></ul></li><li>余额试算平衡<ul><li>全部账户借方期初余额合计 = 全部账户贷方期初余额合计</li><li>全部账户借方期末余额合计 = 全部账户贷方期末余额合计</li></ul></li></ol><p><strong>试算平衡的作用和局限</strong></p><p><strong><em>如果所有账户在一定时期内借、贷方发生余额合计不平衡，肯定本期内几张和结账有错误</em></strong></p><p>但是，如果试算平衡，只能说明记账和结账可能正确。即它不能发现全部几张过程中的错误和遗漏</p><p><strong>来个实例体验借贷记帐</strong></p><p><strong>场景：小明同学通过招商银行向自己的支付宝充值了100元。</strong></p><p>还记得刚刚提到的三步走吗？</p><p><strong>第一步：明确记账主体</strong></p><p>该场景中出现三个主体，小明、银行、支付宝。</p><p>我们先以小明这个主体来操作。</p><p><strong>第二步：明确账户类型</strong></p><p>该场景中小明有两个账户：银行存款账户、支付宝余额账户</p><p>对于这两个账户，都是小明的资产。</p><p>完成前两步，形成了如下关系：</p><p><img src="https://pic2.zhimg.com/80/v2-d18b8508a5bb2a430dc3211c09f26aa1_720w.jpg" alt="img"></p><p>在专业一点，画出会计版本：</p><p><img src="https://pic1.zhimg.com/80/v2-dd64ee369548bc652dab8c896823a508_720w.jpg" alt="img"></p><p><strong>第三步：按照会计理论进行加加减减。</strong></p><p>对于小明来讲，是把银行的钱，放到了支付宝里，银行存款账户减少，支付宝账户增加。</p><p>换成会计的语言：小明银行资产类账户减少，小明支付宝资产类账户增加，资产类增加记为“借”，所以在小明资产类-支付宝账户-左面（借方）记录一笔“增加了100元”。如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d8fe8d6515c4f79d07701e46396ba919_720w.jpg" alt="img"></p><p>小明银行资产类账户减少，资产类增加记为“借””，相对应的资产类减少记为“贷”，如下，小明银行存款-右面（贷方）记录一笔：减少100元。</p><p><img src="https://pic2.zhimg.com/80/v2-f3454d59a8ff9ba42be3f1fd748e247d_720w.jpg" alt="img"></p><p>一直没有提到我们的10字口诀：“有“借”必有“贷”， 借贷必相等”，我们再看一下，是不是这样的。</p><p><img src="https://pic1.zhimg.com/80/v2-36c3e46f881c16f017e174ea530ba18c_720w.jpg" alt="img"></p><p>隐含的操作行为：</p><p><img src="https://pic2.zhimg.com/80/v2-896672ca6d54ce464026a240742b3a39_720w.jpg" alt="img"></p><p>看完了这个例子还没看懂？我们再以该场景中的其他两个主体来看：</p><p>如果以支付宝为记账主体，记账后的结果如下：</p><p><img src="https://pic3.zhimg.com/80/v2-4dac94c5e11d3e26d07d705a76d2af8e_720w.jpg" alt="img"></p><p>第一步：记账主体为“支付宝”。</p><p>第二步：支付宝有个银行存款账户记录着自己在银行的备付金有多少，第二个，自己体系类的，为小明记账的小明余额户。一个是我的资产，一个是我的负债。</p><p>第三步：小明通过招商银行先我的支付宝备付金转移了100元，是增加，前面说过资产类增加记为“借”，所以在左边记录。</p><p>小明的余额增加，负债类增加记为“贷”，记载右面，这样“有借必有贷，借贷必相等。</p><p>隐含的记录规则：</p><p><img src="https://pic3.zhimg.com/80/v2-fc70e9ce5330bba60e3df134c34b8b3e_720w.jpg" alt="img"></p><p>还不明白？我在把以“银行”为主体的记账也写出来，自己在体会一下：</p><p><img src="https://pic4.zhimg.com/80/v2-35692cc30683fc38f63359ec03c09dc3_720w.jpg" alt="img"></p><p>再回过头总结一下：</p><p>复式借贷记账法：对每一笔资金操作所引起的会计要素（账户）的增减变动，都以相等的金额同时在两个或两个以上的相互联系的账户中进行记录的一种科学方法。</p><p><strong>“借”“贷”概念</strong><br>借贷仅仅是记账方法所使用的记账的符号，没有其它特殊的含义，与资金的借出、借入和贷款都没有任何关系。</p><p>如果将来你看到这样一条记录，你能看明白了吗？</p><blockquote><p>D：XXX存款额户 500<br>C：XXXXXXXXX 500</p></blockquote><p>这就是一条会计分录。</p><p>基于复式借贷记账方法，对每一笔经济业务所涉及应借应贷的账户及其金额的记录，简称分录。</p><pre><code>多级科目的会计分录如下：    平台侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-被授权人           贷：5401损益-主营业务成本    平台侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-企业           贷：5401损益-主营业务成本           贷：2202负债-应付账款-平台           借：5401损益-主营业务成本    企业侧        摘要：（快递单号）个人现结退款           借：1122资产-应收账款-员工           贷：5401损益-主营业务成本           贷：2202负债-应付账款-被授权人           借：5401损益-主营业务成本    员工侧        摘要：（快递单号）个人现结退款           贷：2202负债-应付账款-企业           借：3001所有者权益-实收资本</code></pre><p><img src="image-20220208092534699.png" alt="image-20220208092534699"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>数据库</p><ul><li>科目类别表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`subject_index`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`num`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'编码'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`typename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'类别'</span>,</span><br><span class="line">  <span class="string">`rootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`rootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`parentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`parentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`parentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`parentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`parenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220208083033398.png" alt="image-20220208083033398" title class>                <p>image-20220208083033398</p>            </figure><ul><li>科目余额表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`subject_balance`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'科目余额编号'</span>,</span><br><span class="line">  <span class="string">`subjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目名'</span>,</span><br><span class="line">  <span class="string">`subjectbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjecttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目类别'</span>,</span><br><span class="line">  <span class="string">`subjectrootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectrootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectparentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectparentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjectparenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  <span class="string">`financesubjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主体编号'</span>,</span><br><span class="line">  <span class="string">`ending`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'余额'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><ul><li>凭证单表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`voucher_index`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'凭证编号'</span>,</span><br><span class="line">  <span class="string">`vouchernum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证号'</span>,</span><br><span class="line">  <span class="string">`financesubjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'主体编号'</span>,</span><br><span class="line">  <span class="string">`biztype`</span> <span class="built_in">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型'</span>,</span><br><span class="line">  <span class="string">`bizid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'业务类型相关编号'</span>,</span><br><span class="line">  <span class="string">`originatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'制单人编号'</span>,</span><br><span class="line">  <span class="string">`auditorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'审核人编号'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`creatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`editorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'修改人'</span>,</span><br><span class="line">  <span class="string">`is_deleted`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否删除'</span>,</span><br><span class="line">  <span class="string">`is_locked`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否冻结'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><ul><li>凭证信息表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`voucher_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'凭证信息编号'</span>,</span><br><span class="line">  <span class="string">`voucherid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证编号'</span>,</span><br><span class="line">  <span class="string">`vouchernum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证号'</span>,</span><br><span class="line">  <span class="string">`summary`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证摘要'</span>,</span><br><span class="line">  <span class="string">`subjectid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目名'</span>,</span><br><span class="line">  <span class="string">`subjectbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjecttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目类别'</span>,</span><br><span class="line">  <span class="string">`subjectrootid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectrootname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'根科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编号'</span>,</span><br><span class="line">  <span class="string">`subjectparentnum`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目编码'</span>,</span><br><span class="line">  <span class="string">`subjectparentname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目名'</span>,</span><br><span class="line">  <span class="string">`subjectparentbalance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`subjectparenttypename`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父科目类别'</span>,</span><br><span class="line">  <span class="string">`familypath`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'科目祖先路径（用编号）'</span>,</span><br><span class="line">  <span class="string">`balance`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'凭证余额方向 true-借 false-贷'</span>,</span><br><span class="line">  <span class="string">`beginning`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'初始金额'</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'金额'</span>,</span><br><span class="line">  <span class="string">`ending`</span> <span class="built_in">decimal</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'余额'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`creatorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建人'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="string">`editorid`</span> <span class="built_in">bigint</span>(<span class="number">16</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'修改人'</span>,</span><br><span class="line">  <span class="string">`is_deleted`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否删除'</span>,</span><br><span class="line">  <span class="string">`is_locked`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'是否冻结'</span>,</span><br><span class="line">  <span class="string">`version`</span> <span class="built_in">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> <span class="keyword">COMMENT</span> <span class="string">'版本号'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="image-20220208085053670.png" alt="image-20220208085053670" title class>                <p>image-20220208085053670</p>            </figure><figure class="image-box">                <img src="image-20220208090551866.png" alt="image-20220208090551866" title class>                <p>image-20220208090551866</p>            </figure><p>会计分录练习题及答案</p><p>东方公司为增值税一般纳税人工业企业，2001年月12月份发生下列业务：</p><p> 1、 开出现金支票从银行提取现金2000元备用;</p><p>借：现金 2000</p><p>贷：银行存款 2000</p><p>2、 用现金支付生产车间办公用品费440元;</p><p>借：制造费用 440</p><p>贷：现金 440</p><p>3、 收到盛达公司前欠货款80000元，存入银行;</p><p>借：银行存款 80000</p><p>贷：应收账款—盛达公司 80000</p><p>4、 向前进工厂销售A产品一批，不含增值税的售价为100000元，增值税17000元，款项尚未收到;</p><p>借：应收账款—前进工厂 117000</p><p>贷：主营业务收入 100000</p><p>​    应交税金应交增值税(销项税) 17000</p><p> 5、 接到开户银行的通知，收到光明公司前欠货款150000元;</p><p> 借：银行存款 150000</p><p>贷：应收账款—光明工厂 150000</p><p>6、 向大华公司销售B产品一批，不含增值税的售价为200000元，增值税为34000元，合计234000元，当即收到大华公司签发并承兑 的面值为234000元，期限为三个月的商业汇票一张;</p><p>借：应收票据–大华公司 234000</p><p>贷：主营业务收入 200000</p><p>​    应交税金应交增值税(销项税额) 34000</p><p>7、 接到开户银行的通知，胜利工厂签发并承兑的商业汇票已到期，收到胜利工厂支付的票据款120000元;</p><p> 借：银行存款 120000</p><p> 贷：应收票据–胜利工厂 120000</p><p>8、 向宏达公司购买一批甲材料，按合同规定，东方公司用银行存款预付购货款50000元;</p><p>借：预付账款–宏达公司 50000 贷：银行存款 50000</p><p>9、 收到宏达公司发来的甲材料一批，增值税专用发票上注明的买价为80000元，增值税为13600元，合计93600元。扣除预付款 50000元，余额43600元东方公司用银行存款支付，甲材料已验收入库;</p><p>借：原材料甲材料 80000</p><p>​    应交税金应交增值税(进项税额) 13600</p><p>贷：预付账款–宏达公司 50000</p><p>​    银行存款 43600</p><p>10、厂部办公室张强因公出差，预借差旅费800元，付以现金;</p><p>借：其他应收款–张强 800</p><p>贷：现金 800</p>]]></content>
      
      
      <categories>
          
          <category> 会计学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> 会计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济学| 边际收益| 需求第一定律</title>
      <link href="/2019/12/02/law-of-demand/"/>
      <url>/2019/12/02/law-of-demand/</url>
      
        <content type="html"><![CDATA[<h1 id="个人主义的主观价值论"><a href="#个人主义的主观价值论" class="headerlink" title="个人主义的主观价值论"></a>个人主义的主观价值论</h1><h2 id="个人估值的多层含义"><a href="#个人估值的多层含义" class="headerlink" title="个人估值的多层含义"></a>个人估值的多层含义</h2><p>在讲需求定律之前，我们先要引入一个非常重要的概念，这个概念叫“个人估值”，什么是个人估值呢？根据阿尔钦的定义：“一个人对一件商品的个人估值，是他为了得到这件商品所愿意支付的其他商品的最高数量。”</p><p>倒过来，我们也可以说：“一个人对一件商品的个人估值，是他卖掉这件物品所必须得到的其他商品的最低数量。”</p><p>个人估值这个定义，虽然简单——为了得到一件商品，他所愿意放弃的其他商品的最大数量——但它有好几层含义。</p><p>概念：<br>第一，它是个人的，不是集体的；<br>第二，它是主观的，不是客观的；<br>第三，它是由行动支撑的，不是凭空的愿望。</p><p><strong>只有个人才有行动能力</strong><br>第一层，个人估值是个人的估值，不是集体的估值。集体不会感受，不会思考，也不会评估，做出个人估值判断的一定是个人。我们要知道集体不会做任何的事情，机构也不会做任何的事情，学校、机关、民族都不会做任何的事情。我们所说的，我们口头上喜欢说的哪个集体、哪个机构、哪个组织做的什么事情，其实最后都是个人做的。</p><p><strong>所有价值与估值都起源于个人</strong><br>第二层，它是主观的，绝对主观的。并不存在什么客观的估值，如果没有了人，世界上的财富就没有价值，价值都是人赋予的。</p><p>这一点是经济学很重要的一个方法论。许多经济学家还特意写过文章，或者在他们著作的开头就声明，他们是“个人主义的主观价值论者”。首先，他们的研究从个人主义开始，所有的个人估值、所有的价值起源于个人。其次，这些价值都是主观的判断，从这样的起点开始他们的研究。这叫“个人主义的主观价值论”</p><p><strong>个人行动都是可观察可记录的</strong><br>第三层，个人估值不是以个人的愿望为基础的，而是以他所愿意放弃的其他商品的数量来计算的。这是以行动为基础的，而这些行动是可以观察到的。这一点很重要。</p><p>你看它有两面性，第一，个人估值是个人的判断；第二，它不是一个纯粹的愿望，不是你空想的愿望，而是你以一种实际行动表现出来的一种现象，是外人可以观察、可以衡量、可以刻画、可以计算的。这一点也非常重要。</p><p>比方说，我们喜欢问，你觉得这位女孩漂亮不漂亮啊？好多人说，漂亮不漂亮，那完全是主观的判断，见仁见智。没错，经济学讲的首先是主观的判断，但是外人可不可以衡量，到底这个女孩漂亮不漂亮？</p><p>当然也可以。我们到街上看看，那些珠宝广告选的是哪位明星，这位明星的漂亮就是公认的漂亮。因为珠宝商不会随便选一位路人来做珠宝广告，他一定会选一位大家公认的美女来做珠宝广告。</p><p>实际上，一个特定的社会，在一个特定的时期，他们认为什么样才叫美，外人是可以评判的，可以观察的，可以记录的。</p><p>又比如说，人对于什么是舒适，看上去是一个主观的判断。当然，这确实是一个主观的判断，但是你看看世界上所有大众化的五星级酒店，里面的席梦思床、灯光、气味、设施都是高度一致的，因为其实大多数人，对于什么是舒适有共同的感受。</p><p>如果你说人的体验是千奇百怪的话，那理论上，你应该看到有各种各样不同的五星级酒店，有些五星级酒店是有席梦思床的，有些只提供木板床，有些是有抽水马桶的，有些是完全没有的，但实际上你找不到这样的五星级酒店。</p><h2 id="主观价值论与客观价值论的区别"><a href="#主观价值论与客观价值论的区别" class="headerlink" title="主观价值论与客观价值论的区别"></a>主观价值论与客观价值论的区别</h2><p>关于个人估值的应用很广，我今天先着重讲一点，个人主义的主观价值论跟“客观价值论”之间的区别。我们以前学过所谓的客观价值论，它的意思是说，所有世界上的物品，都有客观的、内在的、本质的，不以人的意志为转移的价值，而价格只是围绕这个本质的、客观的价值上下波动的一个现象。</p><p>而今天我说的，是所有的物品，它没有什么本身内在的价值，只有人对它的判断，人觉得它有价值，它就有价值。这两种不同的价值观怎么比较？哪一种才对咱们理解这个世界更有帮助、更好用？</p><p><strong>客观价值论能解释的现象，主观价值论也能解释</strong><br>我们来比较客观价值论和主观价值论，它们之间至少有三个区别： 第一，凡是客观价值论能够解释的现象，主观价值论，或者说个人估值这个概念也能解释。 比方说一辆名贵的跑车，它里面是不是凝聚的贵金属比较多一点？它凝聚的技术含量比较多一点？它凝聚的人类无差别的劳动多一点？是的，所以它比较名贵。 如果你觉得客观价值论能解释这个车为什么贵，那么通过个人估值，或者通过主观价值论这个概念，也能解释：那就是人们喜欢它，人们看重它，所以它就比较贵。</p><p><strong>客观价值论不能解释的现象，主观价值论也能解释</strong><br>第二，客观价值论不能解释的现象，个人估值、主观价值论也能解释。</p><p>比方说，一个明星，花几秒钟喝一瓶矿泉水拍下来的广告，它值很多钱。薛老师也喝矿泉水，拍下来的视频，就不值钱。这两段视频里面凝聚的人类无差别的劳动是差不多的，但市场价格却相差非常大。这一点客观价值论没办法解释，但是个人估值、主观价值论就能解释。因为人们看重的是明星的效应，因为明星短缺，普通的薛老师、普通的经济学老师不短缺。</p><p>比方说一张家庭老照片，也不外乎是一张照片，为什么对有些人来说非常珍贵呢？对有些人来说，它就是一张普通的照片呢？这从客观价值论上看，它得不到解释。但是从主观价值论上看就很清楚，因为人们看重它、觉得它有价值，它就有价值。</p><p>我还记得，在20世纪80年代初，经济学家张五常他说当时中国有两个姓邓的人最红，一个是老邓：邓小平；一个是小邓：邓丽君。</p><p>邓丽君为什么重要呢？因为邓丽君现象打破了当时人们对客观价值论的看法。邓丽君吃的跟别人吃的没多大差别，用的跟别人用的没多大差别，她的嗓音跟别人的嗓音从物理学上来看、从声波上来看没多大差别，但只要人们喜欢她，她就能够创造大量的财富。这是客观价值论觉得挺为难，而主观价值论能够轻而易举解释的现象。</p><p>客观价值论和主观价值论的两个区别：第一是客观价值论能解释的，主观价值论也能解释；第二是客观价值论不能解释的，主观价值论，或者说个人估值这个概念也能解释。</p><p><strong>主观价值论能够更好地指导生产</strong><br>第三个区别，是主观价值论能够更好地指导生产。为什么这么说呢？因为根据客观价值论，你只要在一件商品里面花了努力，付出了劳动，这件商品就具有价值。</p><p>但是主观价值论不这么看，主观价值论认为，你花不花时间、用了多少心思、花了多大的投资，这本身并不重要，最关键的是你能不能把它卖出去，你能不能适销对路，有没有人需要你生产的产品。</p><p>就这么一点区别，形成了计划经济体系和商品经济体系的重要区别。</p><p>计划经济体系里面，人是按照工分算的，你只要工作了，只要努力了，你就创造了财富；但是在商品经济里面，那是结果导向、需求导向，如果你生产的产品没人要，那么不管你投入多少资源，花费多少劳动，它也是不值钱的。所以主观价值论能够更好地指导生产，减少浪费。</p><p><strong> 音乐是否好听有没有客观标准？</strong><br>这个礼拜我们还讨论了一个重要的概念，就是“个人主义的主观价值论”。</p><p>我们说所有关于价值的评判，都是由个人主观作出的，但是他们的评判是可以观察到的，这一点非常重要。</p><p>前两天我也全程看了罗振宇和罗永浩的《长谈》，当中他们讲到，手机到底好看不好看其实有客观的标准。我非常同意这样的看法，因为人的品位最后是有生理基础的。</p><p>比方说，我自己对白色的日光灯就很敏感，觉得这种惨白的灯光简直不可以忍受。但这是不是一个见仁见智的问题呢？你去看看好的酒店，五星级的酒店，你就找不到一盏发出这种惨白光线的灯，它的灯光都是黄色的、温暖的。</p><p>同样我也觉得，音乐是不是好听，其实也有客观的标准。虽然音乐风格、音乐形式多种多样，每一位作曲家其实都是兼任创作者和鉴赏者的。他一方面有创作的能力，能够想象出很多的旋律；但他们同时也是鉴赏者，对自己创作出来的东西进行评判。</p><p>这两种能力，有些人都很强，有些人一个强一个弱。但是没有例外，他们都是很好的鉴赏者。比方说，莫扎特就两者都很强，他写出来的就是好听的。但贝多芬、勃拉姆斯他们可能不能一下子就把好的音乐写出来，但是写来写去，最后他们根据他们的评判，能够发表的都是好听的。</p><p><strong> 人们为什么送礼而不送钱？</strong><br>这里我顺便想到了一个很有趣的经济学问题，就是人为什么要互相送礼而不送钱。你看，很多礼物都是花钱买的，那为什么人们不直接送钱呢？送了钱以后，那个收礼的人不是有更大的自由度，可以爱买什么就买什么吗？</p><p>送礼而不送钱，从经济学的角度看，也能给出很多很好的解释。</p><p>我在德国法兰克福机场，给我的专栏主编小娴买小礼物。这点小礼物，它的市场价值其实挺高的，因为小娴真的要请人在德国给它买一点小礼物，那个运送费用可高了。但是对我来说呢，就是举手之劳，所以是我个人估值不高的东西送给她，让她觉得挺有价值的。这是送礼不送钱的一个原因，顺手方便。</p><p>你看有很多大公司，在赈灾的时候他们不是给钱，而是给他们公司的产品，这也是因为比较顺手的缘故。</p><p>当然送礼还有别的原因，其实也是自私的，比方说你想要人家记住你。</p><p>我到美国读博士的时候，我心里面就非常感激那位录取我的老师。因为我当时的一份成绩单就怎么都寄不到学校，所以我的申请根本就不被考虑，最后是这位老师网开一面，他说他们可以先考虑我的申请，但是到我入学的时候，如果你还不能提供这份材料，那我就不能入学。</p><p>他给了我这个机会，非常感谢他，所以去美国的时候，我就带了一幅画。这幅画的价值大概三四百块人民币的样子。但是我算了一下，它超过40美元，太贵了，不能送给老师，因为有收买老师的嫌疑。</p><p>一般我们都不给老师送任何礼物，这位老师时不时会请同学到他家里吃饭，同学们作为回报，会买一盒巧克力或者买一张明信片，甚至买一瓶酒，但是价值都不超过20块美元，一般十来块美元的样子，做个意思。我那幅画40美元太贵了。</p><p>我是时隔五年之后，已经毕业了，才把这幅画送给老师的。当然，为什么送画而不送钱呢？我是希望过好多年以后，到他家里面，还能看到我的画挂在他的客厅里，而不是反过来问他，老师我当时给你那50美元，还在你钱包里吗？</p><p>送礼而不送钱可能还有其他功能。</p><p>有一位叫苏珊·伍德沃德（Susan Woodward ）的女经济学家，她发现一个现象，就是在家庭主妇常看的杂志里面，经常有给男人用的各种修理工具的广告，原因是什么？</p><p>原因是家庭主妇喜欢给她丈夫买各种修理工具，买了这些修理工具，男人就会老老实实呆在家里修理东西，不会到处乱跑了。</p><h1 id="边际收益"><a href="#边际收益" class="headerlink" title="边际收益"></a>边际收益</h1><p><strong>钻石与水的故事</strong><br>我先来问你，你们家里有钻石，有矿泉水，是钻石给你带来的幸福大还是矿泉水给你带来的幸福大？</p><p>这个问题不好回答。最早提出这个问题的，是经济学鼻祖亚当·斯密，他问道：“水对于人的生命来说是非常重要的，但是水的价格却非常低。钻石对人的生命来说，一点用处都没有，但是钻石却非常贵，这是为什么？”</p><p>要回答这个问题，就必须用到边际的概念。</p><h2 id="何谓边际"><a href="#何谓边际" class="headerlink" title="何谓边际"></a>何谓边际</h2><p>边际就是“新增”带来的“新增”，这就是边际的概念。</p><p>边际成本就是每新增一个单位产品，所要新增的成本叫边际成本；边际收入是多卖一个产品，你能够新增的收入叫边际收入；边际产量是你多增加一份投入，所能够多获得的产量叫边际产量；边际效用是你多消耗一个单位的商品，所能带来的新增的享受叫边际效用。新增带来的新增就叫边际。</p><p>我们在消耗产品的时候，我们在吃馒头的时候，馒头给我们的边际效用是递减的。这句话什么意思？这句话的意思是，你吃第一口馒头，这口馒头给你带来的效用很高，第二口馒头它给你带来的新增的效用就会少一点，第三口又再少一点，一步一步地减下去，这叫边际效用递减。</p><p>美国的罗斯福总统，是美国历史上唯一一位连任4届的总统。当他第四次当选总统以后，有位记者就来问他：“第四次当选总统是什么感受？”罗斯福没有当场回答他的问题，而是请这位记者吃三明治。</p><p>吃第一块三明治的时候，这位记者觉得这可是殊荣啊，真是了不起，面子真大；第二块的时候他觉得已经感觉平平了；第三块的时候，他已经很难咽下去了。</p><p>然后罗斯福把第四块三明治放到这位记者的面前，他说：“你把这第四块三明治吃下去，你刚才问我的问题，我就不用回答了，你自己会有亲身感受。”</p><p>这就是<strong>边际效用递减</strong>的规律。</p><p>其他任何一个例子都是这样的。你养猪，在其他条件不变的情况下，你给这只猪喂饲料，多喂一点，它长的肉就多一点，再多喂，再多一点肉；但是总会有那么一个点，你再加饲料的话，它身体就会生病；再加，它也不会长肉，最后它会死掉。</p><p>喝酒也是这样，第一口酒我们觉得挺辣的不好喝，第二口酒、第三口酒慢慢喝顺了，每一口酒喝下去你得到的边际收益在递增，但是总有那么一点，你再往下喝，你的体验就开始下降，你就会越喝越难受，最后会喝醉。</p><p><strong>边际收益与边际成本趋同</strong><br>我们同时要知道，边际效用和边际成本是一个成对的概念。我们吃馒头，馒头带给我们的效用在递减，但与此同时，我们每吃一块馒头，都要付出一定的成本。比方说你要为馒头付钱，这时候边际效用递减，它减到某个程度，边际效用就会低过你为馒头所付的价格。这时候你就会停止买馒头，停止吃馒头。</p><p>换句话说，当你吃馒头的边际效用，高于你为多吃一个馒头所付出的边际成本的时候，你会继续吃馒头。但是倒过来，如果你为馒头所付的边际成本，高于馒头带给你的边际效用的话，你就要减少吃馒头。</p><p>也就是说，人们会朝着边际平衡的方向迈进，边际收益要尽量等于边际成本。</p><p>这是关于边际的第二个概念。你明白了这两点，咱们就可以回答，一开始我问你的问题：到底是水带给你的幸福高，还是钻石带给你的幸福高。</p><p>当然，亚当·斯密说的没错，水才是我们真正的必需品。事实上，整个过程是这样的。水对我们来说非常重要，所以当我们有钱的时候，我们花的第一个铜板用来买水，因为它是必需品；第二个铜板，也还是买水，因为我们太需要水了；第三个铜板，还是买水；第四个还是买水，第一千个铜板，咱们还是买水。这时候水带给我们的边际收益怎么样？</p><p>在下降，下降到一定程度，假设说到第一千个铜板的时候，边际上带给我们的收益已经相当低了。这时候，我们会动一个念头，说第一千零一个铜板，咱们能不能换一个花样，买一点点钻石？</p><p>那一个铜板给我们买来的一点点的钻石，能够很好地满足我们的虚荣心。于是咱们就把第一千零一个铜板用来买钻石。也就是说，在边际上你们家的水和你们家的钻石，给你带来的幸福是一样的。</p><p>你没有想到吧？你的回答可能是说水比钻石更重要，或者说钻石比水重要。你可能没想过，合理的答案，是它们在边际上给你的回报是一样的。</p><p>你想想，如果不一样会怎么样？如果第一千零一个铜板，你觉得还是需要多喝水，你会怎么做？你会继续买水，不会买钻石。倒过来，如果第999个铜板，你已经觉得买钻石更值得的时候，你就会用它来买钻石。</p><p>你在一个一个铜板花出去的时候，你在追求一件事情，就是水带给你的边际收益，要跟钻石带给你的边际收益相等。</p><p>也就是说，我们怎么才能保证，我们有限的铜板能带来最大的效用呢？办法就是我们一个一个铜板花出去的时候，要确保它永远花在边际效用最大的那个产品上面。</p><p>如果是水给我们的边际效用更大，我们就在水上面花钱，直到水的边际效用跌到跟钻石带给我们的边际效用一样为止，到那一步，我们就开始把铜板转向购买钻石。</p><p><strong>每个人都是边际平衡的高手</strong><br>我们把这个图景再扩大一点。我们举目看过去，我们身上的所有的财物，我们所进行的所有的活动，我们跟所有不同的人打交道，所花的时间，实际上每一个活动每一件商品，它带给我们的边际效用都是一样的。</p><p>如果不一样会怎么样？如果不一样的话，我们就会作出调整。所以我问你，你爱薛老师的“得到”专栏更多，还是爱你的家人更多？</p><p>经济学的回答是：在边际上，你对这两者的爱是一样的。当然你很爱你的家人，所以你花很多时间跟他们在一起，但是由于你花的时间多了，所以跟他们待在一起所带给你的边际效用就开始递减，减到一定的程度，你就会想，“如果我腾出10分钟时间来听薛老师的专栏，而不是跟家人待在一块的话，我得到的收益会更大”，这时候你就打开了你的手机，开始听薛老师的专栏。</p><p>所以在边际上，你对这个专栏的爱，跟你对家人的爱是一样的，有意思吧！</p><p>经济学挺重要的，如果你是个在校学生，你应不应该在经济学这门课上拿个100分？如果你在经济学上努力地拿100分，我就说你不是一个好的经济学学生，为什么？</p><p>因为你要花时间的地方太多了，在经济学这门课上，你从60分变成80分是相对容易的，80分变成90分那就更难了。因为边际成本在增加，而边际效用在递减。你提高的只不过是几分，你的学习总分，除了经济学这门课，还有好多门课。最后，当你从99分到100分的时候，你要花的努力非常的大，而这些努力带给你的边际收益却非常的低。</p><p>所以每一个人都应该是一个边际平衡的高手。也就是说，他应该利用自己有限的时间、有限的精力，在他所可能涉及的所有领域、所有活动、所有选项当中，根据边际平衡的规律，来分配他所有的时间、金钱、精力和其他资源，从而使他的总收入达到最大。</p><h2 id="边际概念才能指导对未来的行动"><a href="#边际概念才能指导对未来的行动" class="headerlink" title="边际概念才能指导对未来的行动"></a>边际概念才能指导对未来的行动</h2><p>我们永远要盯住边际，边际就是新增的新增。跟盯住边际相对的，那是盯住平均值和总量。平均值和总量，不是我们关心的，我们关心的是边际。</p><p>我口袋里面还有一块钱，这一块钱是拿来买水，还是拿来买钻石呢？我们做这个决定的时候，不是根据我们已经喝了多少水，水的总量；我们家里有多少钻石，钻石的总量。过去已经花了多少钱在喝水上不重要，过去已经花了多少钱在钻石上不重要，总量、平均量不重要。我们关注的是，现在手上的这一块钱，到底应该继续用来喝水，还是再买一点钻石。</p><p>我们关心的，是对未来行动的指导，而只有边际的概念，才能指导我们对未来的行动。平均的概念、总量的概念，对指导未来的行动没有帮助。</p><p><strong> 经济学家为什么不喜欢讨论人性善恶 </strong><br>很多哲学家、社会学家喜欢讨论一个问题，人本性到底是善的还是恶的，经济学家不关心这个问题。人的本性是善的还是恶的，讨论的其实是平均量和总量的概念。</p><p>经济学家关心的问题是，如果条件变化，人的行为会朝着哪个方向变化。一个人原来是多么善良或者多么不善良，这一点我们不关心，这是过去的总量或者平均量。</p><p>经济学家关心的是，如果条件变化，如果这个人饿了两三天，他人性不善良的一方面，会不会多暴露出来一点呢？如果社会对良好行为的赞许和奖励增加了，那么他人性当中善的一面，又会不会多表现出来一点呢？经济学家关心这样的问题。</p><p>人情究竟淡薄还是不淡薄？经济学家不关心这个问题。他们关心的是，如果时间成本高一点，那么人情是不是就会淡薄一点，人与人之间交往的礼数会不会就简化一点？</p><p>你在一个很少见到陌生人的乡村里面问路，和在一个大城市的地铁站里面问路，别人对你的耐心程度有没有区别？这是经济学家关心的问题。</p><p>这是为什么平均和总量并不重要，而应该盯住边际的意义。</p><p><strong> 边际平衡：边际收益等于边际成本</strong><br>我们先讲了边际的概念，在边际概念的基础上，我们有边际平衡的概念。也就是我们手上拿着有限的资源，把它投到哪一种用途上面去、从事哪一种活动，取决于哪一种活动带给我们的边际收益更大。</p><p>我们要追求的，是我们手上的有限的资源，在每一种不同的资源或者每一种不同的活动上面，带给我们的边际收入要均衡。</p><p>我们口袋里面的每一块钱，都是我们拥有的资源，它能用在不同的用途上，各种不同的用途都能给我们带来收益，那么到底这块钱应该用在哪呢？我们首先把它用在给我们回报最高的那种用途上面去。</p><p>我们点菜的时候，点一个菜不够我们点两个，两个不够我们点三个，当然这时这顿饭给我们带来的收益就一点一点下降了。下降到某个程度，我们觉得再多一盘菜给我们的收益，比不上我们付出的这一块钱，那么我们就停止点菜了。这就是边际收益等于边际成本的概念。</p><p>所以我们一般说，每当边际成本等于边际收益的时候，我们所获得的总效用是最高的。</p><p><strong> 自助餐为什么流行</strong><br>但你要注意，这里面有一个小的例外，较真地说，我们吃的自助餐，那就是一个边际收益应该等于边际成本的反面案例。</p><p>你看自助餐跟点菜不一样：点菜是多吃一份多给一份钱，自助餐是你给完钱以后，再怎么吃都不用再付钱的。这时候，你吃自助餐的话，就不会在你认为不值得再多花一份钱的时候停下来，因为你不需要再花钱了。这时候你会一直吃，吃到你完全不想再吃的时候才停下来。</p><p>这是两个不同的点。前面那个点是比较早的，你觉得不值得再花多一份钱来吃的时候，那是一个早一点的时间点；而如果你不需要为多吃一口而付任何代价的话，你就会一直吃，直到多吃一口你自己得到的效用是负的、是痛苦那一点为止，那是一个晚一点的时间点。</p><p>所以，从“边际效用应该等于边际成本”的概念来看，自助餐这种形式对社会资源来说是一种浪费。那我们怎么解释自助餐这种形式，在世界上还那么流行呢？</p><p>这时候，我们就得把其他的一些因素考虑在内，比方说点菜缺乏灵活性，比方说餐厅要监督顾客到底吃了几口，监督成本也太大了。把这些因素考虑在内，自助餐的安排也是合理的。</p><p><strong>强者越强的趋势不会永远继续下去</strong><br>“穷者越穷富者越富这句话有道理吗？或者说强者越强弱者越弱，这种趋势会永远继续下去吗？”</p><p>强者不会无止境地发展，因为使强者变强的那些因素，带来的效益是会边际递减的，是会回归的。世界上没有任何一种禀赋，它的边际收益是永远上升的。这个道理我小时候就懂。</p><p>我不知道你有没有玩过，我们小时候玩的“斗兽棋”：猫比老鼠强，狗比猫强，老虎又比狗强，狮子更强，最后最强的是大象，但是大象会被谁征服？被老鼠征服。</p><p>这是个循环，身体越庞大，它的缺点也会逐渐显露出来，边际收益总有下降的时候。</p><p><strong>皮凯蒂的《21世纪资本论》</strong><br>有人提到皮凯蒂的《21世纪资本论》，说这就证明“资本带来的收益会持续增加”。但这本书本身，就提供了反例，他的书的内容就表明：亚洲正在崛起。今天欧洲和美国操心的，就是他们的劳动者相对变穷了，而同时我们都知道，亚洲的劳动者变富裕了。过去上百年来，欧美才是资本的代表，但资本积累到一定程度，边际收益就递减，劳动力的边际收益就递增。</p><p>如果资本本身就具有“越集聚就越增长”的属性，也就是“2的平方， 加2的平方，再加2的平方（即12），一定比不上2+2+2之和的平方（即36）多”的话，那么人类早就把所有企业整合为一家企业，把所有资本集中到一个人手里，而社会财富已经达到无限了。然而，看来世界并不是这样的。</p><h1 id="需求第一定律"><a href="#需求第一定律" class="headerlink" title="需求第一定律"></a>需求第一定律</h1><p>需求第一定律的内容是说：“无论何时何地，价格提高，商品的需求量就减少，价格降到一定的程度，需求量就会增加。”</p><h2 id="需求曲线"><a href="#需求曲线" class="headerlink" title="需求曲线"></a>需求曲线</h2><figure class="image-box">                <img src="Snipaste_2022-02-08_06-00-13.png" alt title class>                <p></p>            </figure><p><strong>当价格上升到一定程度的时候，横坐标需求量就减少；当价格下降，横坐标需求量就增加。这就是需求第一定律。</strong><br>从马歇尔开始的一个传统：在需求曲线上，纵坐标用的是价格，其实可以把它理解为，它才是自变量，横坐标需求量是一个因变量。也就是说，当价格发生变化的时候，需求量会发生变化。这是我们要说的第一点。</p><p><strong>需求与需求量存在重要区别</strong><br>第二点非常重要，就是我们要区分需求和需求量之间的区别。好多人，包括很多的经济学者，他们都没把这两个概念分清楚，时不时他们就混淆。你不能够混淆这两个概念：需求量和需求。</p><p>在需求曲线上的任何一点，它刻画的是价格和需求量之间的关系。也就是说，当价格发生变化，需求量所发生的变化，这是它每一个点所代表的含义。这些点，整个需求曲线上面的所有的点，它们共同构成了一条需求曲线。</p><p>这条需求曲线对应的，是一组关于价格和需求量之间的关系，这整条曲线被称之为一个需求函数，或者一个需求表，或者简单地说是一种需求。</p><p>整条曲线是一个需求函数，或者需求表，或者简单地称之为需求。而这条曲线上的任何一个点所对应的横坐标叫需求量，也就是说，一个点对应的是一个量，需求量。整条曲线对应的是一种需求。</p><p>那么在经济学里面，一条需求曲线或者一个需求，它刻画的是：当所有其他条件不变的情况下，价格和需求量之间的对应关系。</p><p>我们有两种不同的变化：</p><p>一种是需求曲线本身不动，我们沿着这条不动的需求曲线滑动，需求曲线上面的每一个点代表其他条件不变，只有当价格变化的时候，需求量的相对变化。</p><p>另外一种变化，是整条需求曲线发生平移，发生转动，位置发生变化，这表示其他的因素、其他的条件发生了变化。</p><p>下面哪种情况会改变对假发的需求。我说的是会改变对假发的需求，不是需求量。<br>1秃子的收入增加，会不会改变对假发的需求？<br>2帽子的价格上升，会不会改变对假发的需求？<br>3护理头发的成本上升，会不会改变对假发的需求？<br>4重归单身生活，会不会改变对假发的需求？<br>5假发的价格下降，会不会改变对假发的需求？</p><p>答案是前面4种情况都会改变对假发的需求。只有假发的价格下降，不会改变对假发的需求，它改变的只是对假发的需求量。也就是最后一条，假发的价格发生变化，它是沿着一条不变的需求曲线上下滑动。</p><p>其他的4种情况：</p><p>第一，秃子的收入增加，他的财富发生了变化，他对假发的需求也会发生变化。这时候，他对假发的需求曲线就会发生移动；</p><p>第二，帽子的价格上升，帽子是假发的替代品，这时候帽子贵了，他对假发的需求曲线，也会发生变动，也会发生移动；</p><p>第三，护理头发的成本上升，道理是一样的，这时候他对假发的需求也会发生变动，假发的需求曲线也会发生移动；</p><p>第四，重归单身生活，这时候他更要美了，他更要出去约会了，他对假发的需求也会发生变动。</p><p>只有最后一点，假发的价格下降不会使他对假发的需求曲线发生移动，而只是在同一条不变的需求曲线上面滑动。所以，什么时候在同一条需求曲线上面滑动，什么时候要移动需求曲线，理解起来并不难。</p><p>其他任何条件都不变，只有价格发生变化的情况下，我们用滑动来表现；当价格以外的其他条件发生了变化，我们就得平移需求曲线。</p><p><strong> 需求曲线永远向下倾斜 </strong><br>比方说，玻璃做的项链一般人要的很少，但如果是钻石项链，我们买的更多，是不是社会上有一些商品，我们是喜欢越贵越买的呢？那越贵越买，是不是得用一条倾斜向上的需求曲线来表现啊？</p><p>那我给你讲一个有趣的故事。我经常说，如果按照地区来划分的话，我觉得经济学教育水平最高的地区是香港。为什么呢？因为张五常曾经在香港当过18年的高中考大学的经济学试题的出题人，所以一般的中学生只要修过经济学这门课，就能回答这个问题，到底需求曲线有没有向上的。</p><p>有一次，我们有几个朋友坐在一块聊天，其中一位就说：“世界上其实是有倾斜向上的需求曲线的，因为存在着越贵越买的行为。玻璃的项链，人们买得很少，钻石的项链人们买得很多。”</p><p>这时候我们当中的一位女孩，她是在香港读过高中的，她也不是什么经济学家，就读过高中。她脱口而出：“那都不是同一条Curve。”她的意思是，那不是同一条曲线。玻璃所代表的是一条倾斜向下的需求曲线，而钻石代表的是另外一条位置更高，但仍然是倾斜向下的需求曲线。</p><p>股票市场也是这个含义。当股价上升，人们愿意多买一只股票的时候，经济学家怎么来描述？这并不是一条倾斜向上的需求曲线，而是一条位置更高，但仍然是倾斜向下的需求曲线。</p><p>它的含义是什么呢？是人们对这只股票的评价已经发生了变化，这只股票已经变成了另外一种产品，但是如果购买的代价更低，那么人们还是愿意买更多。</p><h2 id="供应曲线"><a href="#供应曲线" class="headerlink" title="供应曲线"></a>供应曲线</h2><figure class="image-box">                <img src="Snipaste_2022-02-08_05-59-02.png" alt title class>                <p></p>            </figure><p>当价格很低的时候，需求量横坐标就很高；价格逐渐上升，需求量就逐渐减少；当价格上升到一定程度，需求量就萎缩成为零。<br>那你会问，如果价格再进一步上升，需求量是多少？这个图就跑到了第二象限，需求量是个负的了。</p><p>也就是说，当价格高到一定程度的时候，需求量就是负的。</p><p>负的需求量是什么意思？负的需求量，意思就是说需求变成了供给。所以你看图里面那条虚线，就是第二象限里面的虚线。其实，它就是一个供给，你把它镜像的折返回来，折到第一象限里面去，它其实就是一条供应曲线。</p><p>这话是什么意思呢？这话是说需求和供给没有黑白之分，它取决于市场价格。当一件商品的市场价格比较低的时候，你是个需求者，你要买入，你要消费；但是当这件商品的价格逐渐升高的时候，你对它的需求量就逐步减少；当这个产品的价格进一步上升，你就停止购买，停止消费；如果它的价格还在上升，你就从需求者变成了供给者。</p><p><strong>价格上升，需求者可变供给者</strong><br>我给你举个例子。好几年前，我有一位经济学同行，在微博上发了这么一个帖子：</p><p>“今天早晨从北京北五环仰山桥去河北廊坊开会，接连询问了9辆出租车，没有一辆车愿意去，一共70公里的路程，条件是一不打里程表，二要三百元钱，三要50%的回程空驶费，合计要450元钱；空驶费有这么算的吗？只好愤然取车自驾去了。”</p><p>我的这位经济学同行还发出感慨：“对于有些人来说，如果灵魂的表坏了，单靠提价是解决不了问题的。”</p><p>我看了他的帖子，就转发并做了一个评论。我说，你这个例子很生动，恰恰说明了价格的重要性。</p><p>第一，当价格提高到450块钱的时候，原来你是个需求者，现在变成了供给者。我可以想见，如果价格不仅仅是450块钱，是4600块钱的时候，你可能就不当经济学老师了，去当出租车司机了。</p><p>第二，如果连续九位司机都不肯接活，恰恰说明这条路线的定价系统出了问题，因为概率上你很难连续找到九个跟金钱过不去的傻瓜。出租车司机出来，他不就是要赚钱吗，他不就是要提供服务吗？他怎么会不干呢？</p><p>那我们可以断定恰恰是定价系统出了问题，而不是什么人的灵魂出了问题。</p><p>说起需求者随着价格的上升会变成供给者这一点，我还想起我当年到美国读书的时候，给我提供住房的就是一对年轻的夫妇，他们都是音乐家，刚买了房，但是他们自己不住，提供给外来的学生。那是为什么？那不就是因为价格比较高，他们宁愿牺牲自己的享受来为别人提供服务吗？</p><p><strong>“消费者剩余”改称为“交易者剩余”</strong><br>讲到需求曲线，我们还得讲另外一个重要的概念，叫“剩余”，或者叫“消费者剩余”。</p><p>你看这条需求曲线，曲线上任何一个点，都代表一个人对这件商品在这个单位上面的个人估值，也就是说，他愿意为了获得这个单位的服务所愿意付出的最大的代价，最多的其他商品。</p><p>但是你要知道，一个人对一件商品的个人估值，跟他为了得到这件商品所付出的代价之间有很大的差距。</p><p>比方说，在我的冰箱里面，有各种各样的食物，有冰激凌、水果、蔬菜，还有肉类，假设它们的总价是三百块钱。这时候忽然停电了，没有了电，里面的食物都会坏掉，三百块钱，眼看就会付诸东流了。这时候如果有人跟我说，他愿意给我提供电，那我愿意付多少钱呢？</p><p>1块钱我愿意付、2块也可以、10块、100块、200块，250块我都愿意付。因为冰箱里面的食物值300块钱，所以只要电价不高于300块钱，我都愿意支付。但实际上我们每天支付的电价是多少呢？大概就是一度电一块钱左右。</p><p>为了保住冰箱里的食物，你愿意花300块钱，但你实际上每天所付的电费也就是一两块钱。这一两块钱跟300块钱之间的差距叫剩余。所以我们在日常生活当中，消费各种各样的商品所享受到的剩余是巨大的。</p><p>同样，生产者和商品的提供者，他们也享受很大的剩余。</p><p>你想想，发电厂卖给你一度电几毛钱，但实际上如果价格再低一点，他们也愿意卖，所以他们也享受了他们对电的个人估值和电的实际价格之间的差价，他们也享受了剩余。</p><p>这当中的剩余，到底应该归谁所有呢？我们通常的名字叫“消费者剩余”，这个名字容易产生误导，让人以为这当中的剩余是属于消费者的，而如果生产者占有了这个剩余，就不地道。</p><p>但实际上，我们知道，这个剩余也就是消费者的个人估值，和他们实际上付出的价格之间的差距，是消费者和生产者共同产生的。</p><p>没有消费者的估值，就不会有剩余；但是如果没有生产者生产和提供，那也不存在这个剩余。所以我们把它称之为“消费者剩余”是容易产生误导的。我的建议是把他们称之为“交易剩余”，只要有交易，买卖双方就都能够享受到无中生有的效用。</p><p><strong>菜农的需求曲线</strong><br>假如你是个菜农，如果市场上的菜价上升了，那么你对蔬菜的需求量是上升了还是下降了？</p><p>这是两条曲线，一条是市场上一般人对蔬菜的需求曲线，当蔬菜的价格上升，其他的因素不变，蔬菜的需求量就会下降。但这时候菜农是个例外，因为他的财富状况明显受到他卖蔬菜的收入的影响。蔬菜贵了，他卖的更好了，收入增加了，财富状况发生了变化。也就是说，他自己的需求曲线发生了移动。这是另外一条需求曲线，他变得有钱了。所以不论在哪个价位上面，它的需求量都上升了。</p><p>菜农的问题的重点，在于理解什么时候是沿着需求曲线滑动，什么时候是需求曲线发生移动。菜价变化对一般人的影响，只是使他们在不变的需求曲线上滑动，而对菜农的影响，则是使他的需求曲线发生了移动。</p>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济学|科斯定律|交易费用|初始界定|平衡解|租与寻租</title>
      <link href="/2019/11/26/coase-theorem/"/>
      <url>/2019/11/26/coase-theorem/</url>
      
        <content type="html"><![CDATA[<p>最近看了薛老师的经济学课堂,感觉受益匪浅,对一些人一些事有了不一样的看法。原来我们生活上的习惯,风俗,道德规范和制度等,它的设定和延续都是有道理和规律所在,这些道理和规律,就是今天我要讲的,这也是薛老师课程里的相关内容</p><h1 id="科斯的忠告"><a href="#科斯的忠告" class="headerlink" title="科斯的忠告"></a>科斯的忠告</h1><p>现在很多人觉得,经济学就意味着曲线和方程式,经济学家们一头埋进象牙塔里,兴致勃勃地解决它们发现的问题,其高度却让人望而却步。<br>科斯把这种经济学批判为”黑板经济学”,他主张了解世界,先掌握经验知识,再解决具体问题的”真实世界经济学”。<br>2010年,科斯邀请一批来自中国的经济学家,到芝加哥大学举办为期一周的研讨会, 科斯103岁挂的,那年他是100岁,他是被院长推着轮椅来到会场,<br>然后他说什么呢?他说,”今天会议非常重要,不是因为我,是因为你们在,中国的经济学家在”他说了5遍<br>这话很重要啊,原因有两:<br>1.中国经济学家撬动的人口多,影响力就大;<br>2.西方经济学已经走上歧途,用了大量的数学,走上了僵化,中国经济学还没完全成形,还有发展空间<br>这就是科斯的忠告:”真实世界的经济学”而不是”黑板经济学”</p><hr><p>好,现在,我想先提几个问题</p><p>飞机场旁边的民宅,成天受扰,居民是否应该要求机场作出相应的赔偿?</p><p>私有土地”风能进,光能进,国王不能进”吗?</p><p>人为什么愿意放弃自己给自己的产品和劳动定价的权利,进入企业工作,把自己的劳动力和贡献一次性地批发给企业,并接受企业经理指手画脚的指挥呢?</p><p>男女结婚各得其所,合作共赢,但礼金和嫁妆为什么总是需要呢?至今还在延续这种习俗?</p><h1 id="交易费用的定义"><a href="#交易费用的定义" class="headerlink" title="交易费用的定义"></a>交易费用的定义</h1><p>假设铁路和亚麻的农场是同一个人所有;假设游泳池和酒店是同一人所有,假设麦田和吃小麦的牛是同一个人所有,有一个好处,他在做计算的时候,做衡量的时候,几乎不需要任何成本,只要自己脑袋里面打架就可以了,只要自己说服自己就可以了</p><p>但现实生活中,哪有这么简单的事情…<br>1.哪怕一个人,晚上做的决定,睡下觉,明天早上起床,也许就有了不同的主意。<br>2.现实生活,我们是两个人,甚至更多人,那么人们到达成资源争用的协议,就麻烦多了<br>比如,人们会隐瞒自己的真实想法,讨价还价的时候虚张声势,有时候不知道对方的存在,即使知道,也很难见面,语言不通,距离很远,还有相互敲竹杠的行为,所有这些行为我们称为”交易费用”</p><p>经济学家张五常:”凡是一个人的社会不存在,而在多个人的社会里存在的成本,就叫交易费用”</p><p>一个人的社会存在成本。比如今天打鱼,那就不嫩去打猎了,今天挖井,就不能修房子。成本是为达到一种目的而放弃另一种目的所牺牲的经济价值,也就是说,成本是放弃了的最大代价,所以哪怕只有一个人的社会。</p><p>有一些成本是一个人的社会不存在的,比如,不需要给自己的财产做公证.不需要给自己的房子加一把锁,不需要花钱跟人打官司,不需要监督别人的劳动,给他计工分</p><p><strong>这些活动,在一个人以上的社会才存在,它们所产生的费用,就是”交易费用”</strong></p><p><strong>交易费用永远为正</strong><br>在现实社会当中交易费用永远是正的，交易费用不是零，交易费用往往是很高的。</p><p><strong>交易费用越低越好</strong><br>我们一方面要理解交易费用当然越低越好，因为交易费用低的话，人们就能够更方便地进行交易，能够更好地配置资源，所以一个社会，交易费用越低是越好的。</p><p>但同时，有些经济学家做统计发现，现代社会越是发达、文明的社会，他们当中有些交易费用，不仅没有跌，而且在涨。比方说律师的费用、通信的费用、教育的费用。</p><p>他们因此得出一个错误结论：交易费用越高越好。这种看法是错的，交易费用当然是越低越好。但是为什么会看到在现代生活中，在文明社会当中，有些交易费用在不断上升呢？</p><p>原因在于，那些落后地区交易费用不是零，而是无限大，所以它们没有被纳入计算当中。</p><p>比方说通信费用，在过去没有互联网的情况下，你要交网费吗？在没有电话的情况下，你会交电话费吗？在没有邮差的情况下，你会交邮票费吗？不会交。那时候看上去我们不会因为通信花一分钱，而那个时候，通信的交易成本其实是无限大，而不是零。</p><p>是技术使得我们进行通信变得可能，这时候，我们的生活费用当中，就多了一项通信费。这通信费看上去是挺高的，但其实它比原来的无限高已经低了很多了。唯一的差别是，在过去它没有纳入计算，而今天它纳入计算了。</p><h1 id="“科斯定律”的定义"><a href="#“科斯定律”的定义" class="headerlink" title="“科斯定律”的定义"></a>“科斯定律”的定义</h1><p>当交易费用为0的时候,不管产权属于谁,资源都会落在最有价值的用途之上。</p><p>误解:很多人认为,科斯说现实生活交易费用是0,科斯没有这个意思<br>相反,科斯,他说,现实交易费用可大着,也就是意味着,要达到他所推测的结果—<strong>不管资源归于谁,所有都能够推到最高的用途上–当中的障碍是非常大</strong></p><p>举个栗子,有个工厂喷黑烟,危害周围居民的健康。我们假定周围有5户居民,每户居民遭受的损失是100块,所以,黑烟造成的伤害是500元。</p><p>再假如,大家都知道,只要在工厂装个过滤器,那么居民就能健康地生活,过滤器价格50元,<br>根据科斯定律,在没有交易费用的情况下,无论法官把污染权判给谁,工厂都会装上过滤器<br>如果判工厂,工厂自掏50元装上;<br>如果判居民,他们就会凑齐50装上,让工厂装上;<br>但是,现实哪有这么好的事情?现实, 居民凑50,再跑到工厂说服工厂装上,这当中就有一系列的麻烦,<br>比如,这五户人,人口有多有少.小孩影响比较大,每户人家的小孩数目又不一样,污染程度又不一样,他们会愿意每个人平均出10元吗??</p><p>所有这些都是现实中的交易费用,而这些交易费用可能大到你无法执行的地步。</p><p>这个时候,初始界定就显得尤为重要。</p><h1 id="初始界定"><a href="#初始界定" class="headerlink" title="初始界定"></a>初始界定</h1><p>思考：风俗习惯和道德规范为何如此重要？</p><p>有个老居民小区修建的时候没有装电梯,现在居民老了,需要一个电梯,但是,就七八层的楼,关于要不要装电梯,怎么装电梯,电梯的费用怎么出的协议,其中的交易费用相当高。</p><p>1.如果这几户人家明明可以达成协议,最后因为互相扯皮,互不认识,互相抬杠,交易费用过高,导致协议无法执行,这算不算市场失败?<br>不,这是世界的失败,是造物主的失败,人就是这样,互不信任。</p><p>2.由于存在交易费用的障碍,权利和资源无法达到最优化。这个时候,如果第三方,比如,政府和有识之士–经济学家,他看到资源应该被分配的方向,他们使用手上的权利,强制对资源进行重新分配,这样做是不是能有效地促进资源的有效的分配?</p><p>肯定是的,也就是说,我们鼓励第三方,在确认资源最佳分配的情况下,在知道资源如何使用更好的情况下,非常有把握的情况下,使用手上的强制力对资源进行重新分配。</p><p>这也就是所有制度,风俗,道德规范以至于政府,法院存在的最根本的理由, 负责完成对资源,责任,权利的初始界定。</p><p>你想想啊,生活一辈子,道德规范,制度约束有多大改变?很小是吧。</p><p>我们很大部分都遵循沿袭的习惯，就节省了很多重新计算的成本,重新讨价还价的成本,重新和别人协商的成本。</p><p>想想,如果交易费用为0的情况,一个人的社会里面,资源,责任,权利怎么分配都无所谓,随机分配都可以,因为咋们可以重新达成协议,资源可以重新调拨,重新落到更有用的地方上。</p><p>但现实呢,交易费用往往是很高的,由于现实中的阻力,所以初始分配就显得尤为重要,习惯,风俗,制度道德规范的就变就显得尤为重要。</p><p>现实往往是通过沿用过去的习惯来节省成本。<br>所以凡是遇到传统的东西,我们首先要理解他,理解他为什么存在,为什么不能随随便便改</p><p>举个栗子,醉驾。</p><p>如果交易成本为0的情况,我们就不需要制定禁止醉驾的规则,因为爱喝酒的人和行人能达成协议,行人上街前可以联系爱喝酒的司机：我今天要上街,你能不能花钱请个代驾？</p><p>如果那个爱喝酒的司机不愿意,那个行人可以说:我帮你请。这是理想的状态,是交易成本为0才发生的。</p><p>显然，现实不可能，所以规则就变得重要了。法律规定“喝酒不能驾驶”，这是对爱喝酒司机的剥夺，他们会说：喝酒驾驶不是罪，撞人才是罪。规则为什么不设定撞人才罚，凡是喝酒驾驶就开始罚？</p><p>因为，各方付出成本不同。路人付出成本高不可攀：要识别哪个司机喝酒而选择避开。</p><p>倒过来，司机在喝酒前请代驾，这事的成本相对低。所以，我们的风俗习惯、道德规范，就把避免意外的责任加到司机上，形成“喝酒不能驾驶”的法律。</p><h1 id="征地的权衡"><a href="#征地的权衡" class="headerlink" title="征地的权衡"></a>征地的权衡</h1><p>政府到底有没有权力向私人征用土地，并把土地用到他们认为价值更高的用途上面去？</p><p>有人说，土地产权保护应该做到“风能进，雨能进，国王不能进”的地步，土地是私人绝对的拥有。别人一点权力都没有，政府一点都不能侵犯私人的产权。这种想法对于保护私有产权来说，当然有帮助。</p><p>但不合理。假如有个人到美国去买土地，他在美国的最北面到美国的最南面买下宽度一寸的土地，这样他就能把美国一分为二了。如果我们奉行刚才说的“风能进，雨能进，国王不能进”的原则的话，他就能把美国东西两侧所有的交通都给阻断了。那是非常可怕的事情，也是非常不合理的事情。</p><p>政府动用手上的征地权，我认为就是合理的。</p><p>事实上，美国宪法第五修正案规定：“假如没有公正的补偿，那么私人财产也不得被取用于公共用途。”<br>美国政府征用私人土地，必须同时符合两个基本条件，一是被征用的土地必须用于公共用途，二是征用时政府必须给予私有产权所有者以公正的赔偿。<br>所谓的公正补偿，比较容易确定，可以根据周边的地产的收购价格，让被征地者有一个参考。<br>所谓的公共用途，却没有一个明确界定。</p><p>2005年美国发生过一场“基洛诉新伦敦市政府案” 。</p><p>辉瑞公司想要征一块地来修建研发中心。它说修成后，能够多雇人，解决社会就业问题，同时向政府多纳税，多做贡献。算是公共用途。</p><p>在这块地上，有一幢粉红色的小房子，户主是一个名字叫基洛的女人，她不愿意把小房子卖给辉瑞公司，结果她就把帮辉瑞公司征地的政府告上了法庭。</p><p>这个案子后来打到最高法院去了。你可能会说，如果一家私人公司雇几个人交一点税，这就算是公共用途的话，那么哪家私人公司都有权力去随便征用别人的土地了，法官一定会站在这个女人基洛的一边。你可想错了。</p><p>这个案子，美国最高法院以5:4的比例确认基洛败诉，而她的粉红色的小房子最后被夷为平地。</p><p>更富戏剧性的是，最后辉瑞公司又决定不再修建研发中心了，结果基洛原来房子的这块地，变成了垃圾堆填区。美国也能发生这么荒唐的案子。</p><p>这个例子是要说明，在征地问题上，两边倒都不对，得中间取一个平衡。但问题是中间的平衡怎么取得，是一个没有确定答案的问题，还有待摸索。</p><p><strong>香港的征地制度</strong><br>根据香港的《强制销售条例》，只要不可分割的物业的90%以上的所有者同意出售，那么剩下的10%的业主，就必须出售他的土地，就必须出售他的资产。<br>到2010年，这个《强制销售条例》，又做了修改，从90%下降到80%。<br>到底是90%合理还是80%更合理呢？我们不可能有一个科学的界定。但这里的要点，是我们必须在私有产权和政府的征地权之间取得一个平衡，这是解决问题的基本方向。</p><p><strong>我国大陆征地</strong><br>我国大陆的征地，政府充当所有土地的唯一买家和唯一卖家，也就是说，政府是对土地进行统购统销的。<br>这样的问题是交易双方更偏向一边。政府确实应该具有征地的权力，同样政府也应该保护私有产权。在这两者当中，应该取得一个平衡。（误</p><h1 id="平衡解"><a href="#平衡解" class="headerlink" title="平衡解"></a>平衡解</h1><p>讲个黄石公园引入狼群的故事，黄石公园到底要引入多少狼，各方争执不已。最后人们找到了一个办法，那就是一头牲口，如果被咬死了，养狼的人要赔多少钱，这时候就能够找到一个平衡解。</p><p><strong>宿舍的安静权</strong><br>几个人住一个宿舍，当中有两位同学，他们要马上考试，需要安静复习；另外几个同学，想要办一个Party。那么这天晚上的安静权是留给复习功课的同学呢？还是留给那些要办Party的同学？</p><p>这时候我们就能够用上科斯定律了。我们说这个问题，不是谁伤害谁的问题，而是资源怎么使用的问题。我们可以让要复习的同学出个价，说他认为的安静权值多少钱，两个同学说值50块钱，那么加起来就是100块钱。但办Party的同学会说，如果咱们不在宿舍里面办，要跑到外面去办，至少得花上300块钱。</p><p>这时候要办Party的同学，说最多愿意出300块钱买下安静权。要办Party的同学愿意出的300块钱，跟希望能够安静复习的同学愿意出的100块钱，之间有200块差价，这200块钱就是这两种同学之间的交易剩余。他们在当中找任何一个数字达成交易，都会皆大欢喜。</p><p>最后办Party的同学只给260块钱，就能把安静权买下来，还省了40块钱；同时超出了要复习的同学的预期，他们拿到了260块，而不是100块。他们拿着这个钱，在外面可以找一个很好的咖啡厅，在那里有喝的，有吃的，好好地刷夜，好好地复习，这就是寻找合作解的一个例子。</p><p><strong>无线电频谱争用</strong><br>无线电频谱，就是我们听收音机的波段。两个电台之间，它们挨得很近，一个电台的信号就会干扰另外一个电台的信号。同样无线电传输也有这个问题，当时很多人都认为，像这种无线电频谱互相干扰的情况，一定得由政府来解决。</p><p>但是科斯说，不一定要政府帮忙，只需要把无线电频谱一段一段地切割开来，就好像停车场里面一个一个的车位，然后拿去拍卖，就可以解决问题了。</p><p>这个想法，在今天我们看来好像没有任何新奇之处，但是在当年，政府官员第一次听说这个想法以后，觉得简直是天方夜谭。</p><p><strong>蜜蜂的寓言</strong><br>说起合作解，经济学家张五常还写过一篇著名的文章，名字叫“蜜蜂的寓言”（”The Fable of the Bees: An Economic Investigation” ）。</p><p>我们知道蜜蜂和果树是互相利用的一对，蜜蜂利用了果树的花蜜，而果树则利用蜜蜂来传授花粉，它们互相利用。问题是，它们之间的互相利用并不完全对等，其中一方会占另外一方更多便宜。</p><p>于是有一位经济学家，诺贝尔经济学奖获得者米德（James Edward Meade ），出来说这是一种真正的市场失败。</p><p>他说，蜜蜂占了果树的便宜，但是养蜂人没有给果农足够的补偿，所以果树的种植就没有达到最大化，如果果农能够得到养蜂人一些补偿的话，他会种更多果树，这时候对蜜蜂采蜜，才会有更大的帮助。由于果农和养蜂人之间没有交易，所以这是一种市场失败。因此米德建议说，政府应该补贴果农，让他们多种树。</p><p>但是张五常去做了实地考察，他发现，其实果农和养蜂人之间，早就形成了互相付费的习惯，那里早就形成一个市场了。</p><p>在美国华盛顿州，苹果树的花蜜不足，蜜蜂传授花粉的贡献更大，这时候，当地的果农就向养蜂人交补贴。相反，在佛罗里达州，橘子的花蜜非常充分，而蜜蜂传授花粉的服务就显得不够，这时候倒过来，就是当地的养蜂人向果农支付补贴。</p><p><strong>瑞格利球场的门票</strong><br>瑞格利球场周边的房子顶上全是座位，每当瑞格利球场举办比赛，周围的居民也向别人卖门票，观众不仅可以进入瑞格利球场看球赛，他还可以到周围居民区，跑到他们的房顶上去观看比赛。</p><p>这些居民区的房顶，建得还相当有规模，它有座位，有看台，还有双层看台，还能提供一些饮食服务。</p><p>你会想，这球场的主人能同意周围的居民这么来卖门票吗？</p><p>当然不同意了。我们知道每年芝加哥的小熊球队，就在这个体育场比赛，门票可是一笔巨大的收入，球场的主人当然不愿意让周围的居民分占他们的收入。</p><p>其实这种居民的看台早就有了，以前是稀稀落落的，直到1980年代，芝加哥小熊球队开始崛起，他们的球赛变得越来越好看了，门票收入越来越高了，这时候居民卖门票，搭顺风车的行为也越来越嚣张了。</p><p>这时候小熊球队还有这个球场，他们就不同意了。到2002年，球场的管理者开始采取行动，想要加进一些挡风的设施，阻挡居民观看比赛。居民也不示弱，他们说：“我可不一定想要看你的比赛，但是你建的这些挡风设施，挡住了我们的视线。”</p><p>到后来他们双方斗到了法院，斗过一阵以后，他们又在法院以外达成了和解。最后和解的方案是居民向球场交纳收入的17%作为回报。然后球场也就同意居民成规模地修建他们的座椅、看台。</p><p>17%这个数字，我也不知道他们是怎么得到的，跟咱们中国的增值税刚好是一个数。不管怎么样，球场和居民达成了合作解，球场的视觉资源得到了最佳的使用。</p><h1 id="租与寻租的定义"><a href="#租与寻租的定义" class="headerlink" title="租与寻租的定义"></a>租与寻租的定义</h1><p>首先了解成本的概念，<strong>成本是放弃了的最大代价。</strong><br>成本就是放弃了的最大代价，如果没什么可放弃，也就不存在成本，所以我们说：“沉没成本不是成本”。凡是说成本，我们一定是向前（未来）看，而不是向后（过去）看的。</p><p>最简单的情况是一个人的社会有形的物资，一棵木材，它用来取暖，就不能拿来盖房子了，这是成本最早的概念。</p><p>然后我们又把它扩充了，它不仅仅是指有形的物资，它也可能指无形的物资。我们盖房子的时候，需要阳光权，可能会产生安静权的问题，还会产生空气权的问题，这些抽象的资源也纳入我们对成本的考虑。</p><p>还需要了解“盈利”和“亏损”的含义。<br>我们说所有的盈利都是横财，都是意外的收入；所有的亏损都是横祸，都是意外的损失。只要发生了盈利或者发生了亏损，我们对资源未来的使用价值就作出了新的调整，成本也因此相应地进行了调整。</p><p>所以旱涝保收的生意，过一段时间以后，它就不再是旱涝保收了，因为当中的资源的价格发生了变动，使用这些资源所要付出的成本也发生了变动。所以<strong>盈利永远只是一次性的，亏损也是一次性的</strong>。</p><p>我们从成本的角度出发，解释“租”的含义，<strong>租就是租金的租，也就是利润、利益、好处。</strong> 租就是对资产的付费，而这个资产的供给在一定程度上，是不以付费的变化而变化的，那就是白赚的收入。</p><p>记得吗？猫王的下一份工作，要比他今天做歌手的工作差很远，所以无论赚多赚少，他仍然会当猫王，仍然会继续唱歌。这当中就有一大部分的收入，是他作为歌星这种资源，而白赚的。这叫租的概念。</p><p>讲完租的概念以后，我们讲“寻租”的概念。寻租的概念指的是，企业在向政府争夺垄断性优惠政策的过程当中，也要付出巨大的成本。“在那里，个人竭尽使价值最大化造成了社会浪费，而没有形成社会剩余”。<strong>是没有从事生产的情况下，为垄断社会资源或维持垄断地位，从而得到垄断利润（亦即经济租）所从事的一种非生产性寻利活动。</strong> 所以我们说乞丐并没有白拿施舍，乞丐拿施舍的过程本身就耗费了好多的资源。这是寻租的概念，也是从成本的概念中衍生出来的。</p>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos部署web项目的环境配置</title>
      <link href="/2019/10/07/centos-init/"/>
      <url>/2019/10/07/centos-init/</url>
      
        <content type="html"><![CDATA[<h2 id="系统查看"><a href="#系统查看" class="headerlink" title="系统查看"></a>系统查看</h2><p>查看版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure></p><h2 id="安装JAVA8"><a href="#安装JAVA8" class="headerlink" title="安装JAVA8"></a>安装JAVA8</h2><p>输入命令，查看jdk安装情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure></p><p>#如果jdk已经存在，可使用批量卸载命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java | xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure></p><p>直接yum安装1.8.0版本openjdk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure><p>验证安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p><h2 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h2><p>输入命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/MariaDB.repo</span><br></pre></td></tr></table></figure></p><p>通过vim操作，写入并保存<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = http://mirrors.ustc.edu.<span class="keyword">cn</span>/mariadb/yum/<span class="number">10.3</span>/centos6-amd64/</span><br><span class="line">gpgkey = http://mirrors.ustc.edu.<span class="keyword">cn</span>/mariadb/yum/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[mariadb]</span><br><span class="line">name = MariaDB</span><br><span class="line">baseurl = http://mirrors.ustc.edu.<span class="keyword">cn</span>/mariadb/yum/<span class="number">10.3</span>/centos7-amd64</span><br><span class="line">gpgkey=http<span class="variable">s:</span>//mirrors.ustc.edu.<span class="keyword">cn</span>/mariadb/yum/RPM-GPG-KEY-MariaDB</span><br><span class="line">gpgcheck=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>搜索已安装的mariadb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br></pre></td></tr></table></figure></p><p>如果存在就删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps mariadb-*</span><br><span class="line"></span><br><span class="line">yum remove mysql mysql-server mysql-libs compat-mysql51</span><br></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum -y install mariadb mariadb-server</span><br></pre></td></tr></table></figure></p><p>基本命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">systemctl start mariadb <span class="comment">#启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb <span class="comment">#设置开机启动</span></span><br><span class="line">systemctl restart mariadb <span class="comment">#重新启动</span></span><br><span class="line">systemctl stop mariadb.service <span class="comment">#停止MariaDB</span></span><br></pre></td></tr></table></figure></p><p>启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure></p><p>设置开机启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig mysql on</span><br></pre></td></tr></table></figure></p><p>登录到数据库　 用命令登录到MariaDB，此时root账户的密码为空。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot</span><br></pre></td></tr></table></figure></p><p>进行MariaDB的相关简单配置,使用mysql_secure_installation命令进行配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure></p><p>配置用户 （账号：root 密码 123456【请修改】）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password &apos;123456&apos;</span><br></pre></td></tr></table></figure></p><p>配置权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 123456</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;missionary&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><hr><h6 id="配置字符集-可忽略"><a href="#配置字符集-可忽略" class="headerlink" title="配置字符集(可忽略)"></a>配置字符集(可忽略)</h6><p>查看当前字符集<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES WHERE Variable_name LIKE <span class="string">'character_set_%'</span> OR Variable_name LIKE &gt; <span class="string">'collation%'</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">show variables like <span class="string">'%character%'</span>;</span><br><span class="line"></span><br><span class="line">show variables like <span class="string">'collation%'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">写mysql 命令</span><br><span class="line">``` bash</span><br><span class="line">set character_set_server=utf8;</span><br><span class="line"></span><br><span class="line">set collation_database=utf8_unicode_ci;</span><br><span class="line"></span><br><span class="line"> set collation_server=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><p>或者</p><p>重新配置mysql<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation </span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter current password for root (enter for none):      &lt;–初次运行直接回车   设置密码Set root password? [Y/n]                               &lt;– 是否设置root用户密码，输入y并回车或直接回车New password:                                          &lt;– 设置root用户的密码，比如密码为123456Re-enter new password:                                 &lt;– 再输入一次你设置的密码   其他配置Remove anonymous users? [Y/n]                          &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n]                    &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n]           &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n]                     &lt;– 是否重新加载权限表，回车</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/my.cnf</span><br></pre></td></tr></table></figure><p>配置文件/etc/my.cnf.d/server.cnf，在[mysqld]标签下添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init_connect=&apos;SET collation_connection = utf8_unicode_ci&apos;</span><br><span class="line"></span><br><span class="line">init_connect=&apos;SET NAMES utf8&apos;</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br></pre></td></tr></table></figure></p><p>然后配置文件/etc/my.cnf.d/mysql-clients.cnf，在[mysql]中添加<br>default-character-set=utf8</p><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install redis</span><br></pre></td></tr></table></figure></p><p> 启动redis 服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis start</span><br></pre></td></tr></table></figure></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">centos 7</span><br><span class="line">systemctl start redis <span class="comment">#启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis <span class="comment">#设置开机启动</span></span><br><span class="line">systemctl restart redis <span class="comment">#重新启动</span></span><br><span class="line">systemctl stop redis.service <span class="comment">#停止MariaDB</span></span><br></pre></td></tr></table></figure><p>启动redis命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>设置开机自动启动redis<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add redis</span><br></pre></td></tr></table></figure></p><p>设置远程连接密码验证<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass "123456"</span><br></pre></td></tr></table></figure></p><h2 id="安装Ngnix"><a href="#安装Ngnix" class="headerlink" title="安装Ngnix"></a>安装Ngnix</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/nginx.repo</span><br></pre></td></tr></table></figure><p>centos6<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[nginx]</span><br><span class="line">name=nginx repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/6/<span class="variable">$basearch</span>/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br></pre></td></tr></table></figure></p><p>centos7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure></p><p>开机启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig nginx on</span><br></pre></td></tr></table></figure></p><p>打开默认配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="1.png" alt title class>                <p></p>            </figure><p>autoindex on;</p><p>autoindex_exact_size off;</p><p>autoindex_localtime on;</p><p>charset utf-8,gbk;</p><p>添加服务,监听80端口<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name aboot.missiono.cn; # 域名</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-NginX-Proxy true;</span><br><span class="line">proxy_pass http://127.0.0.1:8008/; #后端服务</span><br><span class="line">proxy_redirect off;</span><br><span class="line">        client_max_body_size 100m; #表示最大上传100M，需要多大设置多大</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更新nginx配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基础笔记</title>
      <link href="/2019/03/12/python-start/"/>
      <url>/2019/03/12/python-start/</url>
      
        <content type="html"><![CDATA[<p>查看 命名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir(__builtins__)</span><br></pre></td></tr></table></figure></p><p>查看input帮助<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help(input)</span><br></pre></td></tr></table></figure></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><figure class="image-box">                <img src="Image.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[1].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[2].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[3].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[4].png" alt title class>                <p></p>            </figure><h2 id="e记法"><a href="#e记法" class="headerlink" title="e记法"></a>e记法</h2><figure class="image-box">                <img src="Image[5].png" alt title class>                <p></p>            </figure><h2 id="布尔类型计算"><a href="#布尔类型计算" class="headerlink" title="布尔类型计算"></a>布尔类型计算</h2><figure class="image-box">                <img src="Image[6].png" alt title class>                <p></p>            </figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="image-box">                <img src="Image[7].png" alt title class>                <p></p>            </figure><h2 id="查看类型"><a href="#查看类型" class="headerlink" title="查看类型"></a>查看类型</h2><figure class="image-box">                <img src="Image[8].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[9].png" alt title class>                <p></p>            </figure><h2 id="特有计算"><a href="#特有计算" class="headerlink" title="特有计算"></a>特有计算</h2><figure class="image-box">                <img src="Image[10].png" alt title class>                <p></p>            </figure><h2 id="幂运算操作优先级"><a href="#幂运算操作优先级" class="headerlink" title="幂运算操作优先级"></a>幂运算操作优先级</h2><figure class="image-box">                <img src="Image[11].png" alt title class>                <p></p>            </figure><h2 id="三元大小比较"><a href="#三元大小比较" class="headerlink" title="三元大小比较"></a>三元大小比较</h2><figure class="image-box">                <img src="Image[12].png" alt title class>                <p></p>            </figure><h2 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h2><figure class="image-box">                <img src="Image[13].png" alt title class>                <p></p>            </figure><h2 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h2><figure class="image-box">                <img src="Image[14].png" alt title class>                <p></p>            </figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><figure class="image-box">                <img src="Image[15].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[16].png" alt title class>                <p></p>            </figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="image-box">                <img src="Image[17].png" alt title class>                <p></p>            </figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">member = [<span class="string">'小甲鱼'</span>,<span class="string">'小布丁'</span>,<span class="string">'小炮冰'</span>,<span class="string">'大傻逼'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> member:</span><br><span class="line">    print(i,len(i))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小布丁 3</span><br><span class="line">小炮冰 3</span><br><span class="line">大傻逼 3</span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><figure class="image-box">                <img src="Image[18].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[19].png" alt title class>                <p></p>            </figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><code>一个打了激素的列表</code> ,<code>一个工厂的仓库</code> , <code>混合类型的列表</code><br><figure class="image-box">                <img src="Image[20].png" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="Image[21].png" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="Image[22].png" alt title class>                <p></p>            </figure></p><h2 id="列表-remove-del-pop"><a href="#列表-remove-del-pop" class="headerlink" title="列表 remove() del pop()"></a>列表 remove() del pop()</h2><figure class="image-box">                <img src="Image[23].png" alt title class>                <p></p>            </figure><h2 id="列表分片"><a href="#列表分片" class="headerlink" title="列表分片"></a>列表分片</h2><figure class="image-box">                <img src="Image[24].png" alt title class>                <p></p>            </figure><h2 id="比较-从最前面的元素依次比较-类似字符串比较"><a href="#比较-从最前面的元素依次比较-类似字符串比较" class="headerlink" title="比较 从最前面的元素依次比较 (类似字符串比较)"></a>比较 从最前面的元素依次比较 (类似字符串比较)</h2><figure class="image-box">                <img src="Image[25].png" alt title class>                <p></p>            </figure><h2 id="列表运算"><a href="#列表运算" class="headerlink" title="列表运算"></a>列表运算</h2><figure class="image-box">                <img src="Image[26].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[27].png" alt title class>                <p></p>            </figure><h2 id="用分片方式或copy-才能深拷贝"><a href="#用分片方式或copy-才能深拷贝" class="headerlink" title="用分片方式或copy() 才能深拷贝"></a>用分片方式或copy() 才能深拷贝</h2><figure class="image-box">                <img src="Image[28].png" alt title class>                <p></p>            </figure><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝</p><p>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝<br><figure class="image-box">                <img src="Image[29].png" alt title class>                <p></p>            </figure></p><h2 id="元祖"><a href="#元祖" class="headerlink" title="元祖  ()"></a>元祖  ()</h2><figure class="image-box">                <img src="Image[30].png" alt title class>                <p></p>            </figure><p>元祖不可修改,删除和插入<br><figure class="image-box">                <img src="Image[31].png" alt title class>                <p></p>            </figure></p><h3 id="元祖的修改"><a href="#元祖的修改" class="headerlink" title="元祖的修改"></a>元祖的修改</h3><figure class="image-box">                <img src="Image[32].png" alt title class>                <p></p>            </figure><h3 id="元祖的自动回收"><a href="#元祖的自动回收" class="headerlink" title="元祖的自动回收"></a>元祖的自动回收</h3><p>手动回收<br><figure class="image-box">                <img src="Image[33].png" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="Image[34].png" alt title class>                <p></p>            </figure></p><h2 id="字符串-似元祖-无字符类型"><a href="#字符串-似元祖-无字符类型" class="headerlink" title="字符串 (似元祖) (无字符类型)"></a>字符串 (似元祖) (无字符类型)</h2><figure class="image-box">                <img src="Image[35].png" alt title class>                <p></p>            </figure><h2 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h2><figure class="image-box">                <img src="Image[36].png" alt title class>                <p></p>            </figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="image-box">                <img src="Image[37].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[38].png" alt title class>                <p></p>            </figure><h2 id="返回多个值-元祖"><a href="#返回多个值-元祖" class="headerlink" title="返回多个值(元祖)"></a>返回多个值(元祖)</h2><figure class="image-box">                <img src="Image[39].png" alt title class>                <p></p>            </figure><h2 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h2><figure class="image-box">                <img src="Image[40].png" alt title class>                <p></p>            </figure><h2 id="内嵌函数"><a href="#内嵌函数" class="headerlink" title="内嵌函数"></a>内嵌函数</h2><figure class="image-box">                <img src="Image[41].png" alt title class>                <p></p>            </figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="image-box">                <img src="Image[42].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[43].png" alt title class>                <p></p>            </figure><h2 id="声明不是局部变量"><a href="#声明不是局部变量" class="headerlink" title="声明不是局部变量"></a>声明不是局部变量</h2><figure class="image-box">                <img src="Image[44].png" alt title class>                <p></p>            </figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><figure class="image-box">                <img src="Image[45].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[46].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[47].png" alt title class>                <p></p>            </figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="image-box">                <img src="Image[48].png" alt title class>                <p></p>            </figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="image-box">                <img src="Image[49].png" alt title class>                <p></p>            </figure><h2 id="设置递归内存深度"><a href="#设置递归内存深度" class="headerlink" title="设置递归内存深度"></a>设置递归内存深度</h2><figure class="image-box">                <img src="Image[50].png" alt title class>                <p></p>            </figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">### 非递归</span><br><span class="line">def factorial_1(n):</span><br><span class="line">    result = n ;</span><br><span class="line">    for i in range(1,n):</span><br><span class="line">        result *=i;</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">number = int(input(&apos;请输入一个正整数:&apos;))</span><br><span class="line">result = factorial_1(number)</span><br><span class="line">print(&quot;%d 的阶乘是: %d&quot;%(number ,result))</span><br><span class="line"></span><br><span class="line">### 递归</span><br><span class="line">def factorial_2(n):</span><br><span class="line">    if n == 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return n*factorial_2(n-1)</span><br><span class="line"></span><br><span class="line">number = int(input(&quot;请输入一个正整数&quot;))</span><br><span class="line">result = factorial_2(number)</span><br><span class="line">print(&quot;%d 的阶乘是: %d&quot;%(number ,result))</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="Image[51].png" alt title class>                <p></p>            </figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><figure class="image-box">                <img src="Image[52].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[53].png" alt title class>                <p></p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&apos;李宁&apos;: &apos;一切皆有可能&apos;, &apos;nike&apos;: &apos;just do it&apos;, &apos;阿迪&apos;: &apos;impossible is nothing&apos;&#125;</span><br><span class="line">print(dict1[&apos;阿迪&apos;])</span><br><span class="line"></span><br><span class="line">dict2 = &#123;1: &apos;one&apos;, 2: &apos;two&apos;, 3: &apos;three&apos;&#125;</span><br><span class="line">print(dict2[1])</span><br><span class="line"></span><br><span class="line">dict3 = dict(((&apos;a&apos;, 21), (&apos;b&apos;, 43), (&apos;c&apos;, 23423)))</span><br><span class="line">print(dict3[&apos;c&apos;])</span><br><span class="line"></span><br><span class="line">dict4 = dict(我=&apos;帅哥&apos;, 你=&apos;傻b&apos;)</span><br><span class="line">print(dict4[&apos;我&apos;])</span><br><span class="line">dict4[&apos;你&apos;]=&apos;弟弟&apos;</span><br><span class="line">dict4[&apos;他&apos;]=&apos;儿子&apos;</span><br><span class="line">print(dict4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">impossible is nothing</span><br><span class="line">one</span><br><span class="line">23423</span><br><span class="line">帅哥</span><br><span class="line">&#123;&apos;我&apos;: &apos;帅哥&apos;, &apos;你&apos;: &apos;弟弟&apos;, &apos;他&apos;: &apos;儿子&apos;&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="Image[54].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[55].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[56].png" alt title class>                <p></p>            </figure><h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>get(key,new value)<br>如果有项,则返回value,如果没有返回new value<br><figure class="image-box">                <img src="Image[57].png" alt title class>                <p></p>            </figure></p><h2 id="清空和指向"><a href="#清空和指向" class="headerlink" title="清空和指向"></a>清空和指向</h2><figure class="image-box">                <img src="Image[58].png" alt title class>                <p></p>            </figure><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝之后不互相影响<br><figure class="image-box">                <img src="Image[59].png" alt title class>                <p></p>            </figure></p><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><figure class="image-box">                <img src="Image[60].png" alt title class>                <p></p>            </figure><h2 id="setdefaut"><a href="#setdefaut" class="headerlink" title="setdefaut"></a>setdefaut</h2><p>setdefault() 函数和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</p><figure class="image-box">                <img src="Image[61].png" alt title class>                <p></p>            </figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><figure class="image-box">                <img src="Image[62].png" alt title class>                <p></p>            </figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="image-box">                <img src="Image[63].png" alt title class>                <p></p>            </figure><h2 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset"></a>frozenset</h2><figure class="image-box">                <img src="Image[64].png" alt title class>                <p></p>            </figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="image-box">                <img src="Image[65].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[66].png" alt title class>                <p></p>            </figure><p>seek(方法) 是指针<br><figure class="image-box">                <img src="Image[67].png" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="Image[68].png" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="Image[69].png" alt title class>                <p></p>            </figure></p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><figure class="image-box">                <img src="Image[70].png" alt title class>                <p></p>            </figure><h2 id="读取文件分割字符"><a href="#读取文件分割字符" class="headerlink" title="读取文件分割字符"></a>读取文件分割字符</h2><figure class="image-box">                <img src="Image[71].png" alt title class>                <p></p>            </figure><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><figure class="image-box">                <img src="Image[72].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[73].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[74].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[75].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[76].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[77].png" alt title class>                <p></p>            </figure><h2 id="pickle-将字典二进制存放-黄瓜"><a href="#pickle-将字典二进制存放-黄瓜" class="headerlink" title="pickle(将字典二进制存放) 黄瓜"></a>pickle(将字典二进制存放) 黄瓜</h2><figure class="image-box">                <img src="Image[78].png" alt title class>                <p></p>            </figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.getcwd())</span><br><span class="line">my_list=[<span class="number">124</span>,<span class="number">4.23</span>,<span class="string">"we are go"</span> ,[<span class="string">'another list'</span>]]</span><br><span class="line">pickle_file=open(<span class="string">"my_list.pkl"</span>,<span class="string">"wb"</span>)</span><br><span class="line">pickle.dump(my_list,pickle_file)</span><br><span class="line">pickle_file.close();</span><br><span class="line"></span><br><span class="line">pickle_file=open(<span class="string">"my_list.pkl"</span>,<span class="string">"rb"</span>)</span><br><span class="line">my_list2=pickle.load(pickle_file)</span><br><span class="line">print(my_list2)</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="image-box">                <img src="Image[79].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[80].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[81].png" alt title class>                <p></p>            </figure><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>抽象出try catch中的细节<br>代码更简洁<br> <figure class="image-box">                <img src="Image[82].png" alt title class>                <p></p>            </figure></p><h2 id="EasyGui"><a href="#EasyGui" class="headerlink" title="EasyGui"></a>EasyGui</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> # -*- coding:utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Missionary&apos;</span><br><span class="line">__time__ = &apos;2019/3/31 0031 8:59&apos;</span><br><span class="line"></span><br><span class="line">import easygui as g</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    g.msgbox(&quot;欢迎进入界面&quot;)</span><br><span class="line">    msg= &quot;请问你要干什么?&quot;</span><br><span class="line">    title=&quot;游戏互动&quot;</span><br><span class="line">    choices=[&apos;谈恋爱&apos;,&apos;打篮球&apos;,&apos;打工&apos;,&apos;学习&apos;]</span><br><span class="line"></span><br><span class="line">    choices=g.choicebox(msg,title,choices)</span><br><span class="line"></span><br><span class="line">    g.msgbox(&quot;你的选择是&quot;+ str(choices),&quot;结果&quot;)</span><br><span class="line">    msg=&quot;你希望重新开始吗?&quot;</span><br><span class="line">    title=&quot;请选择&quot;</span><br><span class="line"></span><br><span class="line">    if g.ccbox(msg,title):</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        sys.exit(0)</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2> <figure class="image-box">                <img src="Image[83].png" alt title class>                <p></p>            </figure><h2 id="private-伪私有"><a href="#private-伪私有" class="headerlink" title="private 伪私有"></a>private 伪私有</h2> <figure class="image-box">                <img src="Image[84].png" alt title class>                <p></p>            </figure> <figure class="image-box">                <img src="Image[85].png" alt title class>                <p></p>            </figure> <figure class="image-box">                <img src="Image[86].png" alt title class>                <p></p>            </figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> name：一般变量，在类中，类外都可以使用，对象直接可以访问</span><br><span class="line"></span><br><span class="line">__name:双下划线私有变量，在类中可以访问，类外不能直接访问</span><br><span class="line"></span><br><span class="line">_name:单下划线的变量，与双下划线有点类似也是私有变量，区别在于from 模块 import *时不能导入，类和对象能直接访问</span><br><span class="line"></span><br><span class="line">__init__:类似这样的两边都有的双下划线的方法时系统具有特殊功能的方法，一般不要这样自定义方法，如__new__用来创建对象，__init__用来初始化对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xx_:单后置下划线,用于避免与Python关键词的冲突</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> class Parent:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;调用父类&quot;)</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用父类say&quot;)</span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;调用子类&quot;)</span><br><span class="line"></span><br><span class="line">c=Child()</span><br><span class="line">c.hello();</span><br><span class="line">c.say();</span><br></pre></td></tr></table></figure><h2 id="重写构造方法"><a href="#重写构造方法" class="headerlink" title="重写构造方法"></a>重写构造方法</h2> <figure class="image-box">                <img src="Image87.png" alt title class>                <p></p>            </figure><p> <img src="Image[87].png" alt></p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><figure class="image-box">                <img src="Image[88].png" alt title class>                <p></p>            </figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><figure class="image-box">                <img src="Image[89].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[90].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[91].png" alt title class>                <p></p>            </figure><h2 id="静态方法-无self"><a href="#静态方法-无self" class="headerlink" title="静态方法(无self)"></a>静态方法(无self)</h2><figure class="image-box">                <img src="Image[92].png" alt title class>                <p></p>            </figure><h2 id="self-绑定-变成实例对象的方法"><a href="#self-绑定-变成实例对象的方法" class="headerlink" title="self 绑定 变成实例对象的方法"></a>self 绑定 变成实例对象的方法</h2><figure class="image-box">                <img src="Image[93].png" alt title class>                <p></p>            </figure><h2 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h2><figure class="image-box">                <img src="Image[94].png" alt title class>                <p></p>            </figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="image-box">                <img src="Image[95].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[96].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[97].png" alt title class>                <p></p>            </figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="image-box">                <img src="Image[98].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[99].png" alt title class>                <p></p>            </figure><h2 id="property-get-set-del"><a href="#property-get-set-del" class="headerlink" title="property(get,set, del)"></a>property(get,set, del)</h2><figure class="image-box">                <img src="Image[100].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[101].png" alt title class>                <p></p>            </figure><p>意思应该是用户一直用的是x,所以用户是不需要修改的，但是作为程序员我们需要修改，不使用property的话两者都需要修改，使得用户体验很差</p><figure class="image-box">                <img src="Image[102].png" alt title class>                <p></p>            </figure><h2 id="new-极少重写"><a href="#new-极少重写" class="headerlink" title="new   极少重写"></a>new   极少重写</h2><figure class="image-box">                <img src="Image[103].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[104].png" alt title class>                <p></p>            </figure><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><figure class="image-box">                <img src="Image[105].png" alt title class>                <p></p>            </figure><h2 id="加减"><a href="#加减" class="headerlink" title="加减"></a>加减</h2><figure class="image-box">                <img src="Image[106].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[107].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[108].png" alt title class>                <p></p>            </figure><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import time as t</span><br><span class="line"></span><br><span class="line">class MyTimer():</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.unit=[&apos;年&apos;,&apos;月&apos;,&apos;日&apos;,&apos;时&apos;,&apos;分&apos;,&apos;秒&apos;]</span><br><span class="line">        self.prompt=&quot;计时未开始&quot;</span><br><span class="line">        self.lasted=[]</span><br><span class="line">        #self.start=0</span><br><span class="line">        #self.stop =0</span><br><span class="line">        self.begin=0</span><br><span class="line">        self.end =0</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.prompt</span><br><span class="line"></span><br><span class="line">    __repr__=__str__</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        self.begin=t.localtime()</span><br><span class="line">        self.prompt=&apos;请先调用stop()停止计时&apos;</span><br><span class="line">        print(&quot;计时开始!&quot;)</span><br><span class="line"></span><br><span class="line">    def stop(self):</span><br><span class="line">        if not self.begin:</span><br><span class="line">            print(&quot;请先调用start()进行计时&quot;)</span><br><span class="line">        else:</span><br><span class="line">            self.end=t.localtime()</span><br><span class="line">            self._calc()</span><br><span class="line">            print(&quot;计时结束!&quot;)</span><br><span class="line"></span><br><span class="line">##内部方法,计算运行时间</span><br><span class="line">    def _calc(self):</span><br><span class="line">        self.lasted=[]</span><br><span class="line">        self.prompt = &quot;总共运行了&quot;</span><br><span class="line">        for index in range(6) :</span><br><span class="line">            self.lasted.append(self.end[index]-self.begin[index])</span><br><span class="line">            if self.lasted[index]:</span><br><span class="line">                self.prompt+=(str(self.lasted[index])+self.unit[index])</span><br><span class="line">        print(self.prompt)</span><br><span class="line">        # 初始化</span><br><span class="line">        self.begin=0</span><br><span class="line">        self.end=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1=MyTimer()</span><br><span class="line">t1.stop()</span><br><span class="line">print(t1)</span><br><span class="line">t1.start()</span><br><span class="line">print(t1)</span><br><span class="line">t.sleep(4)</span><br><span class="line">t1.stop()</span><br><span class="line">print(t1)</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">请先调用start()进行计时</span><br><span class="line">计时未开始</span><br><span class="line">计时开始!</span><br><span class="line">请先调用stop()停止计时</span><br><span class="line">总共运行了4秒</span><br><span class="line">计时结束!</span><br><span class="line">总共运行了4秒</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="Image[109].png" alt title class>                <p></p>            </figure><p><strong>getattribute</strong>的优先级高于<strong>getattr</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def __getattribute__(self, item):</span><br><span class="line">        print(&quot;getattribute&quot;)</span><br><span class="line">        return super().__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):</span><br><span class="line">        print(&apos;getattr&apos;)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        print(&quot;setattr&quot;)</span><br><span class="line">        super().__setattr__(key,value)</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, item):</span><br><span class="line">        print(&apos;delattr&apos;)</span><br><span class="line">        super().__delattr__(item)</span><br><span class="line"></span><br><span class="line">c=C()</span><br><span class="line">c.x</span><br><span class="line">print(&apos;========&apos;)</span><br><span class="line">c.x=1</span><br><span class="line">print(&apos;========&apos;)</span><br><span class="line">print(c.x)</span><br><span class="line"></span><br><span class="line">del c.x</span><br><span class="line"></span><br><span class="line">================================================</span><br><span class="line">输出:</span><br><span class="line">getattribute</span><br><span class="line">getattr</span><br><span class="line">========</span><br><span class="line">setattr</span><br><span class="line">========</span><br><span class="line">getattribute</span><br><span class="line">1</span><br><span class="line">delattr</span><br></pre></td></tr></table></figure></p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><figure class="image-box">                <img src="Image[110].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[111].png" alt title class>                <p></p>            </figure><p>instance：拥有者的实例对象，owner：拥有者类</p><h2 id="定义容器"><a href="#定义容器" class="headerlink" title="定义容器"></a>定义容器</h2><figure class="image-box">                <img src="Image[112].png" alt title class>                <p></p>            </figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="image-box">                <img src="Image[113].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[114].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[115].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[116].png" alt title class>                <p></p>            </figure><h2 id="生成器-yield"><a href="#生成器-yield" class="headerlink" title="生成器 yield"></a>生成器 yield</h2><figure class="image-box">                <img src="Image[117].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[118].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[119].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[120].png" alt title class>                <p></p>            </figure><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><figure class="image-box">                <img src="Image[121].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[122].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[123].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[124].png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="Image[125].png" alt title class>                <p></p>            </figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019春节假回家碎碎念</title>
      <link href="/2019/02/16/2019-holiday/"/>
      <url>/2019/02/16/2019-holiday/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学校的灯灭了很多，熄了很久，盖似无人烟</p><p>这里的水流了又止，止了又行，周而非复始</p><p>钟海楼保安叨叨絮语，恨不得拎人而鞭驱其乡</p><p>校外车水马龙，待送一批批盟友同志，寻其归宿</p><p>唯博主不曾离开。</p><p>并不是对学校数日相伴的依恋，坦然，我更偏现实主义的人，只是钱绕脑梁，在执行待命于学校的任务罢了。</p><p><strong>谓吾何秀？</strong></p><p>答曰，非蜀道若般项目，亦非坚守不渝之本心，乃怪携程车票抢不到位，误了时辰，鸽了日子。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高铁终有一堵，天命必有一咕。</span><br></pre></td></tr></table></figure><h1 id="2月1日"><a href="#2月1日" class="headerlink" title="2月1日"></a>2月1日</h1><h2 id="归来"><a href="#归来" class="headerlink" title="归来"></a>归来</h2><p>对家乡发展，有惊喜与不满足</p><h3 id="惊喜"><a href="#惊喜" class="headerlink" title="惊喜"></a>惊喜</h3><p>高铁站花开美景<br><figure class="image-box">                <img src="1.JPG" alt title class>                <p></p>            </figure></p><p>回到家乡，人整整齐齐。小伙伴都回来了，相逢吉时，想必能整活一番。</p><h3 id="不满足"><a href="#不满足" class="headerlink" title="不满足"></a>不满足</h3><p>线上支付未能全覆盖家乡。年年岁岁年年，博主盼着不用带现金出门，时至今日还是摆脱不过客运车只收纸币的现实。</p><h1 id="2月2日"><a href="#2月2日" class="headerlink" title="2月2日"></a>2月2日</h1><h2 id="约与见面"><a href="#约与见面" class="headerlink" title="约与见面"></a>约与见面</h2><h3 id="约"><a href="#约" class="headerlink" title="约"></a>约</h3><p>计划约朋友去溜旱冰，顺带陪朋友拿快递。</p><p>当我们前往旱冰场，只看到一个低分差评的场地。我们立马取消了溜旱冰的念头，转去好不热闹的KTV房。一首敬月光，一首敬过往，唱两小时，慢慢有网络上流行的那feel“好嗨哦，感觉人生已经到达了巅峰，感觉人生已经到达……”(啪、严肃点)</p><p>这两小时，单身的博主听着情歌，不经意会思考自己的经历，伤感自己与他人的差异，也悟出了生活中最朴实的道理：<br>“做人不要太攀比 踏踏实实做自己 </p><p>如果非要比一比 那就比比激光雨 u r b b r g r ao u gei 北鼻八啦八啦揪” (～￣▽￣)～</p><p>咳咳，写偏了，回到主线。</p><h3 id="见面"><a href="#见面" class="headerlink" title="见面"></a>见面</h3><p>关于见面，这次的见面主要是见海归友人阿狗，他请客吃麻辣烫，把以前交好的同学聚在了一起，相谈甚欢。<br>他们都长大了，各有见识，各成家事，更高兴的是，店是那家店，人还是那些人，食物还是原来的配方，还是熟悉的味道，真怀念。</p><h1 id="2月3日"><a href="#2月3日" class="headerlink" title="2月3日"></a>2月3日</h1><h2 id="愧疚感"><a href="#愧疚感" class="headerlink" title="愧疚感"></a>愧疚感</h2><p>   在家干活，不存在的。这些天，我就很累很疲倦，个人感受如此。计划上，我今天是休息的。<br>我所理解的休息，包括睡觉，看动漫，看书，闲逸地敲代码，发呆。</p><p>是的，我思想上已编出了好几个不干活的理由，所以，我认为按照自己的想法行动无可厚非。当老妈让我做准备迎春的一些工作的时候，我无动于衷，内心是拒绝的，甚至逃到别人家。这一点，体现博主存在的懒惰，也看到博主在某些方面的固执，比如计划上的事，不想被打破。还看到博主也是相当容易接纳自己，包容自己，因为博主是懒得明明白白，还不知悔改的那种人。（自嘲）</p><p><code>说实话，博主还是挺愧疚的。</code></p><p>推敲事件，联想到一个现象：长辈叫孩子干活，为什么会有抵触情绪呢？<br>依我的表现看出一方面: 如果孩子出现抵触情绪，可能他是有自己的事情在做，或有自己的计划要执行，而这一点，大人往往是忽略的。家人提出一些任务，会打扰到孩子手头上的事情，这样，孩子不耐烦的可能性会增大。看到社交层面，寻找人帮忙之道正是如此，让人帮忙，那得先了解别人当时的忙碌状态，比如问：“现在有没有空呢？”当了解清楚，再去做出要不要让人帮忙的决定，这样更容易让人接受你的请求。</p><p>嗯，这几段真是逻辑鬼才。</p><h1 id="2月4日"><a href="#2月4日" class="headerlink" title="2月4日"></a>2月4日</h1><h2 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h2><p>谢谢网友的新春祝福，当然同时祝福大家猪年大吉，诸事顺利！红包？不存在的。</p><p>┬┴┬┌─　●─┬─　　│─┼─┐　●├─┤○<br>┴┬┴├┬　┌─┼─　│◎　│　│　○└┬┘●<br>─┼─││　│　│　　││─┴─┴　──┼──<br>●│○││　┴─┼─　　│○　　●　／　│　＼<br>今天，给商业项目增加新功能 ，写写博客，一如既往的样子。</p><h1 id="2月5日"><a href="#2月5日" class="headerlink" title="2月5日"></a>2月5日</h1><h2 id="烧烤"><a href="#烧烤" class="headerlink" title="烧烤"></a>烧烤</h2><p>每年春节，我们都会搞活动，不经意间已经传承十多载之余。<br>今年大年初一，又是烧烤。</p><figure class="image-box">                <img src="2.JPG" alt title class>                <p></p>            </figure><p>买的食物有点多，吃不完。</p><p>每年都烧烤，貌似今年才有女生加入搞活动，嗯，她们算是朋友打麻将拐过来的，以前是典型的罗汉局，今年总算增加了一点生物多样性。</p><p>想起以前，博主不擅长社交场合，在一群同龄女生面前，会有不自在，闻到有香水味就想打喷嚏，现在上大学，社交场上的不自然感慢慢克服了，大概是青春期过了吧，不在乎别人打印象分了。</p><p>通过这事，想起一些小时候的刻板印象<br>人总是不经意间给他人贴标签，这是不对的，多年不见面，人的变化肯定存在，如今的自己也不是以前的自己。比如你曾经某些时刻发现小明有点屌~丝行为，从此，在你心里，他便有了屌丝的标签。屌丝，成了你对这个人的刻板印象。</p><p>如何知道自己是否对人有刻板印象？<br>靠时间校验，当你发现眼前的这个人与你想象中差别很大的时候，这可能就说明你心中是给他贴了标签的,存有刻板印象</p><p>别人成长了，就要抛弃曾经对他的刻板印象，用成熟的心态去与他交流。</p><h1 id="2月6"><a href="#2月6" class="headerlink" title="2月6"></a>2月6</h1><h2 id="焗鸡"><a href="#焗鸡" class="headerlink" title="焗鸡"></a>焗鸡</h2><p>性感大厨，在线焗鸡<br><figure class="image-box">                <img src="3.JPG" alt title class>                <p></p>            </figure></p><p>比以前的焗鸡好吃咯，虽然以前的焗鸡已经忘记了味道，但直觉告诉我今年比较好吃</p><h1 id="2月7"><a href="#2月7" class="headerlink" title="2月7"></a>2月7</h1><p>在家，敲代码</p><h1 id="2月8"><a href="#2月8" class="headerlink" title="2月8"></a>2月8</h1><p>在朋友家，敲代码</p><h1 id="2月9"><a href="#2月9" class="headerlink" title="2月9"></a>2月9</h1><p>孙中山故居行<br><figure class="image-box">                <img src="4.png" alt title class>                <p></p>            </figure></p><p>旅游景点分几个区域，美国区、英国区、日本区</p><p>图片正是在日本区中拍摄，服装是可以租借</p><p>博主感觉，除了拍照挺无趣，不值得，不过，无论去哪，陪同家人才是最大的意义</p><h1 id="2月10"><a href="#2月10" class="headerlink" title="2月10"></a>2月10</h1><p>流浪地球<br>无论地球的命运导向何处，我们选择希望</p><figure class="image-box">                <img src="5.jpg" alt title class>                <p></p>            </figure><p>北京第三交通委的提醒深入人心</p><h1 id="2月11"><a href="#2月11" class="headerlink" title="2月11"></a>2月11</h1><p>收拾行李，准备下一站</p><h1 id="2月12"><a href="#2月12" class="headerlink" title="2月12"></a>2月12</h1><p>出发广州</p><p>参加会议</p><p>其中讲到了<code>奋进</code>的概念</p><p>博主理解了一点浅显的内容</p><p>包含两层含义: <code>奋斗与上进</code></p><p><code>上进</code>是发自内心的，它可以无付出的，空想的努力心境亦谓之上进</p><p><code>奋斗</code>是付出行动的，它可以内心不上进的，但行动是切切实实的</p><p>其实每个人都可以是上进的,没有不上进的人</p><p>如果他不上进，他只是缺少激发因素 ，适当的约谈可以赋予人上进的动力</p><p>所谓<code>奋进</code>，就是奋斗与上进的结合，既是内心努力追求 ，又是付出行动</p><p>它应该是一种状态，并非人的特性，人的某时刻是奋进 ，另一时刻却是慵懒</p><p>而追求持续奋进，便是我们创业者所追求达到的目标</p><p>现在把员工分三类:</p><blockquote><ol><li><p>干活少的不积极员工</p></li><li><p>任务完成，点到即止，不愿多余付出的普通员工</p></li><li><p>奋进的积极员工，献出很多劳动付出</p></li></ol></blockquote><p>在公司中<br><code>1类型</code>的员工其实是在<code>剽窃</code>着<code>3类型</code>的的员工的劳动成果</p><p>如果<code>1类型</code>的员工做着自己的剽窃行为，他还在说:我做得少，却获得与大家相当的报酬，我是聪慧的</p><p>这种少劳而洋洋得意的思维会把公司员工的积极性死死地抑制住，把公司推向一个不作为的氛围</p><p>作为管理者，必须让他们明白其中的剽窃逻辑，一起达成良好的强共识，形成积极的企业文化</p><p>明确两点:</p><ul><li><p><code>第一点</code>  作为<code>1类型</code>的员工不可对自己的行为洋洋得意，相对的，是应该抱有感谢<code>3类型</code>的员工的心态，还有羞愧的心理</p></li><li><p><code>第二点</code>  作为管理者，要对<code>3类型</code>的员工做<code>奖励</code>机制，奖励他们的付出</p></li></ul><p><code>启示</code>:<br>做平衡往往是解决许多问题的有效方案</p><h1 id="2月13"><a href="#2月13" class="headerlink" title="2月13"></a>2月13</h1><p>前往湛江</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>下次还是假期回家，还是多待在家里吃晚饭吧，想想以后，在家吃饭的机会不多<br><figure class="image-box">                <img src="6.jpg" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="7.jpg" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="8.jpg" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="9.jpg" alt title class>                <p></p>            </figure><br><figure class="image-box">                <img src="10.jpg" alt title class>                <p></p>            </figure></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置FTP服务器 window10</title>
      <link href="/2019/02/06/ftp-server/"/>
      <url>/2019/02/06/ftp-server/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博主最近对文件网络存储进行了少许摸索, 了解到FTP服务是文件存储的方式之一。下面就讲讲在window10下搭建FTP服务器吧~</p></blockquote><h1 id="FTP服务简介"><a href="#FTP服务简介" class="headerlink" title="FTP服务简介"></a>FTP服务简介</h1><blockquote><p><code>FTP</code> 是<code>File Transfer Protocol</code>（文件传输协议）的英文简称，而中文简称为“文件传输协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。由于FTP的文件传输是明文方式，具有一定危险性，所以又诞生了一种更加安全的传输方式vsftp,有兴趣自行了解。下面将演示如何在Window10 下开启FTP服务。</p></blockquote><h1 id="开启FTP服务"><a href="#开启FTP服务" class="headerlink" title="开启FTP服务"></a>开启FTP服务</h1><ol><li><strong>按【Win + R】快捷键打开运行对话框，输入“optionalfeatures”后，按回车键</strong><figure class="image-box">                <img src="cded92cfb84e998ab5dc5524d0b4b1dc.png" alt title class>                <p></p>            </figure></li></ol><ol start="2"><li><strong>从“启用或关闭Windows功能”弹窗中找到Internet Information Services(或者中文版Internet信息服务)并打开</strong><figure class="image-box">                <img src="7e15c1b94ef45715cec16992c0ea9302.png" alt title class>                <p></p>            </figure></li></ol><ol start="3"><li><strong>配置IIS并点击确定</strong><figure class="image-box">                <img src="4016239a6c0c0ac2ec87ef1b3e0061db.png" alt title class>                <p></p>            </figure></li></ol><ol start="4"><li><strong>开始菜单搜索“IIS”并点击进入IIS管理器</strong><figure class="image-box">                <img src="d719fcafd5a8e0733338f2d6653d968d.png" alt title class>                <p></p>            </figure></li></ol><ol start="5"><li><strong>查看本机ip地址，后续访问Ftp地址需要用到（打开cmd输入ipconfig）</strong><figure class="image-box">                <img src="331455aee43602549541b3ccb028d359.png" alt title class>                <p></p>            </figure></li></ol><ol start="6"><li><strong>IIS网站管理器“网站”右键弹出菜单点击“添加FTP站点”</strong><figure class="image-box">                <img src="af6cae20df02d6b398b9bf8b978f588c.png" alt title class>                <p></p>            </figure></li></ol><p>7.<strong>配置网站（网站名称：FtpSite 物理路径：D:\projectdev\ftpserver</strong><br><figure class="image-box">                <img src="c4a658488e25b98c816167ba406a7743.png" alt title class>                <p></p>            </figure></p><ol start="8"><li><strong>IP 端口号 SSL设置</strong> <figure class="image-box">                <img src="bd59d4c115ba466544c80e21dc03275d.png" alt title class>                <p></p>            </figure></li></ol><ol start="9"><li><strong>身份验证和授权信息设置</strong> <figure class="image-box">                <img src="ed1a1af5b07a5b980ab0e37202f1c90e.png" alt title class>                <p></p>            </figure></li></ol><figure class="image-box">                <img src="1a92cf57ebed2a6dc4d8070744182003.png" alt title class>                <p></p>            </figure><p>可以看到,当访问ftp://<strong> </strong> <strong> </strong> ** 的时候,我们无需用户权限,这样是不安全的<br>所以,下面将为ftp设置禁用匿名权限,只有登录用户才可以访问</p><ol start="10"><li><strong>禁用匿名用户访问</strong><figure class="image-box">                <img src="820c7ab5e5bccaff543ce9ac2c28d906.png" alt title class>                <p></p>            </figure></li></ol><figure class="image-box">                <img src="9ad8290cd1e5d9a2a047b5b968bd5d81.png" alt title class>                <p></p>            </figure><ol start="11"><li><strong>创建新的可登录用户</strong><figure class="image-box">                <img src="73145d99ad7c918bd7cd0f50c9ff2645.png" alt title class>                <p></p>            </figure></li></ol><figure class="image-box">                <img src="e75f2c0da2cb3611c92b2f178bca94a3.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="6f1ee8bdf87910e6bbe15611dcf7fd31.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="3dd44ac1bbffe41bb5096ff1831166e9.png" alt title class>                <p></p>            </figure><p>输入新用户账号密码,即可访问</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这种配置FTP服务的方式,只能针对固定的IPV4地址。当我们换了IPV4地址,则需要再新建一个FTP服务。 这确实不是最佳的FTP服务方案。 如果作为局域网或测试项目的使用, 博主觉得已经这样可以满足您。但是, 当需求更高, 任务更重, 则需要在Linux服务器上搭建vftp服务了。好了, 本文结束, ヾ(￣▽￣)Bye~Bye~</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-data-jpa 投影查询性能之坑</title>
      <link href="/2019/02/05/jpa-problem/"/>
      <url>/2019/02/05/jpa-problem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目开发过程中, 遇到了一个文章列表查询速度非常慢的问题。这到底是怎么回事呢?</p><p>一路追查下来, 发现竟然是<code>spring-data-jpa</code>设计上的问题, 问题稍后说明, 博主先简评一下<code>spring-data-jpa</code>, <code>spring-data-jpa</code>很多时候真的很令人劝退, 各种奇奇怪怪的BUG, 功能达不到项目所需, 关联查询灵活性低 , 一些注解失效或难用, 但它简便的开发方式又令人不忍割舍, 正向生成数据库, 通过命名方法对数据库操作,分页排序查询等确实特别好用。</p><p>总之, <code>spring-data-jpa</code>像个爱耍小脾气的漂亮女生, 一开始接触她, 你能享受到各种快乐优雅的开发模式, 觉得她就是我最想要的人, 被她迷得神魂颠倒, 接触久了, 便发现其中的各种毛病, 她不仅满足不了自己, 还可能会给你带来各种烦恼, 让你不禁会问:  为什么你的操作总是令我头秃 ? 她会说: 你去翻遍我所有的文档, 你会发现, 我就是这样不讲理的。</p><p>这时候, 无奈的你则需要其他框架的辅助, <code>JdbcTemplate</code> 或 <code>Mybatis Plus</code>能够帮帮你解决问题。<code>spring-data-jpa</code>优势很明显, 缺点也多,  希望<code>spring-data-jpa</code>能日趋成熟,  以后做个善解人意的女人, 加大开发灵活性, 满足更多开发者的诉求, 这样博主也会服服帖帖地倒在她的石榴裙下o(<em>￣▽￣</em>)o~嗷~  。</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>看代码</p><h4 id="Article实体类"><a href="#Article实体类" class="headerlink" title="Article实体类"></a>Article实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Sets;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.NotFound;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.NotFoundAction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.annotations.Where;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Range;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/24 0024-15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//jpa 注解</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"article"</span>)</span><br><span class="line"><span class="comment">//Lombok</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Where</span>(clause = <span class="string">"ar_status = 1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span>(strategy =  GenerationType.IDENTITY)</span><br><span class="line">  <span class="keyword">private</span> Long arId;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotNull</span>(message = <span class="string">"文章标题arTitle不能为空"</span>)</span><br><span class="line">  <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">private</span> String arTitle;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Column</span>(columnDefinition = <span class="string">"longtext "</span>)</span><br><span class="line">  <span class="keyword">private</span> String arContent;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>,columnDefinition = <span class="string">"datetime DEFAULT CURRENT_TIMESTAMP"</span>)</span><br><span class="line">  <span class="keyword">private</span> LocalDate arDate;<span class="comment">//时间  默认当前系统时间</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Range</span>(min=-<span class="number">1</span>,max=<span class="number">1</span>,message = <span class="string">"逻辑状态arStatus超出范围"</span>)</span><br><span class="line">  <span class="meta">@Column</span>(length = <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">private</span> Integer arStatus; <span class="comment">// 状态 (0回收站删除 ,1显示)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@OrderBy</span>(<span class="string">"ac_id asc "</span>)</span><br><span class="line">  <span class="meta">@JsonIgnoreProperties</span>(<span class="string">"articles"</span>)</span><br><span class="line">  <span class="meta">@NotFound</span>(action= NotFoundAction.IGNORE)</span><br><span class="line">  <span class="meta">@ManyToMany</span>(cascade = &#123;CascadeType.PERSIST,CascadeType.MERGE,CascadeType.REFRESH&#125;,fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@JoinTable</span>(name = <span class="string">"relation_article_cate"</span>,joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"ar_id"</span>),inverseJoinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"arc_id"</span>))</span><br><span class="line">  <span class="keyword">private</span> Set&lt;ArticleCategory&gt; articleCategories= Sets.newHashSet();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotFound</span>(action= NotFoundAction.IGNORE)</span><br><span class="line">  <span class="meta">@OneToMany</span>(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@JoinColumn</span>(name = <span class="string">"ar_id"</span>)</span><br><span class="line">  <span class="keyword">private</span> Set&lt;FileResource&gt; fileResources = Sets.newHashSet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@NotFound</span>(action= NotFoundAction.IGNORE)</span><br><span class="line">  <span class="meta">@OneToMany</span>(cascade = &#123;CascadeType.ALL&#125;,fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@JoinColumn</span>(name = <span class="string">"ar_id"</span>)</span><br><span class="line">  <span class="keyword">private</span> Set&lt;Video&gt; videos= Sets.newHashSet();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Article投影"><a href="#Article投影" class="headerlink" title="Article投影"></a>Article投影</h4><p>主要关注这里<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/27 0027-9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleSimpleProjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Long <span class="title">getArId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getArTitle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">LocalDate <span class="title">getArDate</span><span class="params">()</span></span>;<span class="comment">//时间  默认当前系统时间</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_EMPTY)</span><br><span class="line">  <span class="function">Set&lt;ArticleCategoryProjection&gt; <span class="title">getArticleCategories</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Article投影查询方法"><a href="#Article投影查询方法" class="headerlink" title="Article投影查询方法"></a>Article投影查询方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.wteam.gdousd.entity.Article;</span><br><span class="line"><span class="keyword">import</span> com.wteam.gdousd.entity.projection.ArticleSimpleProjection;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (Article)表数据库JPA储存库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> makejava</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2019-01-25 15:21:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> <span class="keyword">extends</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Article</span>&gt;,<span class="title">JpaRepository</span>&lt;<span class="title">Article</span>,<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Page&lt;ArticleSimpleProjection&gt; <span class="title">findByArStatusAndArTitleLike</span><span class="params">(Integer status,String arTitle, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>当执行方法以后<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: <span class="keyword">select</span> article0_.ar_id <span class="keyword">as</span> ar_id1_1_, article0_.ar_content <span class="keyword">as</span> ar_conte2_1_, article0_.ar_date <span class="keyword">as</span> ar_date3_1_, article0_.ar_status <span class="keyword">as</span> ar_statu4_1_, article0_.ar_title <span class="keyword">as</span> ar_title5_1_ <span class="keyword">from</span> article article0_ <span class="keyword">where</span> ( article0_.ar_status = <span class="number">1</span>) <span class="keyword">and</span> article0_.ar_status=? <span class="keyword">and</span> (article0_.ar_title <span class="keyword">like</span> ?) <span class="keyword">order</span> <span class="keyword">by</span> article0_.ar_date <span class="keyword">desc</span> <span class="keyword">limit</span> ?</span><br></pre></td></tr></table></figure></p><p>可以看到,<code>article0_.ar_content , article0_.ar_status</code> 等在<code>ArticleSimpleProjection</code> 接口中定义方法没有对应上的数据库字段竟然也被jpa查出 ,其中<code>ar_content</code>是文章内容,属于大文本字段, 查询多个记录而且还查询该字段的话,查询速度就比原来慢了好几倍。 这不是博主想要的结果, 必须优化!</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>投影接口中存在返回集合的定义方法, 使得<code>spring-data-jpa</code>会自动查询所有字段, 目前博主也不知道什么原因(博主没有看过源码)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_EMPTY)</span><br><span class="line"> <span class="function">Set&lt;ArticleCategoryProjection&gt; <span class="title">getArticleCategories</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>因为在投影中存在集合,在<code>ArticleSimpleProjection</code> 接口中就存在了返回Set集合的定义方法<code>getArticleCategories()</code>, 所以查询投影就会将所有字段查询,这是<code>spring-data-jpa</code>的设计所致</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h4 id="Article投影-1"><a href="#Article投影-1" class="headerlink" title="Article投影"></a>Article投影</h4><p>去掉Set集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wteam.gdousd.entity.projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/27 0027-9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleSimpleProjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Long <span class="title">getArId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getArTitle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">LocalDate <span class="title">getArDate</span><span class="params">()</span></span>;<span class="comment">//时间  默认当前系统时间</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_EMPTY)</span><br><span class="line">  <span class="function">ArticleCategoryProjection <span class="title">getArticleCategories</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: <span class="keyword">select</span> article0_.ar_id <span class="keyword">as</span> col_0_0_, article0_.ar_title <span class="keyword">as</span> col_1_0_, article0_.ar_date <span class="keyword">as</span> col_2_0_, articlecat2_.ac_id <span class="keyword">as</span> col_3_0_, articlecat2_.ac_id <span class="keyword">as</span> ac_id1_2_, articlecat2_.ac_name <span class="keyword">as</span> ac_name2_2_, articlecat2_.sub_classify <span class="keyword">as</span> sub_clas3_2_ <span class="keyword">from</span> article article0_ <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> relation_article_cate articlecat1_ <span class="keyword">on</span> article0_.ar_id=articlecat1_.ar_id <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> article_category articlecat2_ <span class="keyword">on</span> articlecat1_.arc_id=articlecat2_.ac_id <span class="keyword">where</span> ( article0_.ar_status = <span class="number">1</span>) <span class="keyword">and</span> article0_.ar_status=? <span class="keyword">and</span> (article0_.ar_title <span class="keyword">like</span> ?) <span class="keyword">order</span> <span class="keyword">by</span> article0_.ar_date <span class="keyword">desc</span> <span class="keyword">limit</span> ?</span><br></pre></td></tr></table></figure><p>从结果可见,只要不用set集合,就不会发生jpa查询所有字段的事情。<br>有时候, 非要把查询结果放在用Set集合中, 就自定义查询吧! 博主认为, 这种情况, 用其他框架 <code>JdbcTemplate</code> 或 <code>Mybatis Plus</code>实现更好。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p> 目前对数据库操作的框架, 博主使用的是<code>spring-data-jpa</code> +<code>JdbcTemplate</code>  或 <code>Mybatis Plus</code>, 基本满足小项目的开发。可是, 各个框架都有优有劣, 博主至今很难做出最佳选择, 真的想全都要呀!可是这样项目体积会变得很庞大哎~~ 如果读者有更好的对数据库操作的框架推荐 或 对本章内容有什么意见建议, 可以在下方评论留言,你的每一言都会让这个无聊博主的人生添上不一样的色彩哦~ヾ(￣▽￣)Bye~Bye~</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用EasyCode十分钟写后端增删改查代码</title>
      <link href="/2019/02/04/2019-new-year/"/>
      <url>/2019/02/04/2019-new-year/</url>
      
        <content type="html"><![CDATA[<blockquote><p>已经到了2019年春节, 可以闲下来写写博客咯。博主自上大学以来,项目开发经验积累了不少。期间, 我也学会了一些”邪门歪道”, 比如, 开发过程使用了Intellij Idea中的插件<code>Easy Code</code>, 发现能大大简化了后端开发, 将开发效率地提高到十分钟就能完成后端的基本功能实现, 真是太棒了! 再也不需要重复地干无趣的活儿了!</p></blockquote><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>下面开始介绍今天的主角 EasyCode 吧</p><blockquote><p><code>English</code>:</p><ul><li>The code generation plug-in based on IntelliJ IDEA is developed to support custom -  templates (Java, HTML, JS, XML).</li><li>As long as database related code can be generated through custom templates. Support database type and Java type mapping relationship configuration.</li><li>The code that supports generating multiple tables at the same time. Each table has a separate configuration information. Full personalization definition, the rules are set by you.</li></ul><p><code>中文</code>：</p><ul><li>基于IntelliJ IDEA开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）。</li><li>只要是与数据库相关的代码都可以通过自定义模板来生成。支持数据库类型与java类型映射关系配置。</li><li>支持同时生成生成多张表的代码。每张表有独立的配置信息。完全的个性化定义，规则由你设置。</li></ul></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="image-box">                <img src="0a5044676b2542ab2743f45566076453.png" alt title class>                <p></p>            </figure><ol><li>在IDEA中打开Settings -&gt; Plugins</li><li>搜索 Easy Code</li><li>点击  Install 安装</li><li>安装完成后,重启IDEA</li></ol><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="image-box">                <img src="a966efa56066f86529e93f19eadaa49c.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="41e85e39baf0fdeddf464197cb27aaf9.png" alt title class>                <p></p>            </figure><p>提前安装和建立好数据库,填写好数据库必要信息(数据库地址,数据库名,数据库账号,密码)</p><h2 id="代码生成使用"><a href="#代码生成使用" class="headerlink" title="代码生成使用"></a>代码生成使用</h2><figure class="image-box">                <img src="a91fcd88f0a3b55e8b8edbe7639c922d.png" alt title class>                <p></p>            </figure><h3 id="选择Config-Table"><a href="#选择Config-Table" class="headerlink" title="选择Config Table"></a>选择Config Table</h3><figure class="image-box">                <img src="d772cd999d966070f28059825dde850d.png" alt title class>                <p></p>            </figure><p>检查或修改 数据库字段类型与属性类型映射对应关系</p><h3 id="选择-Generate-Code"><a href="#选择-Generate-Code" class="headerlink" title="选择 Generate Code"></a>选择 Generate Code</h3><figure class="image-box">                <img src="ea8ad60b3b35b3945291c85de78c81de.png" alt title class>                <p></p>            </figure><p>选择好<code>Module</code> , <code>Package</code>, <code>Path</code>,<br>选择自己所需的<code>Template</code>代码</p><p><strong>点击ok,发现项目已经生成了代码</strong><br><figure class="image-box">                <img src="c5cb1b607f739aaf842b9d67b5177131.png" alt title class>                <p></p>            </figure></p><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p>选择<code>Settings</code> -&gt; <code>Other Settings</code>-&gt; <code>Easy Code</code><br><figure class="image-box">                <img src="9f4b83b5bbf2690063b987b226c31f9e.png" alt title class>                <p></p>            </figure></p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>修改数据库表前缀<br><figure class="image-box">                <img src="930884777e3b6e7647d855d1ffd9eb0e.png" alt title class>                <p></p>            </figure></p><h3 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h3><p>添加longtext类型的映射<br><figure class="image-box">                <img src="5e1227d7d66b3747a472165adca37264.png" alt title class>                <p></p>            </figure></p><h3 id="代码模板配置"><a href="#代码模板配置" class="headerlink" title="代码模板配置"></a>代码模板配置</h3><figure class="image-box">                <img src="9436c57b8e90665bcd5b0c6d1f06b0ee.png" alt title class>                <p></p>            </figure><h4 id="自定义代码配置"><a href="#自定义代码配置" class="headerlink" title="自定义代码配置"></a>自定义代码配置</h4><p><code>Easy Code</code> 提供了自定义模板的功能,这一点非常方便后台的开发,也是本博主最看重这个插件的地方。<br>比如说,我们项目中没有使用到<code>Mybatis</code>,而是使用<code>springboot</code>结合<code>spring-data-jpa</code>开发,这个时候,原来提供的模板是难以派上用场,此时,我们就需要自己写出代码模板,怎么写呢?<br>这需要<code>Velocity</code>模板引擎的知识</p><blockquote><p>Velocity是一个基于java的模板引擎（template engine）。它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。</p></blockquote><p>如果没有这方面的学习,也没关系<br>可以参考网址:<a href="http://www.shujuhaiyang.com" target="_blank" rel="noopener">http://www.shujuhaiyang.com</a><br>也可以看Description的提示和其他模板代码来编写</p><p>下面是博主修改的一些代码模板,是为了使用<code>springboot</code>结合<code>spring-data-jpa</code>开发而编写的,希望看了对你有帮助</p><h5 id="repository-jpa-java"><a href="#repository-jpa-java" class="headerlink" title="repository(jpa).java"></a>repository(jpa).java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">##引入宏定义</span><br><span class="line"> $!define</span><br><span class="line"></span><br><span class="line">##使用宏定义设置回调（保存位置与文件后缀）</span><br><span class="line">        #save("/entity", ".java")</span><br><span class="line"></span><br><span class="line">##使用宏定义设置包后缀</span><br><span class="line">#setPackageSuffix("entity")</span><br><span class="line"></span><br><span class="line">##使用全局变量实现默认包导入</span><br><span class="line">    $!autoImport</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line">##使用宏定义实现类注释信息</span><br><span class="line">#tableComment("实体类")</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $!</span>&#123;tableInfo.name&#125; implements Serializable</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = $!tool.serial();</span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">    #if($&#123;column.comment&#125;)//$&#123;column.comment&#125;#end</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> $!&#123;tool.getClsNameByFullName($column.type)&#125; $!&#123;column.name&#125;;</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">#foreach($column in $tableInfo.fullColumn)</span><br><span class="line">##使用宏定义实现get,set方法</span><br><span class="line">#getSetMethod($column)</span><br><span class="line">#end</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="repository-jpa-data-rest-java"><a href="#repository-jpa-data-rest-java" class="headerlink" title="repository(jpa+data-rest).java"></a>repository(jpa+data-rest).java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##定义初始变量</span><br><span class="line">    #set($tableName = $tool.append($tableInfo.name, "Repository"))</span><br><span class="line">    ##设置回调</span><br><span class="line">    $!callback.setFileName($tool.append($tableName, <span class="string">".java"</span>))</span><br><span class="line">    $!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">"/repository"</span>))</span><br><span class="line"></span><br><span class="line">    ##拿到主键</span><br><span class="line">    #if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">    #end</span><br><span class="line"></span><br><span class="line">    #if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">    <span class="keyword">import</span> java.util.List;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.rest.core.annotation.RepositoryRestResource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表数据库JPA储存库</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RepositoryRestResource</span>(path=<span class="string">"$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)"</span>)</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> $!</span>&#123;tableName&#125; extends JpaSpecificationExecutor&lt;$!&#123;tableInfo.name&#125;&gt;,JpaRepository&lt;$!&#123;tableInfo.name&#125;,$!pk.shortType&gt;&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="service-jpa-java"><a href="#service-jpa-java" class="headerlink" title="service(jpa).java"></a>service(jpa).java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">    #set($tableName = $tool.append($tableInfo.name, "Service"))</span><br><span class="line">    ##设置回调</span><br><span class="line">    $!callback.setFileName($tool.append($tableName, <span class="string">".java"</span>))</span><br><span class="line">    $!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">"/service"</span>))</span><br><span class="line"></span><br><span class="line">    ##拿到主键</span><br><span class="line">    #if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">    #end</span><br><span class="line"></span><br><span class="line">    #if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Example;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> $!</span>&#123;tableName&#125; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID查询单条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询多条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset 查询起始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 查询条数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByLimit(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit);</span><br><span class="line"></span><br><span class="line">    Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByLimit(Pageable pageable);</span><br><span class="line"></span><br><span class="line">    List&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByExample(Example&lt;$!&#123;tableInfo.name&#125;&gt; example);</span><br><span class="line"></span><br><span class="line">    Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByExampleAndLimit(Example&lt;$!&#123;tableInfo.name&#125;&gt; example, Pageable pageable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过主键删除数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteById</span><span class="params">($!pk.shortType $!pk.name)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="serviceimpl-jpa-java"><a href="#serviceimpl-jpa-java" class="headerlink" title="serviceimpl(jpa).java"></a>serviceimpl(jpa).java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">    #set($tableName = $tool.append($tableInfo.name, "ServiceImpl"))</span><br><span class="line">    ##设置回调</span><br><span class="line">    $!callback.setFileName($tool.append($tableName, <span class="string">".java"</span>))</span><br><span class="line">    $!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">"/service/impl"</span>))</span><br><span class="line"></span><br><span class="line">    ##拿到主键</span><br><span class="line">    #if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">    #end</span><br><span class="line"></span><br><span class="line">    #if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;service.impl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.repository.$!&#123;tableInfo.name&#125;Repository;</span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Example;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line">    <span class="keyword">import</span> javax.transaction.Transactional;</span><br><span class="line">    <span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line">    <span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表服务实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"$!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Service"</span>)</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $!</span>&#123;tableName&#125; implements $!&#123;tableInfo.name&#125;Service &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> $!&#123;tableInfo.name&#125;Repository $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过ID查询单条数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> $!&#123;tableInfo.name&#125; queryById($!pk.shortType $!pk.name) &#123;</span><br><span class="line"></span><br><span class="line">    $!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) = $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .findById($!pk.name).get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询多条数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset 查询起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 查询条数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByLimit(<span class="keyword">int</span> offset, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">    Pageable pageable = PageRequest.of(offset, limit);</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByLimit(Pageable pageable) &#123;</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByExample(Example&lt;$!&#123;tableInfo.name&#125;&gt; example) &#123;</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .findAll(example);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;$!&#123;tableInfo.name&#125;&gt; queryAllByExampleAndLimit(Example&lt;$!&#123;tableInfo.name&#125;&gt; example, Pageable pageable) &#123;</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .findAll(example,pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> $!&#123;tableInfo.name&#125; insert($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .save($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 实例对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> $!&#123;tableInfo.name&#125; update($!&#123;tableInfo.name&#125; $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .save($!tool.firstLowerCase($!&#123;tableInfo.name&#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过主键删除数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $!pk.name 主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteById</span><span class="params">($!pk.shortType $!pk.name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    $!tool.firstLowerCase($!&#123;tableInfo.name&#125;)Repository</span><br><span class="line">    .deleteById($!pk.name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="webController-jpa-java"><a href="#webController-jpa-java" class="headerlink" title="webController(jpa).java"></a>webController(jpa).java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">##定义初始变量</span><br><span class="line">    #set($tableName = $tool.append($tableInfo.name, "Controller"))</span><br><span class="line">    ##设置回调</span><br><span class="line">    $!callback.setFileName($tool.append($tableName, <span class="string">".java"</span>))</span><br><span class="line">    $!callback.setSavePath($tool.append($tableInfo.savePath, <span class="string">"/web"</span>))</span><br><span class="line">    ##拿到主键</span><br><span class="line">    #if(!$tableInfo.pkColumn.isEmpty())</span><br><span class="line">    #set($pk = $tableInfo.pkColumn.get(0))</span><br><span class="line">    #end</span><br><span class="line"></span><br><span class="line">    #if($tableInfo.savePackageName)package $!&#123;tableInfo.savePackageName&#125;.#&#123;end&#125;web;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.entity.$!&#123;tableInfo.name&#125;;</span><br><span class="line">    <span class="keyword">import</span> $!&#123;tableInfo.savePackageName&#125;.service.$!&#123;tableInfo.name&#125;Service;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * $!&#123;tableInfo.comment&#125;($!&#123;tableInfo.name&#125;)表控制层</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $!author</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> $!time.currTime()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$!tool.firstLowerCase($tableInfo.name)"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $!</span>&#123;tableName&#125; &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> $!&#123;tableInfo.name&#125;Service $!tool.firstLowerCase($tableInfo.name)Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过主键查询单条数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 单条数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"getOne?&#123;id&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> $!&#123;tableInfo.name&#125; getOne(<span class="meta">@PathVariable</span> $!pk.shortType id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$!&#123;tool.firstLowerCase($tableInfo.name)&#125;Service.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码模板,将上面的代码一一复制粘贴即可<br><figure class="image-box">                <img src="c49dab933600191fcda0c1d352564dc7.png" alt title class>                <p></p>            </figure></p><p>添加后,当选择 <code>Generate Code</code>,可以看到你所添加的代码模板<br><figure class="image-box">                <img src="5c6144b2f4fb0cbcbcee85fb524143e4.png" alt title class>                <p></p>            </figure></p><h2 id="导出模板"><a href="#导出模板" class="headerlink" title="导出模板"></a>导出模板</h2><figure class="image-box">                <img src="d2d232ef03faec357af6e75046943155.png" alt title class>                <p></p>            </figure><h2 id="导入模板"><a href="#导入模板" class="headerlink" title="导入模板"></a>导入模板</h2><figure class="image-box">                <img src="aac06e0247578cc0e896a708857755c2.png" alt title class>                <p></p>            </figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>  新的一年,岁月不居,时节如流。虽然我们又老了一岁,但博主年轻的心态还未逝去。凭借年轻积极的心态,博主充满着激情去干每一件事,哪怕今天是大年初一,我对编程的热爱仍然放不下。而年轻的时光往往都是宝贵的,我不想浪费于假开心的玩乐,也不要花时间做太多的无用功做一些没有太大收获的事。<code>EasyCode</code>很适合处于当前的我,一键生成代码大大提高了开发效率,让我有了更充分的时间去完成其他的事情,更有效地把握住了时间。感谢<code>EasyCode</code>的作者<code>makejava</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> easycode </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git中文安装教程 window10</title>
      <link href="/2019/01/05/git-start/"/>
      <url>/2019/01/05/git-start/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1.Git简介"></a>1.Git简介</h2><blockquote><p><code>Git</code>是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速地处理从很小到非常大的项目版本管理。  Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></blockquote><h2 id="2-为何选择Git"><a href="#2-为何选择Git" class="headerlink" title="2.为何选择Git"></a>2.为何选择Git</h2><blockquote><p> Git 是目前最流行的版本管理工具，如果你使用 <code>Github</code>的话，必定要用到Git。如果这里你说你没使用 <code>GitHub</code>，那么就快去用起来，哥们你错过了很多优秀的开源项目啊不能再这样下去了。目前最火的开源社区 <code>Github</code> ,就是基于 Git 版本控制系统，所以掌握 Git 技能很重要。</p><p> 因为 Git 很火，现在很多 IDE 都集成了 Git,并且提供一些相关的图形化操作。也有很多很优秀,专门用来简化 Git 操作的 Git GUI 工具，例如 <code>SourceTree</code>,<code>Tortoise</code> 等。</p><p>但是我想说的是，<code>命令行</code>才是Git的王者操作！原因是，Git Gui的工具底层也是对常用的 Git 命令进行封装实现的，所以，直接Git命令，才是最灵活的操作。</p></blockquote><h2 id="3-Git优点"><a href="#3-Git优点" class="headerlink" title="3.Git优点"></a>3.Git优点</h2><blockquote><p> 1、适合分布式开发，强调个体；<br> 2、公共的服务器压力和数量都不会太大；<br> 3、速度快， 成熟的架构，开发灵活；<br> 4、任意两个开发者之间可以很容易的解决冲突；<br> 5、离线工作，管理代码成本低，不需要依赖服务器；<br> 6、部署方便。基本上下个命令就可以用；<br> 7、良好的分支机制，可以让主干代码保持干净。</p></blockquote><h2 id="4-什么是版本控制系统"><a href="#4-什么是版本控制系统" class="headerlink" title="4.什么是版本控制系统?"></a>4.什么是版本控制系统?</h2><blockquote><p>如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：</p><p>想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档就“魂飞魄散”了！</p><p>过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。</p><p>看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。</p><p>更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。</p><p>于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？</p><p>这个软件用起来就应该像这个样子，能记录每次文件的改动：</p></blockquote><table><thead><tr><th>版本</th><th style="text-align:right">用户</th><th style="text-align:right">说明</th><th style="text-align:center">日期</th></tr></thead><tbody><tr><td>1</td><td style="text-align:right">张三</td><td style="text-align:right">删除了软件服务条款5</td><td style="text-align:center">7/12 10:38</td></tr><tr><td>2</td><td style="text-align:right">张三</td><td style="text-align:right">增加了License人数限制</td><td style="text-align:center">7/12 18:09</td></tr><tr><td>3</td><td style="text-align:right">李四</td><td style="text-align:right">财务部门调整了合同金额</td><td style="text-align:center">7/13 9:51</td></tr><tr><td>4</td><td style="text-align:right">张三</td><td style="text-align:right">延长了免费升级周期</td><td style="text-align:center">7/14 15:17</td></tr></tbody></table><h2 id="4-下载"><a href="#4-下载" class="headerlink" title="4.下载"></a>4.下载</h2><p>网址: <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><h2 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h2><p>信息</p><figure class="image-box">                <img src="c532d8a1ea8f5f0e40fdd5dfd22a957b.png" alt title class>                <p></p>            </figure><p>选择安装位置</p><p><img src="46f018daeac3ea4d800b68357c1ccdfe.png" alt><br>选择组件</p><p><img src="d3e00efe821376bddeb2a710a180bcf1.png" alt></p><p>创建开始菜单目录</p><figure class="image-box">                <img src="ff01c1b86b69befebe8a582512559807.png" alt title class>                <p></p>            </figure><p>选择Git使用的默认编辑器</p><figure class="image-box">                <img src="95f0c82636056141dcc8746ed92e841a.png" alt title class>                <p></p>            </figure><p>选择VIm</p><figure class="image-box">                <img src="32c8f0c6b3ea1eb5cce5096beb639634.png" alt title class>                <p></p>            </figure><p>配置PATH环境<br><figure class="image-box">                <img src="52b139c0538ec8164b8518ec748c985a.png" alt title class>                <p></p>            </figure></p><p>选择HTTPS传输后端</p><figure class="image-box">                <img src="840b6f3cec80ed2d1467a127e441a625.png" alt title class>                <p></p>            </figure><p>配置行结束转换</p><figure class="image-box">                <img src="4449dad2043e81de03f7b9bd2045baa6.png" alt title class>                <p></p>            </figure><p>配置终端模拟器以与 Git Bash 一起使用</p><figure class="image-box">                <img src="2a84a2912dca2b1daa80ed4e4fa7c8ba.png" alt title class>                <p></p>            </figure><p>配置额外的选项</p><figure class="image-box">                <img src="b2b82340704cc0ea2713a0d35bd7bfa0.png" alt title class>                <p></p>            </figure><p>Installing</p><figure class="image-box">                <img src="21b2bb47bf4d93bce747505e10f451b5.png" alt title class>                <p></p>            </figure><p>完成安装<br><figure class="image-box">                <img src="71c0cf85416ccf9f9789c0bb82598b2d.png" alt title class>                <p></p>            </figure></p><p>运行软件<br><figure class="image-box">                <img src="ebb6ec0f3b19c86118289f3548bd288d.png" alt title class>                <p></p>            </figure></p><h1 id="6-设置"><a href="#6-设置" class="headerlink" title="6.设置"></a>6.设置</h1><h2 id="6-1配置github的ssh密钥"><a href="#6-1配置github的ssh密钥" class="headerlink" title="6.1配置github的ssh密钥:"></a>6.1配置github的ssh密钥:</h2><p>(1)打开Git Bash查看电脑上是否已经存在SSH密钥：<br>输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>(2)创建新的ssh key:<br>输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_email@youremail.com"</span><br></pre></td></tr></table></figure></p><p>按Enter，然后提示输入<code>passphrase（密码）</code>，输入两次（可以不输直接两次Enter），</p><p>然后会在 .ssh 目录生产两个文件<br>：id_rsa和id_rsa.pub用记事本打开.ssh目录下的id_rsa.pub文件，复制里面的内容；</p><h2 id="6-2复制ssh-key到github："><a href="#6-2复制ssh-key到github：" class="headerlink" title="6.2复制ssh key到github："></a>6.2复制ssh key到github：</h2><blockquote><p>On the GitHub site Click “Account Settings” &gt; Click “SSH Keys” &gt; Click “Add SSH key”</p></blockquote><p>打开github网站，点击右上角扳手图标，然后点击左边菜单的 ssh key， 然后右边页面的 add ssh key，将复制的内容粘贴到github的key中，title可以不填，直接保存即可。</p><h2 id="6-3测试-ssh-链接-github："><a href="#6-3测试-ssh-链接-github：" class="headerlink" title="6.3测试 ssh 链接 github："></a>6.3测试 ssh 链接 github：</h2><p>输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><h2 id="6-4设置自己的git信息："><a href="#6-4设置自己的git信息：" class="headerlink" title="6.4设置自己的git信息："></a>6.4设置自己的git信息：</h2><p>输入<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "Firstname Lastname"</span><br></pre></td></tr></table></figure></p><p>（此处name可修改也不是用于登录github的登录名）<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email "your_email@youremail.com"</span><br></pre></td></tr></table></figure></p><p>设置自己的git信息即完成安装和设置，可以输入git config –list查看自己的git信息。</p><h2 id="7-IntelliJ-IDEA-中GIT功能"><a href="#7-IntelliJ-IDEA-中GIT功能" class="headerlink" title="7.IntelliJ IDEA 中GIT功能"></a>7.IntelliJ IDEA 中GIT功能</h2><figure class="image-box">                <img src="dd597e1d9e0975fd13461495920258a9.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="dd597e1d9e0975fd13461495920258a9.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="4acb282c21ae8cd957093583ce38311f.png" alt title class>                <p></p>            </figure><h3 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h3><p><a href="https://blog.csdn.net/bmicnj/article/details/78413058" target="_blank" rel="noopener">https://blog.csdn.net/bmicnj/article/details/78413058</a><br><a href="https://baike.baidu.com/item/GIT/12647237?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/GIT/12647237?fr=aladdin</a><br><a href="https://git-scm.com/doc" target="_blank" rel="noopener">https://git-scm.com/doc</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 下载安装图文教程</title>
      <link href="/2019/01/05/mysql-start/"/>
      <url>/2019/01/05/mysql-start/</url>
      
        <content type="html"><![CDATA[<blockquote><p>岁月不居,时节如流,改革春风吹满地,本国人民真争气。博主在文体两开花之处,从京紫元年,步入了哥德巴赫猜想不到的2019年。今年年初,由于数据库课程设计的需要,部分同学想安装mysql,于是博主就写了个教程。</p></blockquote><h2 id="1-MySQL简介"><a href="#1-MySQL简介" class="headerlink" title="1.MySQL简介"></a>1.MySQL简介</h2><blockquote><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。</p></blockquote><p>基本语法MySQL的基本语法和SQL Server基本相同。</p><h2 id="1-1-MySQL的优缺点"><a href="#1-1-MySQL的优缺点" class="headerlink" title="1.1.MySQL的优缺点　　"></a>1.1.MySQL的优缺点　　</h2><p>（1）支持5000万条记录的数据仓库;　　<br> （2）适应于所有的平台;　　<br> （3）是开源软件，版本更新较快;　　<br> （4）性能很出色。纯粹就性能而言，MySQL是相当出色的，因为它包含一个缺省桌面格式MyISAM。MyISAM 数据库与磁盘非常地兼容而不占用过多的CPU和内存。MySQL可以运行于Windows系统而不会发生冲突，在UNIX或类似UNIX系统上运行则更好。可以通过使用64位处理器来获取额外的一些性能。因为MySQL在内部里很多时候都使用64位的整数处理;</p><h2 id="1-2-应用范围"><a href="#1-2-应用范围" class="headerlink" title="1.2.应用范围"></a>1.2.应用范围</h2><p><strong>Web网站系统</strong>：安装配置简单，性能优越，开源。<br>日志管理系统：高效的插入和查询功能，如果设计地较好，在使用MyISAM存储引擎的时候，两者可以做到互不锁定，达到很高的并发性能。<br><strong>数据仓库系统</strong>：在急需大量存储的空间和高效率的数据分析的需求下，目前基本有三种方式可以解决这一问题：</p><blockquote><ol><li>采用昂贵的高性能主机以提高计算性能，用高端存储设备提高I/O性能，效果理想，但是成本非常高；</li><li>通过将数据复制到多台使用大容量硬盘的廉价pcserver上，以提高整体计算性能和I/O能力，效果尚可，存储空间有一定限制，成本低廉；</li><li>通过将数据水平拆分，使用多台廉价的pcserver和本地磁盘来存放数据，每台机器上面都只有所有数据的.一部分，解决了数据量的问题，所有pcserver一起并行计算，也解决了计算能力问题，通过中间代理程序调配各台机器的运算任务，既可以解决计算性能问题又可以解决I/O性能问题，成本也很低廉。对于第二个和第三个，MySQL都有很大的优势（跨域的简单复制、免费）。*</li></ol></blockquote><p><strong>嵌入式系统</strong>：嵌入式环境对软件系统最大的限制是硬件资源非常有限，在嵌入式环境下运行的软件系统，必须是轻量级低消耗的软件。MySQL有专门针对嵌入式系统的版本。</p><h2 id="2-下载与安装"><a href="#2-下载与安装" class="headerlink" title="2.下载与安装"></a>2.下载与安装</h2><h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><figure class="image-box">                <img src="a265e4f17ccb0631ab8133d7a9848875.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="51384ce992fd9acfcdb0439acce45513.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="3d354a7820ace2c85528ebea002fb795.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="b3d29ca01839dbbec06b678d41318e08.png" alt title class>                <p></p>            </figure><h3 id="2-2安装"><a href="#2-2安装" class="headerlink" title="2.2安装"></a>2.2安装</h3><figure class="image-box">                <img src="3189f4703a91855f879deee059a5f0ff.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="1ac4316f748f679606101eb3cd006bf1.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="a9086d4e5b2952de78e5b1b501e36e28.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="88143bce7155cd2fab7ab2a751632df0.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="4112efa3677b14a1ee9eeac7dde70f72.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="1adacb2e96886e5529d7d11de5b9c561.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="6d6d3785b12356ca541e67013bca4b8c.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="3af5c1de01d4edc471c439347554495f.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="7a41fb6866feefdfc9397fba97f3625b.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="200df265bf650a850848c6b5001fcbbe.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="62c4bfe797c688f1ca1a0f617c7ea5a7.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="88f16748c90730db42c2b6bfb93d6491.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="d4f01e1ccb83be49c428eccb9c62fcee.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="56fd50ea6c3aee851994b325b628ced2.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="055f4afda1b07bc1f527dea0edd2456a.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="1d323ec75dff4d22609cc63aec9032e1.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="ec49ba6e17025f372d8eecfbcbf2cb0e.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="f9bd08ff90ce4f5e37f4da0b0853c7ac.png" alt title class>                <p></p>            </figure><h3 id="2-3-环境配置"><a href="#2-3-环境配置" class="headerlink" title="2.3 环境配置"></a>2.3 环境配置</h3><figure class="image-box">                <img src="5b2b69d8c3f314891eebb8487a8657bc.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="4148b97b90b9946ca3712752622df332.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="5c66e79395b2bdc6772d1f0ea17039c2.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="f94db123854e05a6cafb1f7b83f0938b.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="ef5685899ce7e47654def5fccc246744.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="34ae63c7df1f38ef33aa0c1231e5608c.png" alt title class>                <p></p>            </figure><h1 id="3-FAQ"><a href="#3-FAQ" class="headerlink" title="3.FAQ"></a>3.FAQ</h1><h2 id="3-1配置"><a href="#3-1配置" class="headerlink" title="3.1配置"></a><code>3.1配置</code></h2><ul><li><code>MySQL服务器类型的选择</code></li></ul><p>作为初学者，一般选择的类型为“Developer Machine(开发者机器)”即可。看个人喜好。</p><ul><li><code>MySQL的存储引擎</code></li></ul><p>确定MySQL使用情况时，选择“multifunction database（多功能数据库）”。这种数据库能够支持常用的MyISAM和InnoDB两种存储引擎。每种存储引擎有各自的特点，适用于不同的应用。</p><ul><li><code>字符集设置</code></li></ul><p>字符集的选择影响着数据库能否正常显示中文字符。因此，要手动（manual）设置字符集，以前一般是GB2312（简体中文），这样才能保证数据库中存储的中文字符能够正常地保存和读取，否则会出现乱码。但是，utf-8是现在通用的标准，所以我们也设置为utf-8。</p><ul><li><code>配置文件</code></li></ul><p>在MySQL服务器安装和配置完成之后，在MySQL主目录（如“C:\Program<br>Files\MySQL\MySQL Server 5.7”）下会生成一个my.ini文件，这是MySQL的选项文件，在MySQL启动时会自动加载该文件中的一些选项，可以修改my.ini来更改默认设置（建议不修改，大神除外）。</p><ul><li><code>数据文件存放位置</code><br>MySQL有一个存放数据库文件的data目录，默认路径为“C:\Documents and Settings\All Users\Application Data\MySQL\ MySQL Server 5.7\data”，<br>在data目录下MySQL为每一个数据库建立一个与数据库同名的文件夹，所有表存放在相应的数据库文件夹下。可以直接拷走存储和移动（强大）。<h2 id="3-2-MySQL服务器的启动和关闭"><a href="#3-2-MySQL服务器的启动和关闭" class="headerlink" title="3.2.MySQL服务器的启动和关闭"></a><code>3.2.MySQL服务器的启动和关闭</code></h2>MySQL服务器安装完成后，可随时通过手工方式在本机上启动和关闭。具体操作如下：</li></ul><ol><li>在Windows开始—运行—打开（Win10可以直接输入）中输入“msc”，出现下图的本地服务列表框。</li><li>然后，选中服务列表中的“MySQL”服务，打开“服务”。此时可执行“关闭”，“暂停”，和“启动”等功能操作。<figure class="image-box">                <img src="6e8acc4bf5a53248b46ad313e450ea8a.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="aed303cbe376402a66a7bb6403373d0f.png" alt title class>                <p></p>            </figure></li></ol><h2 id="3-3-MySQL客户端管理工具"><a href="#3-3-MySQL客户端管理工具" class="headerlink" title="3.3.MySQL客户端管理工具"></a><code>3.3.MySQL客户端管理工具</code></h2><p>正确安装和配置MySQL服务器后，大家可以选用自己熟悉的MySQL客户端管理工具来连接和管理MySQL数据库。<br>常用的MySQL客户端管理工具有如下几种（本人经常使用）：<br>1、命令行界面<br>Windows下打开cmd命令行界面：输入mysql -uroot -p，然后输入密码即可。<br><figure class="image-box">                <img src="e8a3fb29f7a0736ac45d8e5e5cdf6db9.png" alt title class>                <p></p>            </figure><br>2、MySQL图形化管理工具<br>前面已经说过，MySQL经常和PHP连接使用，所以PHPmyadmin就是一种MySQL图形化管理工具，可以从<a href="https://www.phpmyadmin.net/downloads/下载。" target="_blank" rel="noopener">https://www.phpmyadmin.net/downloads/下载。</a><br>Phpmyadmin是使用PHP语言开发的基于web方式的MySQL图形化管理工具，它通过B/S工作模式来连接和操作MySQL服务器。如下图所示：<br><figure class="image-box">                <img src="9f2256006c5d6fa239e35156204869db.png" alt title class>                <p></p>            </figure></p><p>3、Navicat for MySQL <code>推荐</code><br>Navicat是一款强大的数据库管理工具，可以连接和管理多种关系型数据库和NoSQL数据库。下载地址：<a href="https://www.navicat.com/products/navicat-for-mysql" target="_blank" rel="noopener">https://www.navicat.com/products/navicat-for-mysql</a><br>大家可根 据自己的喜好和使用习惯选择管理工具。以上是我常用的几款<br><figure class="image-box">                <img src="a466ec383f5eb59b5f4306931a1c0d78.png" alt title class>                <p></p>            </figure></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbox 从下载到安装至maven</title>
      <link href="/2018/12/06/dubbox-maven/"/>
      <url>/2018/12/06/dubbox-maven/</url>
      
        <content type="html"><![CDATA[<h1 id="dubbox-从下载到安装至maven"><a href="#dubbox-从下载到安装至maven" class="headerlink" title="dubbox 从下载到安装至maven"></a>dubbox 从下载到安装至maven</h1><p>@(出自本人)</p><h2 id="dobbox简介"><a href="#dobbox简介" class="headerlink" title="dobbox简介"></a>dobbox简介</h2><blockquote><p>Dubbo是一个被国内很多互联网公司广泛使用的开源分布式服务框架，即使从国际视野来看应该也是一个非常全面的SOA基础框架。作为一个重要的技术研究课题，在当当网我们根据自身的需求，为Dubbo实现了一些新的功能，并将其命名为Dubbox （即Dubbo eXtensions）</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>网址：<a href="https://github.com/dangdangdotcom/dubbox/tree/dubbox-2.8.4" target="_blank" rel="noopener">https://github.com/dangdangdotcom/dubbox/tree/dubbox-2.8.4</a></p><p>解压得到<br><figure class="image-box">                <img src="./1536592678723.png" alt title class>                <p></p>            </figure></p><h2 id="用maven编译文件"><a href="#用maven编译文件" class="headerlink" title="用maven编译文件"></a>用maven编译文件</h2><ul><li>打开终端窗口</li><li>执行命令cd 到该目录</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\Programming\Install\dubbox\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>再执行命令</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install -f D:\Programming\Install\dubbox\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>\pom.xml -D maven.test.skip=true</span><br></pre></td></tr></table></figure><p>稍等片刻<br><figure class="image-box">                <img src="./1536593412261.png" alt title class>                <p></p>            </figure><br>如图,编译完毕,可以看到,dubbox-dubbox-2.8.4子目录下都有一个target文件夹<br><figure class="image-box">                <img src="./1536593598405.png" alt title class>                <p></p>            </figure></p><h2 id="安装到maven本地仓库中"><a href="#安装到maven本地仓库中" class="headerlink" title="安装到maven本地仓库中"></a>安装到maven本地仓库中</h2><p>执行下面语句</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:\Programming\Install\dubbox\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>\dubbox-dubbox-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>\dubbo\target\dubbo-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span> -Dpackaging=jar -DgeneratePom=true</span><br></pre></td></tr></table></figure><p>结果<br><figure class="image-box">                <img src="./1536631397262.png" alt title class>                <p></p>            </figure><br>执行失败了!!!?<br><figure class="image-box">                <img src="./1536631569879.png" alt title class>                <p></p>            </figure></p><p>稍等,给我一点排错的时间。</p><h4 id="发现错误"><a href="#发现错误" class="headerlink" title="发现错误"></a>发现错误</h4><p>原来window10的<code>powershell</code>下执行命令,路径不能带有 <code>-</code>和<code>空格</code><br>发现错误路径<br><em>D:\Programming\Install\dubbox\dubbox-dubbox-2.8.4\dubbox-dubbox-2.8.4\dubbo\target\dubbo-2.8.4.jar</em></p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>进入..\dubbox-dubbox-2.8.4\dubbo</li><li><p>换个路径</p><figure class="image-box">                <img src="./1536632833526.png" alt title class>                <p></p>            </figure><figure class="image-box">                <img src="./1536633160031.png" alt title class>                <p></p>            </figure></li><li><p>执行命令</p></li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:\Programming\setup\target\dubbo-<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span>.jar -DgroupId=com.alibaba -DartifactId=dubbo -Dversion=<span class="number">2</span>.<span class="number">8</span>.<span class="number">4</span> -Dpackaging=jar -DgeneratePom=true</span><br></pre></td></tr></table></figure><ul><li>执行成功的结果<figure class="image-box">                <img src="./1536633300546.png" alt title class>                <p></p>            </figure></li></ul><h2 id="用idea新建项目引入jar包"><a href="#用idea新建项目引入jar包" class="headerlink" title="用idea新建项目引入jar包"></a>用idea新建项目引入jar包</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如图<br><figure class="image-box">                <img src="./1536633948654.png" alt title class>                <p></p>            </figure></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbox </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 使用---- java语法糖</title>
      <link href="/2018/12/05/lambda-java/"/>
      <url>/2018/12/05/lambda-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java8最值得学习的特性就是Lambda表达式和Stream API，如果有python或者javascript的语言基础，对理解Lambda表达式有很大帮助，因为Java正在将自己变的更高（Sha）级（Gua），更人性化。————可以这么说lambda表达式其实就是实现SAM接口的语法糖。</p></blockquote><h1 id="Lambda语法"><a href="#Lambda语法" class="headerlink" title="Lambda语法"></a>Lambda语法</h1><p>Lambda的语法极为简单，类似如下结构:<br>      <code>(parameters) -&gt; expression</code><br>或者<br>    <code>(parameters) -&gt; { statements; }</code></p><h4 id="Lambda表达式由三部分组成："><a href="#Lambda表达式由三部分组成：" class="headerlink" title="Lambda表达式由三部分组成："></a>Lambda表达式由三部分组成：</h4><ul><li><strong>paramaters</strong>：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明也可不声明而由JVM隐含的推断1。另外当只有一个推断类型时可以省略掉圆括号。</li><li><strong>-&gt;</strong>：可理解为“被用于”的意思</li><li><strong>方法体</strong>：可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1：不需要接受参数，直接返回10</span></span><br><span class="line">()-&gt;<span class="number">10</span></span><br><span class="line"><span class="comment">//示例2：接受两个int类型的参数，并返回这两个参数相加的和</span></span><br><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y;</span><br><span class="line"><span class="comment">//示例2：接受x,y两个参数，该参数的类型由JVM根据上下文推断出来，并返回两个参数的和</span></span><br><span class="line">(x,y)-&gt;x+y;</span><br><span class="line"><span class="comment">//示例3：接受一个字符串，并将该字符串打印到控制到，不反回结果</span></span><br><span class="line">(String name)-&gt;System.out.println(name);</span><br><span class="line"><span class="comment">//示例4：接受一个推断类型的参数name，并将该字符串打印到控制台</span></span><br><span class="line">name-&gt;System.out.println(name);</span><br><span class="line"><span class="comment">//示例5：接受两个String类型参数，并分别输出，不反回</span></span><br><span class="line">(String name,String sex)-&gt;&#123;System.out.println(name);System.out.println(sex)&#125;</span><br><span class="line"><span class="comment">//示例6：接受一个参数x，并返回该该参数的两倍</span></span><br><span class="line">x-&gt;<span class="number">2</span>*x</span><br></pre></td></tr></table></figure><h1 id="一-匿名函数"><a href="#一-匿名函数" class="headerlink" title="一.匿名函数"></a>一.匿名函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/3 0003-21:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//直接匿名函数</span></span><br><span class="line">  <span class="comment">//(int x,int y)-&gt;&#123;return x+y;&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略方式</span></span><br><span class="line">  <span class="comment">//(x,y)-&gt;x+y;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用例子</span></span><br><span class="line">  <span class="comment">//lambda表达式</span></span><br><span class="line">  Runnable run1= ()-&gt;&#123;System.out.println(<span class="string">"run1---------"</span>);&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//普通方法</span></span><br><span class="line">  Runnable run2 =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"run2---------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FunctionDemo demo1 =<span class="keyword">new</span> FunctionDemo();</span><br><span class="line">    demo1.run1.run();</span><br><span class="line">    demo1.run2.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run1---------</span><br><span class="line">run2---------</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h2 id="第一个场景应用"><a href="#第一个场景应用" class="headerlink" title="第一个场景应用"></a>第一个场景应用</h2><p>需求:任意2个数的计算</p><p>案例:<br>例一: 方法add(1,2)=1+2=3<br>例二: 方法mult(1,2)=1*2=2</p><h4 id="以前写法"><a href="#以前写法" class="headerlink" title="以前写法"></a>以前写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/4 0004-21:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//+</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//*</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/4 0004-21:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calcimpl</span> <span class="keyword">implements</span> <span class="title">Calc</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mult</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda写法"><a href="#lambda写法" class="headerlink" title="lambda写法"></a>lambda写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/4 0004-21:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">//FunctionalInterface主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LambaCalc</span> </span>&#123;</span><br><span class="line">  <span class="comment">//有且仅有一个抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/4 0004-21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一般以前的使用方式</span></span><br><span class="line">    Calc calc=<span class="keyword">new</span> Calcimpl();</span><br><span class="line">    System.out.println(calc.add(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数式接口</span></span><br><span class="line">    LambaCalc f1=(x, y)-&gt;&#123;<span class="keyword">return</span> x+y;&#125;;</span><br><span class="line">    LambaCalc f2=(x, y)-&gt;x+y;</span><br><span class="line">    System.out.println(f1.calc(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">    System.out.println(f2.calc(<span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------------</span><br><span class="line"><span class="number">11</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h1 id="二-容器遍历方式"><a href="#二-容器遍历方式" class="headerlink" title="二.容器遍历方式"></a>二.容器遍历方式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/4 0004-21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造一个容器</span></span><br><span class="line">    String[] args =&#123;<span class="string">"player1"</span>,<span class="string">"player2"</span>,<span class="string">"player3"</span>,<span class="string">"player4"</span>,<span class="string">"player5"</span>&#125;;</span><br><span class="line">    <span class="comment">//转为List集合</span></span><br><span class="line">    List&lt;String&gt; playerList= Arrays.asList(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以前遍历方式</span></span><br><span class="line">    <span class="comment">//外部方式循环,客户代码</span></span><br><span class="line">    <span class="keyword">for</span> (String player : playerList) &#123;</span><br><span class="line">      System.out.println(player);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lambda方式</span></span><br><span class="line">    <span class="comment">//内循环,JDK自己处理</span></span><br><span class="line">    playerList.forEach((player)-&gt;&#123; System.out.println(player); &#125;);</span><br><span class="line">    System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">    playerList.forEach((player)-&gt; System.out.println(player) );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">player1</span><br><span class="line">player2</span><br><span class="line">player3</span><br><span class="line">player4</span><br><span class="line">player5</span><br><span class="line">--------------------------</span><br><span class="line">player1</span><br><span class="line">player2</span><br><span class="line">player3</span><br><span class="line">player4</span><br><span class="line">player5</span><br><span class="line">--------------------------</span><br><span class="line">player1</span><br><span class="line">player2</span><br><span class="line">player3</span><br><span class="line">player4</span><br><span class="line">player5</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>三.容器内容的删除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//构造一个容器</span></span><br><span class="line">  String[] args =&#123;<span class="string">"player1"</span>,<span class="string">"player2"</span>,<span class="string">"player3"</span>,<span class="string">"player4"</span>,<span class="string">"player5"</span>&#125;;</span><br><span class="line">  <span class="comment">//转为List集合...(若用Arrays.asList(args)转换会报错,原因这样list的iterator不支持remove()方法)</span></span><br><span class="line">  List&lt;String&gt; playerList= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String player : args) &#123;</span><br><span class="line">    playerList.add(player);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"-------------原来-------------"</span>);</span><br><span class="line">  playerList.forEach((player)-&gt; System.out.println(player) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//1.以前删除容器数据方式</span></span><br><span class="line">  Iterator&lt;String&gt; it = playerList.iterator();</span><br><span class="line">  <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    String player=it.next();</span><br><span class="line">    <span class="keyword">if</span> (player.equals(<span class="string">"player2"</span>))&#123;</span><br><span class="line">      it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.新方式removeif</span></span><br><span class="line">  playerList.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String player)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> player.equals(<span class="string">"player3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.removeif 的lambda表达式</span></span><br><span class="line">  playerList.removeIf((player)-&gt;player.equals(<span class="string">"player4"</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"------------删除后------------"</span>);</span><br><span class="line">  playerList.forEach((player)-&gt; System.out.println(player) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-------------原来-------------</span><br><span class="line">player1</span><br><span class="line">player2</span><br><span class="line">player3</span><br><span class="line">player4</span><br><span class="line">player5</span><br><span class="line">------------删除后------------</span><br><span class="line">player1</span><br><span class="line">player5</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h1 id="四-集合Stream的操作"><a href="#四-集合Stream的操作" class="headerlink" title="四.集合Stream的操作"></a>四.集合Stream的操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambdaDemo.com.mission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mission</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/5 0005-16:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionStreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Integer[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="keyword">null</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="keyword">null</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list= Arrays.asList(nums);</span><br><span class="line">    <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以前累加方式</span></span><br><span class="line">    <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sum =sum+num;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"old sum -&gt;"</span>+sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新方式,流方式,lambda实现</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链条操作</span></span><br><span class="line"><span class="comment">     * 1.list.stream() 创建流</span></span><br><span class="line"><span class="comment">     * 2.filter(x-&gt;x!=null) 过滤 Stream 中的元素</span></span><br><span class="line"><span class="comment">     * 3.reduce((s,x)-&gt;s+x) 从一组值中生成一个新的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sum = list.stream().filter(x-&gt;x!=<span class="keyword">null</span>).reduce((s,x)-&gt;s+x).get();</span><br><span class="line">    System.out.println(<span class="string">"stream sum -&gt;"</span>+sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream 中主要包含如下几个方法：</p><p>方法名    简介</p><table><thead><tr><th>collect(toList())</th><th style="text-align:right">通过 Stream 生成一个列表</th></tr></thead><tbody><tr><td>map</td><td style="text-align:right">将流中的一个值转换成一个新的值</td></tr><tr><td>filter</td><td style="text-align:right">过滤 Stream 中的元素</td></tr><tr><td>flatMap</td><td style="text-align:right">将多个 Stream 连接成一个 Stream</td></tr><tr><td>max</td><td style="text-align:right">求最大值</td></tr><tr><td>min</td><td style="text-align:right">求最小值</td></tr><tr><td>reduce</td><td style="text-align:right">从一组值中生成一个新的值</td></tr></tbody></table><p>上面就是 Stream 中包含的几个主要方法，下面逐一对其介绍：</p><h3 id="collect-toList-amp-filter"><a href="#collect-toList-amp-filter" class="headerlink" title="collect(toList()) &amp; filter"></a>collect(toList()) &amp; filter</h3><p>collect(toList()) 的作用是通过一个 Stream 对象生成 List 对象，案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; result = list.stream().filter((value) -&gt; value &gt; <span class="number">2</span>).collect(toList());</span><br><span class="line">result.forEach((value) -&gt; System.out.print(value));</span><br></pre></td></tr></table></figure><p>上面的代码先创建了一个 List 对象并初始化，然后筛选出大于 2 的值，输出。<br>filter 方法的作用是过滤 Stream 中的元素，filter 方法是一个高阶函数，接收一个函数接口作为参数，此高阶函数返回一个 boolean 值，返回 true 的元素会保留下来；<br>collect(toList()) 方法将 filter 操作返回的 Stream 生成一个 List。</p><p>高阶函数：接收或返回一个函数接口的函数称为高阶函数。<br>函数接口：只包含一个函数的接口成为函数接口。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 函数的作用是将流中的一个值转换成一个新的值，举个例子，我们要将一个 List 转换成 List ，那么就可以使用 map 方法，示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;String&gt; result = list.stream().map(value -&gt; String.format(<span class="string">"String:%s"</span>, value)).collect(toList());</span><br><span class="line">result.forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>map 方法将 Integer 元素转换成 String 并使用 collect(toList()) 方法生成一个新的 List。</p><p>System.out::print 是 (value) -&gt; System.out.print(value) 的简化版写法。</p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>flatMap：将多个 Stream 连接成一个 Stream，这个怎么理解呢，举个栗子：<br>首先定义一个 List 对象，将这个对象中的每一个 String 都分割成一个字母并生成一个新的 List 对象，代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">List&lt;Character&gt; result = list.stream().flatMap(value -&gt; &#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = value.toCharArray();</span><br><span class="line">    Character[] characters = <span class="keyword">new</span> Character[chars.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; characters.length; i++)&#123;</span><br><span class="line">        characters[i] = chars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(characters);</span><br><span class="line">&#125;).collect(toList());</span><br><span class="line">result.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面代码先遍历 list ，通过 flatMap 函数将每个 String 元素都生成一个新的 Stream 并将这些 Stream 连接成一个新的 Stream。</p><h3 id="max-amp-min"><a href="#max-amp-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h3><p>求最大值最小值，这个很好理解了，直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Comparator&lt;Integer&gt; comparator = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">System.out.println(list.stream().min(comparator).get());</span><br><span class="line">System.out.println(list.stream().max(comparator).get());</span><br></pre></td></tr></table></figure><p>min 和 max 函数需要一个 Comparator 对象为参数作为比对依据。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>从一组值中生成一个新的值，reduce 函数其实用途非常广泛，作用也比较大，我们举一个累加的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> count = list.stream().reduce(<span class="number">0</span>, (acc, item) -&gt; acc + item).intValue();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>reduce 函数的一个参数为循环的初始值，这里计算累加时初始值为 0，acc 代表已经计算的结果，item 表示循环的每个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例一:小写转换为大写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCase</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String[] str =&#123;<span class="string">"test"</span>,<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"java"</span>,<span class="string">"tom"</span>,<span class="string">"C"</span>,<span class="string">"javascript"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list=Arrays.asList(str);</span><br><span class="line">    list.stream().map(x-&gt;x.toUpperCase()).forEach(x-&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例二:元素扩大两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTwoFold</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer[] data =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list=Arrays.asList(data);</span><br><span class="line">    list.stream().map(x-&gt;<span class="number">2</span>*x).forEach(x-&gt;System.out.println(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例三:求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Integer[] data =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list =Arrays.asList(data);</span><br><span class="line">    <span class="keyword">int</span> num =list.stream().reduce((sum,x)-&gt;sum+x).get();</span><br><span class="line">  System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEST</span><br><span class="line">HELLO</span><br><span class="line">WORLD</span><br><span class="line">JAVA</span><br><span class="line">TOM</span><br><span class="line">C</span><br><span class="line">JAVASCRIPT</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="map和reduce总结"><a href="#map和reduce总结" class="headerlink" title="map和reduce总结"></a>map和reduce总结</h4><ul><li>map是针对每个数据处理</li><li>reduce是针对集合最后处理</li><li>map()进行数据重写组合</li><li>reduce()是对集合中所有数据变为一个结果</li></ul><h1 id="五-Function函数使用"><a href="#五-Function函数使用" class="headerlink" title="五.Function函数使用"></a>五.Function函数使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个整数类型,返回一个字符串类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConvert</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//以前的方法</span></span><br><span class="line">  Function&lt;Integer,String&gt; fun1 =<span class="keyword">new</span> Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(integer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  String s1=fun1.apply(<span class="number">100</span>);</span><br><span class="line">  System.out.println(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//lambda使用</span></span><br><span class="line">  Function&lt;Integer,String&gt; fun2=x-&gt;String.valueOf(x);</span><br><span class="line">  String s2=fun2.apply(<span class="number">2</span>);</span><br><span class="line">  System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h1 id="六-Consumer用法"><a href="#六-Consumer用法" class="headerlink" title="六.Consumer用法"></a>六.Consumer用法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 定义:</span></span><br><span class="line"><span class="comment"> *   代表了接受一个输入参数并且无返回的操作,如果某一类操作不需要返回接口,可以对该类操作抽取逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法:</span></span><br><span class="line"><span class="comment"> * 无返回函数操作 void accept(T t);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 案例:</span></span><br><span class="line"><span class="comment"> * 遍历容器forEach()方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     default void forEach(Consumer&lt;? super T&gt; action) &#123;</span></span><br><span class="line"><span class="comment"> *         Objects.requireNonNull(action);</span></span><br><span class="line"><span class="comment"> *         for (T t : this) &#123;</span></span><br><span class="line"><span class="comment"> *             action.accept(t);</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] str=&#123;<span class="string">"A1"</span>,<span class="string">"B2"</span>,<span class="string">"C3"</span>,<span class="string">"D4"</span>&#125;;</span><br><span class="line">  List&lt;String&gt; list= Arrays.asList(str);</span><br><span class="line">  list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">  list.forEach((x)-&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">C3</span><br><span class="line">D4</span><br><span class="line">----------------------------</span><br><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">C3</span><br><span class="line">D4</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h1 id="七-Predicte用法"><a href="#七-Predicte用法" class="headerlink" title="七.Predicte用法"></a>七.Predicte用法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *Predicte&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 定义:</span></span><br><span class="line"><span class="comment"> *  Predicte函数式接口的主要作用是提供一个test方法,接受一个参数返回布尔类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 方法:</span></span><br><span class="line"><span class="comment"> *  函数操作boolean test(T t)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  案例:</span></span><br><span class="line"><span class="comment"> *  list.stream().filter()方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FunctionalInterface</span></span></span><br><span class="line"><span class="comment"> * public interface Predicate&lt;T&gt; &#123;</span></span><br><span class="line"><span class="comment"> *    boolean test(T t);</span></span><br><span class="line"><span class="comment"> *    ......</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFitler</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//容器中数据过滤掉</span></span><br><span class="line">  String[] str=&#123;<span class="string">"A1"</span>,<span class="string">"B2"</span>,<span class="string">"C3"</span>,<span class="string">"D4"</span>&#125;;</span><br><span class="line">  List&lt;String&gt; list= Arrays.asList(str);</span><br><span class="line"></span><br><span class="line">  list.stream().filter(<span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> !s.equals(<span class="string">"C3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).forEach(t-&gt; System.out.println(t));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">  list.stream().filter(x-&gt;!x.equals(<span class="string">"D4"</span>)).forEach(x-&gt; System.out.println(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">D4</span><br><span class="line">----------------------------</span><br><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">C3</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>本文到此结束</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> lambda </tag>
            
            <tag> 语法糖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法手册</title>
      <link href="/2018/09/22/markdown-manual/"/>
      <url>/2018/09/22/markdown-manual/</url>
      
        <content type="html"><![CDATA[<h2 id="初识Markdown"><a href="#初识Markdown" class="headerlink" title="初识Markdown"></a>初识Markdown</h2><blockquote><p>Markdown 是一种用来写作的轻量级 标记语言，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。</p></blockquote><h2 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h2><blockquote><p>专注你的文字内容而不是排版样式，安心写作。<br>轻松的导出 HTML、PDF 和本身的 .md 文件。<br>纯文本内容，兼容所有的文本编辑器与字处理软件。<br>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。<br>可读、直观、学习成本低。</p></blockquote><h2 id="使用-Markdown-的缺点"><a href="#使用-Markdown-的缺点" class="headerlink" title="使用 Markdown 的缺点"></a>使用 Markdown 的缺点</h2><blockquote><p>没有像word一样格式的花哨。<br>不支持复杂的格式（如表格等）。<br>有太多不兼容的方言。由于原始的Markdown支持的格式有限，所以出现了很多不同的扩展，这些扩展之间的不兼容性是一个问题。<br>markdown没有被标准化，其版本较多，给人感觉有点混乱，因为github的关系，当前比较流行的是markdown是gfm。</p></blockquote><blockquote><p><em>We believe that writing is about content, about what you want to say – not about fancy formatting. </em><br>  <em>— Ulysses for Mac</em>    (我们坚信写作写的是内容，所思所想，而不是花样格式。–麦克尤利西斯)</p></blockquote><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a><em>Markdown语法</em></h2><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p><p>示例：</p><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://missionodd.github.io">本人博客</a> 的链接。</p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><figure class="image-box">                <img src="./img/avatar.jpg" alt="我的头像" title class>                <p>我的头像</p>            </figure><h1 id="Markdown-高阶语法手册"><a href="#Markdown-高阶语法手册" class="headerlink" title="Markdown 高阶语法手册"></a>Markdown 高阶语法手册</h1><h3 id="1-内容目录-本博客失效"><a href="#1-内容目录-本博客失效" class="headerlink" title="1. 内容目录 本博客失效"></a>1. 内容目录 <del>本博客失效</del></h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p> [TOC]</p><h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="4-注脚-本博客失效"><a href="#4-注脚-本博客失效" class="headerlink" title="4. 注脚 本博客失效"></a>4. 注脚 <del>本博客失效</del></h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^1]的样例。</p><p>这是第二个注脚[^2]的样例。</p><h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式：</p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\begin{equation}<br>[a, b, c]=\left|<br>\begin{array}{ccc}<br>  a_1&amp; a_2  &amp; a_3  \\<br> b_1 &amp;b_2   &amp; b_3  \\<br> c_1 &amp;c_2   &amp;c_3<br>\end{array}<br>\right|<br>\end{equation}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><p>Python 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><p>JavaScript 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return </span>the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div id="flowchart-0" class="flow-chart"></div><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图-本博客失效"><a href="#8-序列图-本博客失效" class="headerlink" title="8. 序列图  本博客失效"></a>8. 序列图  <del>本博客失效</del></h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图-本博客失效"><a href="#9-甘特图-本博客失效" class="headerlink" title="9. 甘特图  本博客失效"></a>9. 甘特图  <del>本博客失效</del></h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图-本博客失效"><a href="#10-Mermaid-流程图-本博客失效" class="headerlink" title="10. Mermaid 流程图  本博客失效"></a>10. Mermaid 流程图  <del>本博客失效</del></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图-本博客失效"><a href="#11-Mermaid-序列图-本博客失效" class="headerlink" title="11. Mermaid 序列图  本博客失效"></a>11. Mermaid 序列图  <del>本博客失效</del></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目        | 价格   |  数量  |</span><br><span class="line">| --------   | -----:  | :----:  |</span><br><span class="line">| 计算机     | \$1600 |   5     |</span><br><span class="line">| 手机        |   \$12   |   12   |</span><br><span class="line">| 管线        |    \$1    |  234  |</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;星期一&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;星期二&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;星期三&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;李强&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;张明&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;王平&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p><table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- [ ] **Markdown 开发**</span><br><span class="line">    - [ ] 改进渲染算法，使用局部渲染技术提高渲染效率</span><br><span class="line">    - [ ] 支持以 PDF 格式导出文稿</span><br><span class="line">    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)</span><br><span class="line">    - [x] 改进 LaTex 功能</span><br><span class="line">        - [x] 修复 LaTex 公式渲染问题</span><br><span class="line">        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)</span><br><span class="line">- [ ] **七月旅行准备**</span><br><span class="line">    - [ ] 准备邮轮上需要携带的物品</span><br><span class="line">    - [ ] 浏览日本免税店的物品</span><br><span class="line">    - [x] 购买蓝宝石公主号七月一日的船票</span><br></pre></td></tr></table></figure></p><p>对应显示如下待办事宜 Todo 列表：</p><ul><li style="list-style: none"><input type="checkbox"> <strong>Markdown 开发</strong><ul><li style="list-style: none"><input type="checkbox"> 改进渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox" checked> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li style="list-style: none"><input type="checkbox" checked> 改进 LaTex 功能<ul><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>七月旅行准备</strong><ul><li style="list-style: none"><input type="checkbox"> 准备邮轮上需要携带的物品</li><li style="list-style: none"><input type="checkbox"> 浏览日本免税店的物品</li><li style="list-style: none"><input type="checkbox" checked> 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><h3 id="17-更多-Hexo-写作语法"><a href="#17-更多-Hexo-写作语法" class="headerlink" title="17. 更多 Hexo 写作语法"></a>17. 更多 Hexo 写作语法</h3><ul><li><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">写作</a></li><li><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Front-matter</a></li><li><a href="https://hexo.io/zh-cn/docs/tag-plugins" target="_blank" rel="noopener">标签插件（Tag Plugins）</a></li><li><a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">资源文件夹</a></li><li><a href="https://hexo.io/zh-cn/docs/data-files" target="_blank" rel="noopener">数据文件</a></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#-markdown-高阶语法手册" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#-markdown-高阶语法手册</a></li><li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li><a href="https://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="noopener">https://www.jianshu.com/p/1e402922ee32/</a><br><script src="https://cdnjs.cat.net/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cat.net/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start:>https://www.zybuluo.comio=>inputoutput: verificationop=>operation: Your Operationcond=>condition: Yes or No?sub=>subroutine: Your Subroutinee=>endst->io->op->condcond(yes)->econd(no)->sub->io</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/01/hello-world/"/>
      <url>/2018/09/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1472480890&auto=1&height=66"></iframe><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Test-Java"><a href="#Test-Java" class="headerlink" title="Test Java"></a>Test Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></figure><h3 id="Test-node-js"><a href="#Test-node-js" class="headerlink" title="Test node.js"></a>Test node.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Prism = <span class="built_in">require</span>(<span class="string">'prismjs'</span>);</span><br><span class="line"><span class="keyword">var</span> loadLanguages = <span class="built_in">require</span>(<span class="string">'prismjs/components/'</span>);</span><br><span class="line">loadLanguages([<span class="string">'haml'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The code snippet you want to highlight, as a string</span></span><br><span class="line"><span class="keyword">var</span> code = <span class="string">"= ['hi', 'there', 'reader!'].join \" \""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a highlighted HTML string</span></span><br><span class="line"><span class="keyword">var</span> html = Prism.highlight(code, Prism.languages.haml, <span class="string">'haml'</span>);</span><br></pre></td></tr></table></figure><h3 id="Test-flowchart-js"><a href="#Test-flowchart-js" class="headerlink" title="Test flowchart.js"></a>Test flowchart.js</h3><div id="flowchart-0" class="flow-chart"></div><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><script src="https://cdnjs.cat.net/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cat.net/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>http://www.google.com[blank]e=>end: End:>http://www.google.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yesor No?|approved:>http://www.google.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
      <categories>
          
          <category> 无 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html>
<html>
<!--
　　　　　　　　  　　　/ヽ　　　　　　/ヽ
　　　　　　 　　 　　/ 　ヽ　　　 　 / 　ヽ
　   　＿＿＿＿＿＿ / 　 　 ヽ＿＿/　 　 　ヽ
　   　|　＿＿＿＿／　　　 　 　 　　   :::::::::＼
  　　| |　　　　 / ／　　　　　　＼ 　 　::::::::::::|
　 　| |　QQ　　　| （ ●）　　　 （●）  　 ::::::::::::|
　　| |191965461 |　 　　　 　　　　  　:::::::::::::|    本人一代码菜逼
　　| |　　　　 　|　 　（__人__丿   　.....:::::::::::::/   1998生
   | |＿＿＿＿　ヽ　　　　　    .....::::::::::::::::::::<    宅
　 └＿＿＿／￣￣　　　　　　    　:::::::::::::::::::::::::|  欢迎勾搭
　　|＼　　　 |　　　　　　　　　　　　:::::::::::::::::::::|
　　＼ ＼　　＼＿＿＿　　　　 　　 ::::::::::::::::::::::::|

-->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>消息队列| kafka中间件原理 &amp;&amp; 知识点 | 🎉 Missionary&#39;s Blog 😆 | Missionary 中国 👋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="消息队列,kafka,技术,原理">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">

    
        <link rel="stylesheet" href="/css/third-party/gitment.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","app_key":"CGsuOukhiIkc4nE75fKtUtXy","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","appkey":"CGsuOukhiIkc4nE75fKtUtXy","notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar","highlight":true}'),
            g: JSON.parse('{"enable":true,"lazy":true,"owner":"missionOdd","repo":"FAQ","oauth":{"client_id":"3dffefee0452a0a23205","client_secret":"1b1394230850e312a0a178bdd41c4e70893d759f"},"perPage":6}'),
            d: JSON.parse('{"app_id":"8997440a"}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
        <script type="text/javascript" src="/js/plugins/daovoice.js?v=1.4.4"></script>
    

<link rel="alternate" href="/atom.xml" title="🎉 Missionary's Blog 😆" type="application/atom+xml">
</head>

<script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/css/mdui.min.css">
<link rel="stylesheet"  href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
<link rel="stylesheet" href="/css/custom.css?v=1.4.4">
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.css" rel="stylesheet">
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.css" rel="stylesheet">

<body>
    <div id="loading" class="active mdui-progress">
  <div class="mdui-progress-determinate"></div>
</div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light rubberBand ">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Missionary</h5>
          <a href="mailto:z1165996866@hotmail.com" title="z1165996866@hotmail.com" class="mail">
            
              <span>z</span>
            
              <span>1</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>5</span>
            
              <span>9</span>
            
              <span>9</span>
            
              <span>6</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>h</span>
            
              <span>o</span>
            
              <span>t</span>
            
              <span>m</span>
            
              <span>a</span>
            
              <span>i</span>
            
              <span>l</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
          <a href="/atom.xml" rel="alternate" class="mdui-btn mdui-btn-dense mdui-color-theme-accent mdui-ripple">
              <i class="fa fa-rss"></i>
              RSS订阅
            </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/missionOdd" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://leetcode-cn.com/u/missionary" target="_blank">
                  <i class="icon icon-lg icon-gg-circle"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/" >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/photos" >
                <i class="icon icon-lg icon-camera"></i>
                PHOTOS
              </a>
            </li>
        
            <li class="">
              <a href="/books" >
                <i class="icon icon-lg icon-book"></i>
                BOOKS
              </a>
            </li>
        
            <li class="">
              <a href="/categories" >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags" >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives" >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about" >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/missionOdd" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                GITHUB
              </a>
            </li>
        
            <li class="">
              <a href="https://leetcode-cn.com/u/missionary/" target="_blank">
                <i class="icon icon-lg icon-gg-circle"></i>
                LEETCODE
              </a>
            </li>
        
            <li class="">
              <a href="http://weibo.com/missionodd" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                WEIBO
              </a>
            </li>
        
            <li class="">
              <a href="/custom" >
                <i class="icon icon-lg icon-plus-square"></i>
                LINKS
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>消息队列| kafka中间件原理 &amp;&amp; 知识点</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title animated tada delay-5s">消息队列| kafka中间件原理 &amp;&amp; 知识点</h1>
        <h5 class="subtitle animated swing delay-5s">
            
                <time datetime="2021-12-08T05:50:37.000Z" itemprop="datePublished" class="page-time">
  2021-12-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/中间件/">中间件</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/中间件/技术/">技术</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>



<div class="container body-wrap">
    <article id="post-kafka-notes"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">消息队列| kafka中间件原理 && 知识点</h1>
        <div class="post-meta">
          
            <time class="post-time" title="2021-12-08 13:50:37" datetime="2021-12-08T05:50:37.000Z"  itemprop="datePublished">2021-12-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/中间件/">中间件</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/中间件/技术/">技术</a></li></ul></li></ul>



            

            
<span class="post-comments-counter" id="/2021/12/08/kafka-notes/">
    <span class="post-meta-item-icon">
        <i class="icon icon-comment-o"></i>
    </span>
    
    <a href="/2021/12/08/kafka-notes/#gitment-display-button" onclick="ShowGitment()">
        <span class="post-comments-count gitment-comments-count" itemprop="commentsCount"></span>
    </a>
</span>



    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2021/12/08/kafka-notes/#comment">
            <span class="valine-comment-count" data-xid="/2021/12/08/kafka-notes/"></span>
        </a>
    </span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>首先了解一下使用分布式消息队列的优点，总结主要包括以下几个方面：</p>
<ul>
<li><p>解耦 tags: None</p>
<p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
</li>
<li><p>冗余</p>
<p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
</li>
<li><p>扩展性</p>
<p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
</li>
<li><p>灵活性 &amp; 峰值处理能力</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
</li>
<li><p>可恢复性</p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
</li>
<li><p>顺序保证</p>
<p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。［Kafka保证一个Partition内的消息的有序性；nsq不保证消息的顺序性］</p>
</li>
<li><p>缓冲</p>
<p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p>
</li>
<li><p>异步通信<br>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
</li>
</ul>
<p>不同的Message Queue各具特色，此处以nsq和kafka这两种平台为例，做简要介绍</p>
<h3 id="NSQ"><a href="#NSQ" class="headerlink" title="NSQ"></a>NSQ</h3><p>NSQ是基于Go语言开发的实时的分布式消息平台，具有分布式和去中心化拓扑结构，该结构具有无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。</p>
<p>四个重要组件：</p>
<ul>
<li>nsqd：一个负责接收、排队、转发消息到客户端的守护进程</li>
<li>nsqlookupd：管理拓扑信息并提供最终一致性的发现服务的守护进程</li>
<li>nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行各种各样的管理任务</li>
<li>utilities：常见基础功能、数据流处理工具，如nsq_stat、nsq_tail、nsq_to_file、nsq_to_http、nsq_to_nsq、to_nsq</li>
</ul>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul>
<li>支持无 SPOF 的分布式拓扑</li>
<li>水平扩展(没有中间件，无缝地添加更多的节点到集群)</li>
<li>低延迟消息传递 (性能)</li>
<li>结合负载均衡和多播消息路由</li>
<li>擅长面向流(高吞吐量)和任务(低吞吐量)工作负载</li>
<li>主要是内存中(除了高水位线消息透明地保存在磁盘上)</li>
<li>运行时为消费者提供发现生产者的服务(nsqlookupd)</li>
<li>传输层安全性 (TLS)</li>
<li>数据格式不可知</li>
<li>较少依赖(容易部署)和健全的、有界、默认配置</li>
<li>简单 TCP 协议，可以支持任何语言的客户端库</li>
<li>HTTP 接口统计、管理行为和生产者(不需要客户端库发布)</li>
<li>集成了statsd来实现实时检测</li>
<li>健壮的集群管理界面 (nsqadmin)</li>
</ul>
<h4 id="担保："><a href="#担保：" class="headerlink" title="担保："></a>担保：</h4><ul>
<li>支持消息内存队列的大小设置，默认完全持久化（值为0），消息即可持久到磁盘也可以保存在内存中</li>
<li>保证消息至少传递一次,以确保消息可以最终成功发送</li>
<li>收到的消息是无序的, 实现了松散订购</li>
<li>发现服务nsqlookupd具有最终一致性,消息最终能够找到所有Topic生产者</li>
</ul>
<h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><p>NSQ中的数据流模型是由stream和consumer组成。Topic是一种独特的stream，Channel是一个订阅了给定Topic的consumer逻辑分组。NSQ的数据流模型结构如下图所示：</p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="uigd95fik9.gif" title="uigd95fik9" data-fancybox="images"><img src="uigd95fik9.gif" alt="uigd95fik9" title class></a>
                <p>uigd95fik9</p>
            </figure>
<p>从上图可以看出，单个nsqd可以有多个Topic，每个Topic又可以有多个Channel。</p>
<p>Channel能够接收Topic所有消息的副本，从而实现了消息多播分发；</p>
<p>而Channel上的每个消息被分发给它的订阅者，从而实现负载均衡，所有这些就组成了一个可以表示各种简单和复杂拓扑结构的强大框架。</p>
<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><h4 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h4><ul>
<li>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li>
<li>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。</li>
<li>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。</li>
<li>同时支持离线数据处理和实时数据处理。</li>
<li>Scale out：支持在线水平扩展。</li>
</ul>
<h4 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h4><ul>
<li>Broker：Kafka集群包含一个或多个服务器，这种服务器被称为broker</li>
<li>Topic：每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>Partition：Parition是物理上的概念，每个Topic包含一个或多个Partition.</li>
<li>Producer：负责发布消息到Kafka broker</li>
<li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li>
<li>Consumer Group：每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</li>
</ul>
<h4 id="Kafka拓扑结构"><a href="#Kafka拓扑结构" class="headerlink" title="Kafka拓扑结构"></a>Kafka拓扑结构</h4><figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="1025005-20160924125839231-370630847.png" title="kafka架构图" data-fancybox="images"><img src="1025005-20160924125839231-370630847.png" alt="kafka架构图" title class></a>
                <p>kafka架构图</p>
            </figure>
<p>如上图所示，一个典型的Kafka集群中包含若干Producer（可以是web前端产生的Page View，或者是服务器日志，系统CPU、Memory等），若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。</p>
<h4 id="Topic-amp-Partition"><a href="#Topic-amp-Partition" class="headerlink" title="Topic &amp; Partition"></a>Topic &amp; Partition</h4><p>Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。</p>
<h4 id="Producer消息路由"><a href="#Producer消息路由" class="headerlink" title="Producer消息路由"></a>Producer消息路由</h4><p>Producer发送消息到broker时，会根据Paritition机制选择将其存储到哪一个Partition。如果Partition机制设置合理，所有消息可以均匀分布到不同的Partition里，这样就实现了负载均衡。</p>
<p>在发送一条消息时，可以指定这条消息的key，Producer根据这个key和Partition机制来判断应该将这条消息发送到哪个Parition。</p>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><p>（本节所有描述都是基于Consumer hight level API而非low level API）。</p>
<p>使用Consumer high level API时，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="70.png" title="img" data-fancybox="images"><img src="70.png" alt="img" title class></a>
                <p>img</p>
            </figure>
<p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p>
<h3 id="NSQ-vs-Kafka"><a href="#NSQ-vs-Kafka" class="headerlink" title="NSQ vs Kafka"></a>NSQ vs Kafka</h3><table>
<thead>
<tr>
<th></th>
<th>NSQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>语言</td>
<td>Go</td>
<td>Scala</td>
</tr>
<tr>
<td>消息存储</td>
<td>内存&amp;&amp;磁盘</td>
<td>磁盘，文件方式</td>
</tr>
<tr>
<td>顺序保证</td>
<td>无序，松散订阅</td>
<td>保证有序</td>
</tr>
</tbody>
</table>
<p>至于在实际应用中，两种消息队列如何选择，要根据业务需求和消息队列的特性做出合理选择。以“问答”服务端为例，目前NSQ和Kafka两种消息队列都在使用中：</p>
<p>比如对用户行为进行统计的相关消息，我们采用nsq，主要是因为nsq消息主要保存在内存，它在处理消息上更快；并且统计用户行为的消息，只需要对消息事件记录即可，并不要求严格的顺序。</p>
<p>而对于提交类的事件，就需要保证严格的顺序性。比如用户提交一个答案，随后又立刻删除；由于后台和data相关业务方是根据发送的消息作相关处理，如果删除答案的消息先发送，后台和data相关业务方将会出现错误；对于此类需要严格保证消息顺序的事件，我们就采用kafka。</p>
<hr>
<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h1><h2 id="KafkaServer"><a href="#KafkaServer" class="headerlink" title="KafkaServer"></a>KafkaServer</h2><p>使用消息队列的主要好处有：</p>
<ul>
<li>解耦</li>
<li>峰值处理能力、异步</li>
<li>持久化</li>
<li>顺序保证</li>
<li>扩展性</li>
</ul>
<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><strong>Broker：</strong></p>
<p>Kafka集群中的一台服务器。</p>
<p><strong>Topic：</strong></p>
<p>主题。消息的分类，是逻辑上的概念，实际以partition的形式存放在各Broker服务器上。</p>
<p><strong>Partition：</strong></p>
<ul>
<li>分区。是物理上的概念，组成Topic的单位。</li>
</ul>
<p><strong>Replica：</strong></p>
<p>副本。是具体的分区，比Partition更具体的物理概念，一个真实的目录，存放在一台Broker服务器上。在代码中又分为leader和follower。</p>
<p><strong>Producer：</strong></p>
<ul>
<li>生产者。负责发送消息到Broker。</li>
</ul>
<p><strong>Consumer：</strong></p>
<ul>
<li>消费者。负责订阅Topic并拉取消息。</li>
</ul>
<p><strong>CousumerGroup：</strong></p>
<p>消费者组。每条消息只被组内成员消费一次。</p>
<h3 id="1-2-逻辑架构"><a href="#1-2-逻辑架构" class="headerlink" title="1.2 逻辑架构"></a>1.2 逻辑架构</h3><figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="60af40353a110cbc9948067b4502a75d.png" title="image" data-fancybox="images"><img src="60af40353a110cbc9948067b4502a75d.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<h3 id="1-3-物理架构"><a href="#1-3-物理架构" class="headerlink" title="1.3 物理架构"></a>1.3 物理架构</h3><h4 id="1-3-1-集群物理架构"><a href="#1-3-1-集群物理架构" class="headerlink" title="1.3.1 集群物理架构"></a>1.3.1 集群物理架构</h4><ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="0993d208eeb5dfe12a9e6f132e9d0eef.png" title="image" data-fancybox="images"><img src="0993d208eeb5dfe12a9e6f132e9d0eef.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<p>如上图，本集群有：</p>
<ul>
<li>4台broker。broker_1 到 broker_4</li>
<li>2个topic。topic_A和topic_B</li>
<li>topic_A的分区数是4。topicA_0 到 topic_3</li>
<li>topic_A的副本因子是2。例如topicA_0这个分区，有两个副本，分别分布在broker_1和broker_3两台机器上。</li>
</ul>
<h4 id="1-3-2-一个副本目录结构"><a href="#1-3-2-一个副本目录结构" class="headerlink" title="1.3.2 一个副本目录结构"></a>1.3.2 一个副本目录结构</h4><p>上图中的topicA-0是一个partition，准确的说应该称之为一个副本，即Replica。它是broker_1服务器上的一个日志目录，其内部由多个segment文件组成。topicA-0目录结构：</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="15917459e5a10f3a6839bc535f0afbc6.png" title="image" data-fancybox="images"><img src="15917459e5a10f3a6839bc535f0afbc6.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<p><strong>*.log文件</strong>：日志文件</p>
<p><strong>*.index文件</strong>：稀疏索引文件</p>
<p><strong>*.timeindex文件</strong>：时间戳索引文件。根据时间戳快速定位消息所在位置。（Kafka API offsetsForTimes方法所使用）</p>
<p>index文件与log文件关系:</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="42a9581fb80035875abcaff0e6902542.png" title="image" data-fancybox="images"><img src="42a9581fb80035875abcaff0e6902542.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<h3 id="1-4-代码架构"><a href="#1-4-代码架构" class="headerlink" title="1.4 代码架构"></a>1.4 代码架构</h3><h4 id="1-4-1-线程池"><a href="#1-4-1-线程池" class="headerlink" title="1.4.1 线程池"></a>1.4.1 线程池</h4><p>KafkaServer在启动时，初始化KafkaRequestHandlerPool线程池</p>
<p>KafkaRequestHandlerPool（线程池）由KafkaRequestHandler组成</p>
<p>KafkaRequestHandler调用KafkaApis处理request</p>
<p>下图：Kafka处理request的线程池</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="83fbd9155e52d987bb704a028f719772.png" title="image" data-fancybox="images"><img src="83fbd9155e52d987bb704a028f719772.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<p>kafkaServer接收的请求，包括来自客户端的请求和来自其他server的请求。客户端请求例如producer发送消息请求、consumer消费消息请求。其他broker请求例如副本同步日志请求。请求类型有21个枚举值。</p>
<p>所有的请求最终会收敛到Broker服务器上的KafkaApis.handle方法，如下图：</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="9fb206ff88bb93e7d92cf7dced0e540b.png" title="image" data-fancybox="images"><img src="9fb206ff88bb93e7d92cf7dced0e540b.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<h4 id="1-4-2-处理request的组件"><a href="#1-4-2-处理request的组件" class="headerlink" title="1.4.2 处理request的组件"></a>1.4.2 处理request的组件</h4><p>有3个重要组件处理上图21种请求，它们分别是：</p>
<ul>
<li><strong>ReplicaManager</strong><ul>
<li>把Produce日志写入磁盘</li>
<li>如果副本是follower，启动副本同步线程，发送fetch请求</li>
<li>如果副本是leader，处理来自副本的fetch请求</li>
</ul>
</li>
<li><strong>Coordinator</strong><ul>
<li>管理Consumer的balance</li>
</ul>
</li>
<li><strong>KafkaController</strong><ul>
<li>Broker 的上线、下线</li>
<li>新建 topic 或已有 topic 的扩容，topic 删除</li>
<li>处理replica的分配、迁移、leader 选举、leader 切换</li>
</ul>
</li>
</ul>
<p>下图：处理request请求</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="d85330c319388dddad5de8b90e743c9a.png" title="image" data-fancybox="images"><img src="d85330c319388dddad5de8b90e743c9a.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<h2 id="2-可用性、可靠性保障"><a href="#2-可用性、可靠性保障" class="headerlink" title="2. 可用性、可靠性保障"></a>2. 可用性、可靠性保障</h2><h3 id="2-1-集群高可用性"><a href="#2-1-集群高可用性" class="headerlink" title="2.1 集群高可用性"></a>2.1 集群高可用性</h3><p>在应对单点故障时，kafka仍然能够对外提供服务，主要通过以下特性保证：</p>
<ul>
<li>分布式集群模式，多台服务器，分散单服务器压力。</li>
<li>一个topic拆分成多partition分区</li>
<li>一个partition建立n个副本，分为leader和follower，保持同步。leader一旦宕机从follower选举出新的leader提供读写日志服务。</li>
</ul>
<h3 id="2-2-消息可靠性与一致性"><a href="#2-2-消息可靠性与一致性" class="headerlink" title="2.2 消息可靠性与一致性"></a><strong>2.2 消息可靠性与一致性</strong></h3><p>面对故障时是否仍然保持最终一致。</p>
<ul>
<li>producer.ACKS = [ -1, 0, 1] 保证日志生产的准确性。</li>
<li>HW和LEO机制。保证日志同步的准确性。</li>
</ul>
<h4 id="2-2-1-producer-ACKs"><a href="#2-2-1-producer-ACKs" class="headerlink" title="2.2.1 producer.ACKs"></a>2.2.1 producer.ACKs</h4><p><strong>ACKs=1</strong></p>
<ul>
<li>producer发送日志，只要Leader写入成功，则返回producer成功</li>
</ul>
<p><strong>ACKs=0</strong></p>
<ul>
<li>producer发送日志，不需要等待leader返回成功</li>
<li>传输效率最高，可靠性最差</li>
</ul>
<p><strong>ACKs=-1</strong></p>
<ul>
<li>producer发送日志，Leader需要等待ISR中所有的Replica同步完成后，才返回给客户端成功</li>
<li>可靠性最高，效率最差。集群的瓶颈卡在了最差的那台机器</li>
</ul>
<h4 id="2-2-2-HW和LEO"><a href="#2-2-2-HW和LEO" class="headerlink" title="2.2.2 HW和LEO"></a>2.2.2 HW和LEO</h4><p><strong>LEO</strong></p>
<ul>
<li>LogEndOffset，日志末端偏移量</li>
<li>每个Replica最后一条log所在的位置</li>
</ul>
<p><strong>HW</strong></p>
<ul>
<li>HighWaterMark，高水位</li>
<li>HW = min( ISR.LEO )</li>
<li>已经被ISR完成同步的消息的位置</li>
<li>Consumer最多只能消费到HW所在的位置</li>
<li>对于内部Replica的同步消息请求，没有HW的限制</li>
</ul>
<p>如下图，HW与LEO位置示意：</p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="b9466c871eb1de0157d41377cd06d94a.png" title="image" data-fancybox="images"><img src="b9466c871eb1de0157d41377cd06d94a.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<p><strong>HW与LEO更新过程：</strong></p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="d64eb94018321663dfe38c6ea278bbde.png" title="image" data-fancybox="images"><img src="d64eb94018321663dfe38c6ea278bbde.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<p><strong>HW与LEO更新过程（详细）：</strong></p>
<p>HW与LEO存在于每一个副本，并不仅仅存在于leader。</p>
<p>leader中维护了两套LEO，一套是自己的，另一套是follower的。</p>
<p>假设目前消息队列为空，follower启动的同步消息线程，不会获取到任何消息，也不会更新HW和LEO</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/ec19a2cae1dc96baef8fe646f758b97a.png" title="image" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/ec19a2cae1dc96baef8fe646f758b97a.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<p>此时，Producer给leader发送了一条日志</p>
<ol>
<li>leader的LEO + 1</li>
<li>leader尝试更新HW，HW = min(LEO)，仍然是0</li>
</ol>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/219fab4d24791360c434d96ad75c71e8.png" title="image" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/mafulong/mdPic@master/images/219fab4d24791360c434d96ad75c71e8.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<p>follower发送fetch请求：</p>
<ul>
<li>*<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="65578cc63bfff21a8529caed7fd904ff.png" title="image" data-fancybox="images"><img src="65578cc63bfff21a8529caed7fd904ff.png" alt="image" title class></a>
                <p>image</p>
            </figure></li>
</ul>
<ol>
<li>req的offset参数是0，表示从第0个消息开始fetch</li>
<li>leader更新remote LEO=0，这是因为follower request的offset是0</li>
<li>leader尝试更新HW，HW = min(LEO)，仍然是0</li>
<li>leader把数据和此时的leader HW返回给follower</li>
<li>follower接收到respsonse，更新LEO=1，更新HW仍然是0</li>
</ol>
<p>follower发送第二轮fetch请求:</p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="a730c7a7e7b6ea34fa9d3a71e1911f57.png" title="image" data-fancybox="images"><img src="a730c7a7e7b6ea34fa9d3a71e1911f57.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<ol>
<li>req的offset参数是1，表示请求同步第一个消息</li>
<li>leader更新remote LEO=1，因为follower request的offset是1</li>
<li>leader尝试更新HW，HW=min(LEO)，<strong>此时更新HW=1</strong></li>
<li>leader把数据和此时的leader HW返回给follower</li>
<li>follower接收到respsonse，更新HW，<strong>此时更新HW=1</strong></li>
</ol>
<p>至此，producer生产的消息已经保存到kafka的各个副本上了，Consumer已经可以消费到HW位置了。</p>
<p>一个消息从写入kafka到完成更新HW，需要follower发送两轮fetch请求。 第一轮fetch是follow告诉leader自己的leo, 以及更新offset以及leo. 第二轮fetch是告诉producer自己最新的leo用于leader更新hw.</p>
<h2 id="3-常见的选举、分配、Rebalance"><a href="#3-常见的选举、分配、Rebalance" class="headerlink" title="3. 常见的选举、分配、Rebalance"></a>3. 常见的选举、分配、Rebalance</h2><p>Kafka集群依赖Zookeeper，Zookeeper的数据模型是一棵树，kafka的组件把回调函数注册到zk树节点下，在节点发生变更时，zk通过回调通知kafka。</p>
<h3 id="3-1-Controller选举"><a href="#3-1-Controller选举" class="headerlink" title="3.1 Controller选举"></a>3.1 Controller选举</h3><p>KafkaController的选举过程比较简单，所有的broker启动时，抢占注册Zookeeper的/Controller节点，注册成功即成为Controller。伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def elect: Boolean = &#123;</span><br><span class="line">    leaderId = getControllerID   // 查询当前集群ControllerId</span><br><span class="line"></span><br><span class="line">    if(leaderId != -1) &#123;  // Controller早已存在了</span><br><span class="line">       return amILeader</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        zkCheckedEphemeral.create()  // 注册到zookeeper leader节点</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        case _: ZkNodeExistsException =&gt;   // leader被别人注册，抛异常</span><br><span class="line">        leaderId = getControllerID</span><br><span class="line">    &#125;</span><br><span class="line">    return amILeader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Consumer启动触发Rebalance"><a href="#3-2-Consumer启动触发Rebalance" class="headerlink" title="3.2 Consumer启动触发Rebalance"></a>3.2 Consumer启动触发Rebalance</h3><p>由于Broker数量通常不会很多，所以Controller选举采用抢占注册的方式不会给zookeeper带来很大压力。</p>
<p>但是对于Consumer而言，一个大的Topic可能对应创建了数量庞大的Consumer，Kafka老版本也确实是这么实现的，这种情况下，存在两个问题：</p>
<ul>
<li>羊群效应：任何一个Consumer的增减都会触发所有Consumer的Rebalance</li>
<li>脑裂效应：每个Consumer分别单独通过Zookeeper判断哪些Consumer 宕机了，那么不同Consumer在同一时刻从Zookeeper看到的视角就可能不一样。这就会造成不正确的Reblance尝试。</li>
</ul>
<p>新版本的Kafka对此做了优化，使用了“协调员”这一角色，作为“权威”“指挥”Consumer Rebalance</p>
<p>新版本，Consumer启动过程如下：</p>
<figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="5849ad51359fe5c181c7c4673b8f6da8.png" title="image" data-fancybox="images"><img src="5849ad51359fe5c181c7c4673b8f6da8.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<ol>
<li>Consumer启动，向任意一台broker发送请求，得到响应。响应内容为“协调员的地址”。</li>
<li>Consumer找到自己的Coordinator，<strong>持续</strong>发送心跳请求</li>
<li>Consumer判断心跳请求的响应的ErrorCode，如果没有异常则消费数据。如果有IllegalGeneration异常，说明Coordinator正在计算rebalance，统一给Consumer分配Partition。</li>
<li>Consumer给Coordinator发送JonGroup请求，得到响应，得知自己被分配了哪个Partition，连接那个partition进行消费。</li>
</ol>
<h3 id="3-3-Leader-Replica宕机触发Rebalance"><a href="#3-3-Leader-Replica宕机触发Rebalance" class="headerlink" title="3.3 Leader Replica宕机触发Rebalance"></a>3.3 Leader Replica宕机触发Rebalance</h3><figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="c981ddff865953bf37066940aa92cc28.png" title="image" data-fancybox="images"><img src="c981ddff865953bf37066940aa92cc28.png" alt="image" title class></a>
                <p>image</p>
            </figure>
<p>图：broker宕机触发replica选举</p>
<p>Replica分布在broker上，Replica leader掉线其实就是leader所在的broker的宕机，从宕机到集群恢复稳定态过程：</p>
<ol>
<li>Broker启动，在zookeeper的broker/ids路径注册临时节点</li>
<li>Controller启动，注册watcher函数，监听zookeeper上述路径的节点变化</li>
<li>Broker因为网络、断电、机器故障等原因宕机</li>
<li>zookeeper监听到broker节点掉线，触发controller注册的watcher，通过回调函数通知Controller</li>
<li>Controller决定一个set_p集合，包含宕机broker上的所有partition</li>
<li>对于上述的partition，Controller从/brokers/topics/[topic]/partitions/[partition]/state读取该 Partition 当前的 ISR</li>
<li>Controller从上述ISR中选出Leader。选举算法是quorum（法定人数）算法，通过数据冗余来保证数据一致性的投票算法。对于Kafka而言，选举人数就是ISR。</li>
<li>Controller将新的 Leader、ISR 和新的leader_epoch及controller_epoch写入/brokers/topics/[topic]/partitions/[partition]/state</li>
<li>向set_p相关的broker发送LeaderAndIsrRequest通知受影响的broker更新信息</li>
</ol>
<h3 id="3-4-topic分配到broker"><a href="#3-4-topic分配到broker" class="headerlink" title="3.4 topic分配到broker"></a>3.4 topic分配到broker</h3><ol>
<li>用户调用脚本创建topic，指定分区数和副本数</li>
<li>Controller接收CreateTopic请求，计算broker与partition的对应关系</li>
<li>Controller向Broker发送LeaderAndIsr请求，通知Broker有了新的Topic，各broker负责创建Partition</li>
</ol>
<p>副本分配算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* To achieve this goal for replica assignment without considering racks, we:</span><br><span class="line">* 1. Assign the first replica of each partition by round-robin, starting from a random position in the broker list.</span><br><span class="line">* 2. Assign the remaining replicas of each partition with an increasing shift.</span><br><span class="line">*</span><br><span class="line">* Here is an example of assigning</span><br><span class="line">* broker-0  broker-1  broker-2  broker-3  broker-4</span><br><span class="line">* p0        p1        p2        p3        p4       (1st replica)</span><br><span class="line">* p5        p6        p7        p8        p9       (1st replica)</span><br><span class="line">* p4        p0        p1        p2        p3       (2nd replica)</span><br><span class="line">* p8        p9        p5        p6        p7       (2nd replica)</span><br><span class="line">* p3        p4        p0        p1        p2       (3nd replica)</span><br><span class="line">* p7        p8        p9        p5        p6       (3nd replica)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul>
<li><p>kafka使用tcp, io多路复用即信号驱动io, 生产者有同步和异步2种类型</p>
</li>
<li><p>选择由producer向broker push消息并由consumer从broker pull消息。</p>
</li>
<li><p>kafka和nsq对比：</p>
<ul>
<li>kafka是pull，有序，吞吐高；nsq消息是无序的，吞吐低，有requeue和defer功能，不持久化，不可回溯，pull，用内存，所以速度快。</li>
</ul>
</li>
<li><p>kafka数据可靠性和重复消费</p>
<ol>
<li>需要消费者操作幂等，来保证重复消费无影响</li>
<li>处理后提交commit，保证消息被消费到，事务保证</li>
<li>生产者生产消息失败时，报error。</li>
<li>如果要保证有序，让消息到1个partition就行了，partition内部消费是有序的</li>
</ol>
</li>
<li><p>kafka基于zk.</p>
</li>
<li><p>kafka是发布-订阅模型。</p>
</li>
<li><p>Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到/brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>……</li>
</ol>
</li>
<li><p>ISR:In-Sync Replicas 副本同步队列 AR:Assigned Replicas 所有副本</p>
<p>HW:High Watermark 高水位，取一个partition对应的ISR中最小的LEO作为HW，consumer最多只能消费到HW所在的位置上一条信息。</p>
<p>LEO:LogEndOffset 当前日志文件中下一条待写信息的offset</p>
<p>HW/LEO这两个都是指最后一条的下一条的位置而不是指最后一条的位置。</p>
<p>LSO:Last Stable Offset 对未完成的事务而言，LSO 的值等于事务中第一条消息的位置(firstUnstableOffset)，对已完成的事务而言，它的值同 HW 相同</p>
<p>LW:Low Watermark 低水位, 代表 AR 集合中最小的 logStartOffset 值</p>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul>
<li><a href="https://juejin.cn/post/6844903889003610119" target="_blank" rel="noopener">kafka面试题</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/message-queue/Kafka常见面试题总结.md">kafka面试题2</a></li>
<li><a href="http://trumandu.github.io/2019/04/13/Kafka面试题与答案全套整理/" target="_blank" rel="noopener">整理，答案不全的</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1541215" target="_blank" rel="noopener">面试题3</a></li>
</ul>
<h2 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h2><ul>
<li><p>控制器是如何被选出来的？</p>
<ul>
<li><p>你一定很想知道，控制器是如何被选出来的呢？我们刚刚在前面说过，每台 Broker 都能充当控制器，那么，当集群启动后，Kafka 怎么确认控制器位于哪台 Broker 呢？</p>
<p>实际上，Broker 在启动时，会尝试去 ZooKeeper 中创建 /controller 节点。Kafka 当前选举控制器的规则是：第一个成功创建 /controller 节点的 Broker 会被指定为控制器。</p>
</li>
</ul>
</li>
<li><p>控制器是做什么的？</p>
<ul>
<li><p>1.主题管理（创建、删除、增加分区）</p>
<p>2.分区重分配</p>
<p>3.Preferred 领导者选举</p>
<p>4.集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）</p>
<p>5.数据服务</p>
</li>
</ul>
</li>
<li><p>保存的数据：</p>
</li>
<li><figure class="image-box">
                <a rel=消息队列| kafka中间件原理 && 知识点 href="20210523170815.png" title="image-20210523170815843" data-fancybox="images"><img src="20210523170815.png" alt="image-20210523170815843" title class></a>
                <p>image-20210523170815843</p>
            </figure>
</li>
</ul>
<h2 id="consumer管理offset"><a href="#consumer管理offset" class="headerlink" title="consumer管理offset"></a>consumer管理offset</h2><p><strong>kafka内部有个主题，__consumer_offset</strong></p>
<p>老版本 Consumer 的位移管理是依托于 Apache ZooKeeper 的，它会自动或手动地将位移数据提交到 ZooKeeper 中保存。当 Consumer 重启后，它能自动从 ZooKeeper 中读取位移数据，从而在上次消费截止的地方继续消费。这种设计使得 Kafka Broker 不需要保存位移数据，减少了 Broker 端需要持有的状态空间，因而有利于实现高伸缩性。</p>
<p>但是，ZooKeeper 其实并不适用于这种高频的写操作，因此，Kafka 社区自 0.8.2.x 版本开始，就在酝酿修改这种设计，并最终在新版本 Consumer 中正式推出了全新的位移管理机制，自然也包括这个新的位移主题。</p>
<p>新版本 Consumer 的位移管理机制其实也很简单，就是将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 <strong>consumer_offsets 中。可以这么说，</strong>consumer_offsets 的主要作用是保存 Kafka 消费者的位移信息。它要求这个提交过程不仅要实现高持久性，还要支持高频的写操作。显然，Kafka 的主题设计天然就满足这两个条件，因此，使用 Kafka 主题来保存位移这件事情，实际上就是一个水到渠成的想法了。</p>
<p>位移主题的 Key 中应该保存 3 部分内容：gourpId, topic, partitionId</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2022-02-16T10:35:53.269Z" itemprop="dateUpdated">2022-02-16 18:35:53</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2021/12/08/kafka-notes/" target="_blank" rel="external">https://github.com/missionOdd/2021/12/08/kafka-notes/</a>
        
    </div>
    <div class="mdui-chip" id="accost-btn">
      <span class="mdui-chip-icon mdui-color-red-a700"><i class="mdui-icon material-icons">&#xe311;</i></span>
      <span class="mdui-chip-title">Accost</span>
    </div>
    <footer>
      <div class="mdui-chip">
        <a href="https://github.com/missionOdd">
            <img src="/img/avatar.jpg" alt="Missionary">
             About Missionary
        </a>
        </div>
    </footer>
</blockquote>


        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/">kafka</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/消息队列/">消息队列</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2021/12/08/kafka-notes/&title=《消息队列| kafka中间件原理 && 知识点》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2021/12/08/kafka-notes/&title=《消息队列| kafka中间件原理 && 知识点》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            <div class="mdui-container">
  <div class="mdui-tab" id="tab">
    <a href="#tab1-content" id="tab1" class="mdui-ripple">游客用户</a>
    <a href="#tab2-content" id="tab2" class="mdui-tab-active mdui-ripple">GitHub账户</a>
  </div>

  <div id="tab1-content" class="mdui-p-a-2">
    
      <div id="comment" style=""></div>

  </div>
  <div id="tab2-content" class="mdui-p-a-2">
    
          
    <div onclick="ShowGitment()" id="gitment-display-button" style="display: block;">
        <span>显示 Gitment 评论</span>
    </div>
    <div id="gitment" class="hide"></div>


    
  </div>

</div>

        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2021/12/10/os-notes/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">操作系统 | 硬核图文讲解</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2021/12/06/tomcat-architecture/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Tomcat架构原理解析到架构设计借鉴</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#消息队列"><span class="post-toc-number">1.</span> <span class="post-toc-text">消息队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NSQ"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">NSQ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#特性："><span class="post-toc-number">1.0.1.1.</span> <span class="post-toc-text">特性：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#担保："><span class="post-toc-number">1.0.1.2.</span> <span class="post-toc-text">担保：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构："><span class="post-toc-number">1.0.1.3.</span> <span class="post-toc-text">结构：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#kafka"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">kafka</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#特性：-1"><span class="post-toc-number">1.0.2.1.</span> <span class="post-toc-text">特性：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kafka架构"><span class="post-toc-number">1.0.2.2.</span> <span class="post-toc-text">Kafka架构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Kafka拓扑结构"><span class="post-toc-number">1.0.2.3.</span> <span class="post-toc-text">Kafka拓扑结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Topic-amp-Partition"><span class="post-toc-number">1.0.2.4.</span> <span class="post-toc-text">Topic &amp; Partition</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Producer消息路由"><span class="post-toc-number">1.0.2.5.</span> <span class="post-toc-text">Producer消息路由</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Consumer-Group"><span class="post-toc-number">1.0.2.6.</span> <span class="post-toc-text">Consumer Group</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#NSQ-vs-Kafka"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">NSQ vs Kafka</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#基础架构"><span class="post-toc-number">2.</span> <span class="post-toc-text">基础架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#KafkaServer"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">KafkaServer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-架构"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">1. 架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-1-概念"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">1.1 概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-2-逻辑架构"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">1.2 逻辑架构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-3-物理架构"><span class="post-toc-number">2.2.3.</span> <span class="post-toc-text">1.3 物理架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-1-集群物理架构"><span class="post-toc-number">2.2.3.1.</span> <span class="post-toc-text">1.3.1 集群物理架构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3-2-一个副本目录结构"><span class="post-toc-number">2.2.3.2.</span> <span class="post-toc-text">1.3.2 一个副本目录结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-4-代码架构"><span class="post-toc-number">2.2.4.</span> <span class="post-toc-text">1.4 代码架构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-4-1-线程池"><span class="post-toc-number">2.2.4.1.</span> <span class="post-toc-text">1.4.1 线程池</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-4-2-处理request的组件"><span class="post-toc-number">2.2.4.2.</span> <span class="post-toc-text">1.4.2 处理request的组件</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-可用性、可靠性保障"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">2. 可用性、可靠性保障</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-1-集群高可用性"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">2.1 集群高可用性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-2-消息可靠性与一致性"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">2.2 消息可靠性与一致性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-1-producer-ACKs"><span class="post-toc-number">2.3.2.1.</span> <span class="post-toc-text">2.2.1 producer.ACKs</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-2-HW和LEO"><span class="post-toc-number">2.3.2.2.</span> <span class="post-toc-text">2.2.2 HW和LEO</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-常见的选举、分配、Rebalance"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">3. 常见的选举、分配、Rebalance</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-1-Controller选举"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">3.1 Controller选举</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-2-Consumer启动触发Rebalance"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">3.2 Consumer启动触发Rebalance</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-3-Leader-Replica宕机触发Rebalance"><span class="post-toc-number">2.4.3.</span> <span class="post-toc-text">3.3 Leader Replica宕机触发Rebalance</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-4-topic分配到broker"><span class="post-toc-number">2.4.4.</span> <span class="post-toc-text">3.4 topic分配到broker</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#知识点"><span class="post-toc-number">3.</span> <span class="post-toc-text">知识点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#面试题"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">面试题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#控制器Controller"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">控制器Controller</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#consumer管理offset"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">consumer管理offset</span></a></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    

</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://github.com/missionOdd" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="mdui-bottom-nav">
  <a href="javascript:;" class="mdui-ripple mdui-bottom-nav-active">
    <i class="mdui-icon material-icons">history</i>
    <label>Recents</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">favorite</i>
    <label>Favorites</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">&#xe80e;</i>
    <label>Hot</label>
  </a>

</div>
    <div class="bottom">
        <p>
            <span>
                Missionary &copy; 2018 - 2022
            </span>
           	
           	<span>
           		<a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备19008953号</a>
           	</span>
           	

            

            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            

            
            <span>
	            Hosted by <a href="https://coding.net/pages" target="_blank">Coding Pages</a>
            </span>
            


        </p>
        <p>
          
              
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>


          
          <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
          <script>
              var now = new Date();
              function createtime() {
                  var grt= new Date("09/15/2018 12:49:00");//此处修改你的建站时间或者网站上线时间
                  now.setTime(now.getTime()+250);
                  days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                  hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                  if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                  mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                  seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                  snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                  document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                  document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
              }
          setInterval("createtime()",250);
          </script>
        </p>
    </div>

</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light mdui-ripple"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2021/12/08/kafka-notes/&title=《消息队列| kafka中间件原理 && 知识点》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2021/12/08/kafka-notes/&title=《消息队列| kafka中间件原理 && 知识点》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3aQY6EMAwFUe5/aUbqbYtQ34ZRJ6msEEKQx8JybB8HXudnfV+TO+dwXT1zvLFkyJAxLYN/5vv5MWP8hvHX+d5kyJCxD6MTZMdv4D+F/KDL+zJkyJCBQyFHpqFZhgwZMvoHV7JpfvaUIUOGjNohthNSOfL1s7gMGTImZHQaA29f/1N/Q4YMGT/MOEuLg0nRjYfXy/3IkCFjacbV6zrB9+ptHMAbpTd1OxkyZCzH6JfA0uQv/e7NzmXIkLEo49lwWSuWdcY4jjeivgwZMn6M0Wkr8lGwTtgtpokyZMhYiME3xwN0GnxJYEU9WBkyZGzAqN1JS288BAdBX4YMGdswaskfD77pjESQPsqQIWNpBg+pJBDXRihqe4gTRBkyZEzOSDdX+3yx8od3IkOGjLUZ/OiYthL5RtPiXZxpypAhY1pGfwCCHHf56Fj6jAwZMnZg9Ae5SIDul9WCnFGGDBnLMUhxnxTUSLmNk9JGqQwZMtZm9AcmeMqYNib5MzJkyNiHQQIuCcc81esMZwRVQxkyZCzESANu53jMk9Gg8SBDhoylGbUNdQDpsbn2vAwZMtZgnOEaNzhrAZTzLn+NDBkylmbUAm5tjbebtgQeSA1lyJAxFaM2YEGQtXSwWPiTIUPGBoz04MpHJZ5K7G54MmTIkIFJ/fJc7Q0yZMiQMW5Apk3KZxNQGTJk7MMgh1j+4VqzIU03ZciQsQ+jP2xBDqUEQ7bbmhyRIUPGfIw/kc+yUMVrezwAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>



    
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/plugins/fireworks.js?v=1.4.4"></script>


    <!-- main-js -->
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?18b812f3375b09bd66be7e3a46d7cc2d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    
        <script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>

    
    
        <script type="text/javascript" src="/js/plugins/gitmint.browser.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/gitment.js?v=1.4.4"></script>
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '等你回来！';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)欢迎!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>




    <script type="text/javascript">
  daovoice('init', {
    app_id: "8997440a"
  });
  daovoice('update');
</script>


    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/custom.js?v=1.4.4"></script>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/js/mdui.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script type="text/javascript">
jQuery.noConflict();     //将变量$的控制权让渡
</script>
<script type="text/javascript" color="213,0,0" opacity='0.7' zIndex="-2" count="60" src="//cdnjs.cloudflare.com/ajax/libs/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<!-- <script type="text/javascript">

jQuery(function($){


});
</script> -->

</body>
</html>

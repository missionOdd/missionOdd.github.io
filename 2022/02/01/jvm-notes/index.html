<!DOCTYPE html>
<html>
<!--
　　　　　　　　  　　　/ヽ　　　　　　/ヽ
　　　　　　 　　 　　/ 　ヽ　　　 　 / 　ヽ
　   　＿＿＿＿＿＿ / 　 　 ヽ＿＿/　 　 　ヽ
　   　|　＿＿＿＿／　　　 　 　 　　   :::::::::＼
  　　| |　　　　 / ／　　　　　　＼ 　 　::::::::::::|
　 　| |　QQ　　　| （ ●）　　　 （●）  　 ::::::::::::|
　　| |191965461 |　 　　　 　　　　  　:::::::::::::|    本人一代码菜逼
　　| |　　　　 　|　 　（__人__丿   　.....:::::::::::::/   1998生
   | |＿＿＿＿　ヽ　　　　　    .....::::::::::::::::::::<    宅
　 └＿＿＿／￣￣　　　　　　    　:::::::::::::::::::::::::|  欢迎勾搭
　　|＼　　　 |　　　　　　　　　　　　:::::::::::::::::::::|
　　＼ ＼　　＼＿＿＿　　　　 　　 ::::::::::::::::::::::::|

-->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>jvm | 虚拟机全面扫盲+深入理解的原创笔记 | 🎉 Missionary&#39;s Blog 😆 | Missionary 中国 👋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="技术,原理,jvm,java">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">

    
        <link rel="stylesheet" href="/css/third-party/gitment.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","app_key":"CGsuOukhiIkc4nE75fKtUtXy","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","appkey":"CGsuOukhiIkc4nE75fKtUtXy","notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar","highlight":true}'),
            g: JSON.parse('{"enable":true,"lazy":true,"owner":"missionOdd","repo":"FAQ","oauth":{"client_id":"3dffefee0452a0a23205","client_secret":"1b1394230850e312a0a178bdd41c4e70893d759f"},"perPage":6}'),
            d: JSON.parse('{"app_id":"8997440a"}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
        <script type="text/javascript" src="/js/plugins/daovoice.js?v=1.4.4"></script>
    

<link rel="alternate" href="/atom.xml" title="🎉 Missionary's Blog 😆" type="application/atom+xml">
</head>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/css/mdui.min.css">
<link rel="stylesheet"  href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
<link rel="stylesheet" href="/css/custom.css?v=1.4.4">
<link href="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.css" rel="stylesheet">
<link href="//cdn.bootcss.com/photoswipe/4.1.2/default-skin/default-skin.css" rel="stylesheet">

<body>
    <div id="loading" class="active mdui-progress">
  <div class="mdui-progress-determinate"></div>
</div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light rubberBand ">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Missionary</h5>
          <a href="mailto:z1165996866@hotmail.com" title="z1165996866@hotmail.com" class="mail">
            
              <span>z</span>
            
              <span>1</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>5</span>
            
              <span>9</span>
            
              <span>9</span>
            
              <span>6</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>h</span>
            
              <span>o</span>
            
              <span>t</span>
            
              <span>m</span>
            
              <span>a</span>
            
              <span>i</span>
            
              <span>l</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
          <a href="/atom.xml" rel="alternate" class="mdui-btn mdui-btn-dense mdui-color-theme-accent mdui-ripple">
              <i class="fa fa-rss"></i>
              RSS订阅
            </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/missionOdd" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://leetcode-cn.com/u/missionary" target="_blank">
                  <i class="icon icon-lg icon-gg-circle"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/" >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/photos" >
                <i class="icon icon-lg icon-camera"></i>
                PHOTOS
              </a>
            </li>
        
            <li class="">
              <a href="/books" >
                <i class="icon icon-lg icon-book"></i>
                BOOKS
              </a>
            </li>
        
            <li class="">
              <a href="/categories" >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags" >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives" >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about" >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/missionOdd" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                GITHUB
              </a>
            </li>
        
            <li class="">
              <a href="http://weibo.com/missionodd" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                WEIBO
              </a>
            </li>
        
            <li class="">
              <a href="/custom" >
                <i class="icon icon-lg icon-plus-square"></i>
                LINKS
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>jvm | 虚拟机全面扫盲+深入理解的原创笔记</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title animated tada delay-5s">jvm | 虚拟机全面扫盲+深入理解的原创笔记</h1>
        <h5 class="subtitle animated swing delay-5s">
            
                <time datetime="2022-02-01T05:50:37.000Z" itemprop="datePublished" class="page-time">
  2022-02-01
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/">jvm</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/技术/">技术</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>



<div class="container body-wrap">
    <article id="post-jvm-notes"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">jvm | 虚拟机全面扫盲+深入理解的原创笔记</h1>
        <div class="post-meta">
          
            <time class="post-time" title="2022-02-01 13:50:37" datetime="2022-02-01T05:50:37.000Z"  itemprop="datePublished">2022-02-01</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/">jvm</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/jvm/技术/">技术</a></li></ul></li></ul>



            

            
<span class="post-comments-counter" id="/2022/02/01/jvm-notes/">
    <span class="post-meta-item-icon">
        <i class="icon icon-comment-o"></i>
    </span>
    
    <a href="/2022/02/01/jvm-notes/#gitment-display-button" onclick="ShowGitment()">
        <span class="post-comments-count gitment-comments-count" itemprop="commentsCount"></span>
    </a>
</span>



    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2022/02/01/jvm-notes/#comment">
            <span class="valine-comment-count" data-xid="/2022/02/01/jvm-notes/"></span>
        </a>
    </span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <p><strong>引言：</strong><br>来源：知识结构来自河北王校长的JVM系列，博主基于视频自写笔记，并补充大量的延伸内容。<br>优点：笔记知识点关联性好，挖得深，延伸多。<br>缺点：缺少JVM与多线程结合的内容，以后会补充上；排版一般</p>
<h1 id="1-class文件"><a href="#1-class文件" class="headerlink" title="1. class文件"></a>1. class文件</h1><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208022707509.png" title="class文件" data-fancybox="images"><img src="image-20220208022707509.png" alt="class文件" title class></a>
                <p>class文件</p>
            </figure>
<p><a href="https://blog.csdn.net/lioncatch/article/details/105919391" target="_blank" rel="noopener">https://blog.csdn.net/lioncatch/article/details/105919391</a></p>
<p><a href="https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1717139924001321921&amp;wfr=spider&amp;for=pc</a></p>
<p>8字节 2进制  Java文件编译之后</p>
<ul>
<li><h3 id="4字节魔数：标志文件类型；视频，照片也有魔数"><a href="#4字节魔数：标志文件类型；视频，照片也有魔数" class="headerlink" title="4字节魔数：标志文件类型；视频，照片也有魔数"></a>4字节魔数：标志文件类型；视频，照片也有魔数</h3></li>
<li><h3 id="次版本号和主版本号：标志JDK版本；兼容低版本问题"><a href="#次版本号和主版本号：标志JDK版本；兼容低版本问题" class="headerlink" title="次版本号和主版本号：标志JDK版本；兼容低版本问题"></a>次版本号和主版本号：标志JDK版本；兼容低版本问题</h3></li>
<li><h3 id="常量池计数器：记录后面常量池的常量（数据项）个数；※"><a href="#常量池计数器：记录后面常量池的常量（数据项）个数；※" class="headerlink" title="常量池计数器：记录后面常量池的常量（数据项）个数；※"></a>常量池计数器：记录后面常量池的常量（数据项）个数；※</h3></li>
<li><h3 id="常量池：字面量-符号引用"><a href="#常量池：字面量-符号引用" class="headerlink" title="常量池：字面量+符号引用"></a>常量池：字面量+符号引用</h3><p> 1.字面量：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值。<br> 2.符号引用<br>   package名字，权限命名，字段名称，方法名称，字段描述符，方法描述符，方法句柄，方法类型，动态调用点和动态常量（不了解）<br>   <strong>一句话：这部分就是常量池，装载了全部类的字段，方法，类名称的信息；</strong></p>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118183346.png?v=1&type=image&token=V1:3n03VpBe2yMBZgKD5g9o0h5d90CeNevbyQO6LX2UnvQ" title="" data-fancybox="images"><img src="image_20220118183346.png?v=1&type=image&token=V1:3n03VpBe2yMBZgKD5g9o0h5d90CeNevbyQO6LX2UnvQ" alt title class></a>
                <p></p>
            </figure>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208023504211.png" title="符号引用" data-fancybox="images"><img src="image-20220208023504211.png" alt="符号引用" title class></a>
                <p>符号引用</p>
            </figure>
<p><strong>每个常量项的第一个字节 对应上图中的tag标志 找到对应的结构</strong></p>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118170506.png?v=1&type=image&token=V1:6K2y024TT-YRQvmLRY5b09neyTtm2iaN319VPeQprHY" title="" data-fancybox="images"><img src="image_20220118170506.png?v=1&type=image&token=V1:6K2y024TT-YRQvmLRY5b09neyTtm2iaN319VPeQprHY" alt title class></a>
                <p></p>
            </figure>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118184004.png?v=1&type=image&token=V1:rLsRMkCAd22AUMMS2KXLkI8chGO6nlPHBPOsm1vbbXM" title="" data-fancybox="images"><img src="image_20220118184004.png?v=1&type=image&token=V1:rLsRMkCAd22AUMMS2KXLkI8chGO6nlPHBPOsm1vbbXM" alt title class></a>
                <p></p>
            </figure>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118184033.png?v=1&type=image&token=V1:3CCva6EeaLck4wLZttiedHSfKB0KY8VF3QdPIXjTUjE" title="" data-fancybox="images"><img src="image_20220118184033.png?v=1&type=image&token=V1:3CCva6EeaLck4wLZttiedHSfKB0KY8VF3QdPIXjTUjE" alt title class></a>
                <p></p>
            </figure>
</li>
</ul>
<ol start="2">
<li>面试题</li>
</ol>
<ul>
<li><p>Q  哪些字面量会进入常量池中？</p>
<ol>
<li>【final修饰】的8种基本类型的值会进入常量池。</li>
<li>【非final类型】（包括static的）的8种基本类型的值，只有【double、float、long】的值会进入常量池。</li>
<li><p>常量池中包含的字符串类型字面量（【双引号引起来的字符串值】）。</p>
</li>
<li><p>final类型的8种基本类型的值会进常量池。</p>
</li>
<li><p>final类型（包括static的）的8种基本类型的值，只有double、float、long的值会进常量池。</p>
</li>
<li><p>常量池中包含的字符串类型字量（双引号引起来的字符串值）。</p>
</li>
</ol>
</li>
<li><p>java 字段名和方法名，有无长度限制？<br>A: 有，CONSTANT_Utf8_info 存储字符串字面量， 最大长度是65535，大小限制在小于64kb</p>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220119024159.png?v=1&type=image&token=V1:W7pDbZc-acY3wco7miFQ9qcUzZDjMeym7ot3fpzX19A" title="" data-fancybox="images"><img src="image_20220119024159.png?v=1&type=image&token=V1:W7pDbZc-acY3wco7miFQ9qcUzZDjMeym7ot3fpzX19A" alt title class></a>
                <p></p>
            </figure>
</li>
<li><p>Q 字符串有长度限制吗？是多少？<br>  答：</p>
<ol>
<li>运行期限制<br>首先字符串的内容是由一个字符数组 char[] 来存储的，由于数组的长度及索引是整数，且String类中返回字符串长度的方法length() 的返回值也是int ，所以通过查看java源码中的类Integer我们可以看到Integer的最大范围是2^31 -1,<br>由于数组是从0开始的，所以数组的最大长度可以使【0~2^31】通过计算是大概4GB。</li>
<li>编译时期限制<br>通过翻阅java虚拟机手册对class文件格式的定义以及常量池中对String类型的结构体定义我们可以知道对于索引定义了u2，就是无符号占2个字节，2个字节可以表示的最大范围是2^16 -1 = 65535。但是由于JVM需要1个字节表示结束指令，所以这个范围就为65534了。超出这个范围在编译时期是会报错。<br>原来是为了弥补早期设计时的一个bug，“长度刚好65535个字节，且以1个字节长度的指令结束，这条指令不能被异常处理器处理”，因此就将数组的最大长度限制到了65534了。跟程序计数器有关</li>
</ol>
</li>
</ul>
<p>运行时拼接或者赋值的话范围是在整形的最大范围。<br><a href="https://blog.csdn.net/rd_w_csdn/article/details/110387250" target="_blank" rel="noopener">https://blog.csdn.net/rd_w_csdn/article/details/110387250</a></p>
<p><del>错误回答：</del><br><del>CONSTANT_Utf8_info 中有 u2 length; 表明了该类型存储数据的长度。 u2 是无符号的 16 位整数，因此理论上允许的的最大长度是 2^16=65536。而 java class 文件是使用一种变体 UTF-8 格式来存放字符的，null 值使用两个 字节来表示，因此只剩下 65536－ 2 ＝ 65534 个字节。</del></p>
<p><code>Modified UTF-8</code>  UTF-8 缩略编码是改进版的<code>UTF-8</code>编码，它和标准的UTF-8编码有下面三点区别：</p>
<ol>
<li><code>null</code>空字符的编码从一个字节的<code>&#39;\u0000&#39;</code>改变为2个字节的形式，即11000000 10000000，因此在字符串的编码中不会出现嵌入的null字符；</li>
<li>只使用1~3个字节的格式；（即范围由\u0000-\uffff）</li>
<li>辅助字符以代理对的形式表示。 <strong>补充字符通常指大于u+ffff而小于等于u+10ffff范围内的字符</strong></li>
</ol>
<ul>
<li>Q常量池计数器从0还是1开始？<br>A: 从1开始，0索引留给无法指向的东西，即没有父类，没有类名的，比如匿名内部类，Object类</li>
</ul>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220116204409.png" title="" data-fancybox="images"><img src="image_20220116204409.png" alt title class></a>
                <p></p>
            </figure>
<ul>
<li><h3 id="2字节的访问标志："><a href="#2字节的访问标志：" class="headerlink" title="2字节的访问标志："></a>2字节的访问标志：</h3><p>  表明这个class有什么修饰符 只有两个字节</p>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208024117844.png" title="" data-fancybox="images"><img src="image-20220208024117844.png" alt title class></a>
                <p></p>
            </figure>
</li>
</ul>
<p>举例: 原来是00 20(看下表中ACC_SUPER描述，最低限度必须有此标志)<br>如果：类是public类型-的，则第一个ACC_PUBLIC为true 则加上00 01 ，结果为00 21<br>如果：类还是 final类型-的，则第二个为true，再加上00 10 ，结果为00 31</p>
<p>00 21 = 00 20 + 00 01 ( 加了public)<br>表示为public 的类<br>设置的数值刚好不会出现相加和其他状态相等的情况，很巧妙<br><strong>一句话 访问标识就是只用两个字节表示了这个类的修饰符有哪些</strong></p>
<ul>
<li><h3 id="类、父类-This-class-Super-class"><a href="#类、父类-This-class-Super-class" class="headerlink" title="类、父类(This class,Super class)"></a>类、父类(This class,Super class)</h3><p>如 00 02 和 00 003两个标识符也都是一个两字节的引用，我们class文件中，分别引向常量池中00 02的第二个常量项和00 03 第三个常量项<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到类名</p>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="20200506112335237.png" title="在这里插入图片描述" data-fancybox="images"><img src="20200506112335237.png" alt="在这里插入图片描述" title class></a>
                <p>在这里插入图片描述</p>
            </figure>
</li>
<li><h3 id="接口索引计数器"><a href="#接口索引计数器" class="headerlink" title="接口索引计数器"></a>接口索引计数器</h3><p>类文件实现了接口的数量，没有就是00 00 ，有一个就是 00 01</p>
</li>
<li><h3 id="接口索引项"><a href="#接口索引项" class="headerlink" title="接口索引项"></a>接口索引项</h3><p>指向常量池索引<br>CONSTANT_Class_info -&gt; CONSTANT_Utf8_info -&gt; 找到接口名</p>
</li>
</ul>
<ul>
<li><h3 id="字段表：字段个数，字段1，字段2。。。。"><a href="#字段表：字段个数，字段1，字段2。。。。" class="headerlink" title="字段表：字段个数，字段1，字段2。。。。"></a>字段表：字段个数，字段1，字段2。。。。</h3><p>和上面差不多<br>`<br>※  注意：ConstantValue属性：</p>
<p>  final static String = “hello”<br>必须是String 类型，其值直接存储在字段表里面附带属性项指向的属性表里面的Constant属性里面，这样就可以类未加载直接用，效率提升<br>`</p>
</li>
</ul>
<blockquote>
<p>ConstantValue属性<br>属性表中的一个属性<br>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性。非static类型的变量的赋值是在实例构造器方法中进行的；tatic类型变量赋值分两种，在类构造其中赋值，或使用ConstantValue属性赋值。</p>
<p>在实际的程序中，只有同时被final和static修饰的字段才有ConstantValue属性，且限于基本类型和String。编译时Javac将会为该常量生成ConstantValue属性，在类加载的准备阶段虚拟机便会根据ConstantValue为常量设置相应的值，如果该变量没有被final修饰，或者并非基本类型及字符串，则选择在类构造器中进行初始化。</p>
<p>为什么ConstantValue的属性值只限于基本类型和string？</p>
<p>因为从常量池中只能引用到基本类型和String类型的字面量</p>
<p>final、static、static final修饰的字段赋值的区别</p>
<p>static修饰的字段在加载过程中准备阶段被初始化，但是这个阶段只会赋值一个默认的值（0或者null而并非定义变量设置的值）初始化阶段在类构造器中才会赋值为变量定义的值。</p>
<p>final修饰的字段在运行时被初始化，可以直接赋值，也可以在实例构造器中赋值，赋值后不可修改。</p>
<p>static<br>final修饰的字段在javac编译时生成comstantValue属性，在类加载的准备阶段直接把constantValue的值赋给该字段。</p>
<p>可以理解为在编译期即把结果放入了常量池中。</p>
</blockquote>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118180056.png?v=1&type=image&token=V1:CPihlXhsDyMBxTiSaP4vHqG9vSKcCYlTGlI4SJLB2Os" title="" data-fancybox="images"><img src="image_20220118180056.png?v=1&type=image&token=V1:CPihlXhsDyMBxTiSaP4vHqG9vSKcCYlTGlI4SJLB2Os" alt title class></a>
                <p></p>
            </figure>
<p><strong>分析第一个 access_flags</strong><br>—-其实跟之前我们讲访问标识的时候一样，不一样的是这次的访问标志修饰符是修饰字段的<br>所以在标志名称上有些不同<br><a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208024515966.png" title="在这里插入图片描述" data-fancybox="images"><img src="image-20220208024515966.png" alt="在这里插入图片描述"></a></p>
<p>这里加一张图用另一种方式表示我们的修饰符<br><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208024418503.png" title="在这里插入图片描述" data-fancybox="images"><img src="image-20220208024418503.png" alt="在这里插入图片描述" title class></a>
                <p>在这里插入图片描述</p>
            </figure></p>
<p><strong>分析第四个 attributes_count</strong><br>表示这个字段所拥有的attribute类型的个数，如果是00 01 就表示一个<br><strong>分析第五个 attributes[attributes_count]</strong><br>就是一个长度为 attributes_count，类型是：属性类型的数组<br>这个类型我们暂时不分析，到后面讲到 属性 时一起讲</p>
<p><strong>一句话总结<br>就是一个装有我们定义的所有属性的数组，长度为字段个数，里面的每一个表信息都表示一个字段</strong></p>
<ul>
<li><h3 id="方法表：-方法个数，方法1，方法2。。。。"><a href="#方法表：-方法个数，方法1，方法2。。。。" class="headerlink" title="方法表： 方法个数，方法1，方法2。。。。"></a>方法表： 方法个数，方法1，方法2。。。。</h3><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220118182212.png?v=1&type=image&token=V1:I_meGZXidnP-pQ7GadHjyGZ5OJv_1gQzErPxNEyHeg0" title="" data-fancybox="images"><img src="image_20220118182212.png?v=1&type=image&token=V1:I_meGZXidnP-pQ7GadHjyGZ5OJv_1gQzErPxNEyHeg0" alt title class></a>
                <p></p>
            </figure>
access_flags的修饰类型<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208024616971-16442595798677.png" title="" data-fancybox="images"><img src="image-20220208024616971-16442595798677.png" alt title class></a>
                <p></p>
            </figure>
</li>
</ul>
<p>※※  方法的代码存储在： 方法表里面附带属性项指向的属性表的CODE属性里面。<br><a href="https://blog.csdn.net/weixin_29732737/article/details/113051809" target="_blank" rel="noopener">https://blog.csdn.net/weixin_29732737/article/details/113051809</a><br> <strong>max_stack</strong><br>操作数栈的最大深度，说明方法在编译把方法的栈深度已经定好了。虚拟机运行的时候需要根据这个值来分配栈帧中的操作栈深度。<br><strong>max_locals</strong><br>局部变量表所需要的空间，长度不能变<br>单位是Slot，int、byte和returnAddress不超过32位的数据类型采用1个Slot来存储；<br>double和long等64位的数据类型采用两个Slot存储<br><strong>其他（包括异常信息）</strong><br>code_length存储了方法体中的字节码指令的长度<br>code就存储了具体的字节码指令<br>exception_table_length<br>显示异常(受检查的异常)中的个数(try-cacatch中的异常)<br>exception_info<br>这是受检查异常的具体信息</p>
<ul>
<li><h3 id="属性表：-属性个数，属性1，属性2。。。。"><a href="#属性表：-属性个数，属性1，属性2。。。。" class="headerlink" title="属性表： 属性个数，属性1，属性2。。。。"></a>属性表： 属性个数，属性1，属性2。。。。</h3>上面所说的<strong>字段</strong>和<strong>方法</strong>的最后都有一项：<strong>属性项数组</strong>，里面装的就是这个类型了,比如ConstantValue和Code<br>其实class文件还有一个属性表，就是上面那张图没有覆盖掉的最后一部分<br>在Class文件、字段表、方法表都可以携带自己的属性表集合<br>属性表中不要求各个属性表具有严格的顺序，只要不与已有属性重名即可</li>
</ul>
<h1 id="2-JVM-类加载的整体流程"><a href="#2-JVM-类加载的整体流程" class="headerlink" title="2. JVM 类加载的整体流程"></a>2. JVM 类加载的整体流程</h1><p> 普通回答（过于绝对）：<br> 加载，连接，初始化<br> 连接又分为验证，准备，解析</p>
<p>※ 从细节回答：<br>真正是分为7到8步</p>
<ol>
<li>加载<br> 静态加载，java编译为class文件二进制字节流，获得的是class文件二进制字节流</li>
<li>验证<br> 进入连接阶段的验证：<br>第一步，文件格式验证： 魔数和主次版本号</li>
<li>加载<br> 验证成功后，把class文件二进制字节流 加载到 方法区<br>  作用： 结构调整，把静态存储文件转换为运行时数据结构<br> （思考： class常量池和方法区的运行时常量池的区别和联系）</li>
<li>加载<br> 堆内存生成当前类class对象 作为方法区中这个类的各种访问入口，比如：Object类，java.lang.Object 一定先加载，放入堆，提供给其他类访问</li>
<li>验证<br> 跳到连接阶段的验证：<br>第二步，元数据验证，字节码描述的信息进行语义分析</li>
<li>验证<br> 跳到连接阶段的验证：<br>第三步，字节码验证，通过数据流和控制流分析<br> <a href="https://blog.csdn.net/weixin_38608626/article/details/88173916" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38608626/article/details/88173916</a></li>
<li>准备<br> 0值的初始转化，含了给这个类的静态变量static和其他数据分配内存空间（<strong>仅仅是分配内存空间，具体初始化在最后一步</strong>）。<br> static int a=123;  这一阶段a会变成0</li>
<li>初始化<br> （解析： 第四步，符号验证，常量池内符号引用转直接引用，确定解析一定初始化之前，不确定在何时）【直接引用与虚拟机有关，不同的虚拟机翻译出来一般不会相同】<br> JVM用赋值或者缺省值将静态变量进行初始化，并执行静态初始化程序（static块中的代码），初始化发生在执行main方法之前，但在指定的类初始化之前他的父类必须先初始化，若其父类仍然存在父类，那也需递归的初始化。</li>
</ol>
<p>真正执行java代码，会调用<code>&lt;clinit&gt;()</code>方法 ：<br><code>在编译生成class文件时,会自动产生两个方法,一个是类的初始化方法&lt;clinit&gt;, 另一个是实例的初始化方法&lt;init&gt;。</code><br>只有被static修饰并且赋值的静态属性才会产生<code>&lt;clinit&gt;()</code>方法，不管是直接赋值还是在静态块中赋值，最后都会被合并成一个<code>&lt;clinit&gt;()</code>方法，并按照代码中的顺序依次赋值。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口。</li>
<li>在初始化一个接口时，并不会先初始化它的父接口。</li>
</ul>
<h3 id="（面试题）-什么情况下立即对类初始化？"><a href="#（面试题）-什么情况下立即对类初始化？" class="headerlink" title="（面试题） 什么情况下立即对类初始化？"></a>（面试题） 什么情况下立即对类初始化？</h3><p>1 遇到四条字节码指令会立即初始化：</p>
<ul>
<li>创建普通对象的指令：new</li>
<li>访问类字段（static 字段，或者称为类变量）的指令：getstatic, putstatic</li>
<li>invokestatic 指令：用于调用类方法(static方法)。<br>（new引用类会立即初始化， new数组不会初始化： 原因：创建数组得到指令：newarray , anewarray , multianewarray，不是new指令）</li>
</ul>
<p>2 反射直接初始化<br>3 父类未初始化先初始化<br>4 有main函数<br>5 java.lang.invoke.MethodHandle 实例最后解析结构结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应类没有初始化时，必须触发其初始化。<br>6 jdk1.8 接口default 方法</p>
<p>引申知识：</p>
<ul>
<li><p>加载：<br>  双亲委派模型：<br>  1启动类加载器（lib目录，根加载器），<br>  2拓展类加载器（lib-&gt;ext目录），<br>  3系统类加载器<br>(又叫应用程序加载器，加载用户类路径（classpath）上的指定类库，可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器)<br> 4当然，可以通过继承Classloader实现自定义加载器<br> 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。</p>
<ul>
<li><p>（面试） 双亲委派好处？<br>1.顺序加载。父类优先加载，<strong>避免重复加载</strong><br>2.安全性和唯一性。<strong>避免核心类篡改</strong></p>
<p>  利用 沙箱安全机制。 比如：加载器发现这个名字的类，发现该类已被加载，并不会重新加载网络传递过来（或自己写）的java.lang.Integer<br>  <code>tips： instance of 是根据类名称+类加载器 定位</code></p>
</li>
<li>JVM加载数组？<br>数组这个类加载，不是类加载器加载，其内存区域是运行中内存动态构造的。<br>类型的类在new时，才由加载器加载。<br>如何标记出唯一数组？</li>
</ul>
<ol>
<li>当引用类被加载器加载时，数组标志在加载器的<code>命名空间</code>上。</li>
<li>基础类型数组类型直接标记在<code>启动类加载器</code>的<code>命名空间</code>上。</li>
</ol>
</li>
</ul>
<p><strong>命名空间</strong><br>    <a href="https://blog.csdn.net/chuifuhuo6864/article/details/100887587" target="_blank" rel="noopener">https://blog.csdn.net/chuifuhuo6864/article/details/100887587</a></p>
<blockquote>
<p>由不同的类装载器装载的类将被放在虚拟机内部的不同命名空间。命名空间由一系列唯一的名称组成，每一个被装载的类有一个名字。JAVA虚拟机为每一个类装载器维护一个名字空间。例如，一旦JAVA虚拟机将一个名为Volcano的类装入一个特定的命名空间，它就不能再装载名为Valcano的其他类到相同的命名空间了。可以把多个Valcano类装入一个JAVA虚拟机中，因为可以通过创建多个类装载器从而在一个JAVA应用程序中创建多个命名空间。<br><strong>初始类装载器/</strong> <strong>定义类装载器</strong></p>
<p>命名空间有助于安全的实现，因为你可以有效地在装入了不同命名空间的类之间设置一个防护罩。在JAVA虚拟机中，在同一个命名空间内的类可以直接进行交互，而不同的命名空间中的类甚至不能觉察彼此的存在，除非显示地提供了允许它们进行交互的机制，如获取Class对象的引用后使用反射来访问。</p>
<p>如果要求某个类装载器去装载一个类型，但是却返回了其他类装载器装载的类型，这种装载器被称为是那个类型的<strong>初始类装载器</strong><br>；而实际装载那个类型的类装载器被称为该类型的<strong>定义类装载器</strong><br>。任何被要求装载类型，并且能够返回Class实例的引用代表这个类型的类装载器，都是这个类型的初始类装载器。</p>
</blockquote>
<h1 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h1><p>1.常量池常量池,也叫Class常量池(常量池==Class常量池)。Java文件被编译成Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，常量池是当Class文件被Java虚拟机加载进来后存放在方法区各种字面量(Literal)和符号引用。在Class文件结构中，最头的4个字节用于存储魔数(MagicNumber)，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池常量池主要用于存放两大类常量：字面量和符号引用量，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念。如下</p>
<p>2.运行时常量池</p>
<p>2.1运行时常量池的简介运行时常量池是方法区的一部分。运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class文件常量池里的内容转移到运行时常量池里(运行时常量池也是每个类都有一个)。运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中2.2方法区的Class文件信息，Class常量池和运行时常量池的三者关系字符串常量池</p>
<p>3.1字符串常量池的简介字符串常量池又称为：字符串池，全局字符串池,英文也叫StringPo。在工作中，String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，这就是我们今天要讨论的核心：字符串常量池。字符串常量池由String类私有的维护。</p>
<h1 id="3-运行时数据区"><a href="#3-运行时数据区" class="headerlink" title="3. 运行时数据区"></a>3. 运行时数据区</h1><ol>
<li>线程共享<br> 方法区，堆</li>
<li>线程私有<br> 虚拟机栈，本地方法栈，程序计数器</li>
</ol>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol>
<li>小内存，几乎无OOM，控制代码执行位置，比如循环，线程block恢复，wait恢复</li>
</ol>
<h2 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h2><ol>
<li>存储类信息 （第四步加载过程）</li>
<li>常量，静态变量</li>
<li>即时编译后的代码缓存数据 【Class方法表中Code属性，保存执行指令字节，将其缓存在方法区】</li>
</ol>
<p>元空间：能不限制使用系统内存资源</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><ol>
<li>存放编译期生成的字面量+符号引用</li>
<li>具备动态性<br>不要求常量一定只有编译期才能产生<br><strong>String.intern()</strong> 是一个Native方法。调用intern()方法后，JVM 就会在当前类的运行时常量池中查找是否存在与str等值的String，若存在则直接返回运行时常量池中相应Strnig的引用；若不存在，则会在运行时常量池中创建一个等值的String，然后返回这个String在运行时常量池中的引用。</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li>对象头（Header）: （Mark Word+ class指针+ 数组长度）<br>hashcode，GC分代年龄，锁标志状态，当前锁，偏向锁ID，偏向时间戳</li>
<li>实例数据（ Instance）</li>
<li>对齐填充（Padding）： 不满8字节的倍数就对齐填充<br><strong>字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。 如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址。</strong></li>
</ol>
<p><strong>（面试题） 64位JVM 中 new Object()  在Java中占多少内存？</strong><br>16字节。<br>Mark Word （8字节）+ class指针（指针压缩4字节，否则8字节）+实例数据（0字节）+对齐填充（4字节或0字节）</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>java栈是针对每一个线程的，每一个线程都会有自己的栈，维护在其内部的引用就是本地变量表。</p>
<p>通过线程想起栈，提问，对象是如何被线程访问定位的呀？问的非常底层。<br><a href="https://blog.csdn.net/y471519146/article/details/104638340" target="_blank" rel="noopener">https://blog.csdn.net/y471519146/article/details/104638340</a></p>
<ol>
<li>使用句柄。句柄是一个对象的唯一标示。中间有一个句柄池，存在于java堆的内存区域，线程指向句柄池，句柄池reference链接到对象地址</li>
<li>使用直接指针。线程对象指向另一对象。<br>优劣：直接指针访问快，但gc清理将对象位置移动，每个线程的指针就要改变，消耗大。<br>句柄优势：稳定，句柄池位置不变，当gc清理将对象位置移动，只需改变句柄池1个链接。</li>
</ol>
<h3 id="栈帧※"><a href="#栈帧※" class="headerlink" title="栈帧※"></a>栈帧※</h3><ol>
<li>1个方法创建1个栈帧：存储方法的局部变量表，操作数栈，动态链接，返回地址等。【class方法表中附带属性表中code属性有局部变量所需要的空间】</li>
<li>开始调用到完成过程就是一个栈帧的入栈出栈<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5>存储方法里的局部变量（包括方法参数），编译完成存储【class方法表中附带属性表中code属性】<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5>方法调用的最大深度【code属性的max_stack】，比如递归，调用数超出，则StackOverflowError。<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5>方法调用过程中，链接其他方法或其他类<h5 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h5>谁调用返回给谁。分两点</li>
<li>正常退出。</li>
<li>异常退出。抛错给调用方。</li>
</ol>
<p>####</p>
<h2 id="堆-展开知识-（第二期）"><a href="#堆-展开知识-（第二期）" class="headerlink" title="堆 展开知识 （第二期）"></a>堆 展开知识 （第二期）</h2><p>Q:新生代  eden s0 s1 是根据什么思想 8:1:1分区 ？ 回收器都是这样吗？<br>基于标记复制算法思想； 而基于标记清理算法就不是。</p>
<p>第一次minorgc： eden 空，s0 年龄1<br>第二次minorgc：eden空，s0空，s1 年龄有1和2<br>此时 s0 和 s1 角色互换<br>第三次minorgc：eden 1岁，s0空，s1 年龄有2和3<br>                             eden 空，s0空年龄有1,、2和3 ，s1空<br>此时 s0 和 s1 角色互换…</p>
<p>为什么需要s0和s1？<br> 需要空闲的缓冲内存，存储清理后的存活对象，避免s0区空间碎片化。</p>
<p>老年代</p>
<ol>
<li>年龄15岁以上</li>
<li>超大对象，超过阈值设置 max tenuring thread hold</li>
<li><p>相同年龄所有对象大小总和大于一个幸存者空间的一半，取年龄大于等于的对象，<br>所以年轻代空间利用，只有 90%</p>
<p>（一旦老年代要满就引发fullgc）</p>
</li>
</ol>
<p>※ 空间分配担保策略<br> minorGC发生之前，第一步先检查老年代最大可用连续空间是否大于新生代所有对象的总空间，如果条件成立确保安全，如果条件不成立，比如空间剩余500M；<br> 就会第二步检查虚拟机HandlePromotionFailure参数是否true，是否允许担保失败；<br> 如果允许担保失败，jvm再次第三步检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小；</p>
<ul>
<li>如果大于，比如平均之前300M，冒险尝试一次minorGC，  存在风险：minorGC后存活对象还是大于500M，超出最大可用连续空间，说明老年代要满了就引发fullGC。<ul>
<li>如果小于 或 HandlePromotionFailure参数false，就直接fullGC。</li>
</ul>
</li>
</ul>
<p>（面试）如何判断对象是否存活？ gc过程是什么？<br>可达性分析算法，通过一系列称为“GC Roots”根节点，开始引用链的搜索，如果对象搜索不到，证明对象不可达，标记白色，最终被垃圾回收。<br>引申：引用计数器算法，每个对象有引用计数器，Redis使用<br>5个问题：</p>
<h3 id="1-gcroots-是什么？"><a href="#1-gcroots-是什么？" class="headerlink" title="1.gcroots 是什么？"></a>1.gcroots 是什么？</h3><p>是可达性分析的起点，是两个栈的栈帧的本地变量表中引用的对象，方法区中静态属性引用的对象，方法区中常量引用对象（两个栈两个方法区），其实还有，jvm内部也有引用，锁的获取和释放。</p>
<h3 id="2-引用链是什么？"><a href="#2-引用链是什么？" class="headerlink" title="2.引用链是什么？"></a>2.引用链是什么？</h3><p>强：常见，永远不被垃圾回收<br>软：非必须，内存溢出OOM之前，列入回收范围进行第二次回收，还溢出就抛错<br>弱：生存到下一次垃圾收集之前<br>虚：幽（或幻）灵引用，主要用于监测对象是否已经从内存中删除，堆外内存回收。</p>
<p>软引用尝试保留其引用对象，弱引用不会试图保留其引用对象，虚引用所引用对象不会被被释放直到所有指向该对象的虚引用被清除。</p>
<blockquote>
<ul>
<li><p>虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中</p>
</li>
<li><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</p>
</li>
</ul>
</blockquote>
<h3 id="3-对象不可达意味着什么？一定被回收吗？"><a href="#3-对象不可达意味着什么？一定被回收吗？" class="headerlink" title="3.对象不可达意味着什么？一定被回收吗？"></a>3.对象不可达意味着什么？一定被回收吗？</h3><p>意味对象即将被垃圾回收，当然，不会立即回收。<br>※ 对象会放入f-q 的队列，会启动一条低优先级别的线程，读取对象，一个个调用对象的finalize方法，如果方法被覆盖并且被调用过，jvm会对该对象置为非必要垃圾回收，它逃过垃圾回收</p>
<h3 id="4-三色标记法是什么？"><a href="#4-三色标记法是什么？" class="headerlink" title="4.三色标记法是什么？"></a>4.三色标记法是什么？</h3><p>白： 对象不可达<br>黑： 已被访问，所有关联对象也扫描过<br>灰：未被扫描 （重新标记有关）</p>
<ul>
<li><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="7779607-eecbd09f81b721f8.gif" title="img" data-fancybox="images"><img src="7779607-eecbd09f81b721f8.gif" alt="img" title class></a>
                <p>img</p>
            </figure>
</li>
</ul>
<p>假设现在有白、灰、黑三个集合（表示当前对象的颜色），其遍历访问过程为：</p>
<ol>
<li><p>初始时，所有对象都在【白色集合】中；</p>
</li>
<li><p>将 GC Roots 直接引用到的对象挪到 【灰色集合】中；</p>
</li>
<li><p>从灰色集合中获取对象：<br>3.1. 将本对象引用到的其他对象全部挪到 【灰色集合】中；<br>3.2. 将本对象挪到【黑色集合】里面。</p>
</li>
<li><p>重复步骤3，直至【灰色集合】为空时结束。</p>
</li>
<li><p>结束后，仍在【白色集合】的对象即为 GC Roots 不可达，可以进行回收。</p>
<blockquote>
<p>注：如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</p>
</blockquote>
</li>
</ol>
<p>当 Stop The World （以下简称 STW）时，对象间的引用是不会发生变化的，可以轻松完成标记。</p>
<p>而当需要支持并发标记时，即标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。</p>
<p><strong>多标-浮动垃圾</strong></p>
<p>假设已经遍历到 E（变为灰色了），此时应用执行了 objD.fieldE = null (D &gt; E 的引用断开)：<br><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="1153954-20201220213532679-409632912.png" title="img" data-fancybox="images"><img src="1153954-20201220213532679-409632912.png" alt="img" title class></a>
                <p>img</p>
            </figure></p>
<p>此刻之后，对象 E/F/G 是“应该”被回收的。然而因为 E 已经变为灰色了，其仍会被当作存活对象继续遍历下去。最终的结果是：这部分对象仍会被标记为存活，即本轮 GC 不会回收这部分内存。</p>
<p>这部分本应该回收 但是没有回收到的内存，被称之为“浮动垃圾”。浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，针对并发标记开始后的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分对象期间可能会变为垃圾，这也算是浮动垃圾的一部分。</p>
<p><strong>漏标-读写屏障</strong></p>
<p>假设 GC 线程已经遍历到 E（变为灰色了），此时应用线程先执行了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG;</span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 灰色E 断开引用 白色G</span></span><br><span class="line">objD.fieldG = G;  <span class="comment">// 黑色D 引用 白色G</span></span><br></pre></td></tr></table></figure>
<figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="1153954-20201220214557708-22631031.png" title="img" data-fancybox="images"><img src="1153954-20201220214557708-22631031.png" alt="img" title class></a>
                <p>img</p>
            </figure>
<p>此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合；尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。</p>
<p>最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的。</p>
<p>不难分析，漏标只有同时满足以下两个条件时才会发生：</p>
<ol>
<li>灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。</li>
<li>黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。</li>
</ol>
<p>从代码的角度看：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> G = objE.fieldG; <span class="comment">// 1.读</span></span><br><span class="line">objE.fieldG = <span class="literal">null</span>;  <span class="comment">// 2.写</span></span><br><span class="line">objD.fieldG = G;     <span class="comment">// 3.写</span></span><br></pre></td></tr></table></figure>
<ol>
<li>读取对象 E 的成员变量 fieldG 的引用值，即对象 G；</li>
<li>对象 E 往其成员变量 fieldG，写入 null值。</li>
<li>对象 D 往其成员变量 fieldG，写入对象 G ；</li>
</ol>
<p>我们只要在上面这三步中的任意一步中做一些“手脚”，将对象 G 记录起来，然后作为灰色对象再进行遍历即可。比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），该集合的对象遍历即可（重新标记）。</p>
<blockquote>
<p>重新标记是需要 STW 的，因为应用程序一直在跑的话，该集合可能会一直增加新的对象，导致永远都跑不完。当然，并发标记期间也可以将该集合中的大部分先跑了，从而缩短重新标记 STW 的时间，这个是优化问题了。</p>
</blockquote>
<p>写屏障用于拦截第二和第三步；而读屏障则是拦截第一步。<br>它们的拦截的目的很简单：就是在读写前后，将对象 G 给记录下来。</p>
<p><strong>写屏障(仅拓展)</strong></p>
<ul>
<li><p>CMS：写屏障 + 增量更新</p>
<blockquote>
<p>当有新引用插入进来时，记录下新的引用对象。</p>
<p>思路：不要求保留原始快照，而是针对新增的引用，将其记录下来等待遍历，即增量更新（Incremental Update）。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>G1：写屏障 + SATB</p>
<blockquote>
<p>当原来成员变量的引用发生变化之前，记录下原来的引用对象。</p>
<p>思路：尝试保留开始时的对象图，即原始快照（Snapshot At The Beginning，SATB），当某个时刻 的 GC Roots 确定后，当时的对象图就已经确定了</p>
<p>比如 当时 D 是引用着 G 的，那后续的标记也应该是按照这个时刻的对象图走（D 引用着 G）。如果期间发生变化，则可以记录起来，保证标记依然按照原本的视图来。</p>
</blockquote>
</li>
<li><p>ZGC：读屏障</p>
<blockquote>
<p>当读取成员变量时，一律记录下来</p>
</blockquote>
</li>
</ul>
<h3 id="5-有没有跨代引用的问题？※"><a href="#5-有没有跨代引用的问题？※" class="headerlink" title="5.有没有跨代引用的问题？※"></a>5.有没有跨代引用的问题？※</h3><p>minorGC时候，如果当前年轻对象被老年代的对象引用，那么就需要遍历老年代对象里面的引用，如果有引用就不删除年轻代对象。 遍历过多，这消耗过大。</p>
<p>空间换时间，引入<strong>记忆集</strong>（<strong>RememberSet数据结构</strong>），<br><strong>（卡表CardTable是具体实现类似数组的一种实现）</strong></p>
<p>用于记录从非收集区域指向收集区域的一个指针集合的抽象数据结构。</p>
<p>它存放在收集区域，比如在新生代里面存放着老年代对新生代对象的每一个引用。这样在收集新生代的时候，我们就可以根据记忆集知道哪些对象被老年代对象所引用，不能回收，这就解决了跨代引用的问题。<br><a href="https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1663322935066223947&amp;wfr=spider&amp;for=pc</a></p>
<blockquote>
<p>记忆集根据记录的精度分三类：<br>字长精度：记录的是老年代指向新生代地址。<br>对象精度：记录的是老年代引用的新生代对象。<br>卡精度：记录的是新生代一段地址是否存在被老年代引用的记录。</p>
</blockquote>
<p>把地址的值右移9位相当于除于512就是卡表索引，每字节512为一组对应卡表同一个元素，一组就是一个卡页，<br>如果这个卡页中只要有一个对象被其他区域对象所引用，对应卡表元素的值就变成1，也就是所谓的元素变脏。</p>
<p>在垃圾回收时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页对应的内存包含跨代指针，把他们加入GC Roots中一并扫描。</p>
<h3 id="垃圾回收的3种算法"><a href="#垃圾回收的3种算法" class="headerlink" title="垃圾回收的3种算法"></a>垃圾回收的3种算法</h3><ul>
<li><p>标记-清除算法<br>标记后统一回收<br>空间问题: 他只有一块内存空间，会产生空间碎片，导致没有太多的可用的比较大的连续空间，导致对象创建找不到容纳空间，直接进入老年代。<br>优点：快，找到并马上删除</p>
</li>
<li><p>标记-复制算法<br>起初思想是将内存分半，内存1:1，一部分存储新对象，一部分负责我们的存活对象。实现的时候，eden，s0，s1，幸存者区1个缓冲<br>缺点：至少10%空间浪费，相对慢<br>优点：针对创建对象，有很大的可用连续空间，GC后，eden区域清空，都是连续空空间，没有空间碎片</p>
</li>
</ul>
<ul>
<li>标记-整理算法<br>优化了标记复制算法和标志清除算法的改进，</li>
</ul>
<ol>
<li>标记并清除</li>
<li>存活对象整理到1边<br>删除快，没有空间碎片</li>
</ol>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image_20220129152044.png?v=1&type=image&token=V1:muO6XhBva0We3ErRpB0T7PPyoRqWWSq-G6D2IwZ9ymA" title="" data-fancybox="images"><img src="image_20220129152044.png?v=1&type=image&token=V1:muO6XhBva0We3ErRpB0T7PPyoRqWWSq-G6D2IwZ9ymA" alt title class></a>
                <p></p>
            </figure>
<ol>
<li>新生代：serial 单线程<br>单核服务器最快最理想，有stw暂停和安全点线程挂起的问题。<br>Q：会不会有CPU时间切片轮询？为什么单核快呢？<br>其他线程必须挂起Stop the world，cpu时间片都要落到垃圾收集的线程里面，其他线程不会有cpu时间片轮询，即便有，cpu时间片也是0。其他线程处于内核态，只有垃圾收集器处于用户态。</li>
</ol>
<p>为什么Stop the world呢？</p>
<ol start="2">
<li><p>新生代：并发的parNew 。 serial 的多线程版本<br>标记复制算法</p>
</li>
<li><p>新生代：parallel Scavenge。<br>能多线程，又能关注和控制吞吐量。<br>吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)<br>不与CMS合作</p>
</li>
</ol>
<p>两个控制参数：<br>    最大垃圾收集停顿时间<br>    直接设置吞吐量大小<br>如何控制吞吐量？<br>    首先，运行用户代码不会变。<br>    那么，通过多运行几回垃圾收集，来提高一次虚拟机运行的吞吐量。<br>    比如： 注意吞吐量参数是（0,100）</p>
<ol start="4">
<li><p>老年代：Serial Old 收集器<br>单线程，标记整理算法</p>
</li>
<li><p>老年代：Pallel Old 收集器<br>标记整理算法，jdk1.6才开始，吞吐量优先。</p>
</li>
<li><p>老年代：CMS 收集器<br>Concurent Mark Sweep 多线程标记清除，以最短回收停顿时间为目标的收集器。<br>记忆：<br>三个mark一清除，初重stw</p>
</li>
</ol>
<p>CMS步骤过程：<br>初始标记 stw，标记gcroots 直接关联对象<br>并发标记  不停顿，扫描old区对象。</p>
<blockquote>
<p>刚才产生的集合中标记出存活对象；<br>应用程序也在运行；<br>并不能保证可以标记出所有的存活对象；</p>
</blockquote>
<p>重新标记 stw，修正<br>并发清除</p>
<p>stop the world 其他线程被挂起，处于内核态。</p>
<p>※※<br>CMS 缺点：<br>首先承认，G1 出来之前，jdk9之前, CMS是靠谱的。</p>
<ol>
<li>对资源处理非常敏感。<br>在并发标记时，占用CPU线程数，影响项目中运行所用线程数。因为占用资源，可能导致资源不足。默认启动(核数n+3)/4线程，这样，核数多防止占用。</li>
<li><p>无法处理浮动垃圾。<br>并发清除，程序运行依然运行，有新垃圾出现，本次收集无法处理，留到下一次GC才清理，这就是“浮动垃圾”。如果对象被疯狂访问，大量对象堆积，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p>
</li>
<li><p>“标记清除算法”虽然快，会产生大量空间碎片。</p>
</li>
</ol>
<h3 id="stop-the-word-※※"><a href="#stop-the-word-※※" class="headerlink" title="stop the word ※※"></a>stop the word ※※</h3><p>引入概念：根节点枚举。<br>在开始标记收集的时候，不管单线程还是并发，不管是对象还是线程，一定在一致性的快照里，才能进行。<br>如果不知道当前的状态的话，没办法进行后续的标记。<br>一致性快照的分析工作就是根节点枚举期间：所有线程停顿。</p>
<p>OopMap 特定的位置记录下栈和寄存器中的哪些位置是引用</p>
<blockquote>
<p> OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。<br> 一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。<br> 我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。<br> <strong>可以把oopMap简单理解成是调试信息。在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。</strong><br> 通过上面的解释，我们可以很清楚的看到使用 OopMap 可以避免全栈扫描，加快枚举根节点的速度。但这并不是它的全部用意。它的另外一个更根本的作用是，可以帮助 HotSpot 实现准确式 GC 。</p>
</blockquote>
<h3 id="安全点Safepoint"><a href="#安全点Safepoint" class="headerlink" title="安全点Safepoint"></a>安全点Safepoint</h3><p>垃圾收集过程，用户线程到达特定位置，这位置不会产生新对象，也不会影响项目的执行，只能让垃圾收集非常安全的进行下去。<br>位置：<br>1、循环的末尾<br>2、方法临返回前 / 调用方法的call指令后<br>3、可能抛异常的位置</p>
<p>OopMap线程找对象<br>回顾句柄池，直接指针。</p>
<p>如何线程如何找Class文件？<br>找常量池里的Constant_class_info指向Constant_utf8_info,找到权限命名，再去方法区。（类加载过程中，对象加载到方法区，再在堆生成class对象，作为访问类的入口）在堆中定位到Class。</p>
<p>想继续找方法？<br>方法表-&gt;属性表-&gt;code-&gt;max stack，max local，方法入口-&gt; 代码</p>
<h3 id="G1垃圾收集器※※"><a href="#G1垃圾收集器※※" class="headerlink" title="G1垃圾收集器※※"></a>G1垃圾收集器※※</h3><figure class="image-box">
                <a rel=jvm | 虚拟机全面扫盲+深入理解的原创笔记 href="image-20220208015310593.png" title="" data-fancybox="images"><img src="image-20220208015310593.png" alt title class></a>
                <p></p>
            </figure>
<ol>
<li>分代理论垃圾收集，只不过是增加一个拓展。</li>
<li>把内存区域分成多个大小相等的内存区域块Region。</li>
<li>jdk9发布，把吞吐量组合取代了，成为服务端默认。如果换成CMS，那么JDK参数配置开启CMS，不过提示Warnings：CMS以后会被废弃。</li>
<li>内存分块会按照“意愿”进行局部收集。</li>
<li><p>Region堆内存布局的原理：<br>不再坚持固定大小的分代理论，把内存区域分成多个大小相等的内存区域块Region，每个Region会根据需要扮演新生代eden，survival），老年代的角色。<br>如果有大对象？<br>G1会分出一部分区域作为特殊区域专门存储大对象，如果通过G1检测，只要大小超过<strong>超过1.5个region</strong>，就可以判断大对象，就放到H。Region可以通过JVM参数设置，1-32GB之间。如果超过16GB，肯定放在大对象区域。<br>大对象区域称为：humongous，全称：attempt_allocation_humongous。<br>对于超大对象，比如32GB，会分配两个连续的Region空间。</p>
</li>
<li><p><strong>标榜：可预测停顿时间的模型。</strong><br> 关注每个模块里回收价值的大小，通过设置一个很低的最大允许GC时间ms，，-XX：MaxGCPauseMillis =200，根据200ms去找它能够进行收集的Region，比如：收10个Region需要花300ms，由于超过200ms，按比例降低先收集6-7Region达到而200ms要求。</p>
<ul>
<li>由于分区的原因,G1可以只选取部分区域进行内存回收,这样缩小了回收的范围,因此对于全局停顿情况的发生也能得到较好的控制</li>
</ul>
</li>
</ol>
<ul>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值),在后台维护一个优先列表,<strong>每次根据允许的收集时间,优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</strong>。</li>
</ul>
<p>Q：如何解决跨代Region引用问题？<br>A：使用记忆集，结构相对复杂，是个双向卡表。</p>
<p>步骤：<br>1.初始标记：stw<br>    GCRoots根节点枚举，在安全点进行<br>2.并发标记<br>3.最终标记：stw<br>4.筛选回收<br>    <strong>根据MaxGCPauseMillis最大允许GC时间，优先回收价值最大的Region， 保证可预测停顿时间。</strong></p>
<h3 id="JVM调优经验-※※"><a href="#JVM调优经验-※※" class="headerlink" title="JVM调优经验 ※※"></a>JVM调优经验 ※※</h3><p>根据用户访问量，在不同时刻导致JVM回收<br>在上线前，做压测，监督内存空间的使用，以及发生GC回收的频率和停顿时间。</p>
<ol>
<li><p>大访问的压力，一边回收一边对象持续创建，minorGC会比较频繁，那么，一：<strong>调大年轻代的大小</strong>。二：如果发生时间不长，很快回收，且回收率高，不会导致老年代短时间内有对象填充，那么就，<strong>进行持续压测</strong>，观察老年代的上限。</p>
</li>
<li><p>大对象创建的频繁且常访问，导致FullGC比较频繁，（对于G1会分配到humongous区）。一：压测观察大对象的大小，过大可以把对象拆分，维持在JVM参数下；二：适当调大判断为大对象的参数，防止它直接进入老年代；三：发生OOM异常，如何排查呢？压测过程，一定先dump出来堆内存的heap文件，导入visual VM工具，主要查看堆栈信息。找内存占用高的对象，Reference指向堆栈信息，最终定位代码。springboot的Context上下文是单例，很难发生大对象频繁创建。四:  线程无法到达安全点，请求第三方等待中，比如60s超时时间，其他线程的已经在安全点STW，这里细说：用户态和内核态。</p>
</li>
</ol>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2022-02-08T01:49:22.780Z" itemprop="dateUpdated">2022-02-08 09:49:22</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2022/02/01/jvm-notes/" target="_blank" rel="external">https://github.com/missionOdd/2022/02/01/jvm-notes/</a>
        
    </div>
    <div class="mdui-chip" id="accost-btn">
      <span class="mdui-chip-icon mdui-color-red-a700"><i class="mdui-icon material-icons">&#xe311;</i></span>
      <span class="mdui-chip-title">Accost</span>
    </div>
    <footer>
      <div class="mdui-chip">
        <a href="https://github.com/missionOdd">
            <img src="/img/avatar.jpg" alt="Missionary">
             About Missionary
        </a>
        </div>
    </footer>
</blockquote>


        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2022/02/01/jvm-notes/&title=《jvm | 虚拟机全面扫盲+深入理解的原创笔记》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2022/02/01/jvm-notes/&title=《jvm | 虚拟机全面扫盲+深入理解的原创笔记》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            <div class="mdui-container">
  <div class="mdui-tab" id="tab">
    <a href="#tab1-content" id="tab1" class="mdui-ripple">游客用户</a>
    <a href="#tab2-content" id="tab2" class="mdui-tab-active mdui-ripple">GitHub账户</a>
  </div>

  <div id="tab1-content" class="mdui-p-a-2">
    
      <div id="comment" style=""></div>

  </div>
  <div id="tab2-content" class="mdui-p-a-2">
    
          
    <div onclick="ShowGitment()" id="gitment-display-button" style="display: block;">
        <span>显示 Gitment 评论</span>
    </div>
    <div id="gitment" class="hide"></div>


    
  </div>

</div>

        
    </div>
    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="next">
      <a href="/2022/01/12/zhan-bao/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">TCP粘包是什么？ 如何解决？</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-class文件"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. class文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4字节魔数：标志文件类型；视频，照片也有魔数"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">4字节魔数：标志文件类型；视频，照片也有魔数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#次版本号和主版本号：标志JDK版本；兼容低版本问题"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">次版本号和主版本号：标志JDK版本；兼容低版本问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常量池计数器：记录后面常量池的常量（数据项）个数；※"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">常量池计数器：记录后面常量池的常量（数据项）个数；※</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常量池：字面量-符号引用"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">常量池：字面量+符号引用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2字节的访问标志："><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">2字节的访问标志：</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类、父类-This-class-Super-class"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">类、父类(This class,Super class)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口索引计数器"><span class="post-toc-number">1.0.7.</span> <span class="post-toc-text">接口索引计数器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#接口索引项"><span class="post-toc-number">1.0.8.</span> <span class="post-toc-text">接口索引项</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字段表：字段个数，字段1，字段2。。。。"><span class="post-toc-number">1.0.9.</span> <span class="post-toc-text">字段表：字段个数，字段1，字段2。。。。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方法表：-方法个数，方法1，方法2。。。。"><span class="post-toc-number">1.0.10.</span> <span class="post-toc-text">方法表： 方法个数，方法1，方法2。。。。</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#属性表：-属性个数，属性1，属性2。。。。"><span class="post-toc-number">1.0.11.</span> <span class="post-toc-text">属性表： 属性个数，属性1，属性2。。。。</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-JVM-类加载的整体流程"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. JVM 类加载的整体流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（面试题）-什么情况下立即对类初始化？"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">（面试题） 什么情况下立即对类初始化？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-常量池"><span class="post-toc-number">3.</span> <span class="post-toc-text">2. 常量池</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-运行时数据区"><span class="post-toc-number">4.</span> <span class="post-toc-text">3. 运行时数据区</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#程序计数器"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">程序计数器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#方法区（永久代）"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">方法区（永久代）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运行时常量池"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">运行时常量池</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">堆</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#虚拟机栈"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">虚拟机栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#栈帧※"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">栈帧※</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#堆-展开知识-（第二期）"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">堆 展开知识 （第二期）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-gcroots-是什么？"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">1.gcroots 是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-引用链是什么？"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">2.引用链是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-对象不可达意味着什么？一定被回收吗？"><span class="post-toc-number">4.6.3.</span> <span class="post-toc-text">3.对象不可达意味着什么？一定被回收吗？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-三色标记法是什么？"><span class="post-toc-number">4.6.4.</span> <span class="post-toc-text">4.三色标记法是什么？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-有没有跨代引用的问题？※"><span class="post-toc-number">4.6.5.</span> <span class="post-toc-text">5.有没有跨代引用的问题？※</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾回收的3种算法"><span class="post-toc-number">4.6.6.</span> <span class="post-toc-text">垃圾回收的3种算法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#垃圾收集器"><span class="post-toc-number">4.6.7.</span> <span class="post-toc-text">垃圾收集器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#stop-the-word-※※"><span class="post-toc-number">4.6.8.</span> <span class="post-toc-text">stop the word ※※</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#安全点Safepoint"><span class="post-toc-number">4.6.9.</span> <span class="post-toc-text">安全点Safepoint</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#G1垃圾收集器※※"><span class="post-toc-number">4.6.10.</span> <span class="post-toc-text">G1垃圾收集器※※</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JVM调优经验-※※"><span class="post-toc-number">4.6.11.</span> <span class="post-toc-text">JVM调优经验 ※※</span></a></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    

</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://github.com/missionOdd" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="mdui-bottom-nav">
  <a href="javascript:;" class="mdui-ripple mdui-bottom-nav-active">
    <i class="mdui-icon material-icons">history</i>
    <label>Recents</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">favorite</i>
    <label>Favorites</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">&#xe80e;</i>
    <label>Hot</label>
  </a>

</div>
    <div class="bottom">
        <p>
            <span>
                Missionary &copy; 2018 - 2022
            </span>
           	
           	<span>
           		<a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备19008953号</a>
           	</span>
           	

            

            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            

            
            <span>
	            Hosted by <a href="https://coding.net/pages" target="_blank">Coding Pages</a>
            </span>
            


        </p>
        <p>
          
              
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>


          
          <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
          <script>
              var now = new Date();
              function createtime() {
                  var grt= new Date("09/15/2018 12:49:00");//此处修改你的建站时间或者网站上线时间
                  now.setTime(now.getTime()+250);
                  days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                  hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                  if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                  mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                  seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                  snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                  document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                  document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
              }
          setInterval("createtime()",250);
          </script>
        </p>
    </div>

</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light mdui-ripple"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2022/02/01/jvm-notes/&title=《jvm | 虚拟机全面扫盲+深入理解的原创笔记》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2022/02/01/jvm-notes/&title=《jvm | 虚拟机全面扫盲+深入理解的原创笔记》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3aS27DMAxF0ex/0+4CAjn3kXIBU1ejovFHxwOCpPj54HUt1v2vq+u/71r9Z/OSIUPGaxnkxWQr5K7VFmsfSIYMGacxVo++v4YEyjT4crYMGTJk1AJlGqbv3yVDhgwZHUYtHN8/R4YMGTLuGSR01tLBtDP2eC0uQ4aMFzJ41/3//37kfEOGDBmvYlzh4u02fjB5tZcMGTJmM3iAI1vhLf60PYf2I0OGjKGMdLSLv4y31fhBQpC3ypAhYxyjVmSSxJGPiHVCtgwZMs5hxDfjUNsJu+gIU4YMGaMZJBSmPXmeufEGHPpVhgwZoxk8UeskeSStrI1uyJAhYzajc2yZJoW1AQv0+WTIkDGasavs7CeO5DjhR3IpQ4aMYxhpIVoLqeRp28pXGTJkDGKkCWKtrH1k2EKGDBmjGemRQNqGS0Nw+hw0MyJDhoyXM2qlYxqm+YhG+kFlyJBxDqOW3nVGItKjzWIpK0OGjHGMTkitpZU8jKbhW4YMGfMYaXpXSxbJ9eSj/Bi2kCFDxmhGGhx50y0tUIOSlZx5ypAhYzSD55V7y9TiqJkMGTKGMq5w1ZBpQUvSynhaRIYMGa9l9KN1OhxGttIZyJAhQ8ZUxq42GT+A5Gklf44MGTJOYNQCHw/KnaZesRaXIUPGwYxOgcrb/XERK0OGDBnh5tJtkcELVMTKkCFjNKM2Frbr2DJNH2XIkHEao5PwdZp0/XRThgwZBzD+ADWQQc9xaIkyAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>



    
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/plugins/fireworks.js?v=1.4.4"></script>


    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ab84488547116c4d03e6764e6ced5433";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    
        <script type="text/javascript" src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>
    
    
        <script type="text/javascript" src="/js/plugins/gitmint.browser.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/gitment.js?v=1.4.4"></script>
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '等你回来！';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)欢迎!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>




    <script type="text/javascript">
  daovoice('init', {
    app_id: "8997440a"
  });
  daovoice('update');
</script>


    <script src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/custom.js?v=1.4.4"></script>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/js/mdui.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script type="text/javascript">
jQuery.noConflict();     //将变量$的控制权让渡
</script>
<script type="text/javascript" color="213,0,0" opacity='0.7' zIndex="-2" count="60" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<!-- <script type="text/javascript">

jQuery(function($){


});
</script> -->

</body>
</html>

<!DOCTYPE html>
<html>
<!--
　　　　　　　　  　　　/ヽ　　　　　　/ヽ
　　　　　　 　　 　　/ 　ヽ　　　 　 / 　ヽ
　   　＿＿＿＿＿＿ / 　 　 ヽ＿＿/　 　 　ヽ
　   　|　＿＿＿＿／　　　 　 　 　　   :::::::::＼
  　　| |　　　　 / ／　　　　　　＼ 　 　::::::::::::|
　 　| |　QQ　　　| （ ●）　　　 （●）  　 ::::::::::::|
　　| |191965461 |　 　　　 　　　　  　:::::::::::::|    本人一代码菜逼
　　| |　　　　 　|　 　（__人__丿   　.....:::::::::::::/   1998生
   | |＿＿＿＿　ヽ　　　　　    .....::::::::::::::::::::<    宅
　 └＿＿＿／￣￣　　　　　　    　:::::::::::::::::::::::::|  欢迎勾搭
　　|＼　　　 |　　　　　　　　　　　　:::::::::::::::::::::|
　　＼ ＼　　＼＿＿＿　　　　 　　 ::::::::::::::::::::::::|

-->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>计算机网络 | 网络知识问答梳理 | 🎉 Missionary&#39;s Blog 😆 | Missionary 中国 👋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="技术,原理,计算机网络">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">

    
        <link rel="stylesheet" href="/css/third-party/gitment.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","app_key":"CGsuOukhiIkc4nE75fKtUtXy","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","appkey":"CGsuOukhiIkc4nE75fKtUtXy","notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar","highlight":true}'),
            g: JSON.parse('{"enable":true,"lazy":true,"owner":"missionOdd","repo":"FAQ","oauth":{"client_id":"3dffefee0452a0a23205","client_secret":"1b1394230850e312a0a178bdd41c4e70893d759f"},"perPage":6}'),
            d: JSON.parse('{"app_id":"8997440a"}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
        <script type="text/javascript" src="/js/plugins/daovoice.js?v=1.4.4"></script>
    

<link rel="alternate" href="/atom.xml" title="🎉 Missionary's Blog 😆" type="application/atom+xml">
</head>

<script src="//cdnjs.cat.net/ajax/libs/pace/1.0.2/pace.min.js"></script>
<link href="//cdnjs.cat.net/ajax/libs/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/css/mdui.min.css">
<link rel="stylesheet"  href="//cdnjs.cat.net/ajax/libs/animate.css/3.5.2/animate.min.css">
<link rel="stylesheet" href="/css/custom.css?v=1.4.4">
<link href="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe.css" rel="stylesheet">
<link href="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.css" rel="stylesheet">

<body>
    <div id="loading" class="active mdui-progress">
  <div class="mdui-progress-determinate"></div>
</div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light rubberBand ">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Missionary</h5>
          <a href="mailto:z1165996866@hotmail.com" title="z1165996866@hotmail.com" class="mail">
            
              <span>z</span>
            
              <span>1</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>5</span>
            
              <span>9</span>
            
              <span>9</span>
            
              <span>6</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>h</span>
            
              <span>o</span>
            
              <span>t</span>
            
              <span>m</span>
            
              <span>a</span>
            
              <span>i</span>
            
              <span>l</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
          <a href="/atom.xml" rel="alternate" class="mdui-btn mdui-btn-dense mdui-color-theme-accent mdui-ripple">
              <i class="fa fa-rss"></i>
              RSS订阅
            </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/missionOdd" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://leetcode-cn.com/u/missionary" target="_blank">
                  <i class="icon icon-lg icon-gg-circle"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/" >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/photos" >
                <i class="icon icon-lg icon-camera"></i>
                PHOTOS
              </a>
            </li>
        
            <li class="">
              <a href="/books" >
                <i class="icon icon-lg icon-book"></i>
                BOOKS
              </a>
            </li>
        
            <li class="">
              <a href="/categories" >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags" >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives" >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about" >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/missionOdd" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                GITHUB
              </a>
            </li>
        
            <li class="">
              <a href="https://leetcode-cn.com/u/missionary/" target="_blank">
                <i class="icon icon-lg icon-gg-circle"></i>
                LEETCODE
              </a>
            </li>
        
            <li class="">
              <a href="http://weibo.com/missionodd" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                WEIBO
              </a>
            </li>
        
            <li class="">
              <a href="/custom" >
                <i class="icon icon-lg icon-plus-square"></i>
                LINKS
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>计算机网络 | 网络知识问答梳理</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title animated tada delay-5s">计算机网络 | 网络知识问答梳理</h1>
        <h5 class="subtitle animated swing delay-5s">
            
                <time datetime="2022-02-10T05:50:37.000Z" itemprop="datePublished" class="page-time">
  2022-02-10
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/计算机网络/">计算机网络</a></li></ul></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>



<div class="container body-wrap">
    <article id="post-network"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">计算机网络 | 网络知识问答梳理</h1>
        <div class="post-meta">
          
            <time class="post-time" title="2022-02-10 13:50:37" datetime="2022-02-10T05:50:37.000Z"  itemprop="datePublished">2022-02-10</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/计算机网络/">计算机网络</a></li></ul></li></ul>



            

            
<span class="post-comments-counter" id="/2022/02/10/network/">
    <span class="post-meta-item-icon">
        <i class="icon icon-comment-o"></i>
    </span>
    
    <a href="/2022/02/10/network/#gitment-display-button" onclick="ShowGitment()">
        <span class="post-comments-count gitment-comments-count" itemprop="commentsCount"></span>
    </a>
</span>



    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2022/02/10/network/#comment">
            <span class="valine-comment-count" data-xid="/2022/02/10/network/"></span>
        </a>
    </span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p><strong>序列化就是将对象转换成二进制数据的过程，以方便传输或存储。而反序列就是将二进制转换为对象的过程。</strong><br>比如 网络传输 必须是二进制，但调用方请求的出入参数都是对象。就需要转换过程，如JSON对象和二进制互转，这个过程就是序列化和反序列化。<br>JDK 原生序列化。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>无状态，双向传输基于TCP/IP，灵活，明文传输不安全</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx 提示信息 2xx 成功 3xx 重定向 4xx客户端请求错误 5xx服务器错误<br>302 重定向<br>401 权限不足，需要授权<br>403  资源拒绝访问，需要登录<br>502 网关错误<br>503 超时</p>
<h4 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h4><p>Host  指定服务器域名<br>Content-Length 长度<br>Connection：keep-alive  长连接</p>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>早起1.0 每次请求都要一次TCP三次握手；<br>1.为了解决该问题，1.1 提出了长连接，<br>通过header 配置Connection：keep-alive ，建立CS持久连接，<br>减少建立和断开的额外开销；<br>2.长连接引入，使得管道pipeline网络传输成为可能，客户端可实现连续发请求，无需等待响应的阻塞其他的请求。但是，服务器依然按照顺序回应，必须一个一个处理回应，如果前面回应慢，引起 队头阻塞。</p>
<p>1.1性能一般般，需要HTTP的优化。</p>
<h4 id="HTTPS-解决HTTP什么问题？"><a href="#HTTPS-解决HTTP什么问题？" class="headerlink" title="HTTPS 解决HTTP什么问题？"></a>HTTPS 解决HTTP什么问题？</h4><p>解决明文传输的问题，HTTPS 在HTTP与TCP层之间加入 SSL/TLS 协议。一是把信息加密，解决窃听风险，二是校验机制，解决篡改信息风险，三是身份认证，解决冒充网站风险。</p>
<p>具体来说，HTTPS是 如何解决呢？<br>一个是混合加密，采用对称加密和非对称加密结合，保证信息密文<br>对称加密：只有一个密钥，运算快，密钥保密，无法安全密钥交换。<br>非对称加密：两个密钥，公钥任意分发，私钥保密，能交换密钥但速度慢。</p>
<p>建立通信前，非对称；通信过程，对称</p>
<p>二是摘要算法，用于签名，为数据生成唯一的指纹，校验数据完整性，防篡改。<br>摘要算法一般是不可逆的 ，散列函数与md5与sha系列。客户端在发送前，会通过摘要算法对明文计算，算出一个摘要指纹，把【摘要+明文】加密；在发送后，服务器解密得到【摘要+明文】，用同一个摘要算法对明文计算，算出摘要，并比对传过来的摘要是否想等。</p>
<p>三是数字证书<br>客户端先向服务器索取公钥，然后用公钥机密，传入服务器给私钥解密。<br>虽然摘要算法保证了数据不被篡改，但是，如何保证公钥不被篡改？<br>这个需要第三方权威机构CA，颁发数字证书，将服务器公钥放在数字证书。只要证书可信，公钥就是可信。<br>CA机构是分级的，树型，最顶是根CA，必须相信。<br>如何申请？<br>我们首先要知道，CA有自己的私钥，每个客户端都内置<br>已信任的CA的公钥。<br>1，服务器吧自己公钥注册给CA，<br>2，CA用自己私钥给公钥签名并颁发数字帐户上，<br>3，第一次客户端请求服务器，会拿到数字证书，会使用事先已内置浏览器或OS的CA公钥，校验数字证书真实性。<br>4，认证证书后，就获取服务器的公钥，加密报文数据，给服务私钥解密。</p>
<p>Q：HTTPS是如何建立连接的？期间交互了什么？<br>SSL/TLS 协议流程：<br>基本流程：C向S索取公钥，双方协商生成会话密钥，双方密钥通信。<br>前两步就是握手阶段。<br>详细流程：<br>握手四次通信：<br>1，ClientHello：客户端发送加密通信请求，这一步，客户端主要向服务端发送：TLS版本，客户端随机数（用于生产会话密钥），支持的加密算法列表</p>
<p>2， SeverHello，服务器回应：1，确认TLS版本，若浏览器不支持，关闭加密通信；2，服务端随机数（用于生产会话密钥），3，确认加密算法列表，4，数字证书。</p>
<p>3，客户端回应<br>首先通过客户端CA公钥校验证书，取出公钥，加密报文，向服务器发送：随机数（会被服务器公钥加密），加密通信算法改变通知（表示之后都是会话密钥通信），握手结束通知（表示客户端握手阶段结束，这里还会把数据做个摘要，发送给服务端校验）</p>
<ol start="4">
<li>服务器的最后响应<br>这个过程产生3个随机数，通过加密算法的协商后，计算出本次通信的会话密钥。然后，向客户端发送最后端消息：<br>1，加密算法改变通知（之后都是会话密钥通信）；<br>2，服务端握手结束通知，表示服务端握手已结束（这里同时会把数据做个摘要，给客户端校验）。</li>
</ol>
<p>接下来就是，用会话密钥加密的HTTP请求。</p>
<h4 id="HTTP1-1-HTTP2-0-HTTP3-演变；"><a href="#HTTP1-1-HTTP2-0-HTTP3-演变；" class="headerlink" title="HTTP1.1 /HTTP2.0/HTTP3 演变；"></a>HTTP1.1 /HTTP2.0/HTTP3 演变；</h4><p>首先，将HTTP1.1 相比HTTP1.0 增加 TCP长连接，支持管道传输，节省了频繁建立和断开TCP的性能开销，减少多次请求等待的响应时间。<br>但是，有1.1的问题有三个：<br>一是数据太大，只压缩body，占用带宽；<br>二是队头阻塞，服务器顺序响应，一旦响应过慢，导致后续阻塞。<br>三是单向请求，不适应服务器推送场景。</p>
<p>那么，针对这些问题，HTTP2 进行改进：<br>一是头部压缩，如果头相同或相似，协议会自己消除重复，这是HPACK算法，实现原理是：客户端和服务端同时维护一张头表信息，所有字段都会存入这个表，生成一个索引号，只传输索引号即可，提高速度；<br>二是纯二进制格式，1.1 只是文本，头和主体用空格隔开，2.0头帧和数据帧都是二进制，也是提高传输速度。<br>三是数据流发送，不再像1.1顺序发送顺序响应，而是对数据包做标记，指出它属于哪个回应，同一连接发送连续数据包，每个请求或回应的所有数据包，统称为stream流。</p>
<p>三是数据流<br>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>
<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>
<p>四是多路复用<br>http2在一个连接里并发处理请求或回应，不再是按照顺序对应，不需排队，就没有队头阻塞问题。</p>
<p>五是服务器推送<br>增加新功能，不再是请求-答应模式，而是服务器主动推送消息。<br>比如，初始化HTML是，可以主动推送静态JS，CS到客户端，减少延迟等待。就是Server Push，可减少了多个RTT。</p>
<p>http2 缺陷：<br>多个HTTP请求复用1个TCP连接，下层的TCP协议不知道有多少个HTTP请求；<br>一旦丢包，触发TCP重传机制，此时，HTTP必须等待丢的包被重新传回来，这样阻塞了所有HTTP请求。</p>
<p>HTTP3 改成了UDP！<br>UDP不管顺序，不管丢包，不会出现队头阻塞，也不会出现丢包全部重传问题。</p>
<p>UDP不可靠，那么怎么实现类似TCP可靠呢？<br>QUIC协议保证。当某个流发生丢包，会阻塞这个流，其他流不受影响。然后是TLS1.3 把6次TCP+TLS握手合并为3次QUIC。<br>QUIC是一个UDP之上的伪TCP+TLS+HTTP2的多路复用协议。</p>
<h2 id="Q：一次请求发生了什么？"><a href="#Q：一次请求发生了什么？" class="headerlink" title="Q：一次请求发生了什么？"></a>Q：一次请求发生了什么？</h2><p>一是对URL解析，来确定是发送给WEB服务器请求。<br>包括协议头，服务器host，uri路径。<br>二是查询真真实IP，使用DNS服务器解析。在发送消息前，委托系统查询DNS服务器域名的真实IP。DNS服务器具有树状的层级，根域服务器保存所有域名，顶级域名服务器更少，只保存com或cn后缀的，权威域名保存更少，同时服务器数量也更多。<br>解析过程：客户端发出DNS请求，询问IP，在本地DNS服务器找，如果有自己返回IP，如果没有，委托根域名，根域名委托对应的顶级域名服务器，顶级域名服务器委托对应的权威域名服务器。权威域名服务器找到IP，告诉本地DNS缓存。</p>
<p>三是协议栈 封装<br><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="3786F82F-6457-4550-A5A9-F1596205ABCA_20220228150247.png?v=1&type=image&token=V1:oAbMgcxeh4dd0mWA7fwzOxMQAo_vAQ8ncn8Cu-rEqrw" title="输入图片描述" data-fancybox="images"><img src="3786F82F-6457-4550-A5A9-F1596205ABCA_20220228150247.png?v=1&type=image&token=V1:oAbMgcxeh4dd0mWA7fwzOxMQAo_vAQ8ncn8Cu-rEqrw" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure><br>通过DNS获取IP后，就可以把HTTP的传输工作交给OS的协议栈。<br>协议栈的内部分为几部分，分别承担不同工作，上下关系有一定规则，上面会向下委托公，下面收到委托并执行。</p>
<p>应用程序通过调用socket 库，来委托协议栈工作，协议栈的上方分别是收发数据的TCP和UDP协议，下方是IP协议控制网络包的收发操作，在互联网上传数据时，数据会被切成一块块的网络包，而将网络包发送给对方的操作就是有IP负责。</p>
<p>IP包括ICMP协议 和ARP协议。<br>ICMP时告知网络包传输过程中产生的错误和各种控制信息。<br>ARP 是根据IP地址查询相应的以太网MAC地址。</p>
<p>IP下面是网卡驱动程序，负责控制网卡硬件。最下是网卡硬件，真正的网络信号的收发操作</p>
<p>四，细看，可靠传输TCP<br>先讲讲TCP，序号解决包乱序，校验和解决完整性，窗口大小声明窗口大小，解决两端流量处理能力的控制。此外，拥塞控制，控制发送的速度。</p>
<p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p>
<p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p>
<ul>
<li><p>一开始，客户端和服务端都处于  <code>CLOSED</code>  状态。先是服务端主动监听某个端口，处于  <code>LISTEN</code>  状态。</p>
</li>
<li><p>然后客户端主动发起连接  <code>SYN</code>，之后处于  <code>SYN-SENT</code>  状态。</p>
</li>
<li><p>服务端收到发起的连接，返回  <code>SYN</code>，并且  <code>ACK</code>  客户端的  <code>SYN</code>，之后处于  <code>SYN-RCVD</code>  状态。</p>
</li>
<li><p>客户端收到服务端发送的  <code>SYN</code>  和  <code>ACK</code>  之后，发送  <code>ACK</code>  的  <code>ACK</code>，之后处于  <code>ESTABLISHED</code>  状态，因为它一发一收成功了。</p>
</li>
<li><p>服务端收到  <code>ACK</code>  的  <code>ACK</code>  之后，处于  <code>ESTABLISHED</code>  状态，因为它也一发一收了。</p>
</li>
</ul>
<p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p>
<p>查看连接命令： netstat - napt 命令</p>
<h3 id="TCP-分割数据"><a href="#TCP-分割数据" class="headerlink" title="TCP 分割数据"></a>TCP 分割数据</h3><p>如果HTTP消息过长，超过了MSS的长度。<br>TCP 就要把HTTP的数据拆解一块块的数据发送，而不是一次性发送。</p>
<ul>
<li><code>MTU</code>：一个网络包的最大长度，以太网中一般为  <code>1500</code>  字节。</li>
</ul>
<ul>
<li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li>
</ul>
<p>数据会被拆为MSS长度的单位，并加上TCP头，然后交给IP模块发送数据。</p>
<p>TCP会有两个端口，一个是浏览器监听 的短裤，随机，一个是服务器监听的80或443</p>
<figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="1ADA371D-52C5-44D6-9231-F5087EA7028A_20220228214150.png?v=1&type=image&token=V1:W1SnXQS3hWpVDWnHs53IsS8_HVJPDaPjIDjB3kjENfE" title="输入图片描述" data-fancybox="images"><img src="1ADA371D-52C5-44D6-9231-F5087EA7028A_20220228214150.png?v=1&type=image&token=V1:W1SnXQS3hWpVDWnHs53IsS8_HVJPDaPjIDjB3kjENfE" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<p>双方建立连接后，TCP报文的数据部分就是存放HTTP头+数据，组装好TCP报文之后，要交给下面的网络层处理</p>
<h3 id="远程定位-—-IP"><a href="#远程定位-—-IP" class="headerlink" title="远程定位 —- IP"></a>远程定位 —- IP</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p>
<blockquote>
<p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p>
</blockquote>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p>
<p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p>
<h3 id="两点传输-—-MAC"><a href="#两点传输-—-MAC" class="headerlink" title="两点传输 — MAC"></a>两点传输 — MAC</h3><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p>
<p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p>
<ul>
<li><p><code>0800</code>  ：IP 协议</p>
</li>
<li><p><code>0806</code>  ：ARP 协议</p>
</li>
</ul>
<p>先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给  <code>Gateway</code>  列中的 IP 地址就可以了。</p>
<blockquote>
<p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p>
</blockquote>
<p>不知道对方 MAC 地址？不知道就喊呗。</p>
<p>此时就需要  <code>ARP</code>  协议帮我们找到路由器的 MAC 地址。</p>
<ul>
<li><p>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</p>
</li>
<li><p>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。如果对方和自己处于同一个子网中，那么就可以得到对方回应的 MAC 地址。</p>
<figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="A2E4BDD3-A5A6-44FA-8DFB-1E15722CE355_20220228221916.png?v=1&type=image&token=V1:RuUiMFuU-xJwTZUlj7ESjyJf8vlHyb066kLrMrfYN4s" title="输入图片描述" data-fancybox="images"><img src="A2E4BDD3-A5A6-44FA-8DFB-1E15722CE355_20220228221916.png?v=1&type=image&token=V1:RuUiMFuU-xJwTZUlj7ESjyJf8vlHyb066kLrMrfYN4s" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<h4 id="出口—-网卡"><a href="#出口—-网卡" class="headerlink" title="出口— 网卡"></a>出口— 网卡</h4><p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p>
</li>
</ul>
<p>网卡驱动从 IP 模块获取到包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS</strong>。</p>
<h4 id="送别者—-交换机"><a href="#送别者—-交换机" class="headerlink" title="送别者—-交换机"></a>送别者—-交换机</h4><p>交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p>
<p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p>
<p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p>
<p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p>
<p>交换机的 MAC 地址表主要包含两个信息：</p>
<ul>
<li><p>一个是设备的 MAC 地址，</p>
</li>
<li><p>另一个是该设备连接在交换机的哪个端口上。</p>
</li>
</ul>
<p><strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p>
<p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p>
<p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p>
<h4 id="出境大门-—-路由器"><a href="#出境大门-—-路由器" class="headerlink" title="出境大门 — 路由器"></a>出境大门 — 路由器</h4><p>路由器是基于IP设计，俗称三层网路设备，各个端口都有MAC地址和IP地址；<br>而交换机是基于以太网设计，俗称二层网络设备，端口不具备MAC地址。</p>
<p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p>
<p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p>
<p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p>
<p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p>
<p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p>
<p>接下来就会进入包的<strong>发送操作</strong>。</p>
<p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p>
<ul>
<li><p>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</p>
</li>
<li><p>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</p>
</li>
</ul>
<p>知道对方的 IP 地址之后，接下来需要通过  <code>ARP</code>  协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p>
<p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p>
<p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p>
<p>发送出去的网络包会通过<strong>交换机</strong>（城门）到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。（服务器内网）</p>
<p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p>
<p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p>
<h3 id="互相扒皮—-服务器-与-客户端"><a href="#互相扒皮—-服务器-与-客户端" class="headerlink" title="互相扒皮— 服务器 与 客户端"></a>互相扒皮— 服务器 与 客户端</h3><p>应用层 HTTP<br>传输层 TCP<br>网络层 IP<br>链路层 以太网MAC<br>从高到低封装，从低到高拆解。</p>
<p>当 扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p>
<p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p>
<p>———————<br>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p>
<p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p>
<p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p>
<p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。</p>
<p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p>
<h3 id="扩展-ping原理-ICMP协议"><a href="#扩展-ping原理-ICMP协议" class="headerlink" title="扩展 ping原理 ICMP协议"></a>扩展 ping原理 ICMP协议</h3><p>也就是<strong>互联网控制报文协议</strong>，<code>ICMP</code> 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<h2 id="细说-TCP"><a href="#细说-TCP" class="headerlink" title="细说 TCP"></a>细说 TCP</h2><p>首先，介绍TCP 头部格式。<br><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="797DA83E-0574-4D7F-82CC-3440F36357D5_20220228224408.png?v=1&type=image&token=V1:XWMOSp193u83j6GshiGPmz4BIwQWv6PlX8pyz8iT894" title="输入图片描述" data-fancybox="images"><img src="797DA83E-0574-4D7F-82CC-3440F36357D5_20220228224408.png?v=1&type=image&token=V1:XWMOSp193u83j6GshiGPmz4BIwQWv6PlX8pyz8iT894" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure></p>
<p>序列号：在建立连接时由计算机生成的随机数作为初始值，通过SYN包传输给接收端，每一次累加该数据字节的大小，解决乱序问题。</p>
<p>确认应答号：指下一次期望收到的数据的序列号，用来解决不丢包问题。</p>
<p>控制位：确认答应，异常断开，chu，结束</p>
<h3 id="Q：为什么需要-TCP-协议？TCP-工作在哪一层？"><a href="#Q：为什么需要-TCP-协议？TCP-工作在哪一层？" class="headerlink" title="Q：为什么需要 TCP 协议？TCP 工作在哪一层？"></a>Q：为什么需要 TCP 协议？TCP 工作在哪一层？</h3><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="858E392E-2252-4CEA-A6B2-87A10AC1A95D_20220228225120.png?v=1&type=image&token=V1:OVmGFxz0wgPu7a6SeFkKHnHEzk7UBhhYa7LWsxI8GDs" title="输入图片描述" data-fancybox="images"><img src="858E392E-2252-4CEA-A6B2-87A10AC1A95D_20220228225120.png?v=1&type=image&token=V1:OVmGFxz0wgPu7a6SeFkKHnHEzk7UBhhYa7LWsxI8GDs" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<h3 id="Q：什么是-TCP-？"><a href="#Q：什么是-TCP-？" class="headerlink" title="Q：什么是 TCP ？"></a>Q：什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
</li>
</ul>
<h3 id="Q：什么是TCP连接？"><a href="#Q：什么是TCP连接？" class="headerlink" title="Q：什么是TCP连接？"></a>Q：什么是TCP连接？</h3><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p>
<h3 id="Q：如何唯一确定一个TCP连接？"><a href="#Q：如何唯一确定一个TCP连接？" class="headerlink" title="Q：如何唯一确定一个TCP连接？"></a>Q：如何唯一确定一个TCP连接？</h3><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li><p>源地址</p>
</li>
<li><p>源端口</p>
</li>
<li><p>目的地址</p>
</li>
<li><p>目的端口</p>
</li>
</ul>
<h3 id="Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a>Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</h3><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p>
<p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:<br>最大TCP连接数 = 客户端IP数 x 客户端端口数<br>对于IPv4，2的32次方IP ，2的16次方端口，最大TCP连接数是2的48次方。</p>
<p>这是理论值，实际上：<br>Linux 文件描述符限制，socket是fd文件，打开句柄 1024，这个可调。<br>另一个是内存限制，每个TCP连接占用一定的内存。</p>
<h3 id="Q：UDP和TCP区别与场景？"><a href="#Q：UDP和TCP区别与场景？" class="headerlink" title="Q：UDP和TCP区别与场景？"></a>Q：UDP和TCP区别与场景？</h3><p>UDP 不提供控制机制，利用IP提高的无连接通信<br>UDP 协议简单，头部8字节，分别是 16位源端口，16位目标端口，16位包长度，16位校验和</p>
<p>区别：<br>1，连接<br>TCP面向连接，传输数据前先建立连接<br>UDP无连接<br>2，服务对象<br>TCP连接一对一<br>UDP一对一，一对多，多对多广播<br>3，可靠性<br>TCP可靠，校验和保证无差错，确认答应号保证不丢失，序号保证不重复，顺序性，<br>UDP不可靠，只是尽最大努力交付<br>4，拥塞控制，流量控制<br>TCP拥塞控制和流量控制，保证数据传输多安全性；<br>UPD即使网络非常堵塞，也不影响UDP发送速率<br>5，首部开销<br>TCP首部长度较长，不包括【选项】，20字节；<br>UDP首部只有8字节</p>
<p>6，应用场景<br>TCP：FTP文件传输 HTTP/HTTPS<br>UDP：DNS，视频，音频，广播通信</p>
<h3 id="Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a>Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h3><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<p>选项 常见：MSS最长报文大小</p>
<h3 id="Q：为什么是3次握手？不是两次，四次？"><a href="#Q：为什么是3次握手？不是两次，四次？" class="headerlink" title="Q：为什么是3次握手？不是两次，四次？"></a>Q：为什么是3次握手？不是两次，四次？</h3><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”但是，回答过于片面。<br>首先，了解TCP连接的连接概念。</p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li>
</ul>
<p>那么，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接</strong></p>
<p>接下来，我从3个方面回答：</p>
<ul>
<li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
</ul>
<p>原因一：避免历史连接<br>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong>。</p>
<p>如果旧SYN报文比当前SYN报文先抵达到服务端，服务端会返回SYN+ACK，客户端根据自身上下问题，判断是旧连接，那么客户端发送RST报文，表示中断这一次连接。舍弃之前的，重新开始新的SYN。</p>
<p>如果是两次握手，服务端就不能判断出历史连接而中断。</p>
<ul>
<li><p>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是  <code>RST</code>  报文，以此中止历史连接；</p>
</li>
<li><p>如果不是历史连接，则第三次发送的报文是  <code>ACK</code>  报文，通信双方就会成功建立连接；</p>
</li>
</ul>
<p>原因二：同步双方初始序列号<br>TCP协议双方，都必须维护一个序列号，序列号是可靠传输的关键：可以去重，可以顺序接收，可以表示哪些数据包已经被对方接收。</p>
<p>第一次客户端发送初始序列号SYN，服务端需要ACK回应，同时发生自己的出生序列号SYN，客户端当然也要回应接收。<br>这样来回，次确保双方初始序列号被对方知晓。</p>
<p>原因三：避免资源浪费</p>
<p>如果只有两次握手，服务器ACK不知道客户端是否已经接收，这就导致服务端每次收到SYN就主动建立一个连接，这就有个问题，如果客户端SYN传输被网络阻塞，而引起了超时重发，之后阻塞的SYN也终于发送到服务端，意味着服务端接收了2次相同的SYN，服务器会重复处理请求，造成重复分配资源。</p>
<p>小结：三次握手是为了防止历史连接的 建立，帮助双方初始化序列号，减少重复资源的开销。<br>两次握手无法做到以上这些，四次握手显得多余。</p>
<h3 id="Q：为什么客户端和服务端的初始序列号ISN不相同？"><a href="#Q：为什么客户端和服务端的初始序列号ISN不相同？" class="headerlink" title="Q：为什么客户端和服务端的初始序列号ISN不相同？"></a>Q：为什么客户端和服务端的初始序列号ISN不相同？</h3><p>报文延迟，复制重发，丢失等造成不同连接之间互相影响，客户端和服务端初始化序列号不同，是为了兼容这些问题环境。</p>
<h3 id="Q：IP层会分片，TCP为什么要MSS？"><a href="#Q：IP层会分片，TCP为什么要MSS？" class="headerlink" title="Q：IP层会分片，TCP为什么要MSS？"></a>Q：IP层会分片，TCP为什么要MSS？</h3><p>首先介绍MTU 和 MSS。<br>MTU： 一个网络包的最大长度，以太网中一般位1500字节。<br>MSS：一个减去IP 和TCP 头部的网络包数据的最大长度</p>
<p>如果仅TCP报文交给IP分片，IP层超过一个MTU大小的数据发送，就要进行分片，把数据分片成若干片，保证每一个分片都小于MTU。分片后，由目标主机的IP层重新组装，再交给TCP传输层。</p>
<p>这里存在一个隐患，如果一个IP分片丢失，就需要整个IP报文的所有分片重传，因为IP层没有超时重传机制，那么，它由传输层TCP来负责超时和重传，接收方发现缺失，不会响应ACK，而是等对方超时后，重发整个TCO报文。</p>
<p>这样，非常无效率。</p>
<p>所以，TCP建立连接时，双方协商MSS值，当TCP层发现数据超过MSS时，就会先分片，他肯定不会大于MTU。IP自然不用分片。</p>
<p>经过TCP层分片后，如果TCP分片丢失，超时重发只是发送一个MSS单位的分片，大大增加重传的效率？</p>
<h3 id="Q：SYN攻击是什么？如何避免？"><a href="#Q：SYN攻击是什么？如何避免？" class="headerlink" title="Q：SYN攻击是什么？如何避免？"></a>Q：SYN攻击是什么？如何避免？</h3><p>就是在三次握手过程，攻击者伪造不同IP一直发送SYN报文，服务端接收后，就进入SYN_RCVD状态，且服务端发送ACK+SYN报文无回应，久而久之就会占满SYN接收队列（未连接队列），使得服务器不能正常给用户连接。</p>
<p>如何避免？<br>一是修改Linux内核参数，控制队列大小和饱和策略。<br>比如，限制SYN_RCVD状态连接的最大个数，超出处理能力时，采取丢弃策略。</p>
<p>二是启动sync cookies<br>首先，正常情况下：</p>
<ul>
<li><p>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</p>
</li>
<li><p>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</p>
</li>
<li><p>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</p>
</li>
<li><p>应用通过调用  <code>accept()</code>  socket 接口，从「 Accept 队列」取出的连接。</p>
</li>
<li><p>如果accept方法调用过慢时，就会导致「 Accept 队列」被占满。</p>
</li>
<li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li>
</ul>
<p>但开启sync cookies 后</p>
<ul>
<li><p>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</p>
</li>
<li><p>计算出一个  <code>cookie</code>  值，再以 SYN + ACK 中的「序列号」返回客户端，</p>
</li>
<li><p>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</p>
</li>
<li><p>最后应用通过调用  <code>accpet()</code>  socket 接口，从「 Accept 队列」取出的连接。</p>
</li>
</ul>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>客户端发送首部FIN=1 的TCP报文，即FIN报文，之后进入FIN等待1状态。<br>服务端接收后响应ACK，进入等待关闭状态。<br>客户端接收ACK后，进入FIN等待2状态<br>等服务处理后面，再发送FIN报文，然后进入等待最后ACK状态。<br>客户端收到后，会一个ACK，进入时间等待状态TIME_WAIT。<br>服务器收到后，关闭连接。<br>服务端经过2MSL时间后，关闭连接。</p>
<p>每个方向都需要FIN 和 ACK，这里需要注意，TIME_WAIT是主动关闭连接才有</p>
<h4 id="Q：-为什么四次挥手？"><a href="#Q：-为什么四次挥手？" class="headerlink" title="Q： 为什么四次挥手？"></a>Q： 为什么四次挥手？</h4><p>因为双方都需要分开发送一个FIN 和分开响应一个ACK，来告知和确认。</p>
<h4 id="Q：为什么TIME-WAIT等待是2MSL？"><a href="#Q：为什么TIME-WAIT等待是2MSL？" class="headerlink" title="Q：为什么TIME_WAIT等待是2MSL？"></a>Q：为什么TIME_WAIT等待是2MSL？</h4><p>MSL是最大报文生存时间，它是任何报文在网络上生存的最长时间。<br>顺便一提，TTL是经过路由的跳数。MSL要大于等于TTL消耗位0的时间。</p>
<p>TIME_WAIT持续2倍MSL，在Linux中是60s，说白来，这其实是要等报文一来一回的时间。<br>比如，如果对方没有接收到最后ACK，超时重传FIN报文，然后我接收到FIN报文，ACK与重传FIN 正好一来一回，2MSL足够时间让我接收重传的FIN报文，之后，我重发ACK，2MSL重新计时。</p>
<h4 id="Q：为什么需要TIME-WAIT？"><a href="#Q：为什么需要TIME-WAIT？" class="headerlink" title="Q：为什么需要TIME_WAIT？"></a>Q：为什么需要TIME_WAIT？</h4><p>原因一 ： 防止旧连接的数据包<br>比如，双方关闭连接后，服务端的相同端口号的TCP连接被重用。<br>如果TIME_WAIT没有或过短，上一次由服务器发送，但被网络阻塞的报文，会现在发送过来给一个新的客户端，导致数据错乱。<br>等待2MSL时间，保证服务器所有数据包自然死亡。</p>
<p>原因二：保证连接正确关闭：<br>TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>如果TIME_WAIT没有或过短，</p>
<ul>
<li><p>客户端四次挥手的最后一个  <code>ACK</code>  报文如果在网络中被丢失了，此时如果客户端  <code>TIME-WAIT</code>  过短或没有，则就直接进入了  <code>CLOSE</code>  状态了，那么服务端则会一直处在  <code>LASE-ACK</code>  状态。</p>
</li>
<li><p>当客户端发起建立连接的  <code>SYN</code>  请求报文后，服务端会发送  <code>RST</code>  报文给客户端，连接建立的过程就会被终止。</p>
</li>
</ul>
<h4 id="Q：TIME-WAIT-过多有什么危害？"><a href="#Q：TIME-WAIT-过多有什么危害？" class="headerlink" title="Q：TIME_WAIT 过多有什么危害？"></a>Q：TIME_WAIT 过多有什么危害？</h4><ul>
<li><p>第一是内存资源占用；</p>
</li>
<li><p>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</p>
</li>
</ul>
<h4 id="Q：-如何优化TIME-WAIT？"><a href="#Q：-如何优化TIME-WAIT？" class="headerlink" title="Q： 如何优化TIME_WAIT？"></a>Q： 如何优化TIME_WAIT？</h4><p>一是可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。<br>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p>
<p>由于引入了时间戳，我们在前面提到的  <code>2MSL</code>  问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p>温馨提醒：<code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持  <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。小林在工作中就遇到过。。。排查了非常的久</p>
<p>二是当系统中处于 TIME_WAIT 的连接<strong>一旦超过一个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong>，问题更多</p>
<p>三是我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<h4 id="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="88C54A0C-F18F-40A7-80F3-578C2C001BB3_20220301030128.png?v=1&type=image&token=V1:Yz1FxBY8R886pfetwNkycQ_fy2Zif_dTF5s4IPh4cbw" title="输入图片描述" data-fancybox="images"><img src="88C54A0C-F18F-40A7-80F3-578C2C001BB3_20220301030128.png?v=1&type=image&token=V1:Yz1FxBY8R886pfetwNkycQ_fy2Zif_dTF5s4IPh4cbw" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<ul>
<li><p>服务端和客户端初始化  <code>socket</code>，得到文件描述符；</p>
</li>
<li><p>服务端调用  <code>bind</code>，将绑定在 IP 地址和端口;</p>
</li>
<li><p>服务端调用  <code>listen</code>，进行监听；</p>
</li>
<li><p>服务端调用  <code>accept</code>，等待客户端连接；</p>
</li>
<li><p>客户端调用  <code>connect</code>，向服务器端的地址和端口发起连接请求；</p>
</li>
<li><p>服务端  <code>accept</code>  返回用于传输的  <code>socket</code>  的文件描述符；</p>
</li>
<li><p>客户端调用  <code>write</code>  写入数据；服务端调用  <code>read</code>  读取数据；</p>
</li>
<li><p>客户端断开连接时，会调用  <code>close</code>，那么服务端  <code>read</code>  读取数据的时候，就会读取到了  <code>EOF</code>，待处理完数据后，服务端调用  <code>close</code>，表示连接关闭。</p>
</li>
</ul>
<p>这里需要注意的是，服务端调用  <code>accept</code>  时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h3 id="Q：-listen-时候参数-backlog-的意义？"><a href="#Q：-listen-时候参数-backlog-的意义？" class="headerlink" title="Q： listen 时候参数 backlog 的意义？"></a>Q： listen 时候参数 backlog 的意义？</h3><p>Linux内核中会维护两个队列：</p>
<ul>
<li><p>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</p>
</li>
<li><p>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</p>
</li>
</ul>
<figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="E5A16EFC-F8E5-413F-A373-A9AE832AB3EA_20220301030414.png?v=1&type=image&token=V1:IrGEHjzfy7HoFoFVvIODOCSedyypxsuKtA6k7XErHQs" title="输入图片描述" data-fancybox="images"><img src="E5A16EFC-F8E5-413F-A373-A9AE832AB3EA_20220301030414.png?v=1&type=image&token=V1:IrGEHjzfy7HoFoFVvIODOCSedyypxsuKtA6k7XErHQs" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p>
<h4 id="Q：什么是-TCP-半连接队列和全连接队列？"><a href="#Q：什么是-TCP-半连接队列和全连接队列？" class="headerlink" title="Q：什么是 TCP 半连接队列和全连接队列？"></a>Q：<strong>什么是 TCP 半连接队列和全连接队列？</strong></h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<p>半连接队列，也称 SYN 队列；全连接队列，也称 accepet 队列；服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来</strong>。</p>
<p><a rel=计算机网络 | 网络知识问答梳理 href="3b87e950352ac65c20611873e5e4751793138a62.jpeg" title="img" data-fancybox="images"><img src="3b87e950352ac65c20611873e5e4751793138a62.jpeg" alt="img"></a></p>
<h3 id="Q：accept-发送在三次握手的哪一步？"><a href="#Q：accept-发送在三次握手的哪一步？" class="headerlink" title="Q：accept 发送在三次握手的哪一步？"></a>Q：accept 发送在三次握手的哪一步？</h3><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="2F2DCEA4-F84A-44B5-B5FD-F3F1F9292894_20220301030519.png?v=1&type=image&token=V1:E9Nf8kAwwyq1S2JJ4Qqf53TxBVbnze5R7dw2mCAKtEA" title="输入图片描述" data-fancybox="images"><img src="2F2DCEA4-F84A-44B5-B5FD-F3F1F9292894_20220301030519.png?v=1&type=image&token=V1:E9Nf8kAwwyq1S2JJ4Qqf53TxBVbnze5R7dw2mCAKtEA" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<h3 id="Q：客户端调用-close-了，连接是断开的流程是什么？"><a href="#Q：客户端调用-close-了，连接是断开的流程是什么？" class="headerlink" title="Q：客户端调用 close 了，连接是断开的流程是什么？"></a>Q：客户端调用 close 了，连接是断开的流程是什么？</h3><figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="FF99FD84-160C-451C-9D75-9BA45177F732_20220301030633.png?v=1&type=image&token=V1:Gby9jS5wb0Zu6mRJVZlZ6LovpSaNhvuwrtvx92VrAoM" title="输入图片描述" data-fancybox="images"><img src="FF99FD84-160C-451C-9D75-9BA45177F732_20220301030633.png?v=1&type=image&token=V1:Gby9jS5wb0Zu6mRJVZlZ6LovpSaNhvuwrtvx92VrAoM" alt="输入图片描述" title class></a>
                <p>输入图片描述</p>
            </figure>
<p>————————————————</p>
<h4 id="Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？"><a href="#Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？" class="headerlink" title="Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？"></a>Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？</h4><p>如果有保活机制</p>
<ul>
<li><p>如果<strong>对端程序是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p>
</li>
<li><p>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p>
</li>
</ul>
<p>没有的话：</p>
<p>如果客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程</p>
<p>kill -9 来模拟进程崩溃的情况，发现<strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。<br>如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</p>
<ul>
<li><p>第一种，客户端主机宕机，又迅速重启，会发生什么？</p>
</li>
<li><p>第二种，客户端主机宕机，一直没有重启，会发生什么？</p>
</li>
</ul>
<p>客户端主机宕机，又迅速重启</p>
<p>在客户端主机宕机后，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。</p>
<p>客户端主机宕机，一直没有重启</p>
<p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了</p>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 TCP会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。接收方发送的确认报文中的window字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p>
<figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="image-20210921112213523.png" title="img" data-fancybox="images"><img src="image-20210921112213523.png" alt="img" title class></a>
                <p>img</p>
            </figure>
<p>TCP头包含window字段，16bit位，它代表的是窗口的字节容量，最大为65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p>
<h2 id="详细讲一下拥塞控制？"><a href="#详细讲一下拥塞控制？" class="headerlink" title="详细讲一下拥塞控制？"></a>详细讲一下拥塞控制？</h2><p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p>
<figure class="image-box">
                <a rel=计算机网络 | 网络知识问答梳理 href="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" title="img" data-fancybox="images"><img src="%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" alt="img" title class></a>
                <p>img</p>
            </figure>
<h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。</p>
<p> 当 cwnd &lt; ssthresh 时，使用慢开始<a href>算法</a>。</p>
<p> 当 cwnd &gt; ssthresh 时，停止使用慢开始<a href>算法</a>而改用拥塞避免<a href>算法</a>。</p>
<p> 当 cwnd = ssthresh 时，既可使用慢开始<a href>算法</a>，也可使用拥塞控制避免<a href>算法</a>。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>让拥塞窗口cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始<a href>算法</a>。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口cwnd又设置为1，因而降低了传输效率。</p>
<p>快重传<a href>算法</a>可以避免这个问题。快重传<a href>算法</a>首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送方连续收到三个重复确认，就会把慢开始门限ssthresh减半，接着把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免<a href>算法</a>，使拥塞窗口缓慢地线性增大。</p>
<p>在采用快恢复<a href>算法</a>时，慢开始<a href>算法</a>只是在TCP连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p>
<p>常见重传机制：</p>
<p>超时重传</p>
<p>快速重传</p>
<p>SACK</p>
<p>D-SACK</p>
<h1 id="TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解"><a href="#TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解" class="headerlink" title="TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解"></a>TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解</h1><p><a href="https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Tc09ovdNacOtnMOMeRc_uA</a></p>
<h1 id="精炼版"><a href="#精炼版" class="headerlink" title="精炼版"></a>精炼版</h1><p><a href="https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/plkDQ4YCawcLOr5In_L8TQ</a></p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2022-03-17T14:30:03.601Z" itemprop="dateUpdated">2022-03-17 22:30:03</time>
</span><br>


        
        转载自：小林Coding图解网络
        
    </div>
    <div class="mdui-chip" id="accost-btn">
      <span class="mdui-chip-icon mdui-color-red-a700"><i class="mdui-icon material-icons">&#xe311;</i></span>
      <span class="mdui-chip-title">Accost</span>
    </div>
    <footer>
      <div class="mdui-chip">
        <a href="https://missionodd.github.io/missionOdd">
            <img src="/img/avatar.jpg" alt="Missionary">
             About Missionary
        </a>
        </div>
    </footer>
</blockquote>


        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://missionodd.github.io/missionOdd/2022/02/10/network/&title=《计算机网络 | 网络知识问答梳理》 — 🎉 Missionary's Blog 😆&pic=https://missionodd.github.io/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://missionodd.github.io/missionOdd/2022/02/10/network/&title=《计算机网络 | 网络知识问答梳理》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            <div class="mdui-container">
  <div class="mdui-tab" id="tab">
    <a href="#tab1-content" id="tab1" class="mdui-ripple">游客用户</a>
    <a href="#tab2-content" id="tab2" class="mdui-tab-active mdui-ripple">GitHub账户</a>
  </div>

  <div id="tab1-content" class="mdui-p-a-2">
    
      <div id="comment" style=""></div>

  </div>
  <div id="tab2-content" class="mdui-p-a-2">
    
          
    <div onclick="ShowGitment()" id="gitment-display-button" style="display: block;">
        <span>显示 Gitment 评论</span>
    </div>
    <div id="gitment" class="hide"></div>


    
  </div>

</div>

        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2022/02/12/p8-interview-skills-2/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">面经 | 结合业务，步步深入，P8架构师二面摘录笔记</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2022/02/10/redis-principle-cluster/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Redis | 底层数据结构 | 主从复制</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列化和反序列化"><span class="post-toc-number">1.</span> <span class="post-toc-text">序列化和反序列化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#HTTP"><span class="post-toc-number">2.</span> <span class="post-toc-text">HTTP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#特点"><span class="post-toc-number">2.0.1.</span> <span class="post-toc-text">特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#状态码"><span class="post-toc-number">2.0.2.</span> <span class="post-toc-text">状态码</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#常见字段"><span class="post-toc-number">2.0.3.</span> <span class="post-toc-text">常见字段</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTP1-1"><span class="post-toc-number">2.0.4.</span> <span class="post-toc-text">HTTP1.1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTPS-解决HTTP什么问题？"><span class="post-toc-number">2.0.5.</span> <span class="post-toc-text">HTTPS 解决HTTP什么问题？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTP1-1-HTTP2-0-HTTP3-演变；"><span class="post-toc-number">2.0.6.</span> <span class="post-toc-text">HTTP1.1 /HTTP2.0/HTTP3 演变；</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Q：一次请求发生了什么？"><span class="post-toc-number">3.</span> <span class="post-toc-text">Q：一次请求发生了什么？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-分割数据"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">TCP 分割数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#远程定位-—-IP"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">远程定位 —- IP</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#两点传输-—-MAC"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">两点传输 — MAC</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#出口—-网卡"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">出口— 网卡</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#送别者—-交换机"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">送别者—-交换机</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#出境大门-—-路由器"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">出境大门 — 路由器</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#互相扒皮—-服务器-与-客户端"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">互相扒皮— 服务器 与 客户端</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扩展-ping原理-ICMP协议"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">扩展 ping原理 ICMP协议</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#细说-TCP"><span class="post-toc-number">4.</span> <span class="post-toc-text">细说 TCP</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：为什么需要-TCP-协议？TCP-工作在哪一层？"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Q：为什么需要 TCP 协议？TCP 工作在哪一层？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：什么是-TCP-？"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Q：什么是 TCP ？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：什么是TCP连接？"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Q：什么是TCP连接？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：如何唯一确定一个TCP连接？"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Q：如何唯一确定一个TCP连接？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：有一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">Q：有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：UDP和TCP区别与场景？"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">Q：UDP和TCP区别与场景？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：为什么是3次握手？不是两次，四次？"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">Q：为什么是3次握手？不是两次，四次？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：为什么客户端和服务端的初始序列号ISN不相同？"><span class="post-toc-number">4.9.</span> <span class="post-toc-text">Q：为什么客户端和服务端的初始序列号ISN不相同？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：IP层会分片，TCP为什么要MSS？"><span class="post-toc-number">4.10.</span> <span class="post-toc-text">Q：IP层会分片，TCP为什么要MSS？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：SYN攻击是什么？如何避免？"><span class="post-toc-number">4.11.</span> <span class="post-toc-text">Q：SYN攻击是什么？如何避免？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TCP-四次挥手"><span class="post-toc-number">4.12.</span> <span class="post-toc-text">TCP 四次挥手</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：-为什么四次挥手？"><span class="post-toc-number">4.12.1.</span> <span class="post-toc-text">Q： 为什么四次挥手？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：为什么TIME-WAIT等待是2MSL？"><span class="post-toc-number">4.12.2.</span> <span class="post-toc-text">Q：为什么TIME_WAIT等待是2MSL？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：为什么需要TIME-WAIT？"><span class="post-toc-number">4.12.3.</span> <span class="post-toc-text">Q：为什么需要TIME_WAIT？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：TIME-WAIT-过多有什么危害？"><span class="post-toc-number">4.12.4.</span> <span class="post-toc-text">Q：TIME_WAIT 过多有什么危害？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：-如何优化TIME-WAIT？"><span class="post-toc-number">4.12.5.</span> <span class="post-toc-text">Q： 如何优化TIME_WAIT？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？"><span class="post-toc-number">4.12.6.</span> <span class="post-toc-text">Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#socket编程"><span class="post-toc-number">5.</span> <span class="post-toc-text">socket编程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：-listen-时候参数-backlog-的意义？"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Q： listen 时候参数 backlog 的意义？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：什么是-TCP-半连接队列和全连接队列？"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">Q：什么是 TCP 半连接队列和全连接队列？</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：accept-发送在三次握手的哪一步？"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Q：accept 发送在三次握手的哪一步？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Q：客户端调用-close-了，连接是断开的流程是什么？"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">Q：客户端调用 close 了，连接是断开的流程是什么？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q-没有开启TCP-keepalive保活，-一直没有数据交互；进程崩溃-和主机崩溃的区别？"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">Q: -   没有开启TCP keepalive保活， 一直没有数据交互；进程崩溃 和主机崩溃的区别？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#滑动窗口机制"><span class="post-toc-number">6.</span> <span class="post-toc-text">滑动窗口机制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#详细讲一下拥塞控制？"><span class="post-toc-number">7.</span> <span class="post-toc-text">详细讲一下拥塞控制？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#慢开始"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">慢开始</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#拥塞避免"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">拥塞避免</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快重传"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">快重传</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快恢复"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">快恢复</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TCP-重传、滑动窗口、流量控制、拥塞控制发愁图解"><span class="post-toc-number"></span> <span class="post-toc-text">TCP 重传、滑动窗口、流量控制、拥塞控制发愁图解</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#精炼版"><span class="post-toc-number"></span> <span class="post-toc-text">精炼版</span></a>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    

</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://github.com/missionOdd" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="mdui-bottom-nav">
  <a href="javascript:;" class="mdui-ripple mdui-bottom-nav-active">
    <i class="mdui-icon material-icons">history</i>
    <label>Recents</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">favorite</i>
    <label>Favorites</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">&#xe80e;</i>
    <label>Hot</label>
  </a>

</div>
    <div class="bottom">
        <p>
            <span>
                Missionary &copy; 2018 - 2022
            </span>
           	
           	<span>
           		<a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备19008953号</a>
           	</span>
           	

            

            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            

            
            <span>
	            Hosted by <a href="https://coding.net/pages" target="_blank">Coding Pages</a>
            </span>
            


        </p>
        <p>
          
              
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>


          
          <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
          <script>
              var now = new Date();
              function createtime() {
                  var grt= new Date("09/15/2018 12:49:00");//此处修改你的建站时间或者网站上线时间
                  now.setTime(now.getTime()+250);
                  days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                  hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                  if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                  mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                  seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                  snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                  document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                  document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
              }
          setInterval("createtime()",250);
          </script>
        </p>
    </div>

</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light mdui-ripple"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://missionodd.github.io/missionOdd/2022/02/10/network/&title=《计算机网络 | 网络知识问答梳理》 — 🎉 Missionary's Blog 😆&pic=https://missionodd.github.io/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://missionodd.github.io/missionOdd/2022/02/10/network/&title=《计算机网络 | 网络知识问答梳理》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMElEQVR42u3a0YojIRAF0Pz/T2dhnxYGO/dq97DR41OYdFqPA4VV5esVj/ff8e/n0V+uv/35zuTJ2wYGBsbXMt6XY8QY/fbnM9dLz7dsNBcGBsY5jPZ1+RuuQ22+fR9mxMDAwCgPdknITjYFAwMDYy7gXv+2PfytHDExMDBOY+QlsyilDBbdlupuy8UxMDC+kDHXGPidz4/3NzAwMP57xrscbUtyvQkarQoDA2NrRnJ0awv9eWycu6gxnAUDA2NTRp5ettcs5lLctqiHgYFxDqNtJeaHvDzfnEunMTAwTmCsNBHvOvatbxwGBsYJjCT8JaH5iYJasRIMDIxNGXMXHVpYnpS2QR8DA+M0RhJAn7jINXd8HAZcDAyM7Rj1o8tXx9ryWdE0xcDA2JSxAmiD42tqRNc+MDAwDmCsNDLzQ2QbiIutwcDAOICRTDAXgpNktQ3xw3IbBgbGkYxkWU+Q2rYoBgbG3oynJ27LZ3O3vDAwME5gzIW8uZbkXUW9D/8HDAyMjRh5+JtLSucOlB9S1pUojoGB8bWMuhB/65P5obO+LYKBgbEFY6mwVSaf+ULzEI+BgXEC412OuSsUedKb7Pqwv4GBgbEpIx9tontXspqHbAwMjL0ZK2lkEnbb/WvbBhgYGOcwkrDYRu6V9DhfDwYGBkbyiuRSRV50S6jDqiEGBgZGsMS51Le9RnZDwMXAwPhCRhsK83S0bQDMUTEwMPZmzCWQz5X720QaAwNja8YfmM9W5Dl595YAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>



    
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/plugins/fireworks.js?v=1.4.4"></script>


    <!-- main-js -->
<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?18b812f3375b09bd66be7e3a46d7cc2d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    
        <script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>

    
    
        <script type="text/javascript" src="/js/plugins/gitmint.browser.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/gitment.js?v=1.4.4"></script>
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '等你回来！';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)欢迎!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>




    <script type="text/javascript">
  daovoice('init', {
    app_id: "8997440a"
  });
  daovoice('update');
</script>


    <script src="//cdnjs.cat.net/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/custom.js?v=1.4.4"></script>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/js/mdui.min.js"></script>
<script src="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script type="text/javascript">
jQuery.noConflict();     //将变量$的控制权让渡
</script>
<script type="text/javascript" color="213,0,0" opacity='0.7' zIndex="-2" count="20" src="//cdnjs.cat.net/ajax/libs/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<!-- <script type="text/javascript">

jQuery(function($){


});
</script> -->

</body>
</html>

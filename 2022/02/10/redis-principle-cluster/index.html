<!DOCTYPE html>
<html>
<!--
　　　　　　　　  　　　/ヽ　　　　　　/ヽ
　　　　　　 　　 　　/ 　ヽ　　　 　 / 　ヽ
　   　＿＿＿＿＿＿ / 　 　 ヽ＿＿/　 　 　ヽ
　   　|　＿＿＿＿／　　　 　 　 　　   :::::::::＼
  　　| |　　　　 / ／　　　　　　＼ 　 　::::::::::::|
　 　| |　QQ　　　| （ ●）　　　 （●）  　 ::::::::::::|
　　| |191965461 |　 　　　 　　　　  　:::::::::::::|    本人一代码菜逼
　　| |　　　　 　|　 　（__人__丿   　.....:::::::::::::/   1998生
   | |＿＿＿＿　ヽ　　　　　    .....::::::::::::::::::::<    宅
　 └＿＿＿／￣￣　　　　　　    　:::::::::::::::::::::::::|  欢迎勾搭
　　|＼　　　 |　　　　　　　　　　　　:::::::::::::::::::::|
　　＼ ＼　　＼＿＿＿　　　　 　　 ::::::::::::::::::::::::|

-->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>Redis | 底层数据结构 | 主从复制 | 🎉 Missionary&#39;s Blog 😆 | Missionary 中国 👋</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="技术,原理,Redis">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">

    
        <link rel="stylesheet" href="/css/third-party/gitment.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","app_key":"CGsuOukhiIkc4nE75fKtUtXy","icon":true}'),
            v: JSON.parse('{"enable":true,"appid":"7yVfPXhFH02yrjkOWJ2agpo6-gzGzoHsz","appkey":"CGsuOukhiIkc4nE75fKtUtXy","notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar","highlight":true}'),
            g: JSON.parse('{"enable":true,"lazy":true,"owner":"missionOdd","repo":"FAQ","oauth":{"client_id":"3dffefee0452a0a23205","client_secret":"1b1394230850e312a0a178bdd41c4e70893d759f"},"perPage":6}'),
            d: JSON.parse('{"app_id":"8997440a"}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
        <script type="text/javascript" src="/js/plugins/daovoice.js?v=1.4.4"></script>
    

<link rel="alternate" href="/atom.xml" title="🎉 Missionary's Blog 😆" type="application/atom+xml">
</head>

<script src="//cdnjs.cat.net/ajax/libs/pace/1.0.2/pace.min.js"></script>
<link href="//cdnjs.cat.net/ajax/libs/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/css/mdui.min.css">
<link rel="stylesheet"  href="//cdnjs.cat.net/ajax/libs/animate.css/3.5.2/animate.min.css">
<link rel="stylesheet" href="/css/custom.css?v=1.4.4">
<link href="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe.css" rel="stylesheet">
<link href="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.css" rel="stylesheet">

<body>
    <div id="loading" class="active mdui-progress">
  <div class="mdui-progress-determinate"></div>
</div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light rubberBand ">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Missionary</h5>
          <a href="mailto:z1165996866@hotmail.com" title="z1165996866@hotmail.com" class="mail">
            
              <span>z</span>
            
              <span>1</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>5</span>
            
              <span>9</span>
            
              <span>9</span>
            
              <span>6</span>
            
              <span>8</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>h</span>
            
              <span>o</span>
            
              <span>t</span>
            
              <span>m</span>
            
              <span>a</span>
            
              <span>i</span>
            
              <span>l</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
          <a href="/atom.xml" rel="alternate" class="mdui-btn mdui-btn-dense mdui-color-theme-accent mdui-ripple">
              <i class="fa fa-rss"></i>
              RSS订阅
            </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/missionOdd" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
              <li>
                <a href="https://leetcode-cn.com/u/missionary" target="_blank">
                  <i class="icon icon-lg icon-gg-circle"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/" >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/photos" >
                <i class="icon icon-lg icon-camera"></i>
                PHOTOS
              </a>
            </li>
        
            <li class="">
              <a href="/books" >
                <i class="icon icon-lg icon-book"></i>
                BOOKS
              </a>
            </li>
        
            <li class="">
              <a href="/categories" >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags" >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives" >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/about" >
                <i class="icon icon-lg icon-user"></i>
                ABOUT
              </a>
            </li>
        
            <li class="">
              <a href="https://github.com/missionOdd" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                GITHUB
              </a>
            </li>
        
            <li class="">
              <a href="https://leetcode-cn.com/u/missionary/" target="_blank">
                <i class="icon icon-lg icon-gg-circle"></i>
                LEETCODE
              </a>
            </li>
        
            <li class="">
              <a href="http://weibo.com/missionodd" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                WEIBO
              </a>
            </li>
        
            <li class="">
              <a href="/custom" >
                <i class="icon icon-lg icon-plus-square"></i>
                LINKS
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Redis | 底层数据结构 | 主从复制</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title animated tada delay-5s">Redis | 底层数据结构 | 主从复制</h1>
        <h5 class="subtitle animated swing delay-5s">
            
                <time datetime="2022-02-10T05:50:37.000Z" itemprop="datePublished" class="page-time">
  2022-02-10
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a></li></ul>


            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>



<div class="container body-wrap">
    <article id="post-redis-principle-cluster"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Redis | 底层数据结构 | 主从复制</h1>
        <div class="post-meta">
          
            <time class="post-time" title="2022-02-10 13:50:37" datetime="2022-02-10T05:50:37.000Z"  itemprop="datePublished">2022-02-10</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/技术/">技术</a></li></ul>



            

            
<span class="post-comments-counter" id="/2022/02/10/redis-principle-cluster/">
    <span class="post-meta-item-icon">
        <i class="icon icon-comment-o"></i>
    </span>
    
    <a href="/2022/02/10/redis-principle-cluster/#gitment-display-button" onclick="ShowGitment()">
        <span class="post-comments-count gitment-comments-count" itemprop="commentsCount"></span>
    </a>
</span>



    <span class="leancloud-comment">
        <i class="icon icon-comment-o"></i>
        <a href="/2022/02/10/redis-principle-cluster/#comment">
            <span class="valine-comment-count" data-xid="/2022/02/10/redis-principle-cluster/"></span>
        </a>
    </span>


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h4 id="讲讲Redis的5种数据结构的理解"><a href="#讲讲Redis的5种数据结构的理解" class="headerlink" title="讲讲Redis的5种数据结构的理解"></a>讲讲Redis的5种数据结构的理解</h4><p>5种，字符串，列表，哈希表对象，集合set，有序集合zset。<br>Redis对象有统一的数据结构，RedisObj，里面包含对象类型，对象底层实现数据结构标识encoding，指向底层结构的指针。</p>
<p>先说<strong>字符串</strong>：<br>底层是名为SDS的结构，有buf字节数组，对应长度，未使用空间长度。好处是：<br>1.O(1)定位长度，<br>2.对\0兼容的二进制安全，<br>3.追加字符串，可利用未使用空间，减少内存重新分配空间次数；<br>4.空间不够时，通过自动分配新空间而不会像strcat函数引起缓冲区溢出：小于1MB，按2倍扩容，扩容阈值为1MB。<br>5.用5种不同大小的SDS，灵活保存，节省内存看空间。</p>
<ol start="6">
<li>空间节省还体现在编译优化上，我们先了解，编译器会有一个字节数对齐的工作，以更好地让CPU对内存的规整读写。SDS取消字节对齐，压缩空间。比如，结构体有char，int，对齐下是4+4字节，压缩后1+4字节。</li>
</ol>
<p>不过，空间只增不减，需要手动调API惰性释放</p>
<p><strong>列表</strong><br>双向链表或压缩列表，3.2后用quicklist，50后用了listpack<br>双向链表<br>表头：头节点指针，尾节点指针，长度<br>节点：前驱指针，后驱指针，值指针</p>
<p>插入多时会比数组好，但不连续内存存储，产生空间碎片，无法利用CPU缓存；多出存储头尾节点的空间开销；</p>
<p><strong>压缩列表</strong><br>内存紧凑列表，没有所谓对齐空闲，很好利用CPU缓存；<br>表头3个，整体字节数，尾部偏移量，节点数，表尾1个，8位1结束标记；<br>节点内部：上个节点长度，当前节点类型及长度，节点数据</p>
<p>这种设计，大大节省内存空间。<br>举例：<br>列表中存储字符串，如果用双链表，<strong>每个节点有三个指针，加上SDS的2个长度的存储，再加上字符串本身</strong>。32位操作系统，一个指针6-7字节左右，三指针占<strong>18字节</strong>；<br>如果字符串是个位数，基本每个整数占用1个字节，加起来20个字节左右，不包含字符串本身。<br>当<strong>开启压缩列表</strong>，存储结构变化，它会按照序列化的形式存储，每个节点除了存储字符串本身，<strong>只需存2个整数，一个是前一个节点的字符串长度，另一个是当前节点字符串类型长度。</strong>若它是个位数长度，只需每个整数只占1个字节，总之，字符串本身加上两个字节的额外开销，跟之前字符串加上20字节的额外开销，差了N陪。这样，开启压缩列表，每项存储节省18字节。在此情况，做内存节省，适当将redis里的列表长度的阈值调整，<strong>默认512调整到2048或1024</strong>，不建议特别大。这样满足更长列表的列表压缩，节省更多空间。</p>
<p>但是，压缩列表会产生一定的性能消耗<br>一是读写过程需要编码解码；<br>二是连锁更新问题。新增或修改元素时，一旦空间不够了，压缩列表就会重新分配。特别是插入元素较大，会导致后续的上个节点长度的整型记录发生连锁空间变大，即后续所有空间都要重新分配，造成访问压缩列表的性能下降。<br>比如，前节点原本长度小于254字节，prevlen上节点长度只需1字节空间保存，如果前节点增大超过253，prevlen上节点长度要用5字节保存，而这，又导致当前节点的增大，同样，下一个节点为了记录当前节点长度，也要增大，这是一个多米诺牌的效应。</p>
<p>结论是，压缩列表保存小数据和几乎不变的数据，控制在连锁更新能够接受的尺度。</p>
<p><strong>哈希桶 Hash</strong><br>底层是压缩列表 + 字典，新版本有变化，压缩列表改为listpack<br>压缩列表已经讲过，这里主要是用来存储键key。<br>字典的结构是：2个ht哈希表，ht指向dictEntry哈希节点数组，数组元素指向dictEntry哈希节点链表；<br>1.先说哈希节点，内有key，v，next三个指针，v是联合体结构，里面val有两种含义，一种是8字节指针，一种是8字节长度整型或浮点数，无指向，空间节省优化。</p>
<p>2.采用数组+链表，是解决哈希冲突的链式哈希法。一个ht哈希表内部有数组，数组大小，掩码，节点数量；set的时候，通过key.hash对掩码与运输，定位数组桶位，头插法插入链表。</p>
<p>3.扩容缩容时的渐进式rehash。与hasmap不同，rehash执行过程分散到crud过程，减少单次set操作的性能开销。利用两个ht哈希表实现，一个ht用于存储旧数据；另一个空ht用于扩缩容数组。当达到负载因子阈值，空ht会扩容2倍，新数据进入到在新数组，同时，旧数据在每次crud时分批分次迁移。这是一种归并思想。</p>
<p><strong>集合（sadd）</strong><br>底层是整数集合或字典<br>字典已经介绍过。<br>下面介绍<br>整数集合intset<br>内部有：元素编码，数量，数组<br>优点：</p>
<ol>
<li>连续内存空间，规整的元素大小划分，减少空间碎片</li>
<li>升级操作，针对不同规格的类型，选择编码合适的集合。当新元素超过当前编码，比如int16集合中新增int32，会对整个集合进行一个大小的升级。好处是节省内存资源。</li>
</ol>
<p>不过，只增不减。</p>
<p><strong>有序集合（Zset）</strong><br>底层是压缩列表或跳表。新版压缩列表改为listpack。</p>
<p>跳表<br>一个带有层级关系的有序双向链表。<br>主要介绍三个参数，层级，分值，跨度。<br>每个节点有随机层级，不同层级有不同跨度的指向关系，越高层级跨度越大。利用浮点数分值的有序性，实现一种下楼梯式地层层检索，似二分查询，沿途跳过过多少节点，就是节点跨度。<br>还有前进指针和后退指针，后推指针用于从尾到头的检索。<br>好处是，查询效率下降一定小于log（N），且保持顺序性。</p>
<p>能够实现排行榜。</p>
<p>3.2版本的<br>quicklist<br>跟链表类似，区别是节点val采用了压缩列表指针，并额外存储字节大小，元素个数，能控制压缩列表的大小或者元素个数，规避潜在的连锁更新风险，并没有完全解决</p>
<p>5.0版本的<br>listpack<br>为了解决连锁更新问题，listpack代替压缩列表，舍弃前一个节点长度。<br>结构是：表头： 字节数，元素数量，表尾：结束标识<br>节点：编码，数据，编码+数据总长度。</p>
<h2 id="Redis-3种高级结构"><a href="#Redis-3种高级结构" class="headerlink" title="Redis 3种高级结构"></a>Redis 3种高级结构</h2><p>bitmaps<br>01数组，实际上String类型上的一组面向bit操作的集合。<br>用于活跃用户统计，布隆过滤器</p>
<p>HyperLogLogs<br>是用来做基数统计的算法，HyperLogLogs 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p>
<p>底层是散列出1w多个6bit的桶。类似bitmaps</p>
<p>实现滑动时间的UV数据统计</p>
<p>GEO<br>地理坐标<br>使用了GeoHash编码后，经纬度[120,40]就被编码成了1110011101，这个值就可以作为key对应的score值，把二维变成一维。</p>
<p>pipeline<br>网络管道技术，降低RT次数。<br> pipeline打包命令发送，节省网络时间。pipeline不是原子操作。<br> pipeline都会将数据顺序的传送顺序地返回（redis 单线程）</p>
<p>脚本<br> 大量 pipeline 应用场景可通过  <strong>Redis 脚本</strong>（Redis 版本 &gt;= 2.6）得到更高效的处理，后者在服务器端执行大量工作。脚本的一大优势是可通过最小的延迟读写数据，让读、计算、<strong>写等操作变得非常快（pipeline 在这种情况下不能使用，因为客户端在写命令前需要读命令返回的结果</strong>）。</p>
<h2 id="数据库空间"><a href="#数据库空间" class="headerlink" title="数据库空间"></a>数据库空间</h2><p>数据库空间是16隔DB，包括键-值空间和键-过期时间的字典。</p>
<h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p>每一个键定时删除，CPU开销大；<br>每一次查询检查的惰性删除，容易内存泄露；<br>设置时间定期一次性检查删除，需要合理的频率和执行时长；<br>默认惰性+定期</p>
<p>RDB AOF对过期键的处理：<br>不同点：二者在主从服务器保持数据一致性载入文件对过期键的方式不同。<br>RDB文件，1.主服务器运行时载入会判断过期键不载入；2.从服务器运行时载入不会判断全载入，因为在主从服务器保持数据一致性时会先删除从服务器数据。<br>AOF文件，1.主服务器运行时载入判断过期键会在AOF文件中追加一条del命令；2.从服务器对过期键暂不处理，因为在主从服务器保持数据一致性时，主服务器统一发送del命令，从服务器才会处理过期键;AOF文件处理过期键是由主服务期统一管理。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>用引用计数器，因为没有循环引用。</p>
<h2 id="AOF持久化日志"><a href="#AOF持久化日志" class="headerlink" title="AOF持久化日志"></a>AOF持久化日志</h2><p>只记录写命令操作，追加方式；<br>先执行成功再记录<br>好处：<br>一是避开额外的检查开销<br>二是不会阻塞当前写操作命令执行；<br>风险：<br>一是非原子操作，未及时刷盘导致丢失<br>二是redis单线程写日志，受限于IO压力，可能给下一个命令造成阻塞</p>
<p>这都给写硬盘的时机有关</p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>写入过程：命令追加至AOF缓存区，然后write调用拷贝至内核缓冲区，等待内核刷盘，什么时候刷盘，由内核决定<br>Redis刷盘的3种策略：<br>Always：总是，每次同步<br>Everysec：每隔一秒<br>No：转交给系统控制</p>
<p>要么减少数据丢失，要么阻塞主进程，高可靠，高性能只能选其一；</p>
<p>系统刷盘函数：fsync（）</p>
<h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>为了解决AOF日志过大问题，AOF会读取当前数据库所有数据，生成新的AOF文件，再进行旧AOF日志一次性覆盖。</p>
<p>AOF重写由<strong>子进程</strong>完成，避免阻塞主线程。<br>不使用线程是因为，多线程内存共享，修改 共享数据，需要加锁保证数据安全，降低性能。父子进程的采用数据副本，通过fork，系统把父进程的页表复制给子进程，页表是记录虚拟内存映射关系，不会物理复制。也就是说，虚拟空间不同，物理空间相同。<br>这样，实现内存共享，不过只标记为可读。当父子任意一方进行写一个页表项，CPU就会触发违反权限导致的缺页中断机制，会进行一部分页表项的物理复制，并重新调整映射，该过程就是写时复制：写操作时，才会对在写的物理内存复制。防止整体内存复制过长而引发父进程写阻塞当问题。<br>当然，复制进程页表，父进程会阻塞，但页表其实很小，开销不大。对在写的物理内存复制也会阻塞，这要数据量大小。如果是个bigkey，就有阻塞风险。</p>
<p>如果AOF重写过程中，主进程写入导致两块物理内存不一致，怎么办呢？<br>增加AOF重写缓冲区：重写AOF期间，写命令写入到”AOF缓冲区“与”AOF重写缓冲区“。<br>AOF文件重写工作完成后，此时还没覆盖旧AOF日志，会向主进程发送信号，这是进程之间的异步通信方式。</p>
<p>主进程接收到信号，把AOF重写缓冲区追加到新的AOF中，再把旧AOF日志覆盖。这个过程是阻塞的</p>
<p>整个过程，进程页表复制，写时复制，信号接收处理，都是阻塞的。其他情况不阻塞。</p>
<h2 id="RDB-快照-默认"><a href="#RDB-快照-默认" class="headerlink" title="RDB 快照  默认"></a>RDB 快照  默认</h2><p>所谓快照，就是记录一瞬间的东西，好比拍一张照片。</p>
<p>RDB记录某一个瞬间的二进制内存数据，是全量快照，而AOF是命令日志</p>
<p>好处是Redis要恢复数据时，RDB效率更高。</p>
<p>提供了两个命令：<br>save 和 bgsave： 区别是是否在主进程执行。<br>开启以后，会定期执行保存，这是比较重的操作，这个频率要控制。</p>
<p>缺点：<br>发送宕机时，RDB记录旧的数据，比秒级AOF丢失更多。</p>
<p>执行快照时，数据能被修改吗？<br>可以，使用bgsave，也是子进程写时复制技术。<br>能同步刚修改的数据吗？<br>不同步，只能交由下一次bgsave操作。</p>
<h2 id="RDB和AOF-混合文件持久化"><a href="#RDB和AOF-混合文件持久化" class="headerlink" title="RDB和AOF 混合文件持久化"></a>RDB和AOF 混合文件持久化</h2><p>为了高可用和高性能，控制持久化好频率。</p>
<p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p>
<p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code>出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>，不再有AOF全量数据。</p>
<p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。</p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>
<h2 id="缓存三个异常问题"><a href="#缓存三个异常问题" class="headerlink" title="缓存三个异常问题"></a>缓存三个异常问题</h2><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>大量缓存失效，同一时间过期或者Redis 宕机。<br>导致Mysql压力剧增，引发系统崩溃。</p>
<p>解决：<br>如果是缓存过期：<br>在设置缓存时，提前过期时间散列化，增加随机数；</p>
<p>如果访问缓存不存在，使用互斥锁，保证一个时间内只有一个请求来构建缓存。其他请求等待完成。当然，要设置超时时间，防止长时间阻塞。但锁开销大。</p>
<p>主备双key，一个主key，有过期时间；一个备key，永久缓存。<br>但，更新缓存需要同时更新主备双key。</p>
<p>定期程序更新，缓存不设置过期时间。<br>但，导致缓存紧张，引发淘汰策略。<br>解决上面可以用：<br>一是线程不仅要定期更新缓存，还要频繁检查缓存是否有效，就是把BD和缓存对比检查，有被淘汰的，就马上读取DB更新缓存。几乎实时，不然只查到空值。不推荐</p>
<p>二是消息队列，发现数据淘汰后，通过消息队列发送一条消息到后台线程，后台线程接收消息，先检查缓存是否存在，再读取DB更新到缓存。</p>
<p>在业务上线，要把缓存先加载，这就是所谓缓存预热。</p>
<p>如果是Redis 宕机<br>首先，最好集群化保证高可用，进行一个主从节点的复制。<br>再一个是，构建限流，熔断机制。<br>为了减少业务的影响，触发请求限流，只允许少部分请求进入，等待重启Redis并缓存预热后，再解除限流。<br>还有就是，启动熔断机制，暂停业务应用对缓存服务的访问，直接返回服务不可用错误。等Redis恢复，再允许访问。这主要保证除了Redis缓存外，其他的整体的服务依然可用。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>频繁访问的热点数据过期，大量高并发请求直接访问数据库，造成数据库被冲垮。这问题算是缓存雪崩的一个子集：<br>解决：<br>互斥锁：未查到缓存时，保证一个时间内只有一个业务对一个缓存构建，其他请求该缓存，要么等待要么返回默认值/null</p>
<p>不设置过期时间，后台异步更新缓存，或者热点数据准备过期前，通知后台线程更新以及重新设置过期时间。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>访问的数据不在缓存，也不在数据库。<br>一是校验请求合法性，二是返回空值或默认值，三是布隆过滤器。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h5 id="Q：redis-到底是单线程-还是-多线程？"><a href="#Q：redis-到底是单线程-还是-多线程？" class="headerlink" title="Q：redis 到底是单线程 还是 多线程？"></a>Q：redis 到底是单线程 还是 多线程？</h5><p>Redis 是单线程模型，这是指【从网络IO处理到实际的读写命令处理】都是单个线程完成的。有些命令是可用用后台子进程执行，比如快照生产，AOF重写。</p>
<p>严格意义上说，Redis4.0后并不是单线程，除了主线程之外，后台线程在处理一些比较长的操作，比如垃圾回收，无用连接的释放，大Key大删除。</p>
<p>在Redis6.0后，采用了多线程等待Socket读些，最终执行读写命令的过程依然在主线程。</p>
<h5 id="Q：为什么处理操作命令的过程在单线程呢？"><a href="#Q：为什么处理操作命令的过程在单线程呢？" class="headerlink" title="Q：为什么处理操作命令的过程在单线程呢？"></a>Q：为什么处理操作命令的过程在单线程呢？</h5><p>这样，Redis  不存在CPU瓶颈，主要受限于内存和网络。<br>如果采用多线程读写命令，虽然提高并发性能，但却引入了程序执行顺序的不确定性，带来并发读写的一系列问题， 增加系统复杂度，还有个线程的切换，甚至加锁解锁，死锁造成的性能消耗。</p>
<h5 id="Q：AOF重写缓冲区会被占满吗？"><a href="#Q：AOF重写缓冲区会被占满吗？" class="headerlink" title="Q：AOF重写缓冲区会被占满吗？"></a>Q：AOF重写缓冲区会被占满吗？</h5><p>理论不会，缓冲区维护着一些内存块的双向链表，每个节点指向对应aofblock空间。</p>
<h5 id="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"><a href="#Q：为什么AOF重写和RDB生成要开启子进程而不是线程？" class="headerlink" title="Q：为什么AOF重写和RDB生成要开启子进程而不是线程？"></a>Q：为什么AOF重写和RDB生成要开启子进程而不是线程？</h5><p>因为如果使用线程，多线程之前就会共享内存。那么修改共享数据，需要加锁，锁会阻塞主线程。</p>
<p>子进程的方式，可以利用写时复制的技术，不用加锁。</p>
<h5 id="Q：什么情况才会save？"><a href="#Q：什么情况才会save？" class="headerlink" title="Q：什么情况才会save？"></a>Q：什么情况才会save？</h5><p>当 Redis 内存数据高达几十 G，甚至上百 G 的时候，<strong>如果用 bgsave 进行 RDB 快照的话，在创建子进程的时候，会因为复制太大的页表而导致 Redis 阻塞在  <code>fork()</code>  函数，主线程无法继续执行，相当于停顿了</strong>。</p>
<p>所以针对这种情况建议用 save。</p>
<p>虽然 save 会一直阻塞 Redis 直到快照生成完毕，但是它这个阻塞并不是意味着停顿了，而是在执行生成快照的程序，只是期间主线程无法处理接下来的读写命令。</p>
<h5 id="Q：混合持久化如何区分开？"><a href="#Q：混合持久化如何区分开？" class="headerlink" title="Q：混合持久化如何区分开？"></a>Q：混合持久化如何区分开？</h5><p>头部有有个REDIS 表明锁RDB内容，中间遇到RDB结束标记，然后再解析AOF格式。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>避免单点故障，最好做集群化，做主从备份。<br>多台服务器要保存同一份数据，就要保持数据一致性。<br>Redis 提供了主从复制模式，且主从之间，采用读写分离。</p>
<p>客户端写操作：<br>对所有的数据写入只在主服务上进行，然后，讲最新的数据同步到从服务器，这样，主从服务器的数据保持一致；<br>客户端读操作：<br>通过负载均衡策略，可以在任意一台服务器读取。</p>
<h4 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h4><p>一是从服务器输入命令： replicaof  主IP+端口<br>建立连接，协商同步；<br>二是主服务器同步数据到从服务器，全量复制：主服务期生成并发送RDB文件，从接收后先清除，再载入。为了保证数据一执行，新写入的命令写到replication buffer 缓冲区中。<br>三是主服务器发送新写操作命令给从服务器；<br>将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，然后从服务器重新执行这些操作。</p>
<p>主从服务器再完成第一次同步后，会维护一个TCP连接。</p>
<p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。</p>
<p>而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。</p>
<p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性。</p>
<h4 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h4><p>刚刚讲到，第一次会有生成RDB文件和传输RDB文件两个耗时操作。<br>特别是从服务器非常多，数据量非常大，有两个问题：<br>一是fork阻塞主线程，redis无法正常速度处理读写请求；<br>二是RDB占用主服务网络带宽，也会影响命令请求的速度；</p>
<p>这个时候，需要设置助手，主从架构分成树状架构。从不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器形式将数据同步给从服务器。</p>
<p>这种方式，把同步压力分摊到多个服务器。</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>主从服务器再完成第一次同步后，会基于长连接进行命令传播。<br>这有个问题，就是网络的不稳定性。<br>一旦网络断开，就无法保持数据一致性。<br>2.8之前，断开恢复会进行一次全量复制，这种开销是很恐怖的。<br>从2.8开始，从服务器会采用增量复制，继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p>
<p>主要有3步：<br>1从服务器在恢复网络后，会发送psync命令到主服务器，与第一次有区别，offset参数不是-1<br>2主服务器收到命令后，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；<br>3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p>
<h5 id="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"><a href="#Q：主服务器如何知道要传输哪些增量数据发送给从服务器？" class="headerlink" title="Q：主服务器如何知道要传输哪些增量数据发送给从服务器？"></a>Q：主服务器如何知道要传输哪些增量数据发送给从服务器？</h5><p>依靠两个东西：<br>repl_backlog_buff环形缓冲区，用于主从服务器断连后，从中找到差异的数据；<br>replication offset，标记上面的那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用master_repl_offset来记录自己写到的位置，从服务器使用slave_repl_offset 来记录自己 读到的位置</p>
<h5 id="Q：repl-backlog-buff缓冲区是什么时候写入的呢？"><a href="#Q：repl-backlog-buff缓冲区是什么时候写入的呢？" class="headerlink" title="Q：repl_backlog_buff缓冲区是什么时候写入的呢？"></a>Q：repl_backlog_buff缓冲区是什么时候写入的呢？</h5><p>在主服务器进行命令传播时，不仅会将写命令发送从服务器，还会将写命令写入到repl_backlog_buff 缓冲区里，因此，这个缓冲区里会保存着最近传播到写命令</p>
<p>当网络断开后，当从服务器重新连上主服务器时，从服务器会通过psync命令将自己的复制偏移量，slave_repl_ofset发送给主服务器，主服务根据自己的master_repl_offset和slave_repl_offset 之间的差距，然后决定对从服务器执行哪种同步操作：<br>如果从服务器要读取的数据数据在缓冲区，采用增量同步；<br>否则，采用全量同步。</p>
<p><strong>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</strong></p>
<p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。</p>
<p>因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。</p>
<p>那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。</p>
<h5 id="Q：如何解决覆盖问题？"><a href="#Q：如何解决覆盖问题？" class="headerlink" title="Q：如何解决覆盖问题？"></a>Q：如何解决覆盖问题？</h5><p>因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。</p>
<p>那 repl_backlog_buffer 缓冲区具体要调整到多大呢？</p>
<p>repl_backlog_buffer 最小的大小可以根据这面这个公式估算。</p>
<p>second* write_size_per_second</p>
<p>我来解释下这个公式的意思：</p>
<ul>
<li><p>second 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。</p>
</li>
<li><p>write_size_per_second 则是主服务器平均每秒产生的写命令数据量大小。</p>
</li>
</ul>
<p>举个例子，如果主服务器平均每秒产生 1 MB 的写命令，而从服务器断线之后平均要 5 秒才能重新连接主服务器。</p>
<p>那么 repl_backlog_buffer 大小就不能低于 5 MB，否则新写地命令就会覆盖旧数据了。</p>
<p>当然，为了应对一些突发的情况，可以将 repl_backlog_buffer 的大小设置为此基础上的 2 倍，也就是 10 MB。</p>
<p>关于 repl_backlog_buffer 大小修改的方法，只需要修改配置文件里下面这个参数项的值就可以。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>主从复制共有三种模式：<strong>全量复制、基于长连接的命令传播、增量复制</strong>。</p>
<p>主从服务器第一次同步的时候，就是采用全量复制，此时主服务器会两个耗时的地方，分别是生成 RDB 文件和传输 RDB 文件。为了避免过多的从服务器和主服务器进行全量复制，可以把一部分从服务器升级为「经理角色」，让它也有自己的从服务器，通过这样可以分摊主服务器的压力。</p>
<p>第一次同步完成后，主从服务器都会维护着一个长连接，主服务器在接收到写操作命令后，就会通过这个连接将写命令传播给从服务器，来保证主从服务器的数据一致性。</p>
<p>如果遇到网络断开，增量复制就可以上场了，不过这个还跟 repl_backlog_size 这个大小有关系。</p>
<p>如果它配置的过小，主从服务器网络恢复时，可能发生「从服务器」想读的数据已经被覆盖了，那么这时就会导致主服务器采用全量复制的方式。所以为了避免这种情况的频繁发生，要调大这个参数的值，以降低主从服务器断开后全量同步的概率。</p>
<h2 id="双写一致性"><a href="#双写一致性" class="headerlink" title="双写一致性"></a>双写一致性</h2><p><strong>先更新数据库，再更新缓存</strong><br>一是 db：1 2  缓存：2 1</p>
<p>二是 非原子操作，缓存可能会失败</p>
<p><strong>先更新缓存，再更新数据库</strong><br> 缓存：1 2 db：2 1</p>
<p>加分布式锁，保证一个时间只允许一个请求更新？  性能差，过期很快</p>
<p>旁路缓存策略。</p>
<ul>
<li><p>先删除缓存，再更新数据库；<br>缓存：  A删 B读旧改</p>
</li>
<li><p>先更新数据库，再删除缓存。<br>一是会写问题 A读db  B更db B写缓存 A写旧缓存<br>二是删除失败  写db后，删除失败，等过期才回写生效</p>
</li>
</ul>
<p>缓存过期 + 延迟双删<br>第二次删除前加睡眠，确保A请求在双删内部时间中，B能够读取db，回写缓存，然后A睡醒再删除缓存。</p>
<p>这方案尽可能保证一致性，极端情况，也会出现不一致。<br>比如，第二次的删除全部崩溃，这样，与先删缓存，再更新数据无差别。</p>
<p><strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？</strong><br>一 是重试机制<br>二 是 订阅binlog，再操作缓存。</p>
<p>基于消息队列的重试</p>
<ol>
<li>更新数据库数据；</li>
<li>缓存因为种种问题删除失败</li>
<li>将需要删除的key发送至消息队列</li>
<li>自己消费消息，获得需要删除的key</li>
<li>继续重试删除操作，直到成功</li>
</ol>
<p>基于binlog的阿里中间件canal<br><strong>canal 工作原理</strong>  canal 模拟 MySQL slave 的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump（转储） 协议，MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )，canal 解析 binary log 对象(原始为 byte 流)</p>
<p>摘抄自：小林coding</p>
<hr>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><h4 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制?"></a>为什么要主从复制?</h4><p>1数据冗余 “数据的热备份”  2单机故障 “服务冗余”  3读写分离 “增加读请求能力”  4负载均衡 “分散单服务的压力”  5 高可用的基石  “哨兵和集群化”</p>
<h4 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h4><p>将一台Redis服务器的数据，复制到其他Redis节点上，前者是主节点，后者是从节点，写操作交给主节点，读操作主要给从节点。</p>
<h4 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h4><p>slave节点初次连接master节点，会发送psync命令，并且触发全量复制，此时master节点fork一个后台进程，开始生成一份RDB快照，同时将那些从外面接收  到写命令缓存到缓冲区中，RDB文件生成完毕后，将此文件发送给slave节点，slave节点写入磁盘，再从磁盘价值到内存，接着master会将增加缓冲区的写命令发送给slave，slave执行写命令并同步数据，如果slave节点和master节点因网络故障而中断，会自动重连，连接之后master节点会复制缺少的数据给slave节点。</p>
<h6 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h6><p>建立长连接，  全量数据同步，  增量同步：命令传播，数据反复同步。</p>
<h5 id="主从同步类型"><a href="#主从同步类型" class="headerlink" title="主从同步类型"></a>主从同步类型</h5><p>1全量复制 全量同步一般发生在slave初始化过程，这时slave需要将master上的所有数据复制一份；  2增量复制  增量同步一般是slave初始化后开始正常工作时，主服务器发生写操作同步到从服务器的过程；</p>
<p>主从刚连接，全量同步，再增量同步；  redis优先考虑增量，如果不成功，就是会全量。</p>
<h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p>runId 主节点ID  offset 复制便宜量  replication buffer 内部队列缓冲区  建立连接时创建，全量和增量都会用  repl_backlog_buffer 环形缓冲区  开启命令传播之前，会建立buffer。  buffer记录当前的master接收到新的写操作，offset和命令本身，是所有slave公用的buffer，salve发送psync之后，会和master的offset比较，，来决定是否增量复制。</p>
<h5 id="全量复制流程-（初始化）"><a href="#全量复制流程-（初始化）" class="headerlink" title="全量复制流程 （初始化）"></a>全量复制流程 （初始化）</h5><ul>
<li><p>master连接slave：【slave上输入save of命令】，发送psync ？ -1 命令，用于同步数据  “？” 表示是master的runID，“-1”表示offset第一次复制；</p>
</li>
<li><p>master回复ACK告知slave，它的runId和offset，slave将其保存</p>
</li>
<li><p>master fork子进程（如果单线程做耗时动作，性能非常差），生成RDB+AOF组合快照，然后向所有slave发送快照文件，并通过写时复制技术，继续执行接下来用户的一些写命令，并存放到replication buff 缓冲区当中；</p>
</li>
<li><p>slave 接收后，把本地数据清空，然后把快照加载到本地磁盘，接着加载到内存来执行。</p>
</li>
<li><p>master 发送replication buffer缓冲区给salve同步</p>
</li>
</ul>
<h5 id="增量复制流程-（重连接）"><a href="#增量复制流程-（重连接）" class="headerlink" title="增量复制流程 （重连接）"></a>增量复制流程 （重连接）</h5><p>1从服务器在恢复网络后，会发送psync runId offset命令到主服务器，与第一次有区别，offset参数不是-1 ；（runId比较，如果不一样，就全量复制）  2主服务器收到命令后，两offset求距离差，小于replication buff缓冲区大小，然后用continue响应命令告诉从服务器，要 采用增量复制的方式同步数据；  3然后主服务器将从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</p>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><h5 id="Q：长连接还是短连接？"><a href="#Q：长连接还是短连接？" class="headerlink" title="Q：长连接还是短连接？"></a>Q：长连接还是短连接？</h5><p>长，减少连接开销；</p>
<h5 id="Q：判断某个节点是否正常？"><a href="#Q：判断某个节点是否正常？" class="headerlink" title="Q：判断某个节点是否正常？"></a>Q：判断某个节点是否正常？</h5><p>主从ping-pong心跳检查机制，一半以上的节点区ping一个节点，如果没有pong回应，集群认为该节点宕机；  master 10s发送一次，检查对方在线  slave 1s发一次，给从节点发送自己的复制偏移量，获取最新变更+检查对方在线</p>
<h5 id="Q：过期key如何处理？"><a href="#Q：过期key如何处理？" class="headerlink" title="Q：过期key如何处理？"></a>Q：过期key如何处理？</h5><p>处理key或者淘汰key，master模拟del命令发送给slave；</p>
<h4 id="Q-redis主从切换如何减少数据丢失？"><a href="#Q-redis主从切换如何减少数据丢失？" class="headerlink" title="Q: redis主从切换如何减少数据丢失？"></a><strong>Q: redis主从切换如何减少数据丢失？</strong></h4><p>1 一般是异步复制丢失。  解决：  一master本地缓存或持久化磁盘，在一段时间后写入新master；  二先写入rocketMQ，再发送一个延时消息去写入master。  2 脑裂丢失  脑裂就是一部分slave误以为master已死，选举新的master后，旧的master依旧存活，导致出现了两个master，从而读写数据混乱。  避免脑裂：  一种是投票超过半数作为leader，才被其他节点认可，这也是zookeeper方案。  重点是第二种，哨兵模式。  哨兵群会监控节点存活情况，当超过半数哨兵认为master主观下线，即master转为客户下线，就要推举新master。  哨兵内部讨论，每人1票，投超过半数，成为选举人。  选1举人，根据先优先级，再是节点的同步率，最后是创建时间，选择新的master。  slave会全量同步新的master。  旧的master恢复后，降级为slave，也会全量同步。  这个过程中，旧master全量同步过程就是产生<strong>脑裂丢失</strong>  解决：  两个参数  min-slaves-to-write 2 至少2个slave  min-slaves-max-lag 5 至少5秒  至少2个slave进行同步复制延迟不超过5秒，一旦违反，master停止接收任何请求，让原master下线，选举新的master。尽可能</p>
<h4 id="Q：redis如何做到故障自动切换？"><a href="#Q：redis如何做到故障自动切换？" class="headerlink" title="Q：redis如何做到故障自动切换？"></a>Q：redis如何做到故障自动切换？</h4><p>哨兵模式内部选举出一个选举人，选举人选举新的master。</p>
<h4 id="Q：数据备份方式"><a href="#Q：数据备份方式" class="headerlink" title="Q：数据备份方式"></a>Q：数据备份方式</h4><p>1热备  主库承担业务流量，通过实时备份数据到从库。</p>
<p>2冷备  主库承担业务流量，通过定期或者手动执行脚本备份数据到从库。  （redis）</p>
<p>3多活  由两个数据中心承担业务流量，互为主备，一般主数据中心会承担大部分流量，备数据会承担小部分流量。（多地域）</p>
<p>摘抄自：tojson</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2022-03-16T15:30:45.096Z" itemprop="dateUpdated">2022-03-16 23:30:45</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2022/02/10/redis-principle-cluster/" target="_blank" rel="external">https://github.com/missionOdd/2022/02/10/redis-principle-cluster/</a>
        
    </div>
    <div class="mdui-chip" id="accost-btn">
      <span class="mdui-chip-icon mdui-color-red-a700"><i class="mdui-icon material-icons">&#xe311;</i></span>
      <span class="mdui-chip-title">Accost</span>
    </div>
    <footer>
      <div class="mdui-chip">
        <a href="https://github.com/missionOdd">
            <img src="/img/avatar.jpg" alt="Missionary">
             About Missionary
        </a>
        </div>
    </footer>
</blockquote>


        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2022/02/10/redis-principle-cluster/&title=《Redis | 底层数据结构 | 主从复制》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2022/02/10/redis-principle-cluster/&title=《Redis | 底层数据结构 | 主从复制》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            <div class="mdui-container">
  <div class="mdui-tab" id="tab">
    <a href="#tab1-content" id="tab1" class="mdui-ripple">游客用户</a>
    <a href="#tab2-content" id="tab2" class="mdui-tab-active mdui-ripple">GitHub账户</a>
  </div>

  <div id="tab1-content" class="mdui-p-a-2">
    
      <div id="comment" style=""></div>

  </div>
  <div id="tab2-content" class="mdui-p-a-2">
    
          
    <div onclick="ShowGitment()" id="gitment-display-button" style="display: block;">
        <span>显示 Gitment 评论</span>
    </div>
    <div id="gitment" class="hide"></div>


    
  </div>

</div>

        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2022/02/12/p8-interview-skills-2/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">面经 | 结合业务，步步深入，P8架构师二面摘录笔记</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2022/02/10/design-skiplist/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">设计跳表 | 栈记录插入前驱可能，丢硬币控制插入层级（java）</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Redis"><span class="post-toc-number">1.</span> <span class="post-toc-text">Redis</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Redis数据结构"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">Redis数据结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#讲讲Redis的5种数据结构的理解"><span class="post-toc-number">1.1.0.1.</span> <span class="post-toc-text">讲讲Redis的5种数据结构的理解</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Redis-3种高级结构"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">Redis 3种高级结构</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据库空间"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">数据库空间</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#删除策略"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">删除策略</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#垃圾回收"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">垃圾回收</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#AOF持久化日志"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">AOF持久化日志</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三种写回策略"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">三种写回策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AOF-重写"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">AOF 重写</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RDB-快照-默认"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">RDB 快照  默认</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RDB和AOF-混合文件持久化"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">RDB和AOF 混合文件持久化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#缓存三个异常问题"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">缓存三个异常问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缓存雪崩"><span class="post-toc-number">1.9.0.1.</span> <span class="post-toc-text">缓存雪崩</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缓存击穿"><span class="post-toc-number">1.9.0.2.</span> <span class="post-toc-text">缓存击穿</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#缓存穿透"><span class="post-toc-number">1.9.0.3.</span> <span class="post-toc-text">缓存穿透</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#FAQ"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">FAQ</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#主从复制"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#第一次同步"><span class="post-toc-number">1.11.0.1.</span> <span class="post-toc-text">第一次同步</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#分摊主服务器的压力"><span class="post-toc-number">1.11.0.2.</span> <span class="post-toc-text">分摊主服务器的压力</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#增量复制"><span class="post-toc-number">1.11.0.3.</span> <span class="post-toc-text">增量复制</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#双写一致性"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">双写一致性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Redis主从复制"><span class="post-toc-number">1.12.1.</span> <span class="post-toc-text">Redis主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么要主从复制"><span class="post-toc-number">1.12.1.1.</span> <span class="post-toc-text">为什么要主从复制?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是主从复制"><span class="post-toc-number">1.12.1.2.</span> <span class="post-toc-text">什么是主从复制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Redis主从工作原理"><span class="post-toc-number">1.12.1.3.</span> <span class="post-toc-text">Redis主从工作原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q-redis主从切换如何减少数据丢失？"><span class="post-toc-number">1.12.1.4.</span> <span class="post-toc-text">Q: redis主从切换如何减少数据丢失？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：redis如何做到故障自动切换？"><span class="post-toc-number">1.12.1.5.</span> <span class="post-toc-text">Q：redis如何做到故障自动切换？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Q：数据备份方式"><span class="post-toc-number">1.12.1.6.</span> <span class="post-toc-text">Q：数据备份方式</span></a></li></ol></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    

</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://github.com/missionOdd" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="mdui-bottom-nav">
  <a href="javascript:;" class="mdui-ripple mdui-bottom-nav-active">
    <i class="mdui-icon material-icons">history</i>
    <label>Recents</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">favorite</i>
    <label>Favorites</label>
  </a>
  <a href="javascript:;" class="mdui-ripple">
    <i class="mdui-icon material-icons">&#xe80e;</i>
    <label>Hot</label>
  </a>

</div>
    <div class="bottom">
        <p>
            <span>
                Missionary &copy; 2018 - 2022
            </span>
           	
           	<span>
           		<a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备19008953号</a>
           	</span>
           	

            

            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            

            
            <span>
	            Hosted by <a href="https://coding.net/pages" target="_blank">Coding Pages</a>
            </span>
            


        </p>
        <p>
          
              
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>


          
          <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
          <script>
              var now = new Date();
              function createtime() {
                  var grt= new Date("09/15/2018 12:49:00");//此处修改你的建站时间或者网站上线时间
                  now.setTime(now.getTime()+250);
                  days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
                  hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
                  if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
                  mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
                  seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
                  snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
                  document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
                  document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
              }
          setInterval("createtime()",250);
          </script>
        </p>
    </div>

</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light mdui-ripple"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/missionOdd/2022/02/10/redis-principle-cluster/&title=《Redis | 底层数据结构 | 主从复制》 — 🎉 Missionary's Blog 😆&pic=https://github.com/missionOdd/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/missionOdd/2022/02/10/redis-principle-cluster/&title=《Redis | 底层数据结构 | 主从复制》 — 🎉 Missionary's Blog 😆&source=Web后端/Java在学/单身" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACu0lEQVR42u3aQW7jQAwEQP//01lgTzlYUpMcxglQOhmKHU3JgEg35/WKj6//x/fX389cvXNyJvnPxw48PDy81tKvjnvS/ZmccX/d+1t89Vk8PDy8bd68GFSpyVWS1w8WPDw8vI/y7h/39+Xk/lNJ04yHh4f313k5Jm+y85gDDw8P7zfwkjBiEhzkWev9qhazFjw8PLyY1xuAffb1+nwPDw8PrzVVr0YJvetO1vOwWjw8PLwFXt4ib+xlysdpvaYcDw8Pb5s32SZV3UZQvU3Vr+FNYcDDw8M7xJuUhGSh1UFa9RY8jNDw8PDwFniTBreKzMtGrwV/qHt4eHh4R3k9ZHXL1EYYUQiR8fDw8A7x8h/28x0KSYHptdSXBQkPDw9vjdcLcJOGuNqOT6KQy6wFDw8P7yivui2gGq1WtxfkEXA5jMDDw8M7yusNlu6XWN1kMBmMFXp5PDw8vDHv1DgqX3relFeLx5v14OHh4S3wen332ZCiik/aejw8PLw9Xh4W5KOs3k2plpko6sXDw8Nb4FXb6Gq4kAcTvYFZ4f14eHh4a7z8qG606gUfeeMe/WLAw8PDO8RLmuNe893MRVrsy8KAh4eHt8brDf6rl+/FGdXSgoeHh7fHy0n5KKsXSXxg0xUeHh5ei5dvaZqUil7JyaPbckuNh4eHN+BVH+X52KnaLvfijEJLjYeHh7fMq47nq586FTc8rA0PDw9vgTfZVvWB3Q1xQPxK5ml4eHh4Ld5X8aheoNea91rqN3/Fw8PDW+DN68lZQBIHTwZmeHh4eKd4STHIy0ZvoFUNGgrfDx4eHt4ar/eArm4dyAdpvQr2EODi4eHh/Tivt10g3zhVGGjltwMPDw/vF/DuA4j5wCw/E53Hw8PDW+PNw4jJyP9sNIyHh4e3zettCMgjhuojPv+f81uJh4eHV+T9AxzMAyfXe3RTAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>



    
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
   <script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/plugins/fireworks.js?v=1.4.4"></script>


    <!-- main-js -->
<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?18b812f3375b09bd66be7e3a46d7cc2d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    
        <script type="text/javascript" src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script type="text/javascript" src="/js/plugins/valine.js?v=1.4.4"></script>

    
    
        <script type="text/javascript" src="/js/plugins/gitmint.browser.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/gitment.js?v=1.4.4"></script>
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cat.net/ajax/libs/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>




    <script>
    (function() {
        var OriginTitile = document.title, titleTime;
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.title = '等你回来！';
                clearTimeout(titleTime);
            } else {
                document.title = '(つェ⊂)欢迎!';
                titleTime = setTimeout(function() {
                    document.title = OriginTitile;
                },2000);
            }
        });
    })();
</script>




    <script type="text/javascript">
  daovoice('init', {
    app_id: "8997440a"
  });
  daovoice('update');
</script>


    <script src="//cdnjs.cat.net/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/custom.js?v=1.4.4"></script>
<script src="//cdnjs.loli.net/ajax/libs/mdui/0.4.1/js/mdui.min.js"></script>
<script src="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe.min.js"></script>
<script src="//cdnjs.cat.net/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js"></script>

<script type="text/javascript">
jQuery.noConflict();     //将变量$的控制权让渡
</script>
<script type="text/javascript" color="213,0,0" opacity='0.7' zIndex="-2" count="20" src="//cdnjs.cat.net/ajax/libs/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<!-- <script type="text/javascript">

jQuery(function($){


});
</script> -->

</body>
</html>
